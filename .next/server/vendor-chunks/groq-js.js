"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/groq-js";
exports.ids = ["vendor-chunks/groq-js"];
exports.modules = {

/***/ "(ssr)/./node_modules/groq-js/dist/1.mjs":
/*!*****************************************!*\
  !*** ./node_modules/groq-js/dist/1.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DateTime: () => (/* binding */ DateTime),\n/* harmony export */   Path: () => (/* binding */ Path),\n/* harmony export */   createReferenceTypeNode: () => (/* binding */ createReferenceTypeNode),\n/* harmony export */   evaluate: () => (/* binding */ evaluateQuery),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   typeEvaluate: () => (/* binding */ typeEvaluate)\n/* harmony export */ });\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\");\n\nfunction escapeRegExp(string) {\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction pathRegExp(pattern) {\n    const re = [];\n    for (const part of pattern.split(\".\"))part === \"*\" ? re.push(\"[^.]+\") : part === \"**\" ? re.push(\".*\") : re.push(escapeRegExp(part));\n    return new RegExp(`^${re.join(\".\")}$`);\n}\nclass Path {\n    constructor(pattern){\n        this.pattern = pattern, this.patternRe = pathRegExp(pattern);\n    }\n    matches(str) {\n        return this.patternRe.test(str);\n    }\n    toJSON() {\n        return this.pattern;\n    }\n}\nclass StreamValue {\n    constructor(generator){\n        this.type = \"stream\";\n        this.generator = generator, this.ticker = null, this.isDone = !1, this.data = [];\n    }\n    // eslint-disable-next-line class-methods-use-this\n    isArray() {\n        return !0;\n    }\n    async get() {\n        const result = [];\n        for await (const value of this)result.push(await value.get());\n        return result;\n    }\n    async *[Symbol.asyncIterator]() {\n        let i = 0;\n        for(;;){\n            for(; i < this.data.length; i++)yield this.data[i];\n            if (this.isDone) return;\n            await this._nextTick();\n        }\n    }\n    _nextTick() {\n        if (this.ticker) return this.ticker;\n        let currentResolver;\n        const setupTicker = ()=>{\n            this.ticker = new Promise((resolve)=>{\n                currentResolver = resolve;\n            });\n        }, tick = ()=>{\n            currentResolver(), setupTicker();\n        }, fetch = async ()=>{\n            for await (const value of this.generator())this.data.push(value), tick();\n            this.isDone = !0, tick();\n        };\n        return setupTicker(), fetch(), this.ticker;\n    }\n}\nconst RFC3339_REGEX = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|([-+]\\d{2}:\\d{2}))$/;\nfunction parseRFC3339(str) {\n    return RFC3339_REGEX.test(str) ? new Date(str) : null;\n}\nfunction formatRFC3339(d) {\n    const year = addLeadingZero(d.getUTCFullYear(), 4), month = addLeadingZero(d.getUTCMonth() + 1, 2), day = addLeadingZero(d.getUTCDate(), 2), hour = addLeadingZero(d.getUTCHours(), 2), minute = addLeadingZero(d.getUTCMinutes(), 2), second = addLeadingZero(d.getUTCSeconds(), 2);\n    let fractionalSecond = \"\";\n    const millis = d.getMilliseconds();\n    return millis != 0 && (fractionalSecond = `.${addLeadingZero(millis, 3)}`), `${year}-${month}-${day}T${hour}:${minute}:${second}${fractionalSecond}Z`;\n}\nfunction addLeadingZero(num, targetLength) {\n    let str = num.toString();\n    for(; str.length < targetLength;)str = `0${str}`;\n    return str;\n}\nclass StaticValue {\n    constructor(data, type){\n        this.data = data, this.type = type;\n    }\n    isArray() {\n        return this.type === \"array\";\n    }\n    // eslint-disable-next-line require-await\n    async get() {\n        return this.data;\n    }\n    [Symbol.asyncIterator]() {\n        if (Array.isArray(this.data)) return function*(data) {\n            for (const element of data)yield fromJS(element);\n        }(this.data);\n        throw new Error(`Cannot iterate over: ${this.type}`);\n    }\n}\nconst NULL_VALUE = new StaticValue(null, \"null\"), TRUE_VALUE = new StaticValue(!0, \"boolean\"), FALSE_VALUE = new StaticValue(!1, \"boolean\");\nclass DateTime {\n    constructor(date){\n        this.date = date;\n    }\n    static parseToValue(str) {\n        const date = parseRFC3339(str);\n        return date ? new StaticValue(new DateTime(date), \"datetime\") : NULL_VALUE;\n    }\n    equals(other) {\n        return this.date.getTime() == other.date.getTime();\n    }\n    add(secs) {\n        const copy = new Date(this.date.getTime());\n        return copy.setTime(copy.getTime() + secs * 1e3), new DateTime(copy);\n    }\n    difference(other) {\n        return (this.date.getTime() - other.date.getTime()) / 1e3;\n    }\n    compareTo(other) {\n        return this.date.getTime() - other.date.getTime();\n    }\n    toString() {\n        return formatRFC3339(this.date);\n    }\n    toJSON() {\n        return this.toString();\n    }\n}\nfunction fromNumber(num) {\n    return Number.isFinite(num) ? new StaticValue(num, \"number\") : NULL_VALUE;\n}\nfunction fromString(str) {\n    return new StaticValue(str, \"string\");\n}\nfunction fromDateTime(dt) {\n    return new StaticValue(dt, \"datetime\");\n}\nfunction fromPath(path) {\n    return new StaticValue(path, \"path\");\n}\nfunction isIterator(obj) {\n    return obj && typeof obj.next == \"function\";\n}\nfunction fromJS(val) {\n    return isIterator(val) ? new StreamValue(async function*() {\n        for await (const value of val)yield fromJS(value);\n    }) : val == null ? NULL_VALUE : new StaticValue(val, getType(val));\n}\nfunction getType(data) {\n    return data === null || typeof data > \"u\" ? \"null\" : Array.isArray(data) ? \"array\" : data instanceof Path ? \"path\" : data instanceof DateTime ? \"datetime\" : typeof data;\n}\nfunction isEqual(a, b) {\n    return a.type === \"string\" && b.type === \"string\" || a.type === \"boolean\" && b.type === \"boolean\" || a.type === \"null\" && b.type === \"null\" || a.type === \"number\" && b.type === \"number\" ? a.data === b.data : a.type === \"datetime\" && b.type === \"datetime\" ? a.data.equals(b.data) : !1;\n}\nconst CHARS = /([^!@#$%^&*(),\\\\/?\";:{}|[\\]+<>\\s-])+/g, CHARS_WITH_WILDCARD = /([^!@#$%^&(),\\\\/?\";:{}|[\\]+<>\\s-])+/g, EDGE_CHARS = /(\\b\\.+|\\.+\\b)/g;\nfunction matchText(tokens, patterns) {\n    return tokens.length === 0 || patterns.length === 0 ? !1 : patterns.every((pattern)=>pattern(tokens));\n}\nfunction matchTokenize(text2) {\n    return text2.replace(EDGE_CHARS, \"\").match(CHARS) || [];\n}\nfunction matchAnalyzePattern(text2) {\n    return matchPatternRegex(text2).map((re)=>(tokens)=>tokens.some((token)=>re.test(token)));\n}\nfunction matchPatternRegex(text2) {\n    return (text2.replace(EDGE_CHARS, \"\").match(CHARS_WITH_WILDCARD) || []).map((term)=>new RegExp(`^${term.slice(0, 1024).replace(/\\*/g, \".*\")}$`, \"i\"));\n}\nasync function gatherText(value, cb) {\n    if (value.type === \"string\") return cb(value.data), !0;\n    if (value.isArray()) {\n        let success = !0;\n        for await (const part of value)part.type === \"string\" ? cb(part.data) : success = !1;\n        return success;\n    }\n    return !1;\n}\nconst TYPE_ORDER = {\n    datetime: 1,\n    number: 2,\n    string: 3,\n    boolean: 4\n};\nfunction partialCompare(a, b) {\n    const aType = getType(a), bType = getType(b);\n    if (aType !== bType) return null;\n    switch(aType){\n        case \"number\":\n        case \"boolean\":\n            return a - b;\n        case \"string\":\n            return a < b ? -1 : a > b ? 1 : 0;\n        case \"datetime\":\n            return a.compareTo(b);\n        default:\n            return null;\n    }\n}\nfunction totalCompare(a, b) {\n    const aType = getType(a), bType = getType(b), aTypeOrder = TYPE_ORDER[aType] || 100, bTypeOrder = TYPE_ORDER[bType] || 100;\n    if (aTypeOrder !== bTypeOrder) return aTypeOrder - bTypeOrder;\n    let result = partialCompare(a, b);\n    return result === null && (result = 0), result;\n}\nconst operators = {\n    \"==\": function(left, right) {\n        return isEqual(left, right) ? TRUE_VALUE : FALSE_VALUE;\n    },\n    \"!=\": function(left, right) {\n        return isEqual(left, right) ? FALSE_VALUE : TRUE_VALUE;\n    },\n    \">\": function(left, right) {\n        if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n        const result = partialCompare(left.data, right.data);\n        return result === null ? NULL_VALUE : result > 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    \">=\": function(left, right) {\n        if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n        const result = partialCompare(left.data, right.data);\n        return result === null ? NULL_VALUE : result >= 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    \"<\": function(left, right) {\n        if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n        const result = partialCompare(left.data, right.data);\n        return result === null ? NULL_VALUE : result < 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    \"<=\": function(left, right) {\n        if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n        const result = partialCompare(left.data, right.data);\n        return result === null ? NULL_VALUE : result <= 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    // eslint-disable-next-line func-name-matching\n    in: async function(left, right) {\n        if (right.type === \"path\") return left.type !== \"string\" ? NULL_VALUE : right.data.matches(left.data) ? TRUE_VALUE : FALSE_VALUE;\n        if (right.isArray()) {\n            for await (const b of right)if (isEqual(left, b)) return TRUE_VALUE;\n            return FALSE_VALUE;\n        }\n        return NULL_VALUE;\n    },\n    match: async function(left, right) {\n        let tokens = [], patterns = [];\n        return await gatherText(left, (part)=>{\n            tokens = tokens.concat(matchTokenize(part));\n        }), await gatherText(right, (part)=>{\n            patterns = patterns.concat(matchAnalyzePattern(part));\n        }) && matchText(tokens, patterns) ? TRUE_VALUE : FALSE_VALUE;\n    },\n    \"+\": function(left, right) {\n        return left.type === \"datetime\" && right.type === \"number\" ? fromDateTime(left.data.add(right.data)) : left.type === \"number\" && right.type === \"number\" ? fromNumber(left.data + right.data) : left.type === \"string\" && right.type === \"string\" ? fromString(left.data + right.data) : left.type === \"object\" && right.type === \"object\" ? fromJS({\n            ...left.data,\n            ...right.data\n        }) : left.type === \"array\" && right.type === \"array\" ? fromJS(left.data.concat(right.data)) : left.isArray() && right.isArray() ? new StreamValue(async function*() {\n            for await (const val of left)yield val;\n            for await (const val of right)yield val;\n        }) : NULL_VALUE;\n    },\n    \"-\": function(left, right) {\n        return left.type === \"datetime\" && right.type === \"number\" ? fromDateTime(left.data.add(-right.data)) : left.type === \"datetime\" && right.type === \"datetime\" ? fromNumber(left.data.difference(right.data)) : left.type === \"number\" && right.type === \"number\" ? fromNumber(left.data - right.data) : NULL_VALUE;\n    },\n    \"*\": numericOperator((a, b)=>a * b),\n    \"/\": numericOperator((a, b)=>a / b),\n    \"%\": numericOperator((a, b)=>a % b),\n    \"**\": numericOperator((a, b)=>Math.pow(a, b))\n};\nfunction numericOperator(impl) {\n    return function(left, right) {\n        if (left.type === \"number\" && right.type === \"number\") {\n            const result = impl(left.data, right.data);\n            return fromNumber(result);\n        }\n        return NULL_VALUE;\n    };\n}\nlet Scope$1 = class Scope {\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    constructor(params, source, value, context, parent){\n        this.isHidden = !1;\n        this.params = params, this.source = source, this.value = value, this.context = context, this.parent = parent;\n    }\n    createNested(value) {\n        return this.isHidden ? new Scope(this.params, this.source, value, this.context, this.parent) : new Scope(this.params, this.source, value, this.context, this);\n    }\n    createHidden(value) {\n        const result = this.createNested(value);\n        return result.isHidden = !0, result;\n    }\n};\nfunction evaluate(node, scope, execute = evaluate) {\n    const func = EXECUTORS[node.type];\n    return func(node, scope, execute);\n}\nfunction promiselessApply(value, cb) {\n    return \"then\" in value ? value.then(cb) : cb(value);\n}\nconst EXECUTORS = {\n    This (_, scope) {\n        return scope.value;\n    },\n    Selector () {\n        throw new Error(\"Selectors can not be evaluated\");\n    },\n    Everything (_, scope) {\n        return scope.source;\n    },\n    Parameter ({ name }, scope) {\n        return fromJS(scope.params[name]);\n    },\n    Context ({ key }, scope) {\n        if (key === \"before\" || key === \"after\") return scope.context[key] || NULL_VALUE;\n        throw new Error(`unknown context key: ${key}`);\n    },\n    Parent ({ n }, scope) {\n        let current = scope;\n        for(let i = 0; i < n; i++){\n            if (!current.parent) return NULL_VALUE;\n            current = current.parent;\n        }\n        return current.value;\n    },\n    OpCall ({ op, left, right }, scope, execute) {\n        const func = operators[op];\n        if (!func) throw new Error(`Unknown operator: ${op}`);\n        const leftValue = execute(left, scope), rightValue = execute(right, scope);\n        return \"then\" in leftValue || \"then\" in rightValue ? (async ()=>func(await leftValue, await rightValue))() : func(leftValue, rightValue);\n    },\n    async Select ({ alternatives, fallback }, scope, execute) {\n        for (const alt of alternatives){\n            const altCond = await execute(alt.condition, scope);\n            if (altCond.type === \"boolean\" && altCond.data === !0) return execute(alt.value, scope);\n        }\n        return fallback ? execute(fallback, scope) : NULL_VALUE;\n    },\n    async InRange ({ base, left, right, isInclusive }, scope, execute) {\n        const value = await execute(base, scope), leftValue = await execute(left, scope), rightValue = await execute(right, scope), leftCmp = partialCompare(await value.get(), await leftValue.get());\n        if (leftCmp === null) return NULL_VALUE;\n        const rightCmp = partialCompare(await value.get(), await rightValue.get());\n        return rightCmp === null ? NULL_VALUE : isInclusive ? leftCmp >= 0 && rightCmp <= 0 ? TRUE_VALUE : FALSE_VALUE : leftCmp >= 0 && rightCmp < 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    async Filter ({ base, expr }, scope, execute) {\n        const baseValue = await execute(base, scope);\n        return baseValue.isArray() ? new StreamValue(async function*() {\n            for await (const elem of baseValue){\n                const newScope = scope.createNested(elem), exprValue = await execute(expr, newScope);\n                exprValue.type === \"boolean\" && exprValue.data === !0 && (yield elem);\n            }\n        }) : NULL_VALUE;\n    },\n    async Projection ({ base, expr }, scope, execute) {\n        const baseValue = await execute(base, scope);\n        if (baseValue.type !== \"object\") return NULL_VALUE;\n        const newScope = scope.createNested(baseValue);\n        return execute(expr, newScope);\n    },\n    FuncCall ({ func, args }, scope, execute) {\n        return func(args, scope, execute);\n    },\n    async PipeFuncCall ({ func, base, args }, scope, execute) {\n        const baseValue = await execute(base, scope);\n        return func(baseValue, args, scope, execute);\n    },\n    async AccessAttribute ({ base, name }, scope, execute) {\n        let value = scope.value;\n        return base && (value = await execute(base, scope)), value.type === \"object\" && value.data.hasOwnProperty(name) ? fromJS(value.data[name]) : NULL_VALUE;\n    },\n    async AccessElement ({ base, index }, scope, execute) {\n        const baseValue = await execute(base, scope);\n        if (!baseValue.isArray()) return NULL_VALUE;\n        const data = await baseValue.get(), finalIndex = index < 0 ? index + data.length : index;\n        return fromJS(data[finalIndex]);\n    },\n    async Slice ({ base, left, right, isInclusive }, scope, execute) {\n        const baseValue = await execute(base, scope);\n        if (!baseValue.isArray()) return NULL_VALUE;\n        const array2 = await baseValue.get();\n        let leftIdx = left, rightIdx = right;\n        return leftIdx < 0 && (leftIdx = array2.length + leftIdx), rightIdx < 0 && (rightIdx = array2.length + rightIdx), isInclusive && rightIdx++, leftIdx < 0 && (leftIdx = 0), rightIdx < 0 && (rightIdx = 0), fromJS(array2.slice(leftIdx, rightIdx));\n    },\n    async Deref ({ base }, scope, execute) {\n        const value = await execute(base, scope);\n        if (!scope.source.isArray() || value.type !== \"object\") return NULL_VALUE;\n        const id = value.data._ref;\n        if (typeof id != \"string\") return NULL_VALUE;\n        if (scope.context.dereference) return fromJS(await scope.context.dereference({\n            _ref: id\n        }));\n        for await (const doc of scope.source)if (doc.type === \"object\" && id === doc.data._id) return doc;\n        return NULL_VALUE;\n    },\n    Value ({ value }) {\n        return fromJS(value);\n    },\n    Group ({ base }, scope, execute) {\n        return execute(base, scope);\n    },\n    async Object ({ attributes }, scope, execute) {\n        const result = {};\n        for (const attr of attributes){\n            const attrType = attr.type;\n            switch(attr.type){\n                case \"ObjectAttributeValue\":\n                    {\n                        const value = await execute(attr.value, scope);\n                        result[attr.name] = await value.get();\n                        break;\n                    }\n                case \"ObjectConditionalSplat\":\n                    {\n                        const cond = await execute(attr.condition, scope);\n                        if (cond.type !== \"boolean\" || cond.data === !1) continue;\n                        const value = await execute(attr.value, scope);\n                        value.type === \"object\" && Object.assign(result, value.data);\n                        break;\n                    }\n                case \"ObjectSplat\":\n                    {\n                        const value = await execute(attr.value, scope);\n                        value.type === \"object\" && Object.assign(result, value.data);\n                        break;\n                    }\n                default:\n                    throw new Error(`Unknown node type: ${attrType}`);\n            }\n        }\n        return fromJS(result);\n    },\n    Array ({ elements }, scope, execute) {\n        return new StreamValue(async function*() {\n            for (const element of elements){\n                const value = await execute(element.value, scope);\n                if (element.isSplat) {\n                    if (value.isArray()) for await (const v of value)yield v;\n                } else yield value;\n            }\n        });\n    },\n    Tuple () {\n        throw new Error(\"tuples can not be evaluated\");\n    },\n    async Or ({ left, right }, scope, execute) {\n        const leftValue = await execute(left, scope), rightValue = await execute(right, scope);\n        return leftValue.type === \"boolean\" && leftValue.data === !0 || rightValue.type === \"boolean\" && rightValue.data === !0 ? TRUE_VALUE : leftValue.type !== \"boolean\" || rightValue.type !== \"boolean\" ? NULL_VALUE : FALSE_VALUE;\n    },\n    async And ({ left, right }, scope, execute) {\n        const leftValue = await execute(left, scope), rightValue = await execute(right, scope);\n        return leftValue.type === \"boolean\" && leftValue.data === !1 || rightValue.type === \"boolean\" && rightValue.data === !1 ? FALSE_VALUE : leftValue.type !== \"boolean\" || rightValue.type !== \"boolean\" ? NULL_VALUE : TRUE_VALUE;\n    },\n    async Not ({ base }, scope, execute) {\n        const value = await execute(base, scope);\n        return value.type !== \"boolean\" ? NULL_VALUE : value.data ? FALSE_VALUE : TRUE_VALUE;\n    },\n    Neg ({ base }, scope, execute) {\n        return promiselessApply(execute(base, scope), (value)=>value.type !== \"number\" ? NULL_VALUE : fromNumber(-value.data));\n    },\n    Pos ({ base }, scope, execute) {\n        return promiselessApply(execute(base, scope), (value)=>value.type !== \"number\" ? NULL_VALUE : fromNumber(value.data));\n    },\n    Asc () {\n        return NULL_VALUE;\n    },\n    Desc () {\n        return NULL_VALUE;\n    },\n    async ArrayCoerce ({ base }, scope, execute) {\n        const value = await execute(base, scope);\n        return value.isArray() ? value : NULL_VALUE;\n    },\n    async Map ({ base, expr }, scope, execute) {\n        const value = await execute(base, scope);\n        return value.isArray() ? new StreamValue(async function*() {\n            for await (const elem of value){\n                const newScope = scope.createHidden(elem);\n                yield await execute(expr, newScope);\n            }\n        }) : NULL_VALUE;\n    },\n    async FlatMap ({ base, expr }, scope, execute) {\n        const value = await execute(base, scope);\n        return value.isArray() ? new StreamValue(async function*() {\n            for await (const elem of value){\n                const newScope = scope.createHidden(elem), innerValue = await execute(expr, newScope);\n                if (innerValue.isArray()) for await (const inner of innerValue)yield inner;\n                else yield innerValue;\n            }\n        }) : NULL_VALUE;\n    }\n};\nfunction evaluateQuery(tree, options = {}) {\n    const root = fromJS(options.root), dataset = fromJS(options.dataset), params = {\n        ...options.params\n    }, scope = new Scope$1(params, dataset, root, {\n        timestamp: options.timestamp || /* @__PURE__ */ new Date(),\n        identity: options.identity === void 0 ? \"me\" : options.identity,\n        sanity: options.sanity,\n        after: options.after ? fromJS(options.after) : null,\n        before: options.before ? fromJS(options.before) : null,\n        dereference: options.dereference\n    }, null);\n    return evaluate(tree, scope);\n}\nfunction canConstantEvaluate(node) {\n    switch(node.type){\n        case \"Group\":\n            return canConstantEvaluate(node.base);\n        case \"Value\":\n        case \"Parameter\":\n            return !0;\n        case \"Pos\":\n        case \"Neg\":\n            return canConstantEvaluate(node.base);\n        case \"OpCall\":\n            switch(node.op){\n                case \"+\":\n                case \"-\":\n                case \"*\":\n                case \"/\":\n                case \"%\":\n                case \"**\":\n                    return canConstantEvaluate(node.left) && canConstantEvaluate(node.right);\n                default:\n                    return !1;\n            }\n        default:\n            return !1;\n    }\n}\nconst DUMMY_SCOPE = new Scope$1({}, NULL_VALUE, NULL_VALUE, {\n    timestamp: /* @__PURE__ */ new Date(0),\n    identity: \"me\",\n    before: null,\n    after: null\n}, null);\nfunction tryConstantEvaluate(node) {\n    return canConstantEvaluate(node) ? constantEvaluate(node) : null;\n}\nfunction constantEvaluate(node) {\n    const value = evaluate(node, DUMMY_SCOPE, constantEvaluate);\n    if (\"then\" in value) throw new Error(\"BUG: constant evaluate should never return a promise\");\n    return value;\n}\nasync function portableTextContent(value) {\n    if (value.type === \"object\") return blockText(value.data);\n    if (value.isArray()) {\n        const texts = await arrayText(value);\n        if (texts.length > 0) return texts.join(`\n\n`);\n    }\n    return null;\n}\nasync function arrayText(value, result = []) {\n    for await (const block of value)if (block.type === \"object\") {\n        const text2 = blockText(block.data);\n        text2 !== null && result.push(text2);\n    } else block.isArray() && await arrayText(block, result);\n    return result;\n}\nfunction blockText(obj) {\n    if (typeof obj._type != \"string\") return null;\n    const children = obj.children;\n    if (!Array.isArray(children)) return null;\n    let result = \"\";\n    for (const child of children)child && typeof child == \"object\" && typeof child._type == \"string\" && child._type === \"span\" && typeof child.text == \"string\" && (result += child.text);\n    return result;\n}\nconst BM25k = 1.2;\nasync function evaluateScore(node, scope, execute) {\n    if (node.type === \"OpCall\" && node.op === \"match\") return evaluateMatchScore(node.left, node.right, scope, execute);\n    if (node.type === \"FuncCall\" && node.name === \"boost\") {\n        const innerScore = await evaluateScore(node.args[0], scope, execute), boost = await execute(node.args[1], scope);\n        return boost.type === \"number\" && innerScore > 0 ? innerScore + boost.data : 0;\n    }\n    switch(node.type){\n        case \"Or\":\n            {\n                const leftScore = await evaluateScore(node.left, scope, execute), rightScore = await evaluateScore(node.right, scope, execute);\n                return leftScore + rightScore;\n            }\n        case \"And\":\n            {\n                const leftScore = await evaluateScore(node.left, scope, execute), rightScore = await evaluateScore(node.right, scope, execute);\n                return leftScore === 0 || rightScore === 0 ? 0 : leftScore + rightScore;\n            }\n        default:\n            {\n                const res = await execute(node, scope);\n                return res.type === \"boolean\" && res.data === !0 ? 1 : 0;\n            }\n    }\n}\nasync function evaluateMatchScore(left, right, scope, execute) {\n    const text2 = await execute(left, scope), pattern = await execute(right, scope);\n    let tokens = [], terms = [];\n    if (await gatherText(text2, (part)=>{\n        tokens = tokens.concat(matchTokenize(part));\n    }), !await gatherText(pattern, (part)=>{\n        terms = terms.concat(matchPatternRegex(part));\n    }) || tokens.length === 0 || terms.length === 0) return 0;\n    let score = 0;\n    for (const re of terms){\n        const freq = tokens.reduce((c, token)=>c + (re.test(token) ? 1 : 0), 0);\n        score += freq * (BM25k + 1) / (freq + BM25k);\n    }\n    return score;\n}\nfunction hasReference(value, pathSet) {\n    switch(getType(value)){\n        case \"array\":\n            for (const v of value)if (hasReference(v, pathSet)) return !0;\n            break;\n        case \"object\":\n            if (value._ref) return pathSet.has(value._ref);\n            for (const v of Object.values(value))if (hasReference(v, pathSet)) return !0;\n            break;\n    }\n    return !1;\n}\nfunction countUTF8(str) {\n    let count2 = 0;\n    for(let i = 0; i < str.length; i++){\n        const code = str.charCodeAt(i);\n        code >= 55296 && code <= 56319 || count2++;\n    }\n    return count2;\n}\nconst _global = {};\n_global.anywhere = async function() {\n    throw new Error(\"not implemented\");\n};\n_global.anywhere.arity = 1;\n_global.coalesce = async function(args, scope, execute) {\n    for (const arg of args){\n        const value = await execute(arg, scope);\n        if (value.type !== \"null\") return value;\n    }\n    return NULL_VALUE;\n};\n_global.count = async function(args, scope, execute) {\n    const inner = await execute(args[0], scope);\n    if (!inner.isArray()) return NULL_VALUE;\n    let num = 0;\n    for await (const _ of inner)num++;\n    return fromNumber(num);\n};\n_global.count.arity = 1;\n_global.dateTime = async function(args, scope, execute) {\n    const val = await execute(args[0], scope);\n    return val.type === \"datetime\" ? val : val.type !== \"string\" ? NULL_VALUE : DateTime.parseToValue(val.data);\n};\n_global.dateTime.arity = 1;\n_global.defined = async function(args, scope, execute) {\n    return (await execute(args[0], scope)).type === \"null\" ? FALSE_VALUE : TRUE_VALUE;\n};\n_global.defined.arity = 1;\n_global.identity = async function(_args, scope) {\n    return fromString(scope.context.identity);\n};\n_global.identity.arity = 0;\n_global.length = async function(args, scope, execute) {\n    const inner = await execute(args[0], scope);\n    if (inner.type === \"string\") return fromNumber(countUTF8(inner.data));\n    if (inner.isArray()) {\n        let num = 0;\n        for await (const _ of inner)num++;\n        return fromNumber(num);\n    }\n    return NULL_VALUE;\n};\n_global.length.arity = 1;\n_global.path = async function(args, scope, execute) {\n    const inner = await execute(args[0], scope);\n    return inner.type !== \"string\" ? NULL_VALUE : fromPath(new Path(inner.data));\n};\n_global.path.arity = 1;\n_global.string = async function(args, scope, execute) {\n    const value = await execute(args[0], scope);\n    switch(value.type){\n        case \"number\":\n        case \"string\":\n        case \"boolean\":\n        case \"datetime\":\n            return fromString(`${value.data}`);\n        default:\n            return NULL_VALUE;\n    }\n};\n_global.string.arity = 1;\n_global.references = async function(args, scope, execute) {\n    const pathSet = /* @__PURE__ */ new Set();\n    for (const arg of args){\n        const path2 = await execute(arg, scope);\n        if (path2.type === \"string\") pathSet.add(path2.data);\n        else if (path2.isArray()) for await (const elem of path2)elem.type === \"string\" && pathSet.add(elem.data);\n    }\n    if (pathSet.size === 0) return FALSE_VALUE;\n    const scopeValue = await scope.value.get();\n    return hasReference(scopeValue, pathSet) ? TRUE_VALUE : FALSE_VALUE;\n};\n_global.references.arity = (c)=>c >= 1;\n_global.round = async function(args, scope, execute) {\n    const value = await execute(args[0], scope);\n    if (value.type !== \"number\") return NULL_VALUE;\n    const num = value.data;\n    let prec = 0;\n    if (args.length === 2) {\n        const precValue = await execute(args[1], scope);\n        if (precValue.type !== \"number\" || precValue.data < 0 || !Number.isInteger(precValue.data)) return NULL_VALUE;\n        prec = precValue.data;\n    }\n    return prec === 0 ? num < 0 ? fromNumber(-Math.round(-num)) : fromNumber(Math.round(num)) : fromNumber(Number(num.toFixed(prec)));\n};\n_global.round.arity = (count2)=>count2 >= 1 && count2 <= 2;\n_global.now = async function(_args, scope) {\n    return fromString(scope.context.timestamp.toISOString());\n};\n_global.now.arity = 0;\n_global.boost = async function() {\n    throw new Error(\"unexpected boost call\");\n};\n_global.boost.arity = 2;\nconst string2 = {};\nstring2.lower = async function(args, scope, execute) {\n    const value = await execute(args[0], scope);\n    return value.type !== \"string\" ? NULL_VALUE : fromString(value.data.toLowerCase());\n};\nstring2.lower.arity = 1;\nstring2.upper = async function(args, scope, execute) {\n    const value = await execute(args[0], scope);\n    return value.type !== \"string\" ? NULL_VALUE : fromString(value.data.toUpperCase());\n};\nstring2.upper.arity = 1;\nstring2.split = async function(args, scope, execute) {\n    const str = await execute(args[0], scope);\n    if (str.type !== \"string\") return NULL_VALUE;\n    const sep = await execute(args[1], scope);\n    return sep.type !== \"string\" ? NULL_VALUE : str.data.length === 0 ? fromJS([]) : sep.data.length === 0 ? fromJS(Array.from(str.data)) : fromJS(str.data.split(sep.data));\n};\nstring2.split.arity = 2;\n_global.lower = string2.lower;\n_global.upper = string2.upper;\nstring2.startsWith = async function(args, scope, execute) {\n    const str = await execute(args[0], scope);\n    if (str.type !== \"string\") return NULL_VALUE;\n    const prefix = await execute(args[1], scope);\n    return prefix.type !== \"string\" ? NULL_VALUE : str.data.startsWith(prefix.data) ? TRUE_VALUE : FALSE_VALUE;\n};\nstring2.startsWith.arity = 2;\nconst array = {};\narray.join = async function(args, scope, execute) {\n    const arr = await execute(args[0], scope);\n    if (!arr.isArray()) return NULL_VALUE;\n    const sep = await execute(args[1], scope);\n    if (sep.type !== \"string\") return NULL_VALUE;\n    let buf = \"\", needSep = !1;\n    for await (const elem of arr){\n        switch(needSep && (buf += sep.data), elem.type){\n            case \"number\":\n            case \"string\":\n            case \"boolean\":\n            case \"datetime\":\n                buf += `${elem.data}`;\n                break;\n            default:\n                return NULL_VALUE;\n        }\n        needSep = !0;\n    }\n    return fromJS(buf);\n};\narray.join.arity = 2;\narray.compact = async function(args, scope, execute) {\n    const arr = await execute(args[0], scope);\n    return arr.isArray() ? new StreamValue(async function*() {\n        for await (const elem of arr)elem.type !== \"null\" && (yield elem);\n    }) : NULL_VALUE;\n};\narray.compact.arity = 1;\narray.unique = async function(args, scope, execute) {\n    const value = await execute(args[0], scope);\n    return value.isArray() ? new StreamValue(async function*() {\n        const added = /* @__PURE__ */ new Set();\n        for await (const iter of value)switch(iter.type){\n            case \"number\":\n            case \"string\":\n            case \"boolean\":\n            case \"datetime\":\n                added.has(iter.data) || (added.add(iter.data), yield iter);\n                break;\n            default:\n                yield iter;\n        }\n    }) : NULL_VALUE;\n};\narray.unique.arity = 1;\narray.intersects = async function(args, scope, execute) {\n    const arr1 = await execute(args[0], scope);\n    if (!arr1.isArray()) return NULL_VALUE;\n    const arr2 = await execute(args[1], scope);\n    if (!arr2.isArray()) return NULL_VALUE;\n    for await (const v1 of arr1)for await (const v2 of arr2)if (isEqual(v1, v2)) return TRUE_VALUE;\n    return FALSE_VALUE;\n};\narray.intersects.arity = 2;\nconst pt = {};\npt.text = async function(args, scope, execute) {\n    const value = await execute(args[0], scope), text2 = await portableTextContent(value);\n    return text2 === null ? NULL_VALUE : fromString(text2);\n};\npt.text.arity = 1;\nconst sanity = {};\nsanity.projectId = async function(_args, scope) {\n    return scope.context.sanity ? fromString(scope.context.sanity.projectId) : NULL_VALUE;\n};\nsanity.dataset = async function(_args, scope) {\n    return scope.context.sanity ? fromString(scope.context.sanity.dataset) : NULL_VALUE;\n};\nsanity.versionOf = async function(args, scope, execute) {\n    const value = await execute(args[0], scope);\n    if (value.type !== \"string\") return NULL_VALUE;\n    const baseId = value.data, val = await scope.value.get();\n    if (!val || typeof val._id != \"string\") return NULL_VALUE;\n    const components = val._id.split(\".\");\n    return val._id === baseId || components.length >= 2 && components[0] === \"drafts\" && components.slice(1).join(\".\") === baseId || components.length >= 3 && components[0] === \"versions\" && components.slice(2).join(\".\") === baseId ? TRUE_VALUE : FALSE_VALUE;\n};\nsanity.versionOf.arity = 1;\nsanity.partOfRelease = async function(args, scope, execute) {\n    const value = await execute(args[0], scope);\n    if (value.type !== \"string\") return NULL_VALUE;\n    const baseId = value.data, val = await scope.value.get();\n    if (!val || typeof val._id != \"string\") return NULL_VALUE;\n    const components = val._id.split(\".\");\n    return fromJS(components.length >= 3 && components[0] === \"versions\" && components[1] === baseId);\n};\nsanity.partOfRelease.arity = 1;\nconst releases = {};\nreleases.all = async function(_args, scope) {\n    const allReleases = [];\n    for await (const value of scope.source)if (getType(value) === \"object\") {\n        const val = await value.get();\n        val && \"_type\" in val && val._type === \"system.release\" && allReleases.push(val);\n    }\n    return fromJS(allReleases);\n};\nreleases.all.arity = 0;\nconst pipeFunctions = {};\npipeFunctions.order = async function(base, args, scope, execute) {\n    if (await !0, !base.isArray()) return NULL_VALUE;\n    const mappers = [], directions = [];\n    let n = 0;\n    for (let mapper of args){\n        let direction = \"asc\";\n        mapper.type === \"Desc\" ? (direction = \"desc\", mapper = mapper.base) : mapper.type === \"Asc\" && (mapper = mapper.base), mappers.push(mapper), directions.push(direction), n++;\n    }\n    const aux = [];\n    let idx = 0;\n    for await (const value of base){\n        const newScope = scope.createNested(value), tuple = [\n            await value.get(),\n            idx\n        ];\n        for(let i = 0; i < n; i++){\n            const result = await execute(mappers[i], newScope);\n            tuple.push(await result.get());\n        }\n        aux.push(tuple), idx++;\n    }\n    return aux.sort((aTuple, bTuple)=>{\n        for(let i = 0; i < n; i++){\n            let c = totalCompare(aTuple[i + 2], bTuple[i + 2]);\n            if (directions[i] === \"desc\" && (c = -c), c !== 0) return c;\n        }\n        return aTuple[1] - bTuple[1];\n    }), fromJS(aux.map((v)=>v[0]));\n};\npipeFunctions.order.arity = (count2)=>count2 >= 1;\npipeFunctions.score = async function(base, args, scope, execute) {\n    if (!base.isArray()) return NULL_VALUE;\n    const unknown = [], scored = [];\n    for await (const value of base){\n        if (value.type !== \"object\") {\n            unknown.push(await value.get());\n            continue;\n        }\n        const newScope = scope.createNested(value);\n        let valueScore = typeof value.data._score == \"number\" ? value.data._score : 0;\n        for (const arg of args)valueScore += await evaluateScore(arg, newScope, execute);\n        const newObject = Object.assign({}, value.data, {\n            _score: valueScore\n        });\n        scored.push(newObject);\n    }\n    return scored.sort((a, b)=>b._score - a._score), fromJS(scored);\n};\npipeFunctions.score.arity = (count2)=>count2 >= 1;\nconst delta = {};\ndelta.operation = async function(_args, scope) {\n    const hasBefore = scope.context.before !== null, hasAfter = scope.context.after !== null;\n    return hasBefore && hasAfter ? fromString(\"update\") : hasAfter ? fromString(\"create\") : hasBefore ? fromString(\"delete\") : NULL_VALUE;\n};\ndelta.changedAny = ()=>{\n    throw new Error(\"not implemented\");\n};\ndelta.changedAny.arity = 1;\ndelta.changedAny.mode = \"delta\";\ndelta.changedOnly = ()=>{\n    throw new Error(\"not implemented\");\n};\ndelta.changedOnly.arity = 1;\ndelta.changedOnly.mode = \"delta\";\nconst diff = {};\ndiff.changedAny = ()=>{\n    throw new Error(\"not implemented\");\n};\ndiff.changedAny.arity = 3;\ndiff.changedOnly = ()=>{\n    throw new Error(\"not implemented\");\n};\ndiff.changedOnly.arity = 3;\nconst math = {};\nmath.min = async function(args, scope, execute) {\n    const arr = await execute(args[0], scope);\n    if (!arr.isArray()) return NULL_VALUE;\n    let n;\n    for await (const elem of arr)if (elem.type !== \"null\") {\n        if (elem.type !== \"number\") return NULL_VALUE;\n        (n === void 0 || elem.data < n) && (n = elem.data);\n    }\n    return fromJS(n);\n};\nmath.min.arity = 1;\nmath.max = async function(args, scope, execute) {\n    const arr = await execute(args[0], scope);\n    if (!arr.isArray()) return NULL_VALUE;\n    let n;\n    for await (const elem of arr)if (elem.type !== \"null\") {\n        if (elem.type !== \"number\") return NULL_VALUE;\n        (n === void 0 || elem.data > n) && (n = elem.data);\n    }\n    return fromJS(n);\n};\nmath.max.arity = 1;\nmath.sum = async function(args, scope, execute) {\n    const arr = await execute(args[0], scope);\n    if (!arr.isArray()) return NULL_VALUE;\n    let n = 0;\n    for await (const elem of arr)if (elem.type !== \"null\") {\n        if (elem.type !== \"number\") return NULL_VALUE;\n        n += elem.data;\n    }\n    return fromJS(n);\n};\nmath.sum.arity = 1;\nmath.avg = async function(args, scope, execute) {\n    const arr = await execute(args[0], scope);\n    if (!arr.isArray()) return NULL_VALUE;\n    let n = 0, c = 0;\n    for await (const elem of arr)if (elem.type !== \"null\") {\n        if (elem.type !== \"number\") return NULL_VALUE;\n        n += elem.data, c++;\n    }\n    return c === 0 ? NULL_VALUE : fromJS(n / c);\n};\nmath.avg.arity = 1;\nconst dateTime2 = {};\ndateTime2.now = async function(_args, scope) {\n    return fromDateTime(new DateTime(scope.context.timestamp));\n};\ndateTime2.now.arity = 0;\nconst text = {};\ntext.query = ()=>{\n    throw new Error(\"not implemented\");\n};\ntext.query.arity = 1;\nconst namespaces = {\n    global: _global,\n    string: string2,\n    array,\n    pt,\n    delta,\n    diff,\n    sanity,\n    math,\n    dateTime: dateTime2,\n    releases,\n    text\n};\nclass MarkProcessor {\n    constructor(string, marks, parseOptions){\n        this.allowBoost = !1;\n        this.string = string, this.marks = marks, this.index = 0, this.parseOptions = parseOptions;\n    }\n    hasMark(pos = 0) {\n        return this.index + pos < this.marks.length;\n    }\n    getMark(pos = 0) {\n        return this.marks[this.index + pos];\n    }\n    shift() {\n        this.index += 1;\n    }\n    process(visitor) {\n        const mark = this.marks[this.index];\n        this.shift();\n        const func = visitor[mark.name];\n        if (!func) throw new Error(`Unknown handler: ${mark.name}`);\n        return func.call(visitor, this, mark);\n    }\n    processString() {\n        return this.shift(), this.processStringEnd();\n    }\n    processStringEnd() {\n        const prev = this.marks[this.index - 1], curr = this.marks[this.index];\n        return this.shift(), this.string.slice(prev.position, curr.position);\n    }\n    slice(len) {\n        const pos = this.marks[this.index].position;\n        return this.string.slice(pos, pos + len);\n    }\n}\nconst WS = /^([\\t\\n\\v\\f\\r \\u0085\\u00A0]|(\\/\\/[^\\n]*\\n))+/, NUM = /^\\d+/, IDENT = /^[a-zA-Z_][a-zA-Z_0-9]*/;\nfunction parse$1(str) {\n    let pos = 0;\n    pos = skipWS(str, pos);\n    let result = parseExpr(str, pos, 0);\n    return result.type === \"error\" ? result : (pos = skipWS(str, result.position), pos !== str.length ? (result.failPosition && (pos = result.failPosition - 1), {\n        type: \"error\",\n        position: pos\n    }) : (delete result.position, delete result.failPosition, result));\n}\nfunction parseExpr(str, pos, level) {\n    let startPos = pos, token = str[pos], marks;\n    switch(token){\n        case \"+\":\n            {\n                let rhs = parseExpr(str, skipWS(str, pos + 1), 10);\n                if (rhs.type === \"error\") return rhs;\n                marks = [\n                    {\n                        name: \"pos\",\n                        position: startPos\n                    }\n                ].concat(rhs.marks), pos = rhs.position;\n                break;\n            }\n        case \"-\":\n            {\n                let rhs = parseExpr(str, skipWS(str, pos + 1), 8);\n                if (rhs.type === \"error\") return rhs;\n                marks = [\n                    {\n                        name: \"neg\",\n                        position: startPos\n                    }\n                ].concat(rhs.marks), pos = rhs.position;\n                break;\n            }\n        case \"(\":\n            {\n                let rhs = parseExpr(str, skipWS(str, pos + 1), 0);\n                if (rhs.type === \"error\") return rhs;\n                switch(pos = skipWS(str, rhs.position), str[pos]){\n                    case \",\":\n                        {\n                            for(marks = [\n                                {\n                                    name: \"tuple\",\n                                    position: startPos\n                                }\n                            ].concat(rhs.marks), pos = skipWS(str, pos + 1);;){\n                                if (rhs = parseExpr(str, pos, 0), rhs.type === \"error\") return rhs;\n                                if (pos = skipWS(str, rhs.position), str[pos] !== \",\") break;\n                                pos = skipWS(str, pos + 1);\n                            }\n                            if (str[pos] !== \")\") return {\n                                type: \"error\",\n                                position: pos\n                            };\n                            pos++, marks.push({\n                                name: \"tuple_end\",\n                                position: pos\n                            });\n                            break;\n                        }\n                    case \")\":\n                        {\n                            pos++, marks = [\n                                {\n                                    name: \"group\",\n                                    position: startPos\n                                }\n                            ].concat(rhs.marks);\n                            break;\n                        }\n                    default:\n                        return {\n                            type: \"error\",\n                            position: pos\n                        };\n                }\n                break;\n            }\n        case \"!\":\n            {\n                let rhs = parseExpr(str, skipWS(str, pos + 1), 10);\n                if (rhs.type === \"error\") return rhs;\n                marks = [\n                    {\n                        name: \"not\",\n                        position: startPos\n                    }\n                ].concat(rhs.marks), pos = rhs.position;\n                break;\n            }\n        case \"{\":\n            {\n                let result = parseObject(str, pos);\n                if (result.type === \"error\") return result;\n                marks = result.marks, pos = result.position;\n                break;\n            }\n        case \"[\":\n            if (marks = [\n                {\n                    name: \"array\",\n                    position: pos\n                }\n            ], pos = skipWS(str, pos + 1), str[pos] !== \"]\") for(;;){\n                str.slice(pos, pos + 3) === \"...\" && (marks.push({\n                    name: \"array_splat\",\n                    position: pos\n                }), pos = skipWS(str, pos + 3));\n                let res = parseExpr(str, pos, 0);\n                if (res.type === \"error\") return res;\n                if (marks = marks.concat(res.marks), pos = res.position, pos = skipWS(str, pos), str[pos] !== \",\" || (pos = skipWS(str, pos + 1), str[pos] === \"]\")) break;\n            }\n            if (str[pos] === \"]\") pos++, marks.push({\n                name: \"array_end\",\n                position: pos\n            });\n            else return {\n                type: \"error\",\n                position: pos\n            };\n            break;\n        case \"'\":\n        case '\"':\n            {\n                let result = parseString(str, pos);\n                if (result.type === \"error\") return result;\n                marks = result.marks, pos = result.position;\n                break;\n            }\n        case \"^\":\n            {\n                for(pos++, marks = []; str[pos] === \".\" && str[pos + 1] === \"^\";)marks.push({\n                    name: \"dblparent\",\n                    position: startPos\n                }), pos += 2;\n                marks.push({\n                    name: \"parent\",\n                    position: startPos\n                });\n                break;\n            }\n        case \"@\":\n            marks = [\n                {\n                    name: \"this\",\n                    position: startPos\n                }\n            ], pos++;\n            break;\n        case \"*\":\n            marks = [\n                {\n                    name: \"everything\",\n                    position: startPos\n                }\n            ], pos++;\n            break;\n        case \"$\":\n            {\n                let identLen = parseRegex(str, pos + 1, IDENT);\n                identLen && (pos += 1 + identLen, marks = [\n                    {\n                        name: \"param\",\n                        position: startPos\n                    },\n                    {\n                        name: \"ident\",\n                        position: startPos + 1\n                    },\n                    {\n                        name: \"ident_end\",\n                        position: pos\n                    }\n                ]);\n                break;\n            }\n        default:\n            {\n                let numLen = parseRegex(str, pos, NUM);\n                if (numLen) {\n                    pos += numLen;\n                    let name = \"integer\";\n                    if (str[pos] === \".\") {\n                        let fracLen = parseRegex(str, pos + 1, NUM);\n                        fracLen && (name = \"float\", pos += 1 + fracLen);\n                    }\n                    if (str[pos] === \"e\" || str[pos] === \"E\") {\n                        name = \"sci\", pos++, (str[pos] === \"+\" || str[pos] === \"-\") && pos++;\n                        let expLen = parseRegex(str, pos, NUM);\n                        if (!expLen) return {\n                            type: \"error\",\n                            position: pos\n                        };\n                        pos += expLen;\n                    }\n                    marks = [\n                        {\n                            name,\n                            position: startPos\n                        },\n                        {\n                            name: name + \"_end\",\n                            position: pos\n                        }\n                    ];\n                    break;\n                }\n                let identLen = parseRegex(str, pos, IDENT);\n                if (identLen) {\n                    switch(pos += identLen, str[pos]){\n                        case \":\":\n                        case \"(\":\n                            {\n                                let result = parseFuncCall(str, startPos, pos);\n                                if (result.type === \"error\") return result;\n                                marks = result.marks, pos = result.position;\n                                break;\n                            }\n                        default:\n                            marks = [\n                                {\n                                    name: \"this_attr\",\n                                    position: startPos\n                                },\n                                {\n                                    name: \"ident\",\n                                    position: startPos\n                                },\n                                {\n                                    name: \"ident_end\",\n                                    position: pos\n                                }\n                            ];\n                    }\n                    break;\n                }\n            }\n    }\n    if (!marks) return {\n        type: \"error\",\n        position: pos\n    };\n    let lhsLevel = 12, trav;\n    loop: for(;;){\n        let innerPos = skipWS(str, pos);\n        if (innerPos === str.length) {\n            pos = innerPos;\n            break;\n        }\n        if (trav = parseTraversal(str, innerPos), trav.type === \"success\") {\n            for(marks.unshift({\n                name: \"traverse\",\n                position: startPos\n            }); trav.type === \"success\";)marks = marks.concat(trav.marks), pos = trav.position, trav = parseTraversal(str, skipWS(str, pos));\n            marks.push({\n                name: \"traversal_end\",\n                position: pos\n            });\n            continue;\n        }\n        switch(str[innerPos]){\n            case \"=\":\n                {\n                    switch(str[innerPos + 1]){\n                        case \">\":\n                            {\n                                if (level > 1 || lhsLevel <= 1) break loop;\n                                let rhs = parseExpr(str, skipWS(str, innerPos + 2), 1);\n                                if (rhs.type === \"error\") return rhs;\n                                marks = marks.concat(rhs.marks), marks.unshift({\n                                    name: \"pair\",\n                                    position: startPos\n                                }), pos = rhs.position, lhsLevel = 1;\n                                break;\n                            }\n                        case \"=\":\n                            {\n                                if (level > 4 || lhsLevel <= 4) break loop;\n                                let rhs = parseExpr(str, skipWS(str, innerPos + 2), 5);\n                                if (rhs.type === \"error\") return rhs;\n                                marks.unshift({\n                                    name: \"comp\",\n                                    position: startPos\n                                }), marks.push({\n                                    name: \"op\",\n                                    position: innerPos\n                                }, {\n                                    name: \"op_end\",\n                                    position: innerPos + 2\n                                }), marks = marks.concat(rhs.marks), pos = rhs.position, lhsLevel = 4;\n                                break;\n                            }\n                        default:\n                            break loop;\n                    }\n                    break;\n                }\n            case \"+\":\n                {\n                    if (level > 6 || lhsLevel < 6) break loop;\n                    let rhs = parseExpr(str, skipWS(str, innerPos + 1), 7);\n                    if (rhs.type === \"error\") return rhs;\n                    marks = marks.concat(rhs.marks), marks.unshift({\n                        name: \"add\",\n                        position: startPos\n                    }), pos = rhs.position, lhsLevel = 6;\n                    break;\n                }\n            case \"-\":\n                {\n                    if (level > 6 || lhsLevel < 6) break loop;\n                    let rhs = parseExpr(str, skipWS(str, innerPos + 1), 7);\n                    if (rhs.type === \"error\") return rhs;\n                    marks = marks.concat(rhs.marks), marks.unshift({\n                        name: \"sub\",\n                        position: startPos\n                    }), pos = rhs.position, lhsLevel = 6;\n                    break;\n                }\n            case \"*\":\n                {\n                    if (str[innerPos + 1] === \"*\") {\n                        if (level > 8 || lhsLevel <= 8) break loop;\n                        let rhs2 = parseExpr(str, skipWS(str, innerPos + 2), 8);\n                        if (rhs2.type === \"error\") return rhs2;\n                        marks = marks.concat(rhs2.marks), marks.unshift({\n                            name: \"pow\",\n                            position: startPos\n                        }), pos = rhs2.position, lhsLevel = 8;\n                        break;\n                    }\n                    if (level > 7 || lhsLevel < 7) break loop;\n                    let rhs = parseExpr(str, skipWS(str, innerPos + 1), 8);\n                    if (rhs.type === \"error\") return rhs;\n                    marks = marks.concat(rhs.marks), marks.unshift({\n                        name: \"mul\",\n                        position: startPos\n                    }), pos = rhs.position, lhsLevel = 7;\n                    break;\n                }\n            case \"/\":\n                {\n                    if (level > 7 || lhsLevel < 7) break loop;\n                    let rhs = parseExpr(str, skipWS(str, innerPos + 1), 8);\n                    if (rhs.type === \"error\") return rhs;\n                    marks = marks.concat(rhs.marks), marks.unshift({\n                        name: \"div\",\n                        position: startPos\n                    }), pos = rhs.position, lhsLevel = 7;\n                    break;\n                }\n            case \"%\":\n                {\n                    if (level > 7 || lhsLevel < 7) break loop;\n                    let rhs = parseExpr(str, skipWS(str, innerPos + 1), 8);\n                    if (rhs.type === \"error\") return rhs;\n                    marks = marks.concat(rhs.marks), marks.unshift({\n                        name: \"mod\",\n                        position: startPos\n                    }), pos = rhs.position, lhsLevel = 7;\n                    break;\n                }\n            case \"<\":\n            case \">\":\n                {\n                    if (level > 4 || lhsLevel <= 4) break loop;\n                    let nextPos = innerPos + 1;\n                    str[nextPos] === \"=\" && nextPos++;\n                    let rhs = parseExpr(str, skipWS(str, nextPos), 5);\n                    if (rhs.type === \"error\") return rhs;\n                    marks.unshift({\n                        name: \"comp\",\n                        position: startPos\n                    }), marks.push({\n                        name: \"op\",\n                        position: innerPos\n                    }, {\n                        name: \"op_end\",\n                        position: nextPos\n                    }), marks = marks.concat(rhs.marks), pos = rhs.position, lhsLevel = 4;\n                    break;\n                }\n            case \"|\":\n                {\n                    if (str[innerPos + 1] === \"|\") {\n                        if (level > 2 || lhsLevel < 2) break loop;\n                        let rhs = parseExpr(str, skipWS(str, innerPos + 2), 3);\n                        if (rhs.type === \"error\") return rhs;\n                        marks = marks.concat(rhs.marks), marks.unshift({\n                            name: \"or\",\n                            position: startPos\n                        }), pos = rhs.position, lhsLevel = 2;\n                    } else {\n                        if (level > 11 || lhsLevel < 11) break loop;\n                        let identPos = skipWS(str, innerPos + 1), identLen = parseRegex(str, identPos, IDENT);\n                        if (!identLen) return {\n                            type: \"error\",\n                            position: identPos\n                        };\n                        if (pos = identPos + identLen, str[pos] === \"(\" || str[pos] === \":\") {\n                            let result = parseFuncCall(str, identPos, pos);\n                            if (result.type === \"error\") return result;\n                            marks = marks.concat(result.marks), marks.unshift({\n                                name: \"pipecall\",\n                                position: startPos\n                            }), pos = result.position, lhsLevel = 11;\n                        }\n                    }\n                    break;\n                }\n            case \"&\":\n                {\n                    if (str[innerPos + 1] != \"&\" || level > 3 || lhsLevel < 3) break loop;\n                    let rhs = parseExpr(str, skipWS(str, innerPos + 2), 4);\n                    if (rhs.type === \"error\") return rhs;\n                    marks = marks.concat(rhs.marks), marks.unshift({\n                        name: \"and\",\n                        position: startPos\n                    }), pos = rhs.position, lhsLevel = 3;\n                    break;\n                }\n            case \"!\":\n                {\n                    if (str[innerPos + 1] !== \"=\" || level > 4 || lhsLevel <= 4) break loop;\n                    let rhs = parseExpr(str, skipWS(str, innerPos + 2), 5);\n                    if (rhs.type === \"error\") return rhs;\n                    marks.unshift({\n                        name: \"comp\",\n                        position: startPos\n                    }), marks.push({\n                        name: \"op\",\n                        position: innerPos\n                    }, {\n                        name: \"op_end\",\n                        position: innerPos + 2\n                    }), marks = marks.concat(rhs.marks), pos = rhs.position, lhsLevel = 4;\n                    break;\n                }\n            case \"d\":\n                {\n                    if (str.slice(innerPos, innerPos + 4) !== \"desc\" || level > 4 || lhsLevel < 4) break loop;\n                    marks.unshift({\n                        name: \"desc\",\n                        position: startPos\n                    }), pos = innerPos + 4, lhsLevel = 4;\n                    break;\n                }\n            case \"a\":\n                {\n                    if (str.slice(innerPos, innerPos + 3) !== \"asc\" || level > 4 || lhsLevel < 4) break loop;\n                    marks.unshift({\n                        name: \"asc\",\n                        position: startPos\n                    }), pos = innerPos + 3, lhsLevel = 4;\n                    break;\n                }\n            default:\n                switch(parseRegexStr(str, innerPos, IDENT)){\n                    case \"in\":\n                        {\n                            if (level > 4 || lhsLevel <= 4) break loop;\n                            pos = skipWS(str, innerPos + 2);\n                            let isGroup = !1;\n                            str[pos] === \"(\" && (isGroup = !0, pos = skipWS(str, pos + 1));\n                            let rangePos = pos, result = parseExpr(str, pos, 5);\n                            if (result.type === \"error\") return result;\n                            if (pos = skipWS(str, result.position), str[pos] === \".\" && str[pos + 1] === \".\") {\n                                let type = \"inc_range\";\n                                str[pos + 2] === \".\" ? (type = \"exc_range\", pos = skipWS(str, pos + 3)) : pos = skipWS(str, pos + 2);\n                                let rhs = parseExpr(str, pos, 5);\n                                if (rhs.type === \"error\") return rhs;\n                                marks.unshift({\n                                    name: \"in_range\",\n                                    position: startPos\n                                }), marks = marks.concat({\n                                    name: type,\n                                    position: rangePos\n                                }, result.marks, rhs.marks), pos = rhs.position;\n                            } else marks.unshift({\n                                name: \"comp\",\n                                position: startPos\n                            }), marks.push({\n                                name: \"op\",\n                                position: innerPos\n                            }, {\n                                name: \"op_end\",\n                                position: innerPos + 2\n                            }), marks = marks.concat(result.marks);\n                            if (isGroup) {\n                                if (pos = skipWS(str, pos), str[pos] !== \")\") return {\n                                    type: \"error\",\n                                    position: pos\n                                };\n                                pos++;\n                            }\n                            lhsLevel = 4;\n                            break;\n                        }\n                    case \"match\":\n                        {\n                            if (level > 4 || lhsLevel <= 4) break loop;\n                            let rhs = parseExpr(str, skipWS(str, innerPos + 5), 5);\n                            if (rhs.type === \"error\") return rhs;\n                            marks.unshift({\n                                name: \"comp\",\n                                position: startPos\n                            }), marks.push({\n                                name: \"op\",\n                                position: innerPos\n                            }, {\n                                name: \"op_end\",\n                                position: innerPos + 5\n                            }), marks = marks.concat(rhs.marks), pos = rhs.position, lhsLevel = 4;\n                            break;\n                        }\n                    default:\n                        break loop;\n                }\n        }\n    }\n    let failPosition = trav?.type === \"error\" && trav.position;\n    return {\n        type: \"success\",\n        marks,\n        position: pos,\n        failPosition\n    };\n}\nfunction parseTraversal(str, pos) {\n    let startPos = pos;\n    switch(str[pos]){\n        case \".\":\n            {\n                pos = skipWS(str, pos + 1);\n                let identStart = pos, identLen2 = parseRegex(str, pos, IDENT);\n                return identLen2 ? (pos += identLen2, {\n                    type: \"success\",\n                    marks: [\n                        {\n                            name: \"attr_access\",\n                            position: startPos\n                        },\n                        {\n                            name: \"ident\",\n                            position: identStart\n                        },\n                        {\n                            name: \"ident_end\",\n                            position: pos\n                        }\n                    ],\n                    position: pos\n                }) : {\n                    type: \"error\",\n                    position: pos\n                };\n            }\n        case \"-\":\n            if (str[pos + 1] !== \">\") return {\n                type: \"error\",\n                position: pos\n            };\n            let marks = [\n                {\n                    name: \"deref\",\n                    position: startPos\n                }\n            ];\n            pos += 2;\n            let identPos = skipWS(str, pos), identLen = parseRegex(str, identPos, IDENT);\n            return identLen && (pos = identPos + identLen, marks.push({\n                name: \"deref_attr\",\n                position: identPos\n            }, {\n                name: \"ident\",\n                position: identPos\n            }, {\n                name: \"ident_end\",\n                position: pos\n            })), {\n                type: \"success\",\n                marks,\n                position: pos\n            };\n        case \"[\":\n            {\n                if (pos = skipWS(str, pos + 1), str[pos] === \"]\") return {\n                    type: \"success\",\n                    marks: [\n                        {\n                            name: \"array_postfix\",\n                            position: startPos\n                        }\n                    ],\n                    position: pos + 1\n                };\n                let rangePos = pos, result = parseExpr(str, pos, 0);\n                if (result.type === \"error\") return result;\n                if (pos = skipWS(str, result.position), str[pos] === \".\" && str[pos + 1] === \".\") {\n                    let type = \"inc_range\";\n                    str[pos + 2] === \".\" ? (type = \"exc_range\", pos += 3) : pos += 2, pos = skipWS(str, pos);\n                    let rhs = parseExpr(str, pos, 0);\n                    return rhs.type === \"error\" ? rhs : (pos = skipWS(str, rhs.position), str[pos] !== \"]\" ? {\n                        type: \"error\",\n                        position: pos\n                    } : {\n                        type: \"success\",\n                        marks: [\n                            {\n                                name: \"slice\",\n                                position: startPos\n                            },\n                            {\n                                name: type,\n                                position: rangePos\n                            }\n                        ].concat(result.marks, rhs.marks),\n                        position: pos + 1\n                    });\n                }\n                return str[pos] !== \"]\" ? {\n                    type: \"error\",\n                    position: pos\n                } : {\n                    type: \"success\",\n                    marks: [\n                        {\n                            name: \"square_bracket\",\n                            position: startPos\n                        }\n                    ].concat(result.marks),\n                    position: pos + 1\n                };\n            }\n        case \"|\":\n            {\n                if (pos = skipWS(str, pos + 1), str[pos] === \"{\") {\n                    let result = parseObject(str, pos);\n                    return result.type === \"error\" || result.marks.unshift({\n                        name: \"projection\",\n                        position: startPos\n                    }), result;\n                }\n                break;\n            }\n        case \"{\":\n            {\n                let result = parseObject(str, pos);\n                return result.type === \"error\" || result.marks.unshift({\n                    name: \"projection\",\n                    position: startPos\n                }), result;\n            }\n    }\n    return {\n        type: \"error\",\n        position: pos\n    };\n}\nfunction parseFuncCall(str, startPos, pos) {\n    let marks = [];\n    if (marks.push({\n        name: \"func_call\",\n        position: startPos\n    }), str[pos] === \":\" && str[pos + 1] === \":\") {\n        marks.push({\n            name: \"namespace\",\n            position: startPos\n        }), marks.push({\n            name: \"ident\",\n            position: startPos\n        }, {\n            name: \"ident_end\",\n            position: pos\n        }), pos = skipWS(str, pos + 2);\n        let nameLen = parseRegex(str, pos, IDENT);\n        if (!nameLen) return {\n            type: \"error\",\n            position: pos\n        };\n        if (marks.push({\n            name: \"ident\",\n            position: pos\n        }, {\n            name: \"ident_end\",\n            position: pos + nameLen\n        }), pos = skipWS(str, pos + nameLen), str[pos] !== \"(\") return {\n            type: \"error\",\n            position: pos\n        };\n        pos++, pos = skipWS(str, pos);\n    } else marks.push({\n        name: \"ident\",\n        position: startPos\n    }, {\n        name: \"ident_end\",\n        position: pos\n    }), pos = skipWS(str, pos + 1);\n    let lastPos = pos;\n    if (str[pos] !== \")\") for(;;){\n        let result = parseExpr(str, pos, 0);\n        if (result.type === \"error\") return result;\n        if (marks = marks.concat(result.marks), lastPos = result.position, pos = skipWS(str, result.position), str[pos] !== \",\" || (pos = skipWS(str, pos + 1), str[pos] === \")\")) break;\n    }\n    return str[pos] !== \")\" ? {\n        type: \"error\",\n        position: pos\n    } : (marks.push({\n        name: \"func_args_end\",\n        position: lastPos\n    }), {\n        type: \"success\",\n        marks,\n        position: pos + 1\n    });\n}\nfunction parseObject(str, pos) {\n    let marks = [\n        {\n            name: \"object\",\n            position: pos\n        }\n    ];\n    for(pos = skipWS(str, pos + 1); str[pos] !== \"}\";){\n        let pairPos = pos;\n        if (str.slice(pos, pos + 3) === \"...\") if (pos = skipWS(str, pos + 3), str[pos] !== \"}\" && str[pos] !== \",\") {\n            let expr = parseExpr(str, pos, 0);\n            if (expr.type === \"error\") return expr;\n            marks.push({\n                name: \"object_splat\",\n                position: pairPos\n            }), marks = marks.concat(expr.marks), pos = expr.position;\n        } else marks.push({\n            name: \"object_splat_this\",\n            position: pairPos\n        });\n        else {\n            let expr = parseExpr(str, pos, 0);\n            if (expr.type === \"error\") return expr;\n            let nextPos = skipWS(str, expr.position);\n            if (expr.marks[0].name === \"str\" && str[nextPos] === \":\") {\n                let value = parseExpr(str, skipWS(str, nextPos + 1), 0);\n                if (value.type === \"error\") return value;\n                marks.push({\n                    name: \"object_pair\",\n                    position: pairPos\n                }), marks = marks.concat(expr.marks, value.marks), pos = value.position;\n            } else marks = marks.concat({\n                name: \"object_expr\",\n                position: pos\n            }, expr.marks), pos = expr.position;\n        }\n        if (pos = skipWS(str, pos), str[pos] !== \",\") break;\n        pos = skipWS(str, pos + 1);\n    }\n    return str[pos] !== \"}\" ? {\n        type: \"error\",\n        position: pos\n    } : (pos++, marks.push({\n        name: \"object_end\",\n        position: pos\n    }), {\n        type: \"success\",\n        marks,\n        position: pos\n    });\n}\nfunction parseString(str, pos) {\n    let token = str[pos];\n    pos = pos + 1;\n    const marks = [\n        {\n            name: \"str\",\n            position: pos\n        }\n    ];\n    str: for(;; pos++){\n        if (pos > str.length) return {\n            type: \"error\",\n            position: pos\n        };\n        switch(str[pos]){\n            case token:\n                {\n                    marks.push({\n                        name: \"str_end\",\n                        position: pos\n                    }), pos++;\n                    break str;\n                }\n            case \"\\\\\":\n                marks.push({\n                    name: \"str_pause\",\n                    position: pos\n                }), str[pos + 1] === \"u\" ? str[pos + 2] === \"{\" ? (marks.push({\n                    name: \"unicode_hex\",\n                    position: pos + 3\n                }), pos = str.indexOf(\"}\", pos + 3), marks.push({\n                    name: \"unicode_hex_end\",\n                    position: pos\n                })) : (marks.push({\n                    name: \"unicode_hex\",\n                    position: pos + 2\n                }), marks.push({\n                    name: \"unicode_hex_end\",\n                    position: pos + 6\n                }), pos += 5) : (marks.push({\n                    name: \"single_escape\",\n                    position: pos + 1\n                }), pos += 1), marks.push({\n                    name: \"str_start\",\n                    position: pos + 1\n                });\n        }\n    }\n    return {\n        type: \"success\",\n        marks,\n        position: pos\n    };\n}\nfunction skipWS(str, pos) {\n    return pos + parseRegex(str, pos, WS);\n}\nfunction parseRegex(str, pos, re) {\n    let m = re.exec(str.slice(pos));\n    return m ? m[0].length : 0;\n}\nfunction parseRegexStr(str, pos, re) {\n    let m = re.exec(str.slice(pos));\n    return m ? m[0] : null;\n}\nfunction join(a, b) {\n    return (base)=>b(a(base));\n}\nfunction map(inner) {\n    return (base)=>({\n            type: \"Map\",\n            base,\n            expr: inner({\n                type: \"This\"\n            })\n        });\n}\nfunction flatMap(inner) {\n    return (base)=>({\n            type: \"FlatMap\",\n            base,\n            expr: inner({\n                type: \"This\"\n            })\n        });\n}\nfunction traverseArray(build, right) {\n    if (!right) return {\n        type: \"a-a\",\n        build\n    };\n    switch(right.type){\n        case \"a-a\":\n            return {\n                type: \"a-a\",\n                build: join(build, right.build)\n            };\n        case \"a-b\":\n            return {\n                type: \"a-b\",\n                build: join(build, right.build)\n            };\n        case \"b-b\":\n            return {\n                type: \"a-a\",\n                build: join(build, map(right.build))\n            };\n        case \"b-a\":\n            return {\n                type: \"a-a\",\n                build: join(build, flatMap(right.build))\n            };\n        default:\n            throw new Error(`unknown type: ${right.type}`);\n    }\n}\nfunction traversePlain(mapper, right) {\n    if (!right) return {\n        type: \"b-b\",\n        build: mapper\n    };\n    switch(right.type){\n        case \"a-a\":\n        case \"b-a\":\n            return {\n                type: \"b-a\",\n                build: join(mapper, right.build)\n            };\n        case \"a-b\":\n        case \"b-b\":\n            return {\n                type: \"b-b\",\n                build: join(mapper, right.build)\n            };\n        default:\n            throw new Error(`unknown type: ${right.type}`);\n    }\n}\nfunction traverseElement(mapper, right) {\n    if (!right) return {\n        type: \"a-b\",\n        build: mapper\n    };\n    switch(right.type){\n        case \"a-a\":\n        case \"b-a\":\n            return {\n                type: \"a-a\",\n                build: join(mapper, right.build)\n            };\n        case \"a-b\":\n        case \"b-b\":\n            return {\n                type: \"a-b\",\n                build: join(mapper, right.build)\n            };\n        default:\n            throw new Error(`unknown type: ${right.type}`);\n    }\n}\nfunction traverseProjection(mapper, right) {\n    if (!right) return {\n        type: \"b-b\",\n        build: mapper\n    };\n    switch(right.type){\n        case \"a-a\":\n            return {\n                type: \"a-a\",\n                build: join(map(mapper), right.build)\n            };\n        case \"a-b\":\n            return {\n                type: \"a-b\",\n                build: join(map(mapper), right.build)\n            };\n        case \"b-a\":\n            return {\n                type: \"b-a\",\n                build: join(mapper, right.build)\n            };\n        case \"b-b\":\n            return {\n                type: \"b-b\",\n                build: join(mapper, right.build)\n            };\n        default:\n            throw new Error(`unknown type: ${right.type}`);\n    }\n}\nconst ESCAPE_SEQUENCE = {\n    \"'\": \"'\",\n    '\"': '\"',\n    \"\\\\\": \"\\\\\",\n    \"/\": \"/\",\n    b: \"\\b\",\n    f: \"\\f\",\n    n: `\n`,\n    r: \"\\r\",\n    t: \"\t\"\n};\nfunction expandHex(str) {\n    const charCode = parseInt(str, 16);\n    return String.fromCharCode(charCode);\n}\nclass GroqQueryError extends Error {\n    constructor(...args){\n        super(...args);\n        this.name = \"GroqQueryError\";\n    }\n}\nconst EXPR_BUILDER = {\n    group (p) {\n        return {\n            type: \"Group\",\n            base: p.process(EXPR_BUILDER)\n        };\n    },\n    everything () {\n        return {\n            type: \"Everything\"\n        };\n    },\n    this () {\n        return {\n            type: \"This\"\n        };\n    },\n    parent () {\n        return {\n            type: \"Parent\",\n            n: 1\n        };\n    },\n    dblparent (p) {\n        return {\n            type: \"Parent\",\n            n: p.process(EXPR_BUILDER).n + 1\n        };\n    },\n    traverse (p) {\n        const base = p.process(EXPR_BUILDER), traversalList = [];\n        for(; p.getMark().name !== \"traversal_end\";)traversalList.push(p.process(TRAVERSE_BUILDER));\n        p.shift();\n        let traversal = null;\n        for(let i = traversalList.length - 1; i >= 0; i--)traversal = traversalList[i](traversal);\n        if ((base.type === \"Everything\" || base.type === \"Array\" || base.type === \"PipeFuncCall\") && (traversal = traverseArray((val)=>val, traversal)), traversal === null) throw new Error(\"BUG: unexpected empty traversal\");\n        return traversal.build(base);\n    },\n    this_attr (p) {\n        const name = p.processString();\n        return name === \"null\" ? {\n            type: \"Value\",\n            value: null\n        } : name === \"true\" ? {\n            type: \"Value\",\n            value: !0\n        } : name === \"false\" ? {\n            type: \"Value\",\n            value: !1\n        } : {\n            type: \"AccessAttribute\",\n            name\n        };\n    },\n    neg (p) {\n        return {\n            type: \"Neg\",\n            base: p.process(EXPR_BUILDER)\n        };\n    },\n    pos (p) {\n        return {\n            type: \"Pos\",\n            base: p.process(EXPR_BUILDER)\n        };\n    },\n    add (p) {\n        const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n        return {\n            type: \"OpCall\",\n            op: \"+\",\n            left,\n            right\n        };\n    },\n    sub (p) {\n        const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n        return {\n            type: \"OpCall\",\n            op: \"-\",\n            left,\n            right\n        };\n    },\n    mul (p) {\n        const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n        return {\n            type: \"OpCall\",\n            op: \"*\",\n            left,\n            right\n        };\n    },\n    div (p) {\n        const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n        return {\n            type: \"OpCall\",\n            op: \"/\",\n            left,\n            right\n        };\n    },\n    mod (p) {\n        const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n        return {\n            type: \"OpCall\",\n            op: \"%\",\n            left,\n            right\n        };\n    },\n    pow (p) {\n        const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n        return {\n            type: \"OpCall\",\n            op: \"**\",\n            left,\n            right\n        };\n    },\n    comp (p) {\n        const left = p.process(EXPR_BUILDER), op = p.processString(), right = p.process(EXPR_BUILDER);\n        return {\n            type: \"OpCall\",\n            op,\n            left,\n            right\n        };\n    },\n    in_range (p) {\n        const base = p.process(EXPR_BUILDER), isInclusive = p.getMark().name === \"inc_range\";\n        p.shift();\n        const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n        return {\n            type: \"InRange\",\n            base,\n            left,\n            right,\n            isInclusive\n        };\n    },\n    str (p) {\n        let value = \"\";\n        loop: for(; p.hasMark();){\n            const mark = p.getMark();\n            switch(mark.name){\n                case \"str_end\":\n                    value += p.processStringEnd();\n                    break loop;\n                case \"str_pause\":\n                    value += p.processStringEnd();\n                    break;\n                case \"str_start\":\n                    p.shift();\n                    break;\n                case \"single_escape\":\n                    {\n                        const char = p.slice(1);\n                        p.shift(), value += ESCAPE_SEQUENCE[char];\n                        break;\n                    }\n                case \"unicode_hex\":\n                    p.shift(), value += expandHex(p.processStringEnd());\n                    break;\n                default:\n                    throw new Error(`unexpected mark: ${mark.name}`);\n            }\n        }\n        return {\n            type: \"Value\",\n            value\n        };\n    },\n    integer (p) {\n        const strValue = p.processStringEnd();\n        return {\n            type: \"Value\",\n            value: Number(strValue)\n        };\n    },\n    float (p) {\n        const strValue = p.processStringEnd();\n        return {\n            type: \"Value\",\n            value: Number(strValue)\n        };\n    },\n    sci (p) {\n        const strValue = p.processStringEnd();\n        return {\n            type: \"Value\",\n            value: Number(strValue)\n        };\n    },\n    object (p) {\n        const attributes = [];\n        for(; p.getMark().name !== \"object_end\";)attributes.push(p.process(OBJECT_BUILDER));\n        return p.shift(), {\n            type: \"Object\",\n            attributes\n        };\n    },\n    array (p) {\n        const elements = [];\n        for(; p.getMark().name !== \"array_end\";){\n            let isSplat = !1;\n            p.getMark().name === \"array_splat\" && (isSplat = !0, p.shift());\n            const value = p.process(EXPR_BUILDER);\n            elements.push({\n                type: \"ArrayElement\",\n                value,\n                isSplat\n            });\n        }\n        return p.shift(), {\n            type: \"Array\",\n            elements\n        };\n    },\n    tuple (p) {\n        const members = [];\n        for(; p.getMark().name !== \"tuple_end\";)members.push(p.process(EXPR_BUILDER));\n        return p.shift(), {\n            type: \"Tuple\",\n            members\n        };\n    },\n    func_call (p) {\n        let namespace = \"global\";\n        p.getMark().name === \"namespace\" && (p.shift(), namespace = p.processString());\n        const name = p.processString();\n        if (namespace === \"global\" && name === \"select\") {\n            const result = {\n                type: \"Select\",\n                alternatives: []\n            };\n            for(; p.getMark().name !== \"func_args_end\";)if (p.getMark().name === \"pair\") {\n                if (result.fallback) throw new GroqQueryError(\"unexpected argument to select()\");\n                p.shift();\n                const condition = p.process(EXPR_BUILDER), value = p.process(EXPR_BUILDER);\n                result.alternatives.push({\n                    type: \"SelectAlternative\",\n                    condition,\n                    value\n                });\n            } else {\n                if (result.fallback) throw new GroqQueryError(\"unexpected argument to select()\");\n                const value = p.process(EXPR_BUILDER);\n                result.fallback = value;\n            }\n            return p.shift(), result;\n        }\n        const args = [];\n        for(; p.getMark().name !== \"func_args_end\";)argumentShouldBeSelector(namespace, name, args.length) ? (p.process(SELECTOR_BUILDER), args.push({\n            type: \"Selector\"\n        })) : args.push(p.process(EXPR_BUILDER));\n        if (p.shift(), namespace === \"global\" && (name === \"before\" || name === \"after\") && p.parseOptions.mode === \"delta\") return {\n            type: \"Context\",\n            key: name\n        };\n        if (namespace === \"global\" && name === \"boost\" && !p.allowBoost) throw new GroqQueryError(\"unexpected boost\");\n        const funcs = namespaces[namespace];\n        if (!funcs) throw new GroqQueryError(`Undefined namespace: ${namespace}`);\n        const func = funcs[name];\n        if (!func) throw new GroqQueryError(`Undefined function: ${name}`);\n        if (func.arity !== void 0 && validateArity(name, func.arity, args.length), func.mode !== void 0 && func.mode !== p.parseOptions.mode) throw new GroqQueryError(`Undefined function: ${name}`);\n        return {\n            type: \"FuncCall\",\n            func,\n            namespace,\n            name,\n            args\n        };\n    },\n    pipecall (p) {\n        const base = p.process(EXPR_BUILDER);\n        p.shift();\n        let namespace = \"global\";\n        if (p.getMark().name === \"namespace\" && (p.shift(), namespace = p.processString()), namespace !== \"global\") throw new GroqQueryError(`Undefined namespace: ${namespace}`);\n        const name = p.processString(), args = [], oldAllowBoost = p.allowBoost;\n        for(name === \"score\" && (p.allowBoost = !0);;){\n            const markName = p.getMark().name;\n            if (markName === \"func_args_end\") break;\n            if (name === \"order\") {\n                if (markName === \"asc\") {\n                    p.shift(), args.push({\n                        type: \"Asc\",\n                        base: p.process(EXPR_BUILDER)\n                    });\n                    continue;\n                } else if (markName === \"desc\") {\n                    p.shift(), args.push({\n                        type: \"Desc\",\n                        base: p.process(EXPR_BUILDER)\n                    });\n                    continue;\n                }\n            }\n            args.push(p.process(EXPR_BUILDER));\n        }\n        p.shift(), p.allowBoost = oldAllowBoost;\n        const func = pipeFunctions[name];\n        if (!func) throw new GroqQueryError(`Undefined pipe function: ${name}`);\n        return func.arity && validateArity(name, func.arity, args.length), {\n            type: \"PipeFuncCall\",\n            func,\n            base,\n            name,\n            args\n        };\n    },\n    pair () {\n        throw new GroqQueryError(\"unexpected =>\");\n    },\n    and (p) {\n        const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n        return {\n            type: \"And\",\n            left,\n            right\n        };\n    },\n    or (p) {\n        const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n        return {\n            type: \"Or\",\n            left,\n            right\n        };\n    },\n    not (p) {\n        return {\n            type: \"Not\",\n            base: p.process(EXPR_BUILDER)\n        };\n    },\n    asc () {\n        throw new GroqQueryError(\"unexpected asc\");\n    },\n    desc () {\n        throw new GroqQueryError(\"unexpected desc\");\n    },\n    param (p) {\n        const name = p.processString();\n        return p.parseOptions.params && p.parseOptions.params.hasOwnProperty(name) ? {\n            type: \"Value\",\n            value: p.parseOptions.params[name]\n        } : {\n            type: \"Parameter\",\n            name\n        };\n    }\n}, OBJECT_BUILDER = {\n    object_expr (p) {\n        if (p.getMark().name === \"pair\") {\n            p.shift();\n            const condition = p.process(EXPR_BUILDER), value2 = p.process(EXPR_BUILDER);\n            return {\n                type: \"ObjectConditionalSplat\",\n                condition,\n                value: value2\n            };\n        }\n        const value = p.process(EXPR_BUILDER);\n        return {\n            type: \"ObjectAttributeValue\",\n            name: extractPropertyKey(value),\n            value\n        };\n    },\n    object_pair (p) {\n        const name = p.process(EXPR_BUILDER);\n        if (name.type !== \"Value\") throw new Error(\"name must be string\");\n        const value = p.process(EXPR_BUILDER);\n        return {\n            type: \"ObjectAttributeValue\",\n            name: name.value,\n            value\n        };\n    },\n    object_splat (p) {\n        return {\n            type: \"ObjectSplat\",\n            value: p.process(EXPR_BUILDER)\n        };\n    },\n    object_splat_this () {\n        return {\n            type: \"ObjectSplat\",\n            value: {\n                type: \"This\"\n            }\n        };\n    }\n}, TRAVERSE_BUILDER = {\n    square_bracket (p) {\n        const expr = p.process(EXPR_BUILDER), value = tryConstantEvaluate(expr);\n        return value && value.type === \"number\" ? (right)=>traverseElement((base)=>({\n                    type: \"AccessElement\",\n                    base,\n                    index: value.data\n                }), right) : value && value.type === \"string\" ? (right)=>traversePlain((base)=>({\n                    type: \"AccessAttribute\",\n                    base,\n                    name: value.data\n                }), right) : (right)=>traverseArray((base)=>({\n                    type: \"Filter\",\n                    base,\n                    expr\n                }), right);\n    },\n    slice (p) {\n        const isInclusive = p.getMark().name === \"inc_range\";\n        p.shift();\n        const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER), leftValue = tryConstantEvaluate(left), rightValue = tryConstantEvaluate(right);\n        if (!leftValue || !rightValue || leftValue.type !== \"number\" || rightValue.type !== \"number\") throw new GroqQueryError(\"slicing must use constant numbers\");\n        return (rhs)=>traverseArray((base)=>({\n                    type: \"Slice\",\n                    base,\n                    left: leftValue.data,\n                    right: rightValue.data,\n                    isInclusive\n                }), rhs);\n    },\n    projection (p) {\n        const obj = p.process(EXPR_BUILDER);\n        return (right)=>traverseProjection((base)=>({\n                    type: \"Projection\",\n                    base,\n                    expr: obj\n                }), right);\n    },\n    attr_access (p) {\n        const name = p.processString();\n        return (right)=>traversePlain((base)=>({\n                    type: \"AccessAttribute\",\n                    base,\n                    name\n                }), right);\n    },\n    deref (p) {\n        let attr = null;\n        p.getMark().name === \"deref_attr\" && (p.shift(), attr = p.processString());\n        const wrap = (base)=>attr ? {\n                type: \"AccessAttribute\",\n                base,\n                name: attr\n            } : base;\n        return (right)=>traversePlain((base)=>wrap({\n                    type: \"Deref\",\n                    base\n                }), right);\n    },\n    array_postfix () {\n        return (right)=>traverseArray((base)=>({\n                    type: \"ArrayCoerce\",\n                    base\n                }), right);\n    }\n}, SELECTOR_BUILDER = {\n    group (p) {\n        return p.process(SELECTOR_BUILDER), null;\n    },\n    everything () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    this () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    parent () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    dblparent () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    traverse (p) {\n        for(p.process(SELECTOR_BUILDER); p.getMark().name !== \"traversal_end\";)p.process(TRAVERSE_BUILDER);\n        return p.shift(), null;\n    },\n    this_attr (p) {\n        return p.processString(), null;\n    },\n    neg () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    pos () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    add () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    sub () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    mul () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    div () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    mod () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    pow () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    comp () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    in_range () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    str () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    integer () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    float () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    sci () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    object () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    array () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    tuple () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    func_call (p, mark) {\n        const func = EXPR_BUILDER.func_call(p, mark);\n        if (func.name === \"anywhere\" && func.args.length === 1) return null;\n        throw new Error(\"Invalid selector syntax\");\n    },\n    pipecall () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    pair () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    and () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    or () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    not () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    asc () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    desc () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    param () {\n        throw new Error(\"Invalid selector syntax\");\n    }\n};\nfunction extractPropertyKey(node) {\n    if (node.type === \"AccessAttribute\" && !node.base) return node.name;\n    if (node.type === \"PipeFuncCall\" || node.type === \"Deref\" || node.type === \"Map\" || node.type === \"Projection\" || node.type === \"Slice\" || node.type === \"Filter\" || node.type === \"AccessElement\" || node.type === \"ArrayCoerce\" || node.type === \"Group\") return extractPropertyKey(node.base);\n    throw new GroqQueryError(`Cannot determine property key for type: ${node.type}`);\n}\nfunction validateArity(name, arity, count) {\n    if (typeof arity == \"number\") {\n        if (count !== arity) throw new GroqQueryError(`Incorrect number of arguments to function ${name}(). Expected ${arity}, got ${count}.`);\n    } else if (arity && !arity(count)) throw new GroqQueryError(`Incorrect number of arguments to function ${name}().`);\n}\nfunction argumentShouldBeSelector(namespace, functionName, argCount) {\n    const functionsRequiringSelectors = [\n        \"changedAny\",\n        \"changedOnly\"\n    ];\n    return namespace == \"diff\" && argCount == 2 && functionsRequiringSelectors.includes(functionName);\n}\nclass GroqSyntaxError extends Error {\n    constructor(position){\n        var _temp;\n        _temp = super(`Syntax error in GROQ query at position ${position}`), this.name = \"GroqSyntaxError\", _temp, this.position = position;\n    }\n}\nfunction parse(input, options = {}) {\n    const result = parse$1(input);\n    if (result.type === \"error\") throw new GroqSyntaxError(result.position);\n    return new MarkProcessor(input, result.marks, options).process(EXPR_BUILDER);\n}\nconst { compare } = new Intl.Collator(\"en\");\nfunction typeNodesSorter(a, b) {\n    return a.type === \"null\" ? 1 : compare(hashField(a), hashField(b));\n}\nconst hashCache = /* @__PURE__ */ new WeakMap();\nfunction hashField(field) {\n    if (hashCache.has(field)) return hashCache.get(field);\n    const hash = calculateFieldHash(field);\n    return hashCache.set(field, hash), hash;\n}\nfunction calculateFieldHash(field) {\n    switch(field.type){\n        case \"string\":\n        case \"number\":\n        case \"boolean\":\n            return field.value !== void 0 ? `${field.type}(${field.value})` : `${field.type}`;\n        case \"null\":\n        case \"unknown\":\n            return field.type;\n        case \"array\":\n            return `${field.type}(${hashField(field.of)})`;\n        case \"object\":\n            {\n                const attributes = Object.entries(field.attributes);\n                return attributes.sort(([a], [b])=>compare(a, b)), `${field.type}:(${attributes.map(([key, value])=>`${key}:${hashField(value.value)}(${value.optional ? \"optional\" : \"non-optional\"})`).join(\",\")}):ref-${field.dereferencesTo}:${field.rest ? hashField(field.rest) : \"no-rest\"}`;\n            }\n        case \"union\":\n            {\n                const sorted = [\n                    ...field.of\n                ];\n                return sorted.sort(typeNodesSorter), `${field.type}(${sorted.map(hashField).join(\",\")})`;\n            }\n        case \"inline\":\n            return `${field.type}(${field.name})`;\n        default:\n            return field.type;\n    }\n}\nfunction removeDuplicateTypeNodes(typeNodes) {\n    const seenTypes = /* @__PURE__ */ new Set(), newTypeNodes = [], sortedTypeNodes = [\n        ...typeNodes\n    ];\n    sortedTypeNodes.sort(typeNodesSorter);\n    for (const typeNode of sortedTypeNodes){\n        const hash = hashField(typeNode);\n        if (hash === null) {\n            newTypeNodes.push(typeNode);\n            continue;\n        }\n        seenTypes.has(hash) || (seenTypes.add(hash), newTypeNodes.push(typeNode));\n    }\n    return newTypeNodes;\n}\nfunction optimizeUnions(field) {\n    if (field.type === \"union\") {\n        if (field.of.length === 0) return field;\n        if (field.of = removeDuplicateTypeNodes(field.of), field.of.length === 1) return optimizeUnions(field.of[0]);\n        for(let idx = 0; field.of.length > idx; idx++){\n            const subField = field.of[idx];\n            if (subField.type === \"union\") {\n                field.of.splice(idx, 1, ...subField.of), idx--;\n                continue;\n            }\n            field.of[idx] = optimizeUnions(subField);\n        }\n        return field.of.sort((a, b)=>a.type === \"null\" ? 1 : compare(hashField(a), hashField(b))), field;\n    }\n    if (field.type === \"array\") return field.of = optimizeUnions(field.of), field;\n    if (field.type === \"object\") {\n        for(const idx in field.attributes)Object.hasOwn(field.attributes, idx) && (field.attributes[idx].value = optimizeUnions(field.attributes[idx].value));\n        return field;\n    }\n    return field;\n}\nfunction createReferenceTypeNode(name, inArray = !1) {\n    const attributes = {\n        _ref: {\n            type: \"objectAttribute\",\n            value: {\n                type: \"string\"\n            }\n        },\n        _type: {\n            type: \"objectAttribute\",\n            value: {\n                type: \"string\",\n                value: \"reference\"\n            }\n        },\n        _weak: {\n            type: \"objectAttribute\",\n            value: {\n                type: \"boolean\"\n            },\n            optional: !0\n        }\n    };\n    return inArray && (attributes._key = {\n        type: \"objectAttribute\",\n        value: {\n            type: \"string\"\n        }\n    }), {\n        type: \"object\",\n        attributes,\n        dereferencesTo: name\n    };\n}\nfunction nullUnion(node) {\n    return node.type === \"union\" ? unionOf(...node.of, {\n        type: \"null\"\n    }) : unionOf(node, {\n        type: \"null\"\n    });\n}\nfunction unionOf(...nodes) {\n    return {\n        type: \"union\",\n        of: nodes\n    };\n}\nfunction resolveInline(node, scope) {\n    if (node.type === \"inline\") {\n        const resolvedInline = scope.context.lookupTypeDeclaration(node);\n        return resolveInline(resolvedInline, scope);\n    }\n    return node;\n}\nfunction mapNode(node, scope, mapper, mergeUnions = (nodes)=>optimizeUnions({\n        type: \"union\",\n        of: nodes\n    })) {\n    switch(node.type){\n        case \"boolean\":\n        case \"array\":\n        case \"null\":\n        case \"object\":\n        case \"string\":\n        case \"number\":\n        case \"unknown\":\n            return mapper(node);\n        case \"union\":\n            return mergeUnions(node.of.map((inner)=>mapNode(inner, scope, mapper), mergeUnions));\n        case \"inline\":\n            {\n                const resolvedInline = resolveInline(node, scope);\n                return mapNode(resolvedInline, scope, mapper, mergeUnions);\n            }\n        default:\n            throw new Error(`Unknown type: ${node.type}`);\n    }\n}\nfunction isFuncCall(node, name) {\n    return node.type === \"Group\" ? isFuncCall(node.base, name) : node.type === \"FuncCall\" && `${node.namespace}::${node.name}` === name;\n}\nfunction booleanValue(node, scope) {\n    switch(node.type){\n        case \"unknown\":\n            return {\n                canBeTrue: !0,\n                canBeFalse: !0,\n                canBeNull: !0\n            };\n        case \"boolean\":\n            return node.value === !0 ? {\n                canBeTrue: !0,\n                canBeFalse: !1,\n                canBeNull: !1\n            } : node.value === !1 ? {\n                canBeTrue: !1,\n                canBeFalse: !0,\n                canBeNull: !1\n            } : {\n                canBeTrue: !0,\n                canBeFalse: !0,\n                canBeNull: !1\n            };\n        case \"union\":\n            {\n                const value = {\n                    canBeTrue: !1,\n                    canBeFalse: !1,\n                    canBeNull: !1\n                };\n                for (const sub of node.of){\n                    const match2 = booleanValue(sub, scope);\n                    match2.canBeNull && (value.canBeNull = !0), match2.canBeTrue && (value.canBeTrue = !0), match2.canBeFalse && (value.canBeFalse = !0);\n                }\n                return value;\n            }\n        case \"inline\":\n            {\n                const resolved = resolveInline(node, scope);\n                return booleanValue(resolved, scope);\n            }\n        case \"null\":\n        case \"string\":\n        case \"number\":\n        case \"object\":\n        case \"array\":\n            return {\n                canBeTrue: !1,\n                canBeFalse: !1,\n                canBeNull: !0\n            };\n        default:\n            throw new Error(`unknown node type ${node.type}`);\n    }\n}\nfunction booleanOr(left, right) {\n    return left.canBeTrue && !left.canBeFalse && !left.canBeNull ? left : right.canBeTrue && !right.canBeFalse && !right.canBeNull ? right : {\n        // Either side can be true for the expression to be true\n        canBeTrue: left.canBeTrue || right.canBeTrue,\n        // Both sides must be false for the expression to be false\n        canBeFalse: left.canBeFalse && right.canBeFalse,\n        // if either side can be null, the expression can be null if the other side can't only be true\n        canBeNull: left.canBeNull || right.canBeNull\n    };\n}\nfunction booleanAnd(left, right) {\n    return left.canBeFalse && !left.canBeTrue && !left.canBeNull ? left : right.canBeFalse && !right.canBeTrue && !right.canBeNull ? right : {\n        // Both sides must be true for the expression to be true\n        canBeTrue: left.canBeTrue && right.canBeTrue,\n        // if either side can be false, the expression can be false\n        canBeFalse: left.canBeFalse || right.canBeFalse,\n        // if either side can be null, the expression can be null\n        canBeNull: left.canBeNull || right.canBeNull\n    };\n}\nfunction booleanInterpretationToTypeNode(bool) {\n    return bool.canBeTrue ? bool.canBeFalse ? bool.canBeNull ? nullUnion({\n        type: \"boolean\"\n    }) : {\n        type: \"boolean\"\n    } : bool.canBeNull ? nullUnion({\n        type: \"boolean\",\n        value: !0\n    }) : {\n        type: \"boolean\",\n        value: !0\n    } : bool.canBeFalse ? bool.canBeNull ? nullUnion({\n        type: \"boolean\",\n        value: !1\n    }) : {\n        type: \"boolean\",\n        value: !1\n    } : {\n        type: \"null\"\n    };\n}\nconst $trace$1 = debug__WEBPACK_IMPORTED_MODULE_0__(\"typeEvaluator:scope:trace\");\n$trace$1.log = console.log.bind(console);\nclass Context {\n    constructor(schema){\n        this.schema = schema;\n    }\n    lookupRef(refTo) {\n        for (const val of this.schema)if (val.type === \"document\" && val.name === refTo) return {\n            type: \"object\",\n            attributes: val.attributes\n        };\n        return {\n            type: \"null\"\n        };\n    }\n    lookupTypeDeclaration(alias) {\n        for (const val of this.schema)if (val.type === \"type\" && val.name === alias.name) return val.value;\n        return {\n            type: \"null\"\n        };\n    }\n}\nclass Scope2 {\n    constructor(value, parent, context){\n        this.value = {\n            type: \"union\",\n            of: value\n        }, this.parent = parent, this.context = context || parent?.context || new Context([]), this.isHidden = !1;\n    }\n    createNested(value) {\n        return this.isHidden ? new Scope2(value, this.parent, this.context) : new Scope2(value, this, this.context);\n    }\n    createHidden(value) {\n        const result = this.createNested(value);\n        return result.isHidden = !0, result;\n    }\n}\nfunction unionWithoutNull(unionTypeNode) {\n    return unionTypeNode.type === \"union\" ? {\n        type: \"union\",\n        of: unionTypeNode.of.filter((type)=>type.type !== \"null\")\n    } : unionTypeNode;\n}\nfunction handleFuncCallNode(node, scope) {\n    switch(`${node.namespace}.${node.name}`){\n        case \"array.compact\":\n            {\n                const arg = walk({\n                    node: node.args[0],\n                    scope\n                });\n                return mapNode(arg, scope, (arg2)=>{\n                    if (arg2.type === \"unknown\") return nullUnion({\n                        type: \"array\",\n                        of: {\n                            type: \"unknown\"\n                        }\n                    });\n                    if (arg2.type !== \"array\") return {\n                        type: \"null\"\n                    };\n                    const of = mapNode(arg2.of, scope, (of2)=>of2);\n                    return {\n                        type: \"array\",\n                        of: unionWithoutNull(of)\n                    };\n                });\n            }\n        case \"array.join\":\n            {\n                const arrayArg = walk({\n                    node: node.args[0],\n                    scope\n                }), sepArg = walk({\n                    node: node.args[1],\n                    scope\n                });\n                return mapNode(arrayArg, scope, (arrayArg2)=>mapNode(sepArg, scope, (sepArg2)=>arrayArg2.type === \"unknown\" || sepArg2.type === \"unknown\" ? nullUnion({\n                            type: \"string\"\n                        }) : arrayArg2.type !== \"array\" || sepArg2.type !== \"string\" ? {\n                            type: \"null\"\n                        } : mapNode(arrayArg2.of, scope, (of)=>of.type === \"unknown\" ? nullUnion({\n                                type: \"string\"\n                            }) : of.type !== \"string\" && of.type !== \"number\" && of.type !== \"boolean\" ? {\n                                type: \"null\"\n                            } : {\n                                type: \"string\"\n                            })));\n            }\n        case \"array.unique\":\n            {\n                const arg = walk({\n                    node: node.args[0],\n                    scope\n                });\n                return mapNode(arg, scope, (arg2)=>arg2.type === \"unknown\" ? nullUnion({\n                        type: \"array\",\n                        of: {\n                            type: \"unknown\"\n                        }\n                    }) : arg2.type !== \"array\" ? {\n                        type: \"null\"\n                    } : arg2);\n            }\n        case \"array.intersects\":\n            {\n                const arg1 = walk({\n                    node: node.args[0],\n                    scope\n                }), arg2 = walk({\n                    node: node.args[1],\n                    scope\n                });\n                return mapNode(arg1, scope, (arg12)=>mapNode(arg2, scope, (arg22)=>arg12.type !== \"array\" ? {\n                            type: \"null\"\n                        } : arg22.type !== \"array\" ? {\n                            type: \"null\"\n                        } : {\n                            type: \"boolean\"\n                        }));\n            }\n        case \"global.lower\":\n            {\n                const arg = walk({\n                    node: node.args[0],\n                    scope\n                });\n                return mapNode(arg, scope, (arg2)=>arg2.type === \"unknown\" ? nullUnion({\n                        type: \"string\"\n                    }) : arg2.type !== \"string\" ? {\n                        type: \"null\"\n                    } : arg2.value !== void 0 ? {\n                        type: \"string\",\n                        value: arg2.value.toLowerCase()\n                    } : {\n                        type: \"string\"\n                    });\n            }\n        case \"global.upper\":\n            {\n                const arg = walk({\n                    node: node.args[0],\n                    scope\n                });\n                return mapNode(arg, scope, (arg2)=>arg2.type === \"unknown\" ? nullUnion({\n                        type: \"string\"\n                    }) : arg2.type !== \"string\" ? {\n                        type: \"null\"\n                    } : arg2.value !== void 0 ? {\n                        type: \"string\",\n                        value: arg2.value.toUpperCase()\n                    } : {\n                        type: \"string\"\n                    });\n            }\n        case \"dateTime.now\":\n            return {\n                type: \"string\"\n            };\n        case \"global.now\":\n            return {\n                type: \"string\"\n            };\n        case \"global.defined\":\n            {\n                const arg = walk({\n                    node: node.args[0],\n                    scope\n                });\n                return mapNode(arg, scope, (node2)=>node2.type === \"unknown\" ? {\n                        type: \"boolean\"\n                    } : {\n                        type: \"boolean\",\n                        value: node2.type !== \"null\"\n                    });\n            }\n        case \"global.path\":\n            {\n                const arg = walk({\n                    node: node.args[0],\n                    scope\n                });\n                return mapNode(arg, scope, (arg2)=>arg2.type === \"unknown\" ? nullUnion({\n                        type: \"string\"\n                    }) : arg2.type === \"string\" ? {\n                        type: \"string\"\n                    } : {\n                        type: \"null\"\n                    });\n            }\n        case \"global.coalesce\":\n            {\n                if (node.args.length === 0) return {\n                    type: \"null\"\n                };\n                const typeNodes = [];\n                let canBeNull = !0;\n                for (const arg of node.args){\n                    const argNode = optimizeUnions(walk({\n                        node: arg,\n                        scope\n                    })), allNull = argNode.type === \"null\" || argNode.type === \"union\" && argNode.of.every((t)=>t.type === \"null\");\n                    if (canBeNull = allNull || argNode.type === \"unknown\" || argNode.type === \"union\" && argNode.of.some((t)=>t.type === \"null\" || t.type === \"unknown\"), allNull || typeNodes.push(unionWithoutNull(argNode)), !canBeNull) break;\n                }\n                return canBeNull && typeNodes.push({\n                    type: \"null\"\n                }), {\n                    type: \"union\",\n                    of: typeNodes\n                };\n            }\n        case \"global.count\":\n            {\n                const arg = walk({\n                    node: node.args[0],\n                    scope\n                });\n                return mapNode(arg, scope, (arg2)=>arg2.type === \"unknown\" ? nullUnion({\n                        type: \"string\"\n                    }) : arg2.type === \"array\" ? {\n                        type: \"number\"\n                    } : {\n                        type: \"null\"\n                    });\n            }\n        case \"global.dateTime\":\n            {\n                const arg = walk({\n                    node: node.args[0],\n                    scope\n                });\n                return mapNode(arg, scope, (arg2)=>arg2.type === \"unknown\" ? nullUnion({\n                        type: \"string\"\n                    }) : arg2.type === \"string\" ? nullUnion({\n                        type: \"string\"\n                    }) : {\n                        type: \"null\"\n                    });\n            }\n        case \"global.length\":\n            {\n                const arg = walk({\n                    node: node.args[0],\n                    scope\n                });\n                return mapNode(arg, scope, (arg2)=>arg2.type === \"unknown\" ? nullUnion({\n                        type: \"number\"\n                    }) : arg2.type === \"array\" || arg2.type === \"string\" ? {\n                        type: \"number\"\n                    } : {\n                        type: \"null\"\n                    });\n            }\n        case \"global.references\":\n            return {\n                type: \"boolean\"\n            };\n        case \"global.round\":\n            {\n                const numNode = walk({\n                    node: node.args[0],\n                    scope\n                });\n                return mapNode(numNode, scope, (num)=>{\n                    if (num.type === \"unknown\") return nullUnion({\n                        type: \"number\"\n                    });\n                    if (num.type !== \"number\") return {\n                        type: \"null\"\n                    };\n                    if (node.args.length === 2) {\n                        const precisionNode = walk({\n                            node: node.args[1],\n                            scope\n                        });\n                        return mapNode(precisionNode, scope, (precision)=>precision.type === \"unknown\" ? nullUnion({\n                                type: \"number\"\n                            }) : precision.type !== \"number\" ? {\n                                type: \"null\"\n                            } : {\n                                type: \"number\"\n                            });\n                    }\n                    return {\n                        type: \"number\"\n                    };\n                });\n            }\n        case \"global.string\":\n            {\n                const arg = walk({\n                    node: node.args[0],\n                    scope\n                });\n                return mapNode(arg, scope, (node2)=>node2.type === \"unknown\" ? nullUnion({\n                        type: \"string\"\n                    }) : node2.type === \"string\" || node2.type === \"number\" || node2.type === \"boolean\" ? node2.value ? {\n                        type: \"string\",\n                        value: node2.value.toString()\n                    } : {\n                        type: \"string\"\n                    } : {\n                        type: \"null\"\n                    });\n            }\n        case \"math.sum\":\n            {\n                const values = walk({\n                    node: node.args[0],\n                    scope\n                });\n                return mapNode(values, scope, (node2)=>node2.type === \"unknown\" ? nullUnion({\n                        type: \"number\"\n                    }) : node2.type !== \"array\" ? {\n                        type: \"null\"\n                    } : mapNode(node2.of, scope, (node3)=>node3.type === \"unknown\" ? nullUnion({\n                            type: \"number\"\n                        }) : node3.type === \"number\" || node3.type === \"null\" ? {\n                            type: \"number\"\n                        } : {\n                            type: \"null\"\n                        }));\n            }\n        case \"math.avg\":\n            {\n                const values = walk({\n                    node: node.args[0],\n                    scope\n                });\n                return mapNode(values, scope, (node2)=>node2.type === \"unknown\" ? nullUnion({\n                        type: \"number\"\n                    }) : node2.type !== \"array\" ? {\n                        type: \"null\"\n                    } : mapNode(node2.of, scope, (node3)=>node3.type === \"unknown\" ? nullUnion({\n                            type: \"number\"\n                        }) : node3.type === \"number\" ? {\n                            type: \"number\"\n                        } : {\n                            type: \"null\"\n                        }));\n            }\n        case \"math.max\":\n        case \"math.min\":\n            {\n                const values = walk({\n                    node: node.args[0],\n                    scope\n                });\n                return mapNode(values, scope, (node2)=>node2.type === \"unknown\" ? nullUnion({\n                        type: \"number\"\n                    }) : node2.type !== \"array\" ? {\n                        type: \"null\"\n                    } : mapNode(node2.of, scope, (node3)=>node3.type === \"unknown\" ? nullUnion({\n                            type: \"number\"\n                        }) : node3.type === \"number\" ? node3 : {\n                            type: \"null\"\n                        }));\n            }\n        case \"pt.text\":\n            return node.args.length === 0 ? {\n                type: \"null\"\n            } : {\n                type: \"string\"\n            };\n        case \"string.startsWith\":\n            {\n                const strTypeNode = walk({\n                    node: node.args[0],\n                    scope\n                }), prefixTypeNode = walk({\n                    node: node.args[1],\n                    scope\n                });\n                return mapNode(strTypeNode, scope, (strNode)=>mapNode(prefixTypeNode, scope, (prefixNode)=>strNode.type === \"unknown\" || prefixNode.type === \"unknown\" ? nullUnion({\n                            type: \"boolean\"\n                        }) : strNode.type !== \"string\" || prefixNode.type !== \"string\" ? {\n                            type: \"null\"\n                        } : {\n                            type: \"boolean\"\n                        }));\n            }\n        case \"string.split\":\n            {\n                const strTypeNode = walk({\n                    node: node.args[0],\n                    scope\n                }), sepTypeNode = walk({\n                    node: node.args[1],\n                    scope\n                });\n                return mapNode(strTypeNode, scope, (strNode)=>mapNode(sepTypeNode, scope, (sepNode)=>strNode.type === \"unknown\" || sepNode.type === \"unknown\" ? nullUnion({\n                            type: \"array\",\n                            of: {\n                                type: \"string\"\n                            }\n                        }) : strNode.type !== \"string\" || sepNode.type !== \"string\" ? {\n                            type: \"null\"\n                        } : {\n                            type: \"array\",\n                            of: {\n                                type: \"string\"\n                            }\n                        }));\n            }\n        case \"sanity.versionOf\":\n            {\n                const typeNode = walk({\n                    node: node.args[0],\n                    scope\n                });\n                return mapNode(typeNode, scope, (typeNode2)=>typeNode2.type === \"unknown\" ? nullUnion({\n                        type: \"boolean\"\n                    }) : typeNode2.type !== \"string\" ? {\n                        type: \"null\"\n                    } : {\n                        type: \"boolean\"\n                    });\n            }\n        case \"sanity.partOfRelease\":\n            {\n                const typeNode = walk({\n                    node: node.args[0],\n                    scope\n                });\n                return mapNode(typeNode, scope, (typeNode2)=>typeNode2.type === \"unknown\" ? nullUnion({\n                        type: \"boolean\"\n                    }) : typeNode2.type !== \"string\" ? {\n                        type: \"null\"\n                    } : {\n                        type: \"boolean\"\n                    });\n            }\n        default:\n            return {\n                type: \"unknown\"\n            };\n    }\n}\nfunction match(left, right) {\n    let tokens = [], patterns = [];\n    if (left.type === \"string\") {\n        if (left.value === void 0) return;\n        tokens = tokens.concat(matchTokenize(left.value));\n    }\n    if (left.type === \"array\") {\n        if (left.of.type === \"unknown\") return;\n        if (left.of.type === \"string\") {\n            if (left.of.value === void 0) return;\n            tokens = tokens.concat(matchTokenize(left.of.value));\n        }\n        if (left.of.type === \"union\") for (const node of left.of.of)node.type === \"string\" && node.value !== void 0 && (tokens = tokens.concat(matchTokenize(node.value)));\n    }\n    if (right.type === \"string\") {\n        if (right.value === void 0) return;\n        patterns = patterns.concat(matchAnalyzePattern(right.value));\n    }\n    if (right.type === \"array\") {\n        if (right.of.type === \"unknown\") return;\n        if (right.of.type === \"string\") {\n            if (right.of.value === void 0) return;\n            patterns = patterns.concat(matchAnalyzePattern(right.of.value));\n        }\n        if (right.of.type === \"union\") for (const node of right.of.of){\n            if (node.type === \"string\") {\n                if (node.value === void 0) return;\n                patterns = patterns.concat(matchAnalyzePattern(node.value));\n            }\n            if (node.type !== \"string\") return !1;\n        }\n    }\n    return matchText(tokens, patterns);\n}\nconst $trace = debug__WEBPACK_IMPORTED_MODULE_0__(\"typeEvaluator:evaluate:trace\");\n$trace.log = console.log.bind(console);\nconst $debug = debug__WEBPACK_IMPORTED_MODULE_0__(\"typeEvaluator:evaluate:debug\");\n$debug.log = console.log.bind(console);\nconst $warn = debug__WEBPACK_IMPORTED_MODULE_0__(\"typeEvaluator:evaluate:warn\");\nfunction typeEvaluate(ast, schema) {\n    $debug(\"evaluateQueryType.ast %O\", ast), $debug(\"evaluateQueryType.schema %O\", schema);\n    const parsed = walk({\n        node: ast,\n        scope: new Scope2([], void 0, new Context(schema))\n    });\n    $trace(\"evaluateQueryType.parsed %O\", parsed);\n    const optimized = optimizeUnions(parsed);\n    return $debug(\"evaluateQueryType.optimized %O\", optimized), optimized;\n}\nfunction mapDeref(base, scope) {\n    return base.type === \"union\" ? {\n        type: \"union\",\n        of: base.of.map((node)=>mapDeref(node, scope))\n    } : base.type === \"array\" ? {\n        type: \"array\",\n        of: mapDeref(base.of, scope)\n    } : base.type === \"object\" && base.dereferencesTo !== void 0 ? scope.context.lookupRef(base.dereferencesTo) : {\n        type: \"null\"\n    };\n}\nfunction handleDerefNode(node, scope) {\n    $trace(\"deref.node %O\", node);\n    const base = walk({\n        node: node.base,\n        scope\n    });\n    if ($trace(\"deref.base %O\", base), base.type === \"null\" || base.type === \"unknown\") return {\n        type: \"null\"\n    };\n    const derefedNode = mapDeref(base, scope);\n    return $trace(\"deref.derefedNode %O\", derefedNode), derefedNode;\n}\nfunction handleObjectSplatNode(attr, scope) {\n    const value = walk({\n        node: attr.value,\n        scope\n    });\n    return $trace(\"object.splat.value %O\", value), mapNode(value, scope, (node)=>{\n        if (node.type === \"unknown\") return {\n            type: \"unknown\"\n        };\n        if (node.type !== \"object\") return {\n            type: \"object\",\n            attributes: {}\n        };\n        const attributes = {};\n        for(const name in node.attributes)node.attributes.hasOwnProperty(name) && (attributes[name] = node.attributes[name]);\n        if (node.rest !== void 0) {\n            const resolvedRest = resolveInline(node.rest, scope);\n            if (resolvedRest.type === \"unknown\") return {\n                type: \"unknown\"\n            };\n            if (resolvedRest.type !== \"object\") return {\n                type: \"null\"\n            };\n            for(const name in resolvedRest.attributes)resolvedRest.attributes.hasOwnProperty(name) && (attributes[name] = resolvedRest.attributes[name]);\n        }\n        return {\n            type: \"object\",\n            attributes\n        };\n    });\n}\nfunction handleObjectNode(node, scope) {\n    if ($trace(\"object.node %O\", node), node.attributes.length === 0) return {\n        type: \"object\",\n        attributes: {}\n    };\n    const objectAttributes = [], splatVariants = [], conditionalVariants = [];\n    for (const [idx, attr] of node.attributes.entries()){\n        if (attr.type === \"ObjectAttributeValue\") {\n            const attributeNode = walk({\n                node: attr.value,\n                scope\n            });\n            objectAttributes.push([\n                idx,\n                attr.name,\n                {\n                    type: \"objectAttribute\",\n                    value: attributeNode\n                }\n            ]);\n            continue;\n        }\n        if (attr.type === \"ObjectSplat\") {\n            const attributeNode = handleObjectSplatNode(attr, scope);\n            switch($trace(\"object.splat.result %O\", attributeNode), attributeNode.type){\n                case \"object\":\n                    {\n                        splatVariants.push([\n                            idx,\n                            attributeNode\n                        ]);\n                        continue;\n                    }\n                case \"union\":\n                    {\n                        for (const node2 of attributeNode.of)if (node2.type === \"unknown\") return node2;\n                        splatVariants.push([\n                            idx,\n                            attributeNode\n                        ]);\n                        continue;\n                    }\n                default:\n                    return {\n                        type: \"unknown\"\n                    };\n            }\n        }\n        if (attr.type === \"ObjectConditionalSplat\") {\n            const condition = booleanValue(walk({\n                node: attr.condition,\n                scope\n            }), scope);\n            if ($trace(\"object.conditional.splat.condition %O\", condition), condition.canBeTrue === !1) continue;\n            const attributeNode = handleObjectSplatNode(attr, scope);\n            if ($trace(\"object.conditional.splat.result %O\", attributeNode), condition.canBeFalse === !1 && condition.canBeNull === !1) switch(attributeNode.type){\n                case \"object\":\n                    {\n                        splatVariants.push([\n                            idx,\n                            attributeNode\n                        ]);\n                        continue;\n                    }\n                case \"union\":\n                    {\n                        for (const node2 of attributeNode.of)if (node2.type !== \"object\") return {\n                            type: \"unknown\"\n                        };\n                        splatVariants.push([\n                            idx,\n                            attributeNode\n                        ]);\n                        continue;\n                    }\n                default:\n                    return {\n                        type: \"unknown\"\n                    };\n            }\n            const variant = mapNode(attributeNode, scope, (attributeNode2)=>($trace(\"object.conditional.splat.result.concrete %O\", attributeNode2), attributeNode2.type !== \"object\" ? {\n                    type: \"unknown\"\n                } : {\n                    type: \"object\",\n                    attributes: attributeNode2.attributes\n                }));\n            if (variant.type === \"union\") {\n                for (const node2 of variant.of)if (node2.type !== \"object\") return {\n                    type: \"unknown\"\n                };\n                variant.of.push({\n                    type: \"object\",\n                    attributes: {}\n                }), conditionalVariants.push([\n                    idx,\n                    variant\n                ]);\n                continue;\n            }\n            if (variant.type !== \"object\") return {\n                type: \"unknown\"\n            };\n            conditionalVariants.push([\n                idx,\n                {\n                    type: \"union\",\n                    of: [\n                        {\n                            type: \"object\",\n                            attributes: {}\n                        },\n                        variant\n                    ]\n                }\n            ]);\n            continue;\n        }\n        throw new Error(`Unknown object attribute type: ${attr.type}`);\n    }\n    const guaranteedAttributes = [];\n    guaranteedAttributes.push(...objectAttributes);\n    for (const [idx, splatNode] of splatVariants){\n        if (splatNode.type === \"object\") {\n            for(const name in splatNode.attributes){\n                if (!splatNode.attributes.hasOwnProperty(name)) continue;\n                const attribute = splatNode.attributes[name];\n                guaranteedAttributes.push([\n                    idx,\n                    name,\n                    attribute\n                ]);\n            }\n            continue;\n        }\n        conditionalVariants.push([\n            idx,\n            splatNode\n        ]);\n    }\n    if (guaranteedAttributes.sort(([a], [b])=>a - b), conditionalVariants.length === 0) return {\n        type: \"object\",\n        attributes: Object.fromEntries(guaranteedAttributes.map(([, name, attribute])=>[\n                name,\n                attribute\n            ]))\n    };\n    const matrix = [];\n    for (const [unionIdx, union] of conditionalVariants){\n        const unionGuaranteedBefore = [], unionGuaranteedAfter = [];\n        for (const [guaranteedIndex, name, attribute] of guaranteedAttributes)guaranteedIndex < unionIdx && unionGuaranteedBefore.push([\n            guaranteedIndex,\n            name,\n            attribute\n        ]), guaranteedIndex > unionIdx && unionGuaranteedAfter.push([\n            guaranteedIndex,\n            name,\n            attribute\n        ]);\n        const allVariantsAttributes = [];\n        for (const [conditionalVariantIdx, otherUnion] of conditionalVariants){\n            const variantAttributes = [];\n            for (const node2 of otherUnion.of)variantAttributes.push(node2.attributes);\n            allVariantsAttributes.push([\n                conditionalVariantIdx,\n                variantAttributes\n            ]);\n        }\n        for (const node2 of union.of){\n            matrix.push({\n                type: \"object\",\n                attributes: {\n                    ...Object.fromEntries(unionGuaranteedBefore.map(([, name, attribute])=>[\n                            name,\n                            attribute\n                        ])),\n                    ...node2.attributes,\n                    ...Object.fromEntries(unionGuaranteedAfter.map(([, name, attribute])=>[\n                            name,\n                            attribute\n                        ]))\n                }\n            });\n            for (const [outerIdx, outerAttributes] of allVariantsAttributes)for (const outer of outerAttributes)for (const [innerIdx, innerAttributes] of allVariantsAttributes)if (outerIdx !== innerIdx) for (const inner of innerAttributes){\n                const _before = [\n                    ...unionGuaranteedBefore\n                ], _after = [\n                    ...unionGuaranteedAfter\n                ];\n                for(const name in outer)outer.hasOwnProperty(name) && outerIdx !== unionIdx && (outerIdx < unionIdx && _before.push([\n                    outerIdx,\n                    name,\n                    outer[name]\n                ]), outerIdx > unionIdx && _after.push([\n                    outerIdx,\n                    name,\n                    outer[name]\n                ]));\n                for(const name in inner)inner.hasOwnProperty(name) && outerIdx !== unionIdx && (innerIdx < unionIdx && _before.push([\n                    innerIdx,\n                    name,\n                    inner[name]\n                ]), innerIdx > unionIdx && _after.push([\n                    innerIdx,\n                    name,\n                    inner[name]\n                ]));\n                _before.sort(([a], [b])=>a - b), _after.sort(([a], [b])=>a - b);\n                const before = Object.fromEntries(_before.map(([, name, attribute])=>[\n                        name,\n                        attribute\n                    ])), after = Object.fromEntries(_after.map(([, name, attribute])=>[\n                        name,\n                        attribute\n                    ]));\n                matrix.push({\n                    type: \"object\",\n                    attributes: {\n                        ...before,\n                        ...node2.attributes,\n                        ...after\n                    }\n                });\n            }\n        }\n    }\n    return optimizeUnions({\n        type: \"union\",\n        of: matrix\n    });\n}\nfunction handleOpCallNode(node, scope) {\n    $trace(\"opcall.node %O\", node);\n    const lhs = walk({\n        node: node.left,\n        scope\n    }), rhs = walk({\n        node: node.right,\n        scope\n    });\n    return mapNode(lhs, scope, (left)=>// eslint-disable-next-line complexity, max-statements\n        mapNode(rhs, scope, (right)=>{\n            switch($trace('opcall.node.concrete \"%s\" %O', node.op, {\n                left,\n                right\n            }), node.op){\n                case \"==\":\n                    return left.type === \"unknown\" || right.type === \"unknown\" ? {\n                        type: \"boolean\"\n                    } : left.type !== right.type ? {\n                        type: \"boolean\",\n                        value: !1\n                    } : left.type === \"null\" ? {\n                        type: \"boolean\",\n                        value: !0\n                    } : !isPrimitiveTypeNode(left) || !isPrimitiveTypeNode(right) ? {\n                        type: \"boolean\",\n                        value: !1\n                    } : {\n                        type: \"boolean\",\n                        value: evaluateComparison(node.op, left, right)\n                    };\n                case \"!=\":\n                    {\n                        if (left.type === \"unknown\" || right.type === \"unknown\") return {\n                            type: \"boolean\"\n                        };\n                        if (left.type !== right.type) return {\n                            type: \"boolean\",\n                            value: !0\n                        };\n                        if (left.type === \"null\") return {\n                            type: \"boolean\",\n                            value: !1\n                        };\n                        if (!isPrimitiveTypeNode(left) || !isPrimitiveTypeNode(right)) return {\n                            type: \"boolean\",\n                            value: !0\n                        };\n                        let value = evaluateComparison(\"==\", left, right);\n                        return value !== void 0 && (value = !value), {\n                            type: \"boolean\",\n                            value\n                        };\n                    }\n                case \">\":\n                case \">=\":\n                case \"<\":\n                case \"<=\":\n                    return left.type === \"unknown\" || right.type === \"unknown\" ? nullUnion({\n                        type: \"boolean\"\n                    }) : left.type !== right.type ? {\n                        type: \"null\"\n                    } : !isPrimitiveTypeNode(left) || !isPrimitiveTypeNode(right) ? {\n                        type: \"null\"\n                    } : {\n                        type: \"boolean\",\n                        value: evaluateComparison(node.op, left, right)\n                    };\n                case \"in\":\n                    return left.type === \"unknown\" || right.type === \"unknown\" ? nullUnion({\n                        type: \"boolean\"\n                    }) : right.type !== \"array\" ? isFuncCall(node.right, \"global::path\") ? {\n                        type: \"boolean\"\n                    } : {\n                        type: \"null\"\n                    } : !isPrimitiveTypeNode(left) && left.type !== \"null\" ? {\n                        type: \"boolean\",\n                        value: !1\n                    } : mapNode(right.of, scope, (arrayTypeNode)=>arrayTypeNode.type === \"unknown\" ? nullUnion({\n                            type: \"boolean\"\n                        }) : left.type === \"null\" ? {\n                            type: \"boolean\",\n                            value: arrayTypeNode.type === \"null\"\n                        } : left.value === void 0 ? {\n                            type: \"boolean\"\n                        } : isPrimitiveTypeNode(arrayTypeNode) ? arrayTypeNode.value === void 0 ? {\n                            type: \"boolean\"\n                        } : {\n                            type: \"boolean\",\n                            value: left.value === arrayTypeNode.value\n                        } : {\n                            type: \"boolean\",\n                            value: !1\n                        });\n                case \"match\":\n                    return left.type === \"unknown\" || right.type === \"unknown\" ? {\n                        type: \"boolean\"\n                    } : {\n                        type: \"boolean\",\n                        value: match(left, right)\n                    };\n                case \"+\":\n                    return left.type === \"unknown\" || right.type === \"unknown\" ? {\n                        type: \"unknown\"\n                    } : left.type === \"string\" && right.type === \"string\" ? {\n                        type: \"string\",\n                        value: left.value !== void 0 && right.value !== void 0 ? left.value + right.value : void 0\n                    } : left.type === \"number\" && right.type === \"number\" ? {\n                        type: \"number\",\n                        value: left.value !== void 0 && right.value !== void 0 ? left.value + right.value : void 0\n                    } : left.type === \"array\" && right.type === \"array\" ? {\n                        type: \"array\",\n                        of: {\n                            type: \"union\",\n                            of: [\n                                left.of,\n                                right.of\n                            ]\n                        }\n                    } : left.type === \"object\" && right.type === \"object\" ? {\n                        type: \"object\",\n                        attributes: {\n                            ...left.attributes,\n                            ...right.attributes\n                        }\n                    } : {\n                        type: \"null\"\n                    };\n                case \"-\":\n                    return left.type === \"unknown\" || right.type === \"unknown\" ? nullUnion({\n                        type: \"number\"\n                    }) : left.type === \"number\" && right.type === \"number\" ? {\n                        type: \"number\",\n                        value: left.value !== void 0 && right.value !== void 0 ? left.value - right.value : void 0\n                    } : {\n                        type: \"null\"\n                    };\n                case \"*\":\n                    return left.type === \"unknown\" || right.type === \"unknown\" ? nullUnion({\n                        type: \"number\"\n                    }) : left.type === \"number\" && right.type === \"number\" ? {\n                        type: \"number\",\n                        value: left.value !== void 0 && right.value !== void 0 ? left.value * right.value : void 0\n                    } : {\n                        type: \"null\"\n                    };\n                case \"/\":\n                    return left.type === \"unknown\" || right.type === \"unknown\" ? nullUnion({\n                        type: \"number\"\n                    }) : left.type === \"number\" && right.type === \"number\" ? {\n                        type: \"number\",\n                        value: left.value !== void 0 && right.value !== void 0 ? left.value / right.value : void 0\n                    } : {\n                        type: \"null\"\n                    };\n                case \"**\":\n                    return left.type === \"unknown\" || right.type === \"unknown\" ? nullUnion({\n                        type: \"number\"\n                    }) : left.type === \"number\" && right.type === \"number\" ? {\n                        type: \"number\",\n                        value: left.value !== void 0 && right.value !== void 0 ? left.value ** right.value : void 0\n                    } : {\n                        type: \"null\"\n                    };\n                case \"%\":\n                    return left.type === \"unknown\" || right.type === \"unknown\" ? nullUnion({\n                        type: \"number\"\n                    }) : left.type === \"number\" && right.type === \"number\" ? {\n                        type: \"number\",\n                        value: left.value !== void 0 && right.value !== void 0 ? left.value % right.value : void 0\n                    } : {\n                        type: \"null\"\n                    };\n                default:\n                    return {\n                        type: \"unknown\"\n                    };\n            }\n        }));\n}\nfunction handleSelectNode(node, scope) {\n    const values = [];\n    let guaranteed = !1;\n    for (const alternative of node.alternatives){\n        const conditionValue = walk({\n            node: alternative.condition,\n            scope\n        }), conditionScope = resolveFilter(alternative.condition, scope);\n        conditionScope.type === \"union\" && conditionScope.of.length > 0 && values.push(walk({\n            node: alternative.value,\n            scope: scope.createHidden(conditionScope.of)\n        })), conditionValue.type === \"boolean\" && conditionValue.value === !0 && (guaranteed = !0);\n    }\n    return node.fallback && !guaranteed && values.push(walk({\n        node: node.fallback,\n        scope\n    })), values.length === 0 ? {\n        type: \"null\"\n    } : {\n        type: \"union\",\n        of: values\n    };\n}\nfunction handleArrayCoerceNode(node, scope) {\n    const base = walk({\n        node: node.base,\n        scope\n    });\n    return $trace(\"arrayCoerce.base %O\", base), mapArray(base, scope, (base2)=>base2);\n}\nfunction handleFlatMap(node, scope) {\n    const base = walk({\n        node: node.base,\n        scope\n    });\n    return mapArray(base, scope, (base2)=>{\n        const inner = walk({\n            node: node.expr,\n            scope: scope.createHidden([\n                base2.of\n            ])\n        });\n        return mapNode(inner, scope, (inner2)=>inner2.type === \"array\" ? inner2 : {\n                type: \"array\",\n                of: inner2\n            }, (nodes)=>{\n            const inner2 = [];\n            for (const node2 of nodes){\n                if (node2.type === \"unknown\") return {\n                    type: \"array\",\n                    of: node2\n                };\n                if (node2.type !== \"array\") throw new Error(`Unexpected type: ${node2.type}`);\n                inner2.push(node2.of);\n            }\n            return {\n                type: \"array\",\n                of: optimizeUnions({\n                    type: \"union\",\n                    of: inner2\n                })\n            };\n        });\n    });\n}\nfunction handleMap(node, scope) {\n    const base = walk({\n        node: node.base,\n        scope\n    });\n    return $trace(\"map.base %O\", base), mapArray(base, scope, (base2)=>({\n            type: \"array\",\n            of: walk({\n                node: node.expr,\n                scope: scope.createHidden([\n                    base2.of\n                ])\n            })\n        }));\n}\nfunction handleProjectionNode(node, scope) {\n    const base = walk({\n        node: node.base,\n        scope\n    });\n    return $trace(\"projection.base %O\", base), mapObject(base, scope, (base2)=>walk({\n            node: node.expr,\n            scope: scope.createNested([\n                base2\n            ])\n        }));\n}\nfunction createFilterScope(base, scope) {\n    return base.type === \"array\" ? base.of.type === \"union\" ? scope.createNested(base.of.of) : scope.createNested([\n        base.of\n    ]) : scope.createNested([\n        base\n    ]);\n}\nfunction handleFilterNode(node, scope) {\n    const base = walk({\n        node: node.base,\n        scope\n    });\n    return $trace(\"filter.base %O\", base), mapNode(base, scope, (base2)=>{\n        if ($trace(\"filter.resolving %O\", base2), base2.type === \"null\") return base2;\n        const resolved = resolveFilter(node.expr, createFilterScope(base2, scope));\n        return $trace(\"filter.resolved %O\", resolved), {\n            type: \"array\",\n            of: resolved\n        };\n    });\n}\nfunction handleAccessAttributeNode(node, scope) {\n    let attributeBase = scope.value;\n    return node.base && (attributeBase = walk({\n        node: node.base,\n        scope\n    })), $trace(\"accessAttribute.base %s %O\", node.name, attributeBase), handleAccessAttributeBase(attributeBase, node.name, scope);\n}\nfunction handleAccessAttributeBase(base, name, scope) {\n    return mapObject(base, scope, (base2)=>{\n        $trace('Looking for attribute \"%s\" in object %O', name, base2);\n        const attribute = base2.attributes[name];\n        return attribute !== void 0 ? ($debug(`accessAttribute.attribute found ${name} %O`, attribute), attribute.optional ? nullUnion(attribute.value) : attribute.value) : base2.rest ? handleAccessAttributeBase(base2.rest, name, scope) : ($warn(`attribute \"${name}\" not found in object`), {\n            type: \"null\"\n        });\n    });\n}\nfunction handleAccessElementNode(node, scope) {\n    const base = walk({\n        node: node.base,\n        scope\n    });\n    return $trace(\"accessElement.base %O\", base), mapArray(base, scope, (base2)=>nullUnion(base2.of));\n}\nfunction handleArrayNode(node, scope) {\n    const of = [];\n    for (const el of node.elements){\n        const node2 = walk({\n            node: el.value,\n            scope\n        });\n        node2 !== null && of.push(node2);\n    }\n    return {\n        type: \"array\",\n        of: {\n            type: \"union\",\n            of\n        }\n    };\n}\nfunction handleValueNode(node, scope) {\n    if (node.value === null) return {\n        type: \"null\"\n    };\n    switch(typeof node.value){\n        case \"string\":\n            return {\n                type: \"string\",\n                value: node.value\n            };\n        case \"number\":\n            return {\n                type: \"number\",\n                value: node.value\n            };\n        case \"boolean\":\n            return {\n                type: \"boolean\",\n                value: node.value\n            };\n        case \"object\":\n            return node.value === null ? {\n                type: \"null\"\n            } : Array.isArray(node.value) ? {\n                type: \"array\",\n                of: {\n                    type: \"union\",\n                    of: node.value.map((value)=>walk({\n                            node: {\n                                type: \"Value\",\n                                value\n                            },\n                            scope\n                        }))\n                }\n            } : {\n                type: \"object\",\n                attributes: Object.fromEntries(Object.entries(node.value).map(([key, value])=>[\n                        key,\n                        {\n                            type: \"objectAttribute\",\n                            value: walk({\n                                node: {\n                                    type: \"Value\",\n                                    value\n                                },\n                                scope\n                            })\n                        }\n                    ]))\n            };\n        default:\n            return {\n                type: \"unknown\"\n            };\n    }\n}\nfunction handleSlice(node, scope) {\n    $trace(\"slice.node %O\", node);\n    const base = walk({\n        node: node.base,\n        scope\n    });\n    return mapArray(base, scope, (base2)=>base2);\n}\nfunction handleParentNode({ n }, scope) {\n    $trace(\"handle.parent.currentScope %d %O\", n, scope);\n    let current = scope;\n    for(let i = 0; i < n; i++){\n        for(; current?.isHidden;)current = current.parent;\n        current = current?.parent;\n    }\n    return $trace(\"handle.parent.newScope %d %O\", n, current), current ? current.value.of.length === 0 ? {\n        type: \"null\"\n    } : current.value : {\n        type: \"null\"\n    };\n}\nfunction handleNotNode(node, scope) {\n    const base = walk({\n        node: node.base,\n        scope\n    });\n    return mapNode(base, scope, (base2)=>base2.type === \"unknown\" ? nullUnion({\n            type: \"boolean\"\n        }) : base2.type === \"boolean\" ? base2.value !== void 0 ? {\n            type: \"boolean\",\n            value: base2.value === !1\n        } : {\n            type: \"boolean\"\n        } : {\n            type: \"null\"\n        });\n}\nfunction handleNegNode(node, scope) {\n    const base = walk({\n        node: node.base,\n        scope\n    });\n    return mapNode(base, scope, (base2)=>base2.type === \"unknown\" ? nullUnion({\n            type: \"number\"\n        }) : base2.type !== \"number\" ? {\n            type: \"null\"\n        } : base2.value !== void 0 ? {\n            type: \"number\",\n            value: -base2.value\n        } : base2);\n}\nfunction handlePosNode(node, scope) {\n    const base = walk({\n        node: node.base,\n        scope\n    });\n    return mapNode(base, scope, (base2)=>base2.type === \"unknown\" ? nullUnion({\n            type: \"number\"\n        }) : base2.type !== \"number\" ? {\n            type: \"null\"\n        } : base2);\n}\nfunction handleEverythingNode(_, scope) {\n    return {\n        type: \"array\",\n        of: {\n            type: \"union\",\n            of: scope.context.schema.filter((obj)=>obj.type === \"document\").map((doc)=>({\n                    type: \"object\",\n                    attributes: doc.attributes\n                }))\n        }\n    };\n}\nfunction handleAndNode(node, scope) {\n    const left = walk({\n        node: node.left,\n        scope\n    }), right = walk({\n        node: node.right,\n        scope\n    });\n    return mapNode(left, scope, (lhs)=>mapNode(right, scope, (rhs)=>{\n            const value = booleanAnd(booleanValue(lhs, scope), booleanValue(rhs, scope));\n            return booleanInterpretationToTypeNode(value);\n        }));\n}\nfunction handleOrNode(node, scope) {\n    const left = walk({\n        node: node.left,\n        scope\n    }), right = walk({\n        node: node.right,\n        scope\n    });\n    return mapNode(left, scope, (lhs)=>mapNode(right, scope, (rhs)=>{\n            const value = booleanOr(booleanValue(lhs, scope), booleanValue(rhs, scope));\n            return booleanInterpretationToTypeNode(value);\n        }));\n}\nconst OVERRIDE_TYPE_SYMBOL = Symbol(\"groq-js.type\");\nfunction walk({ node, scope }) {\n    if (OVERRIDE_TYPE_SYMBOL in node) return node[OVERRIDE_TYPE_SYMBOL];\n    switch(node.type){\n        // Filtering, traversal & projections\n        case \"Map\":\n            return handleMap(node, scope);\n        case \"Projection\":\n            return handleProjectionNode(node, scope);\n        case \"Filter\":\n            return handleFilterNode(node, scope);\n        case \"AccessAttribute\":\n            return optimizeUnions(handleAccessAttributeNode(node, scope));\n        case \"AccessElement\":\n            return handleAccessElementNode(node, scope);\n        case \"ArrayCoerce\":\n            return handleArrayCoerceNode(node, scope);\n        case \"FlatMap\":\n            return handleFlatMap(node, scope);\n        // Operations\n        case \"OpCall\":\n            return handleOpCallNode(node, scope);\n        case \"And\":\n            return handleAndNode(node, scope);\n        case \"Or\":\n            return handleOrNode(node, scope);\n        case \"Select\":\n            return handleSelectNode(node, scope);\n        case \"PipeFuncCall\":\n            return walk({\n                node: node.base,\n                scope\n            });\n        // Values\n        case \"Deref\":\n            return handleDerefNode(node, scope);\n        case \"Object\":\n            return handleObjectNode(node, scope);\n        case \"Value\":\n            return handleValueNode(node, scope);\n        case \"Array\":\n            return handleArrayNode(node, scope);\n        // Special cases\n        case \"Everything\":\n            return handleEverythingNode(node, scope);\n        case \"This\":\n            return $trace(\"this %O\", scope.value), scope.value;\n        case \"Parent\":\n            return handleParentNode(node, scope);\n        case \"FuncCall\":\n            return handleFuncCallNode(node, scope);\n        case \"Group\":\n            return walk({\n                node: node.base,\n                scope\n            });\n        case \"Not\":\n            return handleNotNode(node, scope);\n        case \"Parameter\":\n            return {\n                type: \"unknown\"\n            };\n        case \"Slice\":\n            return handleSlice(node, scope);\n        case \"Neg\":\n            return handleNegNode(node, scope);\n        case \"Pos\":\n            return handlePosNode(node, scope);\n        // everything else\n        case \"Asc\":\n        case \"Desc\":\n        case \"Context\":\n        case \"Tuple\":\n        case \"Selector\":\n        case \"InRange\":\n            return {\n                type: \"unknown\"\n            };\n        default:\n            throw new Error(`unknown node type ${node.type}`);\n    }\n}\nfunction isPrimitiveTypeNode(node) {\n    return node.type === \"string\" || node.type === \"number\" || node.type === \"boolean\";\n}\nfunction evaluateComparison(opcall, left, right) {\n    if (!(left.value === void 0 || right.value === void 0)) switch(opcall){\n        case \"==\":\n            return left.value === right.value;\n        case \"<\":\n            return left.value < right.value;\n        case \"<=\":\n            return left.value <= right.value;\n        case \">\":\n            return left.value > right.value;\n        case \">=\":\n            return left.value >= right.value;\n        default:\n            throw new Error(`unknown comparison operator ${opcall}`);\n    }\n}\nfunction resolveFilter(expr, scope) {\n    $trace(\"resolveFilter.expr %O\", expr);\n    const filtered = scope.value.of.filter((node)=>{\n        const subScope = scope.createHidden([\n            node\n        ]), cond = walk({\n            node: expr,\n            scope: subScope\n        });\n        return booleanValue(cond, subScope).canBeTrue;\n    });\n    return $trace(`resolveFilter ${expr.type === \"OpCall\" ? `${expr.type}/${expr.op}` : expr.type} %O`, filtered), {\n        type: \"union\",\n        of: filtered\n    };\n}\nfunction mapArray(node, scope, mapper) {\n    return mapNode(node, scope, (base)=>base.type === \"unknown\" ? base : base.type === \"array\" ? mapper(base) : {\n            type: \"null\"\n        });\n}\nfunction mapObject(node, scope, mapper) {\n    return mapNode(node, scope, (base)=>base.type === \"unknown\" ? base : base.type === \"object\" ? mapper(base) : {\n            type: \"null\"\n        });\n}\n //# sourceMappingURL=1.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SUFBSSxFQUFFQyxLQUFLLEVBQUVxTCxNQUFNO0lBQ25DLE9BQU93TSxRQUFROVgsTUFBTUMsT0FBTyxDQUFDNEIsT0FBU0EsS0FBSzdKLElBQUksS0FBSyxZQUFZNkosT0FBT0EsS0FBSzdKLElBQUksS0FBSyxVQUFVc1QsT0FBT3pKLFFBQVE7WUFBRTdKLE1BQU07UUFBTztBQUMvSDtBQUNBLFNBQVMwbUIsVUFBVTFlLElBQUksRUFBRUMsS0FBSyxFQUFFcUwsTUFBTTtJQUNwQyxPQUFPd00sUUFBUTlYLE1BQU1DLE9BQU8sQ0FBQzRCLE9BQVNBLEtBQUs3SixJQUFJLEtBQUssWUFBWTZKLE9BQU9BLEtBQUs3SixJQUFJLEtBQUssV0FBV3NULE9BQU96SixRQUFRO1lBQUU3SixNQUFNO1FBQU87QUFDaEk7QUFRRSxDQUNGLDhCQUE4QiIsInNvdXJjZXMiOlsid2VicGFjazovL2VyYS1wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvZ3JvcS1qcy9kaXN0LzEubWpzPzk4YzEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGRlYnVnIGZyb20gXCJkZWJ1Z1wiO1xuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCBcIlxcXFwkJlwiKTtcbn1cbmZ1bmN0aW9uIHBhdGhSZWdFeHAocGF0dGVybikge1xuICBjb25zdCByZSA9IFtdO1xuICBmb3IgKGNvbnN0IHBhcnQgb2YgcGF0dGVybi5zcGxpdChcIi5cIikpXG4gICAgcGFydCA9PT0gXCIqXCIgPyByZS5wdXNoKFwiW14uXStcIikgOiBwYXJ0ID09PSBcIioqXCIgPyByZS5wdXNoKFwiLipcIikgOiByZS5wdXNoKGVzY2FwZVJlZ0V4cChwYXJ0KSk7XG4gIHJldHVybiBuZXcgUmVnRXhwKGBeJHtyZS5qb2luKFwiLlwiKX0kYCk7XG59XG5jbGFzcyBQYXRoIHtcbiAgcGF0dGVybjtcbiAgcGF0dGVyblJlO1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgdGhpcy5wYXR0ZXJuID0gcGF0dGVybiwgdGhpcy5wYXR0ZXJuUmUgPSBwYXRoUmVnRXhwKHBhdHRlcm4pO1xuICB9XG4gIG1hdGNoZXMoc3RyKSB7XG4gICAgcmV0dXJuIHRoaXMucGF0dGVyblJlLnRlc3Qoc3RyKTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMucGF0dGVybjtcbiAgfVxufVxuY2xhc3MgU3RyZWFtVmFsdWUge1xuICB0eXBlID0gXCJzdHJlYW1cIjtcbiAgZ2VuZXJhdG9yO1xuICB0aWNrZXI7XG4gIGlzRG9uZTtcbiAgZGF0YTtcbiAgY29uc3RydWN0b3IoZ2VuZXJhdG9yKSB7XG4gICAgdGhpcy5nZW5lcmF0b3IgPSBnZW5lcmF0b3IsIHRoaXMudGlja2VyID0gbnVsbCwgdGhpcy5pc0RvbmUgPSAhMSwgdGhpcy5kYXRhID0gW107XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgaXNBcnJheSgpIHtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgYXN5bmMgZ2V0KCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgdGhpcylcbiAgICAgIHJlc3VsdC5wdXNoKGF3YWl0IHZhbHVlLmdldCgpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGFzeW5jICpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKDsgOyApIHtcbiAgICAgIGZvciAoOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKVxuICAgICAgICB5aWVsZCB0aGlzLmRhdGFbaV07XG4gICAgICBpZiAodGhpcy5pc0RvbmUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGF3YWl0IHRoaXMuX25leHRUaWNrKCk7XG4gICAgfVxuICB9XG4gIF9uZXh0VGljaygpIHtcbiAgICBpZiAodGhpcy50aWNrZXIpXG4gICAgICByZXR1cm4gdGhpcy50aWNrZXI7XG4gICAgbGV0IGN1cnJlbnRSZXNvbHZlcjtcbiAgICBjb25zdCBzZXR1cFRpY2tlciA9ICgpID0+IHtcbiAgICAgIHRoaXMudGlja2VyID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgY3VycmVudFJlc29sdmVyID0gcmVzb2x2ZTtcbiAgICAgIH0pO1xuICAgIH0sIHRpY2sgPSAoKSA9PiB7XG4gICAgICBjdXJyZW50UmVzb2x2ZXIoKSwgc2V0dXBUaWNrZXIoKTtcbiAgICB9LCBmZXRjaCA9IGFzeW5jICgpID0+IHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgdGhpcy5nZW5lcmF0b3IoKSlcbiAgICAgICAgdGhpcy5kYXRhLnB1c2godmFsdWUpLCB0aWNrKCk7XG4gICAgICB0aGlzLmlzRG9uZSA9ICEwLCB0aWNrKCk7XG4gICAgfTtcbiAgICByZXR1cm4gc2V0dXBUaWNrZXIoKSwgZmV0Y2goKSwgdGhpcy50aWNrZXI7XG4gIH1cbn1cbmNvbnN0IFJGQzMzMzlfUkVHRVggPSAvXlxcZHs0fS1cXGR7Mn0tXFxkezJ9VFxcZHsyfTpcXGR7Mn06XFxkezJ9KFxcLlxcZCspPyhafChbLStdXFxkezJ9OlxcZHsyfSkpJC87XG5mdW5jdGlvbiBwYXJzZVJGQzMzMzkoc3RyKSB7XG4gIHJldHVybiBSRkMzMzM5X1JFR0VYLnRlc3Qoc3RyKSA/IG5ldyBEYXRlKHN0cikgOiBudWxsO1xufVxuZnVuY3Rpb24gZm9ybWF0UkZDMzMzOShkKSB7XG4gIGNvbnN0IHllYXIgPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ0Z1bGxZZWFyKCksIDQpLCBtb250aCA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDTW9udGgoKSArIDEsIDIpLCBkYXkgPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ0RhdGUoKSwgMiksIGhvdXIgPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ0hvdXJzKCksIDIpLCBtaW51dGUgPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ01pbnV0ZXMoKSwgMiksIHNlY29uZCA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDU2Vjb25kcygpLCAyKTtcbiAgbGV0IGZyYWN0aW9uYWxTZWNvbmQgPSBcIlwiO1xuICBjb25zdCBtaWxsaXMgPSBkLmdldE1pbGxpc2Vjb25kcygpO1xuICByZXR1cm4gbWlsbGlzICE9IDAgJiYgKGZyYWN0aW9uYWxTZWNvbmQgPSBgLiR7YWRkTGVhZGluZ1plcm8obWlsbGlzLCAzKX1gKSwgYCR7eWVhcn0tJHttb250aH0tJHtkYXl9VCR7aG91cn06JHttaW51dGV9OiR7c2Vjb25kfSR7ZnJhY3Rpb25hbFNlY29uZH1aYDtcbn1cbmZ1bmN0aW9uIGFkZExlYWRpbmdaZXJvKG51bSwgdGFyZ2V0TGVuZ3RoKSB7XG4gIGxldCBzdHIgPSBudW0udG9TdHJpbmcoKTtcbiAgZm9yICg7IHN0ci5sZW5ndGggPCB0YXJnZXRMZW5ndGg7IClcbiAgICBzdHIgPSBgMCR7c3RyfWA7XG4gIHJldHVybiBzdHI7XG59XG5jbGFzcyBTdGF0aWNWYWx1ZSB7XG4gIGRhdGE7XG4gIHR5cGU7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIHR5cGUpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhLCB0aGlzLnR5cGUgPSB0eXBlO1xuICB9XG4gIGlzQXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gXCJhcnJheVwiO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZXF1aXJlLWF3YWl0XG4gIGFzeW5jIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhO1xuICB9XG4gIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5kYXRhKSlcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKGRhdGEpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGRhdGEpXG4gICAgICAgICAgeWllbGQgZnJvbUpTKGVsZW1lbnQpO1xuICAgICAgfSh0aGlzLmRhdGEpO1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGl0ZXJhdGUgb3ZlcjogJHt0aGlzLnR5cGV9YCk7XG4gIH1cbn1cbmNvbnN0IE5VTExfVkFMVUUgPSBuZXcgU3RhdGljVmFsdWUobnVsbCwgXCJudWxsXCIpLCBUUlVFX1ZBTFVFID0gbmV3IFN0YXRpY1ZhbHVlKCEwLCBcImJvb2xlYW5cIiksIEZBTFNFX1ZBTFVFID0gbmV3IFN0YXRpY1ZhbHVlKCExLCBcImJvb2xlYW5cIik7XG5jbGFzcyBEYXRlVGltZSB7XG4gIGRhdGU7XG4gIGNvbnN0cnVjdG9yKGRhdGUpIHtcbiAgICB0aGlzLmRhdGUgPSBkYXRlO1xuICB9XG4gIHN0YXRpYyBwYXJzZVRvVmFsdWUoc3RyKSB7XG4gICAgY29uc3QgZGF0ZSA9IHBhcnNlUkZDMzMzOShzdHIpO1xuICAgIHJldHVybiBkYXRlID8gbmV3IFN0YXRpY1ZhbHVlKG5ldyBEYXRlVGltZShkYXRlKSwgXCJkYXRldGltZVwiKSA6IE5VTExfVkFMVUU7XG4gIH1cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0ZS5nZXRUaW1lKCkgPT0gb3RoZXIuZGF0ZS5nZXRUaW1lKCk7XG4gIH1cbiAgYWRkKHNlY3MpIHtcbiAgICBjb25zdCBjb3B5ID0gbmV3IERhdGUodGhpcy5kYXRlLmdldFRpbWUoKSk7XG4gICAgcmV0dXJuIGNvcHkuc2V0VGltZShjb3B5LmdldFRpbWUoKSArIHNlY3MgKiAxZTMpLCBuZXcgRGF0ZVRpbWUoY29weSk7XG4gIH1cbiAgZGlmZmVyZW5jZShvdGhlcikge1xuICAgIHJldHVybiAodGhpcy5kYXRlLmdldFRpbWUoKSAtIG90aGVyLmRhdGUuZ2V0VGltZSgpKSAvIDFlMztcbiAgfVxuICBjb21wYXJlVG8ob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRlLmdldFRpbWUoKSAtIG90aGVyLmRhdGUuZ2V0VGltZSgpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBmb3JtYXRSRkMzMzM5KHRoaXMuZGF0ZSk7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZyb21OdW1iZXIobnVtKSB7XG4gIHJldHVybiBOdW1iZXIuaXNGaW5pdGUobnVtKSA/IG5ldyBTdGF0aWNWYWx1ZShudW0sIFwibnVtYmVyXCIpIDogTlVMTF9WQUxVRTtcbn1cbmZ1bmN0aW9uIGZyb21TdHJpbmcoc3RyKSB7XG4gIHJldHVybiBuZXcgU3RhdGljVmFsdWUoc3RyLCBcInN0cmluZ1wiKTtcbn1cbmZ1bmN0aW9uIGZyb21EYXRlVGltZShkdCkge1xuICByZXR1cm4gbmV3IFN0YXRpY1ZhbHVlKGR0LCBcImRhdGV0aW1lXCIpO1xufVxuZnVuY3Rpb24gZnJvbVBhdGgocGF0aCkge1xuICByZXR1cm4gbmV3IFN0YXRpY1ZhbHVlKHBhdGgsIFwicGF0aFwiKTtcbn1cbmZ1bmN0aW9uIGlzSXRlcmF0b3Iob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIG9iai5uZXh0ID09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIGZyb21KUyh2YWwpIHtcbiAgcmV0dXJuIGlzSXRlcmF0b3IodmFsKSA/IG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xuICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgdmFsKVxuICAgICAgeWllbGQgZnJvbUpTKHZhbHVlKTtcbiAgfSkgOiB2YWwgPT0gbnVsbCA/IE5VTExfVkFMVUUgOiBuZXcgU3RhdGljVmFsdWUodmFsLCBnZXRUeXBlKHZhbCkpO1xufVxuZnVuY3Rpb24gZ2V0VHlwZShkYXRhKSB7XG4gIHJldHVybiBkYXRhID09PSBudWxsIHx8IHR5cGVvZiBkYXRhID4gXCJ1XCIgPyBcIm51bGxcIiA6IEFycmF5LmlzQXJyYXkoZGF0YSkgPyBcImFycmF5XCIgOiBkYXRhIGluc3RhbmNlb2YgUGF0aCA/IFwicGF0aFwiIDogZGF0YSBpbnN0YW5jZW9mIERhdGVUaW1lID8gXCJkYXRldGltZVwiIDogdHlwZW9mIGRhdGE7XG59XG5mdW5jdGlvbiBpc0VxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEudHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBiLnR5cGUgPT09IFwic3RyaW5nXCIgfHwgYS50eXBlID09PSBcImJvb2xlYW5cIiAmJiBiLnR5cGUgPT09IFwiYm9vbGVhblwiIHx8IGEudHlwZSA9PT0gXCJudWxsXCIgJiYgYi50eXBlID09PSBcIm51bGxcIiB8fCBhLnR5cGUgPT09IFwibnVtYmVyXCIgJiYgYi50eXBlID09PSBcIm51bWJlclwiID8gYS5kYXRhID09PSBiLmRhdGEgOiBhLnR5cGUgPT09IFwiZGF0ZXRpbWVcIiAmJiBiLnR5cGUgPT09IFwiZGF0ZXRpbWVcIiA/IGEuZGF0YS5lcXVhbHMoYi5kYXRhKSA6ICExO1xufVxuY29uc3QgQ0hBUlMgPSAvKFteIUAjJCVeJiooKSxcXFxcLz9cIjs6e318W1xcXSs8Plxccy1dKSsvZywgQ0hBUlNfV0lUSF9XSUxEQ0FSRCA9IC8oW14hQCMkJV4mKCksXFxcXC8/XCI7Ont9fFtcXF0rPD5cXHMtXSkrL2csIEVER0VfQ0hBUlMgPSAvKFxcYlxcLit8XFwuK1xcYikvZztcbmZ1bmN0aW9uIG1hdGNoVGV4dCh0b2tlbnMsIHBhdHRlcm5zKSB7XG4gIHJldHVybiB0b2tlbnMubGVuZ3RoID09PSAwIHx8IHBhdHRlcm5zLmxlbmd0aCA9PT0gMCA/ICExIDogcGF0dGVybnMuZXZlcnkoKHBhdHRlcm4pID0+IHBhdHRlcm4odG9rZW5zKSk7XG59XG5mdW5jdGlvbiBtYXRjaFRva2VuaXplKHRleHQyKSB7XG4gIHJldHVybiB0ZXh0Mi5yZXBsYWNlKEVER0VfQ0hBUlMsIFwiXCIpLm1hdGNoKENIQVJTKSB8fCBbXTtcbn1cbmZ1bmN0aW9uIG1hdGNoQW5hbHl6ZVBhdHRlcm4odGV4dDIpIHtcbiAgcmV0dXJuIG1hdGNoUGF0dGVyblJlZ2V4KHRleHQyKS5tYXAoKHJlKSA9PiAodG9rZW5zKSA9PiB0b2tlbnMuc29tZSgodG9rZW4pID0+IHJlLnRlc3QodG9rZW4pKSk7XG59XG5mdW5jdGlvbiBtYXRjaFBhdHRlcm5SZWdleCh0ZXh0Mikge1xuICByZXR1cm4gKHRleHQyLnJlcGxhY2UoRURHRV9DSEFSUywgXCJcIikubWF0Y2goQ0hBUlNfV0lUSF9XSUxEQ0FSRCkgfHwgW10pLm1hcChcbiAgICAodGVybSkgPT4gbmV3IFJlZ0V4cChgXiR7dGVybS5zbGljZSgwLCAxMDI0KS5yZXBsYWNlKC9cXCovZywgXCIuKlwiKX0kYCwgXCJpXCIpXG4gICk7XG59XG5hc3luYyBmdW5jdGlvbiBnYXRoZXJUZXh0KHZhbHVlLCBjYikge1xuICBpZiAodmFsdWUudHlwZSA9PT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gY2IodmFsdWUuZGF0YSksICEwO1xuICBpZiAodmFsdWUuaXNBcnJheSgpKSB7XG4gICAgbGV0IHN1Y2Nlc3MgPSAhMDtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHBhcnQgb2YgdmFsdWUpXG4gICAgICBwYXJ0LnR5cGUgPT09IFwic3RyaW5nXCIgPyBjYihwYXJ0LmRhdGEpIDogc3VjY2VzcyA9ICExO1xuICAgIHJldHVybiBzdWNjZXNzO1xuICB9XG4gIHJldHVybiAhMTtcbn1cbmNvbnN0IFRZUEVfT1JERVIgPSB7XG4gIGRhdGV0aW1lOiAxLFxuICBudW1iZXI6IDIsXG4gIHN0cmluZzogMyxcbiAgYm9vbGVhbjogNFxufTtcbmZ1bmN0aW9uIHBhcnRpYWxDb21wYXJlKGEsIGIpIHtcbiAgY29uc3QgYVR5cGUgPSBnZXRUeXBlKGEpLCBiVHlwZSA9IGdldFR5cGUoYik7XG4gIGlmIChhVHlwZSAhPT0gYlR5cGUpXG4gICAgcmV0dXJuIG51bGw7XG4gIHN3aXRjaCAoYVR5cGUpIHtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIHJldHVybiBhIC0gYjtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDA7XG4gICAgY2FzZSBcImRhdGV0aW1lXCI6XG4gICAgICByZXR1cm4gYS5jb21wYXJlVG8oYik7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiB0b3RhbENvbXBhcmUoYSwgYikge1xuICBjb25zdCBhVHlwZSA9IGdldFR5cGUoYSksIGJUeXBlID0gZ2V0VHlwZShiKSwgYVR5cGVPcmRlciA9IFRZUEVfT1JERVJbYVR5cGVdIHx8IDEwMCwgYlR5cGVPcmRlciA9IFRZUEVfT1JERVJbYlR5cGVdIHx8IDEwMDtcbiAgaWYgKGFUeXBlT3JkZXIgIT09IGJUeXBlT3JkZXIpXG4gICAgcmV0dXJuIGFUeXBlT3JkZXIgLSBiVHlwZU9yZGVyO1xuICBsZXQgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUoYSwgYik7XG4gIHJldHVybiByZXN1bHQgPT09IG51bGwgJiYgKHJlc3VsdCA9IDApLCByZXN1bHQ7XG59XG5jb25zdCBvcGVyYXRvcnMgPSB7XG4gIFwiPT1cIjogZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gaXNFcXVhbChsZWZ0LCByaWdodCkgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gIH0sXG4gIFwiIT1cIjogZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gaXNFcXVhbChsZWZ0LCByaWdodCkgPyBGQUxTRV9WQUxVRSA6IFRSVUVfVkFMVUU7XG4gIH0sXG4gIFwiPlwiOiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwic3RyZWFtXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJzdHJlYW1cIikgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgY29uc3QgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUobGVmdC5kYXRhLCByaWdodC5kYXRhKTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBudWxsID8gTlVMTF9WQUxVRSA6IHJlc3VsdCA+IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gIH0sXG4gIFwiPj1cIjogZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC50eXBlID09PSBcInN0cmVhbVwiIHx8IHJpZ2h0LnR5cGUgPT09IFwic3RyZWFtXCIpIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIGNvbnN0IHJlc3VsdCA9IHBhcnRpYWxDb21wYXJlKGxlZnQuZGF0YSwgcmlnaHQuZGF0YSk7XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gbnVsbCA/IE5VTExfVkFMVUUgOiByZXN1bHQgPj0gMCA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgfSxcbiAgXCI8XCI6IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJzdHJlYW1cIiB8fCByaWdodC50eXBlID09PSBcInN0cmVhbVwiKSByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICBjb25zdCByZXN1bHQgPSBwYXJ0aWFsQ29tcGFyZShsZWZ0LmRhdGEsIHJpZ2h0LmRhdGEpO1xuICAgIHJldHVybiByZXN1bHQgPT09IG51bGwgPyBOVUxMX1ZBTFVFIDogcmVzdWx0IDwgMCA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgfSxcbiAgXCI8PVwiOiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwic3RyZWFtXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJzdHJlYW1cIikgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgY29uc3QgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUobGVmdC5kYXRhLCByaWdodC5kYXRhKTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBudWxsID8gTlVMTF9WQUxVRSA6IHJlc3VsdCA8PSAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lLW1hdGNoaW5nXG4gIGluOiBhc3luYyBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIGlmIChyaWdodC50eXBlID09PSBcInBhdGhcIilcbiAgICAgIHJldHVybiBsZWZ0LnR5cGUgIT09IFwic3RyaW5nXCIgPyBOVUxMX1ZBTFVFIDogcmlnaHQuZGF0YS5tYXRjaGVzKGxlZnQuZGF0YSkgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gICAgaWYgKHJpZ2h0LmlzQXJyYXkoKSkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBiIG9mIHJpZ2h0KVxuICAgICAgICBpZiAoaXNFcXVhbChsZWZ0LCBiKSlcbiAgICAgICAgICByZXR1cm4gVFJVRV9WQUxVRTtcbiAgICAgIHJldHVybiBGQUxTRV9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH0sXG4gIG1hdGNoOiBhc3luYyBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIGxldCB0b2tlbnMgPSBbXSwgcGF0dGVybnMgPSBbXTtcbiAgICByZXR1cm4gYXdhaXQgZ2F0aGVyVGV4dChsZWZ0LCAocGFydCkgPT4ge1xuICAgICAgdG9rZW5zID0gdG9rZW5zLmNvbmNhdChtYXRjaFRva2VuaXplKHBhcnQpKTtcbiAgICB9KSwgYXdhaXQgZ2F0aGVyVGV4dChyaWdodCwgKHBhcnQpID0+IHtcbiAgICAgIHBhdHRlcm5zID0gcGF0dGVybnMuY29uY2F0KG1hdGNoQW5hbHl6ZVBhdHRlcm4ocGFydCkpO1xuICAgIH0pICYmIG1hdGNoVGV4dCh0b2tlbnMsIHBhdHRlcm5zKSA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgfSxcbiAgXCIrXCI6IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIGxlZnQudHlwZSA9PT0gXCJkYXRldGltZVwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIgPyBmcm9tRGF0ZVRpbWUobGVmdC5kYXRhLmFkZChyaWdodC5kYXRhKSkgOiBsZWZ0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIiA/IGZyb21OdW1iZXIobGVmdC5kYXRhICsgcmlnaHQuZGF0YSkgOiBsZWZ0LnR5cGUgPT09IFwic3RyaW5nXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJzdHJpbmdcIiA/IGZyb21TdHJpbmcobGVmdC5kYXRhICsgcmlnaHQuZGF0YSkgOiBsZWZ0LnR5cGUgPT09IFwib2JqZWN0XCIgJiYgcmlnaHQudHlwZSA9PT0gXCJvYmplY3RcIiA/IGZyb21KUyh7IC4uLmxlZnQuZGF0YSwgLi4ucmlnaHQuZGF0YSB9KSA6IGxlZnQudHlwZSA9PT0gXCJhcnJheVwiICYmIHJpZ2h0LnR5cGUgPT09IFwiYXJyYXlcIiA/IGZyb21KUyhsZWZ0LmRhdGEuY29uY2F0KHJpZ2h0LmRhdGEpKSA6IGxlZnQuaXNBcnJheSgpICYmIHJpZ2h0LmlzQXJyYXkoKSA/IG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCB2YWwgb2YgbGVmdClcbiAgICAgICAgeWllbGQgdmFsO1xuICAgICAgZm9yIGF3YWl0IChjb25zdCB2YWwgb2YgcmlnaHQpXG4gICAgICAgIHlpZWxkIHZhbDtcbiAgICB9KSA6IE5VTExfVkFMVUU7XG4gIH0sXG4gIFwiLVwiOiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIHJldHVybiBsZWZ0LnR5cGUgPT09IFwiZGF0ZXRpbWVcIiAmJiByaWdodC50eXBlID09PSBcIm51bWJlclwiID8gZnJvbURhdGVUaW1lKGxlZnQuZGF0YS5hZGQoLXJpZ2h0LmRhdGEpKSA6IGxlZnQudHlwZSA9PT0gXCJkYXRldGltZVwiICYmIHJpZ2h0LnR5cGUgPT09IFwiZGF0ZXRpbWVcIiA/IGZyb21OdW1iZXIobGVmdC5kYXRhLmRpZmZlcmVuY2UocmlnaHQuZGF0YSkpIDogbGVmdC50eXBlID09PSBcIm51bWJlclwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIgPyBmcm9tTnVtYmVyKGxlZnQuZGF0YSAtIHJpZ2h0LmRhdGEpIDogTlVMTF9WQUxVRTtcbiAgfSxcbiAgXCIqXCI6IG51bWVyaWNPcGVyYXRvcigoYSwgYikgPT4gYSAqIGIpLFxuICBcIi9cIjogbnVtZXJpY09wZXJhdG9yKChhLCBiKSA9PiBhIC8gYiksXG4gIFwiJVwiOiBudW1lcmljT3BlcmF0b3IoKGEsIGIpID0+IGEgJSBiKSxcbiAgXCIqKlwiOiBudW1lcmljT3BlcmF0b3IoKGEsIGIpID0+IE1hdGgucG93KGEsIGIpKVxufTtcbmZ1bmN0aW9uIG51bWVyaWNPcGVyYXRvcihpbXBsKSB7XG4gIHJldHVybiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgY29uc3QgcmVzdWx0ID0gaW1wbChsZWZ0LmRhdGEsIHJpZ2h0LmRhdGEpO1xuICAgICAgcmV0dXJuIGZyb21OdW1iZXIocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH07XG59XG5sZXQgU2NvcGUkMSA9IGNsYXNzIFNjb3BlIHtcbiAgcGFyYW1zO1xuICBzb3VyY2U7XG4gIHZhbHVlO1xuICBwYXJlbnQ7XG4gIGNvbnRleHQ7XG4gIGlzSGlkZGVuID0gITE7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG4gIGNvbnN0cnVjdG9yKHBhcmFtcywgc291cmNlLCB2YWx1ZSwgY29udGV4dCwgcGFyZW50KSB7XG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXMsIHRoaXMuc291cmNlID0gc291cmNlLCB0aGlzLnZhbHVlID0gdmFsdWUsIHRoaXMuY29udGV4dCA9IGNvbnRleHQsIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICB9XG4gIGNyZWF0ZU5lc3RlZCh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmlzSGlkZGVuID8gbmV3IFNjb3BlKHRoaXMucGFyYW1zLCB0aGlzLnNvdXJjZSwgdmFsdWUsIHRoaXMuY29udGV4dCwgdGhpcy5wYXJlbnQpIDogbmV3IFNjb3BlKHRoaXMucGFyYW1zLCB0aGlzLnNvdXJjZSwgdmFsdWUsIHRoaXMuY29udGV4dCwgdGhpcyk7XG4gIH1cbiAgY3JlYXRlSGlkZGVuKHZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5jcmVhdGVOZXN0ZWQodmFsdWUpO1xuICAgIHJldHVybiByZXN1bHQuaXNIaWRkZW4gPSAhMCwgcmVzdWx0O1xuICB9XG59O1xuZnVuY3Rpb24gZXZhbHVhdGUobm9kZSwgc2NvcGUsIGV4ZWN1dGUgPSBldmFsdWF0ZSkge1xuICBjb25zdCBmdW5jID0gRVhFQ1VUT1JTW25vZGUudHlwZV07XG4gIHJldHVybiBmdW5jKG5vZGUsIHNjb3BlLCBleGVjdXRlKTtcbn1cbmZ1bmN0aW9uIHByb21pc2VsZXNzQXBwbHkodmFsdWUsIGNiKSB7XG4gIHJldHVybiBcInRoZW5cIiBpbiB2YWx1ZSA/IHZhbHVlLnRoZW4oY2IpIDogY2IodmFsdWUpO1xufVxuY29uc3QgRVhFQ1VUT1JTID0ge1xuICBUaGlzKF8sIHNjb3BlKSB7XG4gICAgcmV0dXJuIHNjb3BlLnZhbHVlO1xuICB9LFxuICBTZWxlY3RvcigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWxlY3RvcnMgY2FuIG5vdCBiZSBldmFsdWF0ZWRcIik7XG4gIH0sXG4gIEV2ZXJ5dGhpbmcoXywgc2NvcGUpIHtcbiAgICByZXR1cm4gc2NvcGUuc291cmNlO1xuICB9LFxuICBQYXJhbWV0ZXIoeyBuYW1lIH0sIHNjb3BlKSB7XG4gICAgcmV0dXJuIGZyb21KUyhzY29wZS5wYXJhbXNbbmFtZV0pO1xuICB9LFxuICBDb250ZXh0KHsga2V5IH0sIHNjb3BlKSB7XG4gICAgaWYgKGtleSA9PT0gXCJiZWZvcmVcIiB8fCBrZXkgPT09IFwiYWZ0ZXJcIilcbiAgICAgIHJldHVybiBzY29wZS5jb250ZXh0W2tleV0gfHwgTlVMTF9WQUxVRTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gY29udGV4dCBrZXk6ICR7a2V5fWApO1xuICB9LFxuICBQYXJlbnQoeyBuIH0sIHNjb3BlKSB7XG4gICAgbGV0IGN1cnJlbnQgPSBzY29wZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgaWYgKCFjdXJyZW50LnBhcmVudClcbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50LnZhbHVlO1xuICB9LFxuICBPcENhbGwoeyBvcCwgbGVmdCwgcmlnaHQgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCBmdW5jID0gb3BlcmF0b3JzW29wXTtcbiAgICBpZiAoIWZ1bmMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gb3BlcmF0b3I6ICR7b3B9YCk7XG4gICAgY29uc3QgbGVmdFZhbHVlID0gZXhlY3V0ZShsZWZ0LCBzY29wZSksIHJpZ2h0VmFsdWUgPSBleGVjdXRlKHJpZ2h0LCBzY29wZSk7XG4gICAgcmV0dXJuIFwidGhlblwiIGluIGxlZnRWYWx1ZSB8fCBcInRoZW5cIiBpbiByaWdodFZhbHVlID8gKGFzeW5jICgpID0+IGZ1bmMoYXdhaXQgbGVmdFZhbHVlLCBhd2FpdCByaWdodFZhbHVlKSkoKSA6IGZ1bmMobGVmdFZhbHVlLCByaWdodFZhbHVlKTtcbiAgfSxcbiAgYXN5bmMgU2VsZWN0KHsgYWx0ZXJuYXRpdmVzLCBmYWxsYmFjayB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGZvciAoY29uc3QgYWx0IG9mIGFsdGVybmF0aXZlcykge1xuICAgICAgY29uc3QgYWx0Q29uZCA9IGF3YWl0IGV4ZWN1dGUoYWx0LmNvbmRpdGlvbiwgc2NvcGUpO1xuICAgICAgaWYgKGFsdENvbmQudHlwZSA9PT0gXCJib29sZWFuXCIgJiYgYWx0Q29uZC5kYXRhID09PSAhMClcbiAgICAgICAgcmV0dXJuIGV4ZWN1dGUoYWx0LnZhbHVlLCBzY29wZSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxsYmFjayA/IGV4ZWN1dGUoZmFsbGJhY2ssIHNjb3BlKSA6IE5VTExfVkFMVUU7XG4gIH0sXG4gIGFzeW5jIEluUmFuZ2UoeyBiYXNlLCBsZWZ0LCByaWdodCwgaXNJbmNsdXNpdmUgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpLCBsZWZ0VmFsdWUgPSBhd2FpdCBleGVjdXRlKGxlZnQsIHNjb3BlKSwgcmlnaHRWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUocmlnaHQsIHNjb3BlKSwgbGVmdENtcCA9IHBhcnRpYWxDb21wYXJlKGF3YWl0IHZhbHVlLmdldCgpLCBhd2FpdCBsZWZ0VmFsdWUuZ2V0KCkpO1xuICAgIGlmIChsZWZ0Q21wID09PSBudWxsKVxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgY29uc3QgcmlnaHRDbXAgPSBwYXJ0aWFsQ29tcGFyZShhd2FpdCB2YWx1ZS5nZXQoKSwgYXdhaXQgcmlnaHRWYWx1ZS5nZXQoKSk7XG4gICAgcmV0dXJuIHJpZ2h0Q21wID09PSBudWxsID8gTlVMTF9WQUxVRSA6IGlzSW5jbHVzaXZlID8gbGVmdENtcCA+PSAwICYmIHJpZ2h0Q21wIDw9IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUUgOiBsZWZ0Q21wID49IDAgJiYgcmlnaHRDbXAgPCAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICBhc3luYyBGaWx0ZXIoeyBiYXNlLCBleHByIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgYmFzZVZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgcmV0dXJuIGJhc2VWYWx1ZS5pc0FycmF5KCkgPyBuZXcgU3RyZWFtVmFsdWUoYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiBiYXNlVmFsdWUpIHtcbiAgICAgICAgY29uc3QgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVOZXN0ZWQoZWxlbSksIGV4cHJWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoZXhwciwgbmV3U2NvcGUpO1xuICAgICAgICBleHByVmFsdWUudHlwZSA9PT0gXCJib29sZWFuXCIgJiYgZXhwclZhbHVlLmRhdGEgPT09ICEwICYmICh5aWVsZCBlbGVtKTtcbiAgICAgIH1cbiAgICB9KSA6IE5VTExfVkFMVUU7XG4gIH0sXG4gIGFzeW5jIFByb2plY3Rpb24oeyBiYXNlLCBleHByIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgYmFzZVZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgaWYgKGJhc2VWYWx1ZS50eXBlICE9PSBcIm9iamVjdFwiKVxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgY29uc3QgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVOZXN0ZWQoYmFzZVZhbHVlKTtcbiAgICByZXR1cm4gZXhlY3V0ZShleHByLCBuZXdTY29wZSk7XG4gIH0sXG4gIEZ1bmNDYWxsKHsgZnVuYywgYXJncyB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHJldHVybiBmdW5jKGFyZ3MsIHNjb3BlLCBleGVjdXRlKTtcbiAgfSxcbiAgYXN5bmMgUGlwZUZ1bmNDYWxsKHsgZnVuYywgYmFzZSwgYXJncyB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IGJhc2VWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIHJldHVybiBmdW5jKGJhc2VWYWx1ZSwgYXJncywgc2NvcGUsIGV4ZWN1dGUpO1xuICB9LFxuICBhc3luYyBBY2Nlc3NBdHRyaWJ1dGUoeyBiYXNlLCBuYW1lIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHZhbHVlID0gc2NvcGUudmFsdWU7XG4gICAgcmV0dXJuIGJhc2UgJiYgKHZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSkpLCB2YWx1ZS50eXBlID09PSBcIm9iamVjdFwiICYmIHZhbHVlLmRhdGEuaGFzT3duUHJvcGVydHkobmFtZSkgPyBmcm9tSlModmFsdWUuZGF0YVtuYW1lXSkgOiBOVUxMX1ZBTFVFO1xuICB9LFxuICBhc3luYyBBY2Nlc3NFbGVtZW50KHsgYmFzZSwgaW5kZXggfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCBiYXNlVmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICBpZiAoIWJhc2VWYWx1ZS5pc0FycmF5KCkpXG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgYmFzZVZhbHVlLmdldCgpLCBmaW5hbEluZGV4ID0gaW5kZXggPCAwID8gaW5kZXggKyBkYXRhLmxlbmd0aCA6IGluZGV4O1xuICAgIHJldHVybiBmcm9tSlMoZGF0YVtmaW5hbEluZGV4XSk7XG4gIH0sXG4gIGFzeW5jIFNsaWNlKHsgYmFzZSwgbGVmdCwgcmlnaHQsIGlzSW5jbHVzaXZlIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgYmFzZVZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgaWYgKCFiYXNlVmFsdWUuaXNBcnJheSgpKVxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgY29uc3QgYXJyYXkyID0gYXdhaXQgYmFzZVZhbHVlLmdldCgpO1xuICAgIGxldCBsZWZ0SWR4ID0gbGVmdCwgcmlnaHRJZHggPSByaWdodDtcbiAgICByZXR1cm4gbGVmdElkeCA8IDAgJiYgKGxlZnRJZHggPSBhcnJheTIubGVuZ3RoICsgbGVmdElkeCksIHJpZ2h0SWR4IDwgMCAmJiAocmlnaHRJZHggPSBhcnJheTIubGVuZ3RoICsgcmlnaHRJZHgpLCBpc0luY2x1c2l2ZSAmJiByaWdodElkeCsrLCBsZWZ0SWR4IDwgMCAmJiAobGVmdElkeCA9IDApLCByaWdodElkeCA8IDAgJiYgKHJpZ2h0SWR4ID0gMCksIGZyb21KUyhhcnJheTIuc2xpY2UobGVmdElkeCwgcmlnaHRJZHgpKTtcbiAgfSxcbiAgYXN5bmMgRGVyZWYoeyBiYXNlIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICBpZiAoIXNjb3BlLnNvdXJjZS5pc0FycmF5KCkgfHwgdmFsdWUudHlwZSAhPT0gXCJvYmplY3RcIilcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIGNvbnN0IGlkID0gdmFsdWUuZGF0YS5fcmVmO1xuICAgIGlmICh0eXBlb2YgaWQgIT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIGlmIChzY29wZS5jb250ZXh0LmRlcmVmZXJlbmNlKVxuICAgICAgcmV0dXJuIGZyb21KUyhhd2FpdCBzY29wZS5jb250ZXh0LmRlcmVmZXJlbmNlKHsgX3JlZjogaWQgfSkpO1xuICAgIGZvciBhd2FpdCAoY29uc3QgZG9jIG9mIHNjb3BlLnNvdXJjZSlcbiAgICAgIGlmIChkb2MudHlwZSA9PT0gXCJvYmplY3RcIiAmJiBpZCA9PT0gZG9jLmRhdGEuX2lkKVxuICAgICAgICByZXR1cm4gZG9jO1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9LFxuICBWYWx1ZSh7IHZhbHVlIH0pIHtcbiAgICByZXR1cm4gZnJvbUpTKHZhbHVlKTtcbiAgfSxcbiAgR3JvdXAoeyBiYXNlIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgcmV0dXJuIGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICB9LFxuICBhc3luYyBPYmplY3QoeyBhdHRyaWJ1dGVzIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBhdHRyIG9mIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJUeXBlID0gYXR0ci50eXBlO1xuICAgICAgc3dpdGNoIChhdHRyLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcIk9iamVjdEF0dHJpYnV0ZVZhbHVlXCI6IHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXR0ci52YWx1ZSwgc2NvcGUpO1xuICAgICAgICAgIHJlc3VsdFthdHRyLm5hbWVdID0gYXdhaXQgdmFsdWUuZ2V0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIk9iamVjdENvbmRpdGlvbmFsU3BsYXRcIjoge1xuICAgICAgICAgIGNvbnN0IGNvbmQgPSBhd2FpdCBleGVjdXRlKGF0dHIuY29uZGl0aW9uLCBzY29wZSk7XG4gICAgICAgICAgaWYgKGNvbmQudHlwZSAhPT0gXCJib29sZWFuXCIgfHwgY29uZC5kYXRhID09PSAhMSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhdHRyLnZhbHVlLCBzY29wZSk7XG4gICAgICAgICAgdmFsdWUudHlwZSA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3QuYXNzaWduKHJlc3VsdCwgdmFsdWUuZGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIk9iamVjdFNwbGF0XCI6IHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXR0ci52YWx1ZSwgc2NvcGUpO1xuICAgICAgICAgIHZhbHVlLnR5cGUgPT09IFwib2JqZWN0XCIgJiYgT2JqZWN0LmFzc2lnbihyZXN1bHQsIHZhbHVlLmRhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIG5vZGUgdHlwZTogJHthdHRyVHlwZX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZyb21KUyhyZXN1bHQpO1xuICB9LFxuICBBcnJheSh7IGVsZW1lbnRzIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShlbGVtZW50LnZhbHVlLCBzY29wZSk7XG4gICAgICAgIGlmIChlbGVtZW50LmlzU3BsYXQpIHtcbiAgICAgICAgICBpZiAodmFsdWUuaXNBcnJheSgpKVxuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCB2IG9mIHZhbHVlKVxuICAgICAgICAgICAgICB5aWVsZCB2O1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICB5aWVsZCB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgVHVwbGUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidHVwbGVzIGNhbiBub3QgYmUgZXZhbHVhdGVkXCIpO1xuICB9LFxuICBhc3luYyBPcih7IGxlZnQsIHJpZ2h0IH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgbGVmdFZhbHVlID0gYXdhaXQgZXhlY3V0ZShsZWZ0LCBzY29wZSksIHJpZ2h0VmFsdWUgPSBhd2FpdCBleGVjdXRlKHJpZ2h0LCBzY29wZSk7XG4gICAgcmV0dXJuIGxlZnRWYWx1ZS50eXBlID09PSBcImJvb2xlYW5cIiAmJiBsZWZ0VmFsdWUuZGF0YSA9PT0gITAgfHwgcmlnaHRWYWx1ZS50eXBlID09PSBcImJvb2xlYW5cIiAmJiByaWdodFZhbHVlLmRhdGEgPT09ICEwID8gVFJVRV9WQUxVRSA6IGxlZnRWYWx1ZS50eXBlICE9PSBcImJvb2xlYW5cIiB8fCByaWdodFZhbHVlLnR5cGUgIT09IFwiYm9vbGVhblwiID8gTlVMTF9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICBhc3luYyBBbmQoeyBsZWZ0LCByaWdodCB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IGxlZnRWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUobGVmdCwgc2NvcGUpLCByaWdodFZhbHVlID0gYXdhaXQgZXhlY3V0ZShyaWdodCwgc2NvcGUpO1xuICAgIHJldHVybiBsZWZ0VmFsdWUudHlwZSA9PT0gXCJib29sZWFuXCIgJiYgbGVmdFZhbHVlLmRhdGEgPT09ICExIHx8IHJpZ2h0VmFsdWUudHlwZSA9PT0gXCJib29sZWFuXCIgJiYgcmlnaHRWYWx1ZS5kYXRhID09PSAhMSA/IEZBTFNFX1ZBTFVFIDogbGVmdFZhbHVlLnR5cGUgIT09IFwiYm9vbGVhblwiIHx8IHJpZ2h0VmFsdWUudHlwZSAhPT0gXCJib29sZWFuXCIgPyBOVUxMX1ZBTFVFIDogVFJVRV9WQUxVRTtcbiAgfSxcbiAgYXN5bmMgTm90KHsgYmFzZSB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgcmV0dXJuIHZhbHVlLnR5cGUgIT09IFwiYm9vbGVhblwiID8gTlVMTF9WQUxVRSA6IHZhbHVlLmRhdGEgPyBGQUxTRV9WQUxVRSA6IFRSVUVfVkFMVUU7XG4gIH0sXG4gIE5lZyh7IGJhc2UgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICByZXR1cm4gcHJvbWlzZWxlc3NBcHBseShleGVjdXRlKGJhc2UsIHNjb3BlKSwgKHZhbHVlKSA9PiB2YWx1ZS50eXBlICE9PSBcIm51bWJlclwiID8gTlVMTF9WQUxVRSA6IGZyb21OdW1iZXIoLXZhbHVlLmRhdGEpKTtcbiAgfSxcbiAgUG9zKHsgYmFzZSB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHJldHVybiBwcm9taXNlbGVzc0FwcGx5KGV4ZWN1dGUoYmFzZSwgc2NvcGUpLCAodmFsdWUpID0+IHZhbHVlLnR5cGUgIT09IFwibnVtYmVyXCIgPyBOVUxMX1ZBTFVFIDogZnJvbU51bWJlcih2YWx1ZS5kYXRhKSk7XG4gIH0sXG4gIEFzYygpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfSxcbiAgRGVzYygpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfSxcbiAgYXN5bmMgQXJyYXlDb2VyY2UoeyBiYXNlIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICByZXR1cm4gdmFsdWUuaXNBcnJheSgpID8gdmFsdWUgOiBOVUxMX1ZBTFVFO1xuICB9LFxuICBhc3luYyBNYXAoeyBiYXNlLCBleHByIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICByZXR1cm4gdmFsdWUuaXNBcnJheSgpID8gbmV3IFN0cmVhbVZhbHVlKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IGVsZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVIaWRkZW4oZWxlbSk7XG4gICAgICAgIHlpZWxkIGF3YWl0IGV4ZWN1dGUoZXhwciwgbmV3U2NvcGUpO1xuICAgICAgfVxuICAgIH0pIDogTlVMTF9WQUxVRTtcbiAgfSxcbiAgYXN5bmMgRmxhdE1hcCh7IGJhc2UsIGV4cHIgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIHJldHVybiB2YWx1ZS5pc0FycmF5KCkgPyBuZXcgU3RyZWFtVmFsdWUoYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiB2YWx1ZSkge1xuICAgICAgICBjb25zdCBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZUhpZGRlbihlbGVtKSwgaW5uZXJWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoZXhwciwgbmV3U2NvcGUpO1xuICAgICAgICBpZiAoaW5uZXJWYWx1ZS5pc0FycmF5KCkpXG4gICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBpbm5lciBvZiBpbm5lclZhbHVlKVxuICAgICAgICAgICAgeWllbGQgaW5uZXI7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB5aWVsZCBpbm5lclZhbHVlO1xuICAgICAgfVxuICAgIH0pIDogTlVMTF9WQUxVRTtcbiAgfVxufTtcbmZ1bmN0aW9uIGV2YWx1YXRlUXVlcnkodHJlZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHJvb3QgPSBmcm9tSlMob3B0aW9ucy5yb290KSwgZGF0YXNldCA9IGZyb21KUyhvcHRpb25zLmRhdGFzZXQpLCBwYXJhbXMgPSB7IC4uLm9wdGlvbnMucGFyYW1zIH0sIHNjb3BlID0gbmV3IFNjb3BlJDEoXG4gICAgcGFyYW1zLFxuICAgIGRhdGFzZXQsXG4gICAgcm9vdCxcbiAgICB7XG4gICAgICB0aW1lc3RhbXA6IG9wdGlvbnMudGltZXN0YW1wIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLFxuICAgICAgaWRlbnRpdHk6IG9wdGlvbnMuaWRlbnRpdHkgPT09IHZvaWQgMCA/IFwibWVcIiA6IG9wdGlvbnMuaWRlbnRpdHksXG4gICAgICBzYW5pdHk6IG9wdGlvbnMuc2FuaXR5LFxuICAgICAgYWZ0ZXI6IG9wdGlvbnMuYWZ0ZXIgPyBmcm9tSlMob3B0aW9ucy5hZnRlcikgOiBudWxsLFxuICAgICAgYmVmb3JlOiBvcHRpb25zLmJlZm9yZSA/IGZyb21KUyhvcHRpb25zLmJlZm9yZSkgOiBudWxsLFxuICAgICAgZGVyZWZlcmVuY2U6IG9wdGlvbnMuZGVyZWZlcmVuY2VcbiAgICB9LFxuICAgIG51bGxcbiAgKTtcbiAgcmV0dXJuIGV2YWx1YXRlKHRyZWUsIHNjb3BlKTtcbn1cbmZ1bmN0aW9uIGNhbkNvbnN0YW50RXZhbHVhdGUobm9kZSkge1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJHcm91cFwiOlxuICAgICAgcmV0dXJuIGNhbkNvbnN0YW50RXZhbHVhdGUobm9kZS5iYXNlKTtcbiAgICBjYXNlIFwiVmFsdWVcIjpcbiAgICBjYXNlIFwiUGFyYW1ldGVyXCI6XG4gICAgICByZXR1cm4gITA7XG4gICAgY2FzZSBcIlBvc1wiOlxuICAgIGNhc2UgXCJOZWdcIjpcbiAgICAgIHJldHVybiBjYW5Db25zdGFudEV2YWx1YXRlKG5vZGUuYmFzZSk7XG4gICAgY2FzZSBcIk9wQ2FsbFwiOlxuICAgICAgc3dpdGNoIChub2RlLm9wKSB7XG4gICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgIGNhc2UgXCIqXCI6XG4gICAgICAgIGNhc2UgXCIvXCI6XG4gICAgICAgIGNhc2UgXCIlXCI6XG4gICAgICAgIGNhc2UgXCIqKlwiOlxuICAgICAgICAgIHJldHVybiBjYW5Db25zdGFudEV2YWx1YXRlKG5vZGUubGVmdCkgJiYgY2FuQ29uc3RhbnRFdmFsdWF0ZShub2RlLnJpZ2h0KTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAhMTtcbiAgfVxufVxuY29uc3QgRFVNTVlfU0NPUEUgPSBuZXcgU2NvcGUkMShcbiAge30sXG4gIE5VTExfVkFMVUUsXG4gIE5VTExfVkFMVUUsXG4gIHsgdGltZXN0YW1wOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoMCksIGlkZW50aXR5OiBcIm1lXCIsIGJlZm9yZTogbnVsbCwgYWZ0ZXI6IG51bGwgfSxcbiAgbnVsbFxuKTtcbmZ1bmN0aW9uIHRyeUNvbnN0YW50RXZhbHVhdGUobm9kZSkge1xuICByZXR1cm4gY2FuQ29uc3RhbnRFdmFsdWF0ZShub2RlKSA/IGNvbnN0YW50RXZhbHVhdGUobm9kZSkgOiBudWxsO1xufVxuZnVuY3Rpb24gY29uc3RhbnRFdmFsdWF0ZShub2RlKSB7XG4gIGNvbnN0IHZhbHVlID0gZXZhbHVhdGUobm9kZSwgRFVNTVlfU0NPUEUsIGNvbnN0YW50RXZhbHVhdGUpO1xuICBpZiAoXCJ0aGVuXCIgaW4gdmFsdWUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQlVHOiBjb25zdGFudCBldmFsdWF0ZSBzaG91bGQgbmV2ZXIgcmV0dXJuIGEgcHJvbWlzZVwiKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuYXN5bmMgZnVuY3Rpb24gcG9ydGFibGVUZXh0Q29udGVudCh2YWx1ZSkge1xuICBpZiAodmFsdWUudHlwZSA9PT0gXCJvYmplY3RcIilcbiAgICByZXR1cm4gYmxvY2tUZXh0KHZhbHVlLmRhdGEpO1xuICBpZiAodmFsdWUuaXNBcnJheSgpKSB7XG4gICAgY29uc3QgdGV4dHMgPSBhd2FpdCBhcnJheVRleHQodmFsdWUpO1xuICAgIGlmICh0ZXh0cy5sZW5ndGggPiAwKVxuICAgICAgcmV0dXJuIHRleHRzLmpvaW4oYFxuXG5gKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGFycmF5VGV4dCh2YWx1ZSwgcmVzdWx0ID0gW10pIHtcbiAgZm9yIGF3YWl0IChjb25zdCBibG9jayBvZiB2YWx1ZSlcbiAgICBpZiAoYmxvY2sudHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgY29uc3QgdGV4dDIgPSBibG9ja1RleHQoYmxvY2suZGF0YSk7XG4gICAgICB0ZXh0MiAhPT0gbnVsbCAmJiByZXN1bHQucHVzaCh0ZXh0Mik7XG4gICAgfSBlbHNlIGJsb2NrLmlzQXJyYXkoKSAmJiBhd2FpdCBhcnJheVRleHQoYmxvY2ssIHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBibG9ja1RleHQob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqLl90eXBlICE9IFwic3RyaW5nXCIpIHJldHVybiBudWxsO1xuICBjb25zdCBjaGlsZHJlbiA9IG9iai5jaGlsZHJlbjtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkgcmV0dXJuIG51bGw7XG4gIGxldCByZXN1bHQgPSBcIlwiO1xuICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKVxuICAgIGNoaWxkICYmIHR5cGVvZiBjaGlsZCA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBjaGlsZC5fdHlwZSA9PSBcInN0cmluZ1wiICYmIGNoaWxkLl90eXBlID09PSBcInNwYW5cIiAmJiB0eXBlb2YgY2hpbGQudGV4dCA9PSBcInN0cmluZ1wiICYmIChyZXN1bHQgKz0gY2hpbGQudGV4dCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBCTTI1ayA9IDEuMjtcbmFzeW5jIGZ1bmN0aW9uIGV2YWx1YXRlU2NvcmUobm9kZSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJPcENhbGxcIiAmJiBub2RlLm9wID09PSBcIm1hdGNoXCIpXG4gICAgcmV0dXJuIGV2YWx1YXRlTWF0Y2hTY29yZShub2RlLmxlZnQsIG5vZGUucmlnaHQsIHNjb3BlLCBleGVjdXRlKTtcbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJGdW5jQ2FsbFwiICYmIG5vZGUubmFtZSA9PT0gXCJib29zdFwiKSB7XG4gICAgY29uc3QgaW5uZXJTY29yZSA9IGF3YWl0IGV2YWx1YXRlU2NvcmUobm9kZS5hcmdzWzBdLCBzY29wZSwgZXhlY3V0ZSksIGJvb3N0ID0gYXdhaXQgZXhlY3V0ZShub2RlLmFyZ3NbMV0sIHNjb3BlKTtcbiAgICByZXR1cm4gYm9vc3QudHlwZSA9PT0gXCJudW1iZXJcIiAmJiBpbm5lclNjb3JlID4gMCA/IGlubmVyU2NvcmUgKyBib29zdC5kYXRhIDogMDtcbiAgfVxuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJPclwiOiB7XG4gICAgICBjb25zdCBsZWZ0U2NvcmUgPSBhd2FpdCBldmFsdWF0ZVNjb3JlKG5vZGUubGVmdCwgc2NvcGUsIGV4ZWN1dGUpLCByaWdodFNjb3JlID0gYXdhaXQgZXZhbHVhdGVTY29yZShub2RlLnJpZ2h0LCBzY29wZSwgZXhlY3V0ZSk7XG4gICAgICByZXR1cm4gbGVmdFNjb3JlICsgcmlnaHRTY29yZTtcbiAgICB9XG4gICAgY2FzZSBcIkFuZFwiOiB7XG4gICAgICBjb25zdCBsZWZ0U2NvcmUgPSBhd2FpdCBldmFsdWF0ZVNjb3JlKG5vZGUubGVmdCwgc2NvcGUsIGV4ZWN1dGUpLCByaWdodFNjb3JlID0gYXdhaXQgZXZhbHVhdGVTY29yZShub2RlLnJpZ2h0LCBzY29wZSwgZXhlY3V0ZSk7XG4gICAgICByZXR1cm4gbGVmdFNjb3JlID09PSAwIHx8IHJpZ2h0U2NvcmUgPT09IDAgPyAwIDogbGVmdFNjb3JlICsgcmlnaHRTY29yZTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgZXhlY3V0ZShub2RlLCBzY29wZSk7XG4gICAgICByZXR1cm4gcmVzLnR5cGUgPT09IFwiYm9vbGVhblwiICYmIHJlcy5kYXRhID09PSAhMCA/IDEgOiAwO1xuICAgIH1cbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZXZhbHVhdGVNYXRjaFNjb3JlKGxlZnQsIHJpZ2h0LCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCB0ZXh0MiA9IGF3YWl0IGV4ZWN1dGUobGVmdCwgc2NvcGUpLCBwYXR0ZXJuID0gYXdhaXQgZXhlY3V0ZShyaWdodCwgc2NvcGUpO1xuICBsZXQgdG9rZW5zID0gW10sIHRlcm1zID0gW107XG4gIGlmIChhd2FpdCBnYXRoZXJUZXh0KHRleHQyLCAocGFydCkgPT4ge1xuICAgIHRva2VucyA9IHRva2Vucy5jb25jYXQobWF0Y2hUb2tlbml6ZShwYXJ0KSk7XG4gIH0pLCAhYXdhaXQgZ2F0aGVyVGV4dChwYXR0ZXJuLCAocGFydCkgPT4ge1xuICAgIHRlcm1zID0gdGVybXMuY29uY2F0KG1hdGNoUGF0dGVyblJlZ2V4KHBhcnQpKTtcbiAgfSkgfHwgdG9rZW5zLmxlbmd0aCA9PT0gMCB8fCB0ZXJtcy5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIDA7XG4gIGxldCBzY29yZSA9IDA7XG4gIGZvciAoY29uc3QgcmUgb2YgdGVybXMpIHtcbiAgICBjb25zdCBmcmVxID0gdG9rZW5zLnJlZHVjZSgoYywgdG9rZW4pID0+IGMgKyAocmUudGVzdCh0b2tlbikgPyAxIDogMCksIDApO1xuICAgIHNjb3JlICs9IGZyZXEgKiAoQk0yNWsgKyAxKSAvIChmcmVxICsgQk0yNWspO1xuICB9XG4gIHJldHVybiBzY29yZTtcbn1cbmZ1bmN0aW9uIGhhc1JlZmVyZW5jZSh2YWx1ZSwgcGF0aFNldCkge1xuICBzd2l0Y2ggKGdldFR5cGUodmFsdWUpKSB7XG4gICAgY2FzZSBcImFycmF5XCI6XG4gICAgICBmb3IgKGNvbnN0IHYgb2YgdmFsdWUpXG4gICAgICAgIGlmIChoYXNSZWZlcmVuY2UodiwgcGF0aFNldCkpXG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgaWYgKHZhbHVlLl9yZWYpXG4gICAgICAgIHJldHVybiBwYXRoU2V0Lmhhcyh2YWx1ZS5fcmVmKTtcbiAgICAgIGZvciAoY29uc3QgdiBvZiBPYmplY3QudmFsdWVzKHZhbHVlKSlcbiAgICAgICAgaWYgKGhhc1JlZmVyZW5jZSh2LCBwYXRoU2V0KSlcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiBjb3VudFVURjgoc3RyKSB7XG4gIGxldCBjb3VudDIgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBjb2RlID49IDU1Mjk2ICYmIGNvZGUgPD0gNTYzMTkgfHwgY291bnQyKys7XG4gIH1cbiAgcmV0dXJuIGNvdW50Mjtcbn1cbmNvbnN0IF9nbG9iYWwgPSB7fTtcbl9nbG9iYWwuYW55d2hlcmUgPSBhc3luYyBmdW5jdGlvbigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xufTtcbl9nbG9iYWwuYW55d2hlcmUuYXJpdHkgPSAxO1xuX2dsb2JhbC5jb2FsZXNjZSA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGZvciAoY29uc3QgYXJnIG9mIGFyZ3MpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXJnLCBzY29wZSk7XG4gICAgaWYgKHZhbHVlLnR5cGUgIT09IFwibnVsbFwiKVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBOVUxMX1ZBTFVFO1xufTtcbl9nbG9iYWwuY291bnQgPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBpbm5lciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoIWlubmVyLmlzQXJyYXkoKSlcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgbGV0IG51bSA9IDA7XG4gIGZvciBhd2FpdCAoY29uc3QgXyBvZiBpbm5lcilcbiAgICBudW0rKztcbiAgcmV0dXJuIGZyb21OdW1iZXIobnVtKTtcbn07XG5fZ2xvYmFsLmNvdW50LmFyaXR5ID0gMTtcbl9nbG9iYWwuZGF0ZVRpbWUgPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCB2YWwgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgcmV0dXJuIHZhbC50eXBlID09PSBcImRhdGV0aW1lXCIgPyB2YWwgOiB2YWwudHlwZSAhPT0gXCJzdHJpbmdcIiA/IE5VTExfVkFMVUUgOiBEYXRlVGltZS5wYXJzZVRvVmFsdWUodmFsLmRhdGEpO1xufTtcbl9nbG9iYWwuZGF0ZVRpbWUuYXJpdHkgPSAxO1xuX2dsb2JhbC5kZWZpbmVkID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgcmV0dXJuIChhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKSkudHlwZSA9PT0gXCJudWxsXCIgPyBGQUxTRV9WQUxVRSA6IFRSVUVfVkFMVUU7XG59O1xuX2dsb2JhbC5kZWZpbmVkLmFyaXR5ID0gMTtcbl9nbG9iYWwuaWRlbnRpdHkgPSBhc3luYyBmdW5jdGlvbihfYXJncywgc2NvcGUpIHtcbiAgcmV0dXJuIGZyb21TdHJpbmcoc2NvcGUuY29udGV4dC5pZGVudGl0eSk7XG59O1xuX2dsb2JhbC5pZGVudGl0eS5hcml0eSA9IDA7XG5fZ2xvYmFsLmxlbmd0aCA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IGlubmVyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmIChpbm5lci50eXBlID09PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBmcm9tTnVtYmVyKGNvdW50VVRGOChpbm5lci5kYXRhKSk7XG4gIGlmIChpbm5lci5pc0FycmF5KCkpIHtcbiAgICBsZXQgbnVtID0gMDtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IF8gb2YgaW5uZXIpXG4gICAgICBudW0rKztcbiAgICByZXR1cm4gZnJvbU51bWJlcihudW0pO1xuICB9XG4gIHJldHVybiBOVUxMX1ZBTFVFO1xufTtcbl9nbG9iYWwubGVuZ3RoLmFyaXR5ID0gMTtcbl9nbG9iYWwucGF0aCA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IGlubmVyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIHJldHVybiBpbm5lci50eXBlICE9PSBcInN0cmluZ1wiID8gTlVMTF9WQUxVRSA6IGZyb21QYXRoKG5ldyBQYXRoKGlubmVyLmRhdGEpKTtcbn07XG5fZ2xvYmFsLnBhdGguYXJpdHkgPSAxO1xuX2dsb2JhbC5zdHJpbmcgPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBzd2l0Y2ggKHZhbHVlLnR5cGUpIHtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgY2FzZSBcImRhdGV0aW1lXCI6XG4gICAgICByZXR1cm4gZnJvbVN0cmluZyhgJHt2YWx1ZS5kYXRhfWApO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxufTtcbl9nbG9iYWwuc3RyaW5nLmFyaXR5ID0gMTtcbl9nbG9iYWwucmVmZXJlbmNlcyA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHBhdGhTZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IGFyZyBvZiBhcmdzKSB7XG4gICAgY29uc3QgcGF0aDIgPSBhd2FpdCBleGVjdXRlKGFyZywgc2NvcGUpO1xuICAgIGlmIChwYXRoMi50eXBlID09PSBcInN0cmluZ1wiKVxuICAgICAgcGF0aFNldC5hZGQocGF0aDIuZGF0YSk7XG4gICAgZWxzZSBpZiAocGF0aDIuaXNBcnJheSgpKVxuICAgICAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIHBhdGgyKVxuICAgICAgICBlbGVtLnR5cGUgPT09IFwic3RyaW5nXCIgJiYgcGF0aFNldC5hZGQoZWxlbS5kYXRhKTtcbiAgfVxuICBpZiAocGF0aFNldC5zaXplID09PSAwKVxuICAgIHJldHVybiBGQUxTRV9WQUxVRTtcbiAgY29uc3Qgc2NvcGVWYWx1ZSA9IGF3YWl0IHNjb3BlLnZhbHVlLmdldCgpO1xuICByZXR1cm4gaGFzUmVmZXJlbmNlKHNjb3BlVmFsdWUsIHBhdGhTZXQpID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xufTtcbl9nbG9iYWwucmVmZXJlbmNlcy5hcml0eSA9IChjKSA9PiBjID49IDE7XG5fZ2xvYmFsLnJvdW5kID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKHZhbHVlLnR5cGUgIT09IFwibnVtYmVyXCIpXG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIGNvbnN0IG51bSA9IHZhbHVlLmRhdGE7XG4gIGxldCBwcmVjID0gMDtcbiAgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgY29uc3QgcHJlY1ZhbHVlID0gYXdhaXQgZXhlY3V0ZShhcmdzWzFdLCBzY29wZSk7XG4gICAgaWYgKHByZWNWYWx1ZS50eXBlICE9PSBcIm51bWJlclwiIHx8IHByZWNWYWx1ZS5kYXRhIDwgMCB8fCAhTnVtYmVyLmlzSW50ZWdlcihwcmVjVmFsdWUuZGF0YSkpXG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICBwcmVjID0gcHJlY1ZhbHVlLmRhdGE7XG4gIH1cbiAgcmV0dXJuIHByZWMgPT09IDAgPyBudW0gPCAwID8gZnJvbU51bWJlcigtTWF0aC5yb3VuZCgtbnVtKSkgOiBmcm9tTnVtYmVyKE1hdGgucm91bmQobnVtKSkgOiBmcm9tTnVtYmVyKE51bWJlcihudW0udG9GaXhlZChwcmVjKSkpO1xufTtcbl9nbG9iYWwucm91bmQuYXJpdHkgPSAoY291bnQyKSA9PiBjb3VudDIgPj0gMSAmJiBjb3VudDIgPD0gMjtcbl9nbG9iYWwubm93ID0gYXN5bmMgZnVuY3Rpb24oX2FyZ3MsIHNjb3BlKSB7XG4gIHJldHVybiBmcm9tU3RyaW5nKHNjb3BlLmNvbnRleHQudGltZXN0YW1wLnRvSVNPU3RyaW5nKCkpO1xufTtcbl9nbG9iYWwubm93LmFyaXR5ID0gMDtcbl9nbG9iYWwuYm9vc3QgPSBhc3luYyBmdW5jdGlvbigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwidW5leHBlY3RlZCBib29zdCBjYWxsXCIpO1xufTtcbl9nbG9iYWwuYm9vc3QuYXJpdHkgPSAyO1xuY29uc3Qgc3RyaW5nMiA9IHt9O1xuc3RyaW5nMi5sb3dlciA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIHJldHVybiB2YWx1ZS50eXBlICE9PSBcInN0cmluZ1wiID8gTlVMTF9WQUxVRSA6IGZyb21TdHJpbmcodmFsdWUuZGF0YS50b0xvd2VyQ2FzZSgpKTtcbn07XG5zdHJpbmcyLmxvd2VyLmFyaXR5ID0gMTtcbnN0cmluZzIudXBwZXIgPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICByZXR1cm4gdmFsdWUudHlwZSAhPT0gXCJzdHJpbmdcIiA/IE5VTExfVkFMVUUgOiBmcm9tU3RyaW5nKHZhbHVlLmRhdGEudG9VcHBlckNhc2UoKSk7XG59O1xuc3RyaW5nMi51cHBlci5hcml0eSA9IDE7XG5zdHJpbmcyLnNwbGl0ID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3Qgc3RyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmIChzdHIudHlwZSAhPT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgY29uc3Qgc2VwID0gYXdhaXQgZXhlY3V0ZShhcmdzWzFdLCBzY29wZSk7XG4gIHJldHVybiBzZXAudHlwZSAhPT0gXCJzdHJpbmdcIiA/IE5VTExfVkFMVUUgOiBzdHIuZGF0YS5sZW5ndGggPT09IDAgPyBmcm9tSlMoW10pIDogc2VwLmRhdGEubGVuZ3RoID09PSAwID8gZnJvbUpTKEFycmF5LmZyb20oc3RyLmRhdGEpKSA6IGZyb21KUyhzdHIuZGF0YS5zcGxpdChzZXAuZGF0YSkpO1xufTtcbnN0cmluZzIuc3BsaXQuYXJpdHkgPSAyO1xuX2dsb2JhbC5sb3dlciA9IHN0cmluZzIubG93ZXI7XG5fZ2xvYmFsLnVwcGVyID0gc3RyaW5nMi51cHBlcjtcbnN0cmluZzIuc3RhcnRzV2l0aCA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHN0ciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoc3RyLnR5cGUgIT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIGNvbnN0IHByZWZpeCA9IGF3YWl0IGV4ZWN1dGUoYXJnc1sxXSwgc2NvcGUpO1xuICByZXR1cm4gcHJlZml4LnR5cGUgIT09IFwic3RyaW5nXCIgPyBOVUxMX1ZBTFVFIDogc3RyLmRhdGEuc3RhcnRzV2l0aChwcmVmaXguZGF0YSkgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG59O1xuc3RyaW5nMi5zdGFydHNXaXRoLmFyaXR5ID0gMjtcbmNvbnN0IGFycmF5ID0ge307XG5hcnJheS5qb2luID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgYXJyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICghYXJyLmlzQXJyYXkoKSlcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgY29uc3Qgc2VwID0gYXdhaXQgZXhlY3V0ZShhcmdzWzFdLCBzY29wZSk7XG4gIGlmIChzZXAudHlwZSAhPT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgbGV0IGJ1ZiA9IFwiXCIsIG5lZWRTZXAgPSAhMTtcbiAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIGFycikge1xuICAgIHN3aXRjaCAobmVlZFNlcCAmJiAoYnVmICs9IHNlcC5kYXRhKSwgZWxlbS50eXBlKSB7XG4gICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgY2FzZSBcImRhdGV0aW1lXCI6XG4gICAgICAgIGJ1ZiArPSBgJHtlbGVtLmRhdGF9YDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgbmVlZFNlcCA9ICEwO1xuICB9XG4gIHJldHVybiBmcm9tSlMoYnVmKTtcbn07XG5hcnJheS5qb2luLmFyaXR5ID0gMjtcbmFycmF5LmNvbXBhY3QgPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBhcnIgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgcmV0dXJuIGFyci5pc0FycmF5KCkgPyBuZXcgU3RyZWFtVmFsdWUoYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGVsZW0gb2YgYXJyKVxuICAgICAgZWxlbS50eXBlICE9PSBcIm51bGxcIiAmJiAoeWllbGQgZWxlbSk7XG4gIH0pIDogTlVMTF9WQUxVRTtcbn07XG5hcnJheS5jb21wYWN0LmFyaXR5ID0gMTtcbmFycmF5LnVuaXF1ZSA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIHJldHVybiB2YWx1ZS5pc0FycmF5KCkgPyBuZXcgU3RyZWFtVmFsdWUoYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICBjb25zdCBhZGRlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgZm9yIGF3YWl0IChjb25zdCBpdGVyIG9mIHZhbHVlKVxuICAgICAgc3dpdGNoIChpdGVyLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIGNhc2UgXCJkYXRldGltZVwiOlxuICAgICAgICAgIGFkZGVkLmhhcyhpdGVyLmRhdGEpIHx8IChhZGRlZC5hZGQoaXRlci5kYXRhKSwgeWllbGQgaXRlcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgeWllbGQgaXRlcjtcbiAgICAgIH1cbiAgfSkgOiBOVUxMX1ZBTFVFO1xufTtcbmFycmF5LnVuaXF1ZS5hcml0eSA9IDE7XG5hcnJheS5pbnRlcnNlY3RzID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgYXJyMSA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoIWFycjEuaXNBcnJheSgpKVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICBjb25zdCBhcnIyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzFdLCBzY29wZSk7XG4gIGlmICghYXJyMi5pc0FycmF5KCkpXG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIGZvciBhd2FpdCAoY29uc3QgdjEgb2YgYXJyMSlcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHYyIG9mIGFycjIpXG4gICAgICBpZiAoaXNFcXVhbCh2MSwgdjIpKVxuICAgICAgICByZXR1cm4gVFJVRV9WQUxVRTtcbiAgcmV0dXJuIEZBTFNFX1ZBTFVFO1xufTtcbmFycmF5LmludGVyc2VjdHMuYXJpdHkgPSAyO1xuY29uc3QgcHQgPSB7fTtcbnB0LnRleHQgPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpLCB0ZXh0MiA9IGF3YWl0IHBvcnRhYmxlVGV4dENvbnRlbnQodmFsdWUpO1xuICByZXR1cm4gdGV4dDIgPT09IG51bGwgPyBOVUxMX1ZBTFVFIDogZnJvbVN0cmluZyh0ZXh0Mik7XG59O1xucHQudGV4dC5hcml0eSA9IDE7XG5jb25zdCBzYW5pdHkgPSB7fTtcbnNhbml0eS5wcm9qZWN0SWQgPSBhc3luYyBmdW5jdGlvbihfYXJncywgc2NvcGUpIHtcbiAgcmV0dXJuIHNjb3BlLmNvbnRleHQuc2FuaXR5ID8gZnJvbVN0cmluZyhzY29wZS5jb250ZXh0LnNhbml0eS5wcm9qZWN0SWQpIDogTlVMTF9WQUxVRTtcbn07XG5zYW5pdHkuZGF0YXNldCA9IGFzeW5jIGZ1bmN0aW9uKF9hcmdzLCBzY29wZSkge1xuICByZXR1cm4gc2NvcGUuY29udGV4dC5zYW5pdHkgPyBmcm9tU3RyaW5nKHNjb3BlLmNvbnRleHQuc2FuaXR5LmRhdGFzZXQpIDogTlVMTF9WQUxVRTtcbn07XG5zYW5pdHkudmVyc2lvbk9mID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKHZhbHVlLnR5cGUgIT09IFwic3RyaW5nXCIpIHJldHVybiBOVUxMX1ZBTFVFO1xuICBjb25zdCBiYXNlSWQgPSB2YWx1ZS5kYXRhLCB2YWwgPSBhd2FpdCBzY29wZS52YWx1ZS5nZXQoKTtcbiAgaWYgKCF2YWwgfHwgdHlwZW9mIHZhbC5faWQgIT0gXCJzdHJpbmdcIikgcmV0dXJuIE5VTExfVkFMVUU7XG4gIGNvbnN0IGNvbXBvbmVudHMgPSB2YWwuX2lkLnNwbGl0KFwiLlwiKTtcbiAgcmV0dXJuIHZhbC5faWQgPT09IGJhc2VJZCB8fCBjb21wb25lbnRzLmxlbmd0aCA+PSAyICYmIGNvbXBvbmVudHNbMF0gPT09IFwiZHJhZnRzXCIgJiYgY29tcG9uZW50cy5zbGljZSgxKS5qb2luKFwiLlwiKSA9PT0gYmFzZUlkIHx8IGNvbXBvbmVudHMubGVuZ3RoID49IDMgJiYgY29tcG9uZW50c1swXSA9PT0gXCJ2ZXJzaW9uc1wiICYmIGNvbXBvbmVudHMuc2xpY2UoMikuam9pbihcIi5cIikgPT09IGJhc2VJZCA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbn07XG5zYW5pdHkudmVyc2lvbk9mLmFyaXR5ID0gMTtcbnNhbml0eS5wYXJ0T2ZSZWxlYXNlID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKHZhbHVlLnR5cGUgIT09IFwic3RyaW5nXCIpIHJldHVybiBOVUxMX1ZBTFVFO1xuICBjb25zdCBiYXNlSWQgPSB2YWx1ZS5kYXRhLCB2YWwgPSBhd2FpdCBzY29wZS52YWx1ZS5nZXQoKTtcbiAgaWYgKCF2YWwgfHwgdHlwZW9mIHZhbC5faWQgIT0gXCJzdHJpbmdcIikgcmV0dXJuIE5VTExfVkFMVUU7XG4gIGNvbnN0IGNvbXBvbmVudHMgPSB2YWwuX2lkLnNwbGl0KFwiLlwiKTtcbiAgcmV0dXJuIGZyb21KUyhjb21wb25lbnRzLmxlbmd0aCA+PSAzICYmIGNvbXBvbmVudHNbMF0gPT09IFwidmVyc2lvbnNcIiAmJiBjb21wb25lbnRzWzFdID09PSBiYXNlSWQpO1xufTtcbnNhbml0eS5wYXJ0T2ZSZWxlYXNlLmFyaXR5ID0gMTtcbmNvbnN0IHJlbGVhc2VzID0ge307XG5yZWxlYXNlcy5hbGwgPSBhc3luYyBmdW5jdGlvbihfYXJncywgc2NvcGUpIHtcbiAgY29uc3QgYWxsUmVsZWFzZXMgPSBbXTtcbiAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiBzY29wZS5zb3VyY2UpXG4gICAgaWYgKGdldFR5cGUodmFsdWUpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb25zdCB2YWwgPSBhd2FpdCB2YWx1ZS5nZXQoKTtcbiAgICAgIHZhbCAmJiBcIl90eXBlXCIgaW4gdmFsICYmIHZhbC5fdHlwZSA9PT0gXCJzeXN0ZW0ucmVsZWFzZVwiICYmIGFsbFJlbGVhc2VzLnB1c2godmFsKTtcbiAgICB9XG4gIHJldHVybiBmcm9tSlMoYWxsUmVsZWFzZXMpO1xufTtcbnJlbGVhc2VzLmFsbC5hcml0eSA9IDA7XG5jb25zdCBwaXBlRnVuY3Rpb25zID0ge307XG5waXBlRnVuY3Rpb25zLm9yZGVyID0gYXN5bmMgZnVuY3Rpb24oYmFzZSwgYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgaWYgKGF3YWl0ICEwLCAhYmFzZS5pc0FycmF5KCkpXG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIGNvbnN0IG1hcHBlcnMgPSBbXSwgZGlyZWN0aW9ucyA9IFtdO1xuICBsZXQgbiA9IDA7XG4gIGZvciAobGV0IG1hcHBlciBvZiBhcmdzKSB7XG4gICAgbGV0IGRpcmVjdGlvbiA9IFwiYXNjXCI7XG4gICAgbWFwcGVyLnR5cGUgPT09IFwiRGVzY1wiID8gKGRpcmVjdGlvbiA9IFwiZGVzY1wiLCBtYXBwZXIgPSBtYXBwZXIuYmFzZSkgOiBtYXBwZXIudHlwZSA9PT0gXCJBc2NcIiAmJiAobWFwcGVyID0gbWFwcGVyLmJhc2UpLCBtYXBwZXJzLnB1c2gobWFwcGVyKSwgZGlyZWN0aW9ucy5wdXNoKGRpcmVjdGlvbiksIG4rKztcbiAgfVxuICBjb25zdCBhdXggPSBbXTtcbiAgbGV0IGlkeCA9IDA7XG4gIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgYmFzZSkge1xuICAgIGNvbnN0IG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlTmVzdGVkKHZhbHVlKSwgdHVwbGUgPSBbYXdhaXQgdmFsdWUuZ2V0KCksIGlkeF07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV4ZWN1dGUobWFwcGVyc1tpXSwgbmV3U2NvcGUpO1xuICAgICAgdHVwbGUucHVzaChhd2FpdCByZXN1bHQuZ2V0KCkpO1xuICAgIH1cbiAgICBhdXgucHVzaCh0dXBsZSksIGlkeCsrO1xuICB9XG4gIHJldHVybiBhdXguc29ydCgoYVR1cGxlLCBiVHVwbGUpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgbGV0IGMgPSB0b3RhbENvbXBhcmUoYVR1cGxlW2kgKyAyXSwgYlR1cGxlW2kgKyAyXSk7XG4gICAgICBpZiAoZGlyZWN0aW9uc1tpXSA9PT0gXCJkZXNjXCIgJiYgKGMgPSAtYyksIGMgIT09IDApXG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgICByZXR1cm4gYVR1cGxlWzFdIC0gYlR1cGxlWzFdO1xuICB9KSwgZnJvbUpTKGF1eC5tYXAoKHYpID0+IHZbMF0pKTtcbn07XG5waXBlRnVuY3Rpb25zLm9yZGVyLmFyaXR5ID0gKGNvdW50MikgPT4gY291bnQyID49IDE7XG5waXBlRnVuY3Rpb25zLnNjb3JlID0gYXN5bmMgZnVuY3Rpb24oYmFzZSwgYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgaWYgKCFiYXNlLmlzQXJyYXkoKSkgcmV0dXJuIE5VTExfVkFMVUU7XG4gIGNvbnN0IHVua25vd24gPSBbXSwgc2NvcmVkID0gW107XG4gIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgYmFzZSkge1xuICAgIGlmICh2YWx1ZS50eXBlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICB1bmtub3duLnB1c2goYXdhaXQgdmFsdWUuZ2V0KCkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlTmVzdGVkKHZhbHVlKTtcbiAgICBsZXQgdmFsdWVTY29yZSA9IHR5cGVvZiB2YWx1ZS5kYXRhLl9zY29yZSA9PSBcIm51bWJlclwiID8gdmFsdWUuZGF0YS5fc2NvcmUgOiAwO1xuICAgIGZvciAoY29uc3QgYXJnIG9mIGFyZ3MpXG4gICAgICB2YWx1ZVNjb3JlICs9IGF3YWl0IGV2YWx1YXRlU2NvcmUoYXJnLCBuZXdTY29wZSwgZXhlY3V0ZSk7XG4gICAgY29uc3QgbmV3T2JqZWN0ID0gT2JqZWN0LmFzc2lnbih7fSwgdmFsdWUuZGF0YSwgeyBfc2NvcmU6IHZhbHVlU2NvcmUgfSk7XG4gICAgc2NvcmVkLnB1c2gobmV3T2JqZWN0KTtcbiAgfVxuICByZXR1cm4gc2NvcmVkLnNvcnQoKGEsIGIpID0+IGIuX3Njb3JlIC0gYS5fc2NvcmUpLCBmcm9tSlMoc2NvcmVkKTtcbn07XG5waXBlRnVuY3Rpb25zLnNjb3JlLmFyaXR5ID0gKGNvdW50MikgPT4gY291bnQyID49IDE7XG5jb25zdCBkZWx0YSA9IHt9O1xuZGVsdGEub3BlcmF0aW9uID0gYXN5bmMgZnVuY3Rpb24oX2FyZ3MsIHNjb3BlKSB7XG4gIGNvbnN0IGhhc0JlZm9yZSA9IHNjb3BlLmNvbnRleHQuYmVmb3JlICE9PSBudWxsLCBoYXNBZnRlciA9IHNjb3BlLmNvbnRleHQuYWZ0ZXIgIT09IG51bGw7XG4gIHJldHVybiBoYXNCZWZvcmUgJiYgaGFzQWZ0ZXIgPyBmcm9tU3RyaW5nKFwidXBkYXRlXCIpIDogaGFzQWZ0ZXIgPyBmcm9tU3RyaW5nKFwiY3JlYXRlXCIpIDogaGFzQmVmb3JlID8gZnJvbVN0cmluZyhcImRlbGV0ZVwiKSA6IE5VTExfVkFMVUU7XG59O1xuZGVsdGEuY2hhbmdlZEFueSA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xufTtcbmRlbHRhLmNoYW5nZWRBbnkuYXJpdHkgPSAxO1xuZGVsdGEuY2hhbmdlZEFueS5tb2RlID0gXCJkZWx0YVwiO1xuZGVsdGEuY2hhbmdlZE9ubHkgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbn07XG5kZWx0YS5jaGFuZ2VkT25seS5hcml0eSA9IDE7XG5kZWx0YS5jaGFuZ2VkT25seS5tb2RlID0gXCJkZWx0YVwiO1xuY29uc3QgZGlmZiA9IHt9O1xuZGlmZi5jaGFuZ2VkQW55ID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG59O1xuZGlmZi5jaGFuZ2VkQW55LmFyaXR5ID0gMztcbmRpZmYuY2hhbmdlZE9ubHkgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbn07XG5kaWZmLmNoYW5nZWRPbmx5LmFyaXR5ID0gMztcbmNvbnN0IG1hdGggPSB7fTtcbm1hdGgubWluID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgYXJyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICghYXJyLmlzQXJyYXkoKSlcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgbGV0IG47XG4gIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiBhcnIpXG4gICAgaWYgKGVsZW0udHlwZSAhPT0gXCJudWxsXCIpIHtcbiAgICAgIGlmIChlbGVtLnR5cGUgIT09IFwibnVtYmVyXCIpXG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgKG4gPT09IHZvaWQgMCB8fCBlbGVtLmRhdGEgPCBuKSAmJiAobiA9IGVsZW0uZGF0YSk7XG4gICAgfVxuICByZXR1cm4gZnJvbUpTKG4pO1xufTtcbm1hdGgubWluLmFyaXR5ID0gMTtcbm1hdGgubWF4ID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgYXJyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICghYXJyLmlzQXJyYXkoKSlcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgbGV0IG47XG4gIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiBhcnIpXG4gICAgaWYgKGVsZW0udHlwZSAhPT0gXCJudWxsXCIpIHtcbiAgICAgIGlmIChlbGVtLnR5cGUgIT09IFwibnVtYmVyXCIpXG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgKG4gPT09IHZvaWQgMCB8fCBlbGVtLmRhdGEgPiBuKSAmJiAobiA9IGVsZW0uZGF0YSk7XG4gICAgfVxuICByZXR1cm4gZnJvbUpTKG4pO1xufTtcbm1hdGgubWF4LmFyaXR5ID0gMTtcbm1hdGguc3VtID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgYXJyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICghYXJyLmlzQXJyYXkoKSlcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgbGV0IG4gPSAwO1xuICBmb3IgYXdhaXQgKGNvbnN0IGVsZW0gb2YgYXJyKVxuICAgIGlmIChlbGVtLnR5cGUgIT09IFwibnVsbFwiKSB7XG4gICAgICBpZiAoZWxlbS50eXBlICE9PSBcIm51bWJlclwiKVxuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgIG4gKz0gZWxlbS5kYXRhO1xuICAgIH1cbiAgcmV0dXJuIGZyb21KUyhuKTtcbn07XG5tYXRoLnN1bS5hcml0eSA9IDE7XG5tYXRoLmF2ZyA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IGFyciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoIWFyci5pc0FycmF5KCkpXG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIGxldCBuID0gMCwgYyA9IDA7XG4gIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiBhcnIpXG4gICAgaWYgKGVsZW0udHlwZSAhPT0gXCJudWxsXCIpIHtcbiAgICAgIGlmIChlbGVtLnR5cGUgIT09IFwibnVtYmVyXCIpXG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgbiArPSBlbGVtLmRhdGEsIGMrKztcbiAgICB9XG4gIHJldHVybiBjID09PSAwID8gTlVMTF9WQUxVRSA6IGZyb21KUyhuIC8gYyk7XG59O1xubWF0aC5hdmcuYXJpdHkgPSAxO1xuY29uc3QgZGF0ZVRpbWUyID0ge307XG5kYXRlVGltZTIubm93ID0gYXN5bmMgZnVuY3Rpb24oX2FyZ3MsIHNjb3BlKSB7XG4gIHJldHVybiBmcm9tRGF0ZVRpbWUobmV3IERhdGVUaW1lKHNjb3BlLmNvbnRleHQudGltZXN0YW1wKSk7XG59O1xuZGF0ZVRpbWUyLm5vdy5hcml0eSA9IDA7XG5jb25zdCB0ZXh0ID0ge307XG50ZXh0LnF1ZXJ5ID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG59O1xudGV4dC5xdWVyeS5hcml0eSA9IDE7XG5jb25zdCBuYW1lc3BhY2VzID0ge1xuICBnbG9iYWw6IF9nbG9iYWwsXG4gIHN0cmluZzogc3RyaW5nMixcbiAgYXJyYXksXG4gIHB0LFxuICBkZWx0YSxcbiAgZGlmZixcbiAgc2FuaXR5LFxuICBtYXRoLFxuICBkYXRlVGltZTogZGF0ZVRpbWUyLFxuICByZWxlYXNlcyxcbiAgdGV4dFxufTtcbmNsYXNzIE1hcmtQcm9jZXNzb3Ige1xuICBzdHJpbmc7XG4gIG1hcmtzO1xuICBpbmRleDtcbiAgcGFyc2VPcHRpb25zO1xuICBhbGxvd0Jvb3N0ID0gITE7XG4gIGNvbnN0cnVjdG9yKHN0cmluZywgbWFya3MsIHBhcnNlT3B0aW9ucykge1xuICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nLCB0aGlzLm1hcmtzID0gbWFya3MsIHRoaXMuaW5kZXggPSAwLCB0aGlzLnBhcnNlT3B0aW9ucyA9IHBhcnNlT3B0aW9ucztcbiAgfVxuICBoYXNNYXJrKHBvcyA9IDApIHtcbiAgICByZXR1cm4gdGhpcy5pbmRleCArIHBvcyA8IHRoaXMubWFya3MubGVuZ3RoO1xuICB9XG4gIGdldE1hcmsocG9zID0gMCkge1xuICAgIHJldHVybiB0aGlzLm1hcmtzW3RoaXMuaW5kZXggKyBwb3NdO1xuICB9XG4gIHNoaWZ0KCkge1xuICAgIHRoaXMuaW5kZXggKz0gMTtcbiAgfVxuICBwcm9jZXNzKHZpc2l0b3IpIHtcbiAgICBjb25zdCBtYXJrID0gdGhpcy5tYXJrc1t0aGlzLmluZGV4XTtcbiAgICB0aGlzLnNoaWZ0KCk7XG4gICAgY29uc3QgZnVuYyA9IHZpc2l0b3JbbWFyay5uYW1lXTtcbiAgICBpZiAoIWZ1bmMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gaGFuZGxlcjogJHttYXJrLm5hbWV9YCk7XG4gICAgcmV0dXJuIGZ1bmMuY2FsbCh2aXNpdG9yLCB0aGlzLCBtYXJrKTtcbiAgfVxuICBwcm9jZXNzU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnNoaWZ0KCksIHRoaXMucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICB9XG4gIHByb2Nlc3NTdHJpbmdFbmQoKSB7XG4gICAgY29uc3QgcHJldiA9IHRoaXMubWFya3NbdGhpcy5pbmRleCAtIDFdLCBjdXJyID0gdGhpcy5tYXJrc1t0aGlzLmluZGV4XTtcbiAgICByZXR1cm4gdGhpcy5zaGlmdCgpLCB0aGlzLnN0cmluZy5zbGljZShwcmV2LnBvc2l0aW9uLCBjdXJyLnBvc2l0aW9uKTtcbiAgfVxuICBzbGljZShsZW4pIHtcbiAgICBjb25zdCBwb3MgPSB0aGlzLm1hcmtzW3RoaXMuaW5kZXhdLnBvc2l0aW9uO1xuICAgIHJldHVybiB0aGlzLnN0cmluZy5zbGljZShwb3MsIHBvcyArIGxlbik7XG4gIH1cbn1cbmNvbnN0IFdTID0gL14oW1xcdFxcblxcdlxcZlxcciBcXHUwMDg1XFx1MDBBMF18KFxcL1xcL1teXFxuXSpcXG4pKSsvLCBOVU0gPSAvXlxcZCsvLCBJREVOVCA9IC9eW2EtekEtWl9dW2EtekEtWl8wLTldKi87XG5mdW5jdGlvbiBwYXJzZSQxKHN0cikge1xuICBsZXQgcG9zID0gMDtcbiAgcG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgbGV0IHJlc3VsdCA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gIHJldHVybiByZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiID8gcmVzdWx0IDogKHBvcyA9IHNraXBXUyhzdHIsIHJlc3VsdC5wb3NpdGlvbiksIHBvcyAhPT0gc3RyLmxlbmd0aCA/IChyZXN1bHQuZmFpbFBvc2l0aW9uICYmIChwb3MgPSByZXN1bHQuZmFpbFBvc2l0aW9uIC0gMSksIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH0pIDogKGRlbGV0ZSByZXN1bHQucG9zaXRpb24sIGRlbGV0ZSByZXN1bHQuZmFpbFBvc2l0aW9uLCByZXN1bHQpKTtcbn1cbmZ1bmN0aW9uIHBhcnNlRXhwcihzdHIsIHBvcywgbGV2ZWwpIHtcbiAgbGV0IHN0YXJ0UG9zID0gcG9zLCB0b2tlbiA9IHN0cltwb3NdLCBtYXJrcztcbiAgc3dpdGNoICh0b2tlbikge1xuICAgIGNhc2UgXCIrXCI6IHtcbiAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBwb3MgKyAxKSwgMTApO1xuICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICBtYXJrcyA9IFt7IG5hbWU6IFwicG9zXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XS5jb25jYXQocmhzLm1hcmtzKSwgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCItXCI6IHtcbiAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBwb3MgKyAxKSwgOCk7XG4gICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgIG1hcmtzID0gW3sgbmFtZTogXCJuZWdcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dLmNvbmNhdChyaHMubWFya3MpLCBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIihcIjoge1xuICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIHBvcyArIDEpLCAwKTtcbiAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgc3dpdGNoIChwb3MgPSBza2lwV1Moc3RyLCByaHMucG9zaXRpb24pLCBzdHJbcG9zXSkge1xuICAgICAgICBjYXNlIFwiLFwiOiB7XG4gICAgICAgICAgZm9yIChtYXJrcyA9IFt7IG5hbWU6IFwidHVwbGVcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dLmNvbmNhdChyaHMubWFya3MpLCBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTsgOyApIHtcbiAgICAgICAgICAgIGlmIChyaHMgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApLCByaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICAgICAgaWYgKHBvcyA9IHNraXBXUyhzdHIsIHJocy5wb3NpdGlvbiksIHN0cltwb3NdICE9PSBcIixcIikgYnJlYWs7XG4gICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0cltwb3NdICE9PSBcIilcIikgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgICAgICAgcG9zKyssIG1hcmtzLnB1c2goeyBuYW1lOiBcInR1cGxlX2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCIpXCI6IHtcbiAgICAgICAgICBwb3MrKywgbWFya3MgPSBbeyBuYW1lOiBcImdyb3VwXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XS5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCIhXCI6IHtcbiAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBwb3MgKyAxKSwgMTApO1xuICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICBtYXJrcyA9IFt7IG5hbWU6IFwibm90XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XS5jb25jYXQocmhzLm1hcmtzKSwgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJ7XCI6IHtcbiAgICAgIGxldCByZXN1bHQgPSBwYXJzZU9iamVjdChzdHIsIHBvcyk7XG4gICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJlc3VsdDtcbiAgICAgIG1hcmtzID0gcmVzdWx0Lm1hcmtzLCBwb3MgPSByZXN1bHQucG9zaXRpb247XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIltcIjpcbiAgICAgIGlmIChtYXJrcyA9IFt7IG5hbWU6IFwiYXJyYXlcIiwgcG9zaXRpb246IHBvcyB9XSwgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSksIHN0cltwb3NdICE9PSBcIl1cIilcbiAgICAgICAgZm9yICg7IDsgKSB7XG4gICAgICAgICAgc3RyLnNsaWNlKHBvcywgcG9zICsgMykgPT09IFwiLi4uXCIgJiYgKG1hcmtzLnB1c2goeyBuYW1lOiBcImFycmF5X3NwbGF0XCIsIHBvc2l0aW9uOiBwb3MgfSksIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDMpKTtcbiAgICAgICAgICBsZXQgcmVzID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgICAgICBpZiAocmVzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJlcztcbiAgICAgICAgICBpZiAobWFya3MgPSBtYXJrcy5jb25jYXQocmVzLm1hcmtzKSwgcG9zID0gcmVzLnBvc2l0aW9uLCBwb3MgPSBza2lwV1Moc3RyLCBwb3MpLCBzdHJbcG9zXSAhPT0gXCIsXCIgfHwgKHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpLCBzdHJbcG9zXSA9PT0gXCJdXCIpKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgaWYgKHN0cltwb3NdID09PSBcIl1cIilcbiAgICAgICAgcG9zKyssIG1hcmtzLnB1c2goeyBuYW1lOiBcImFycmF5X2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCInXCI6XG4gICAgY2FzZSAnXCInOiB7XG4gICAgICBsZXQgcmVzdWx0ID0gcGFyc2VTdHJpbmcoc3RyLCBwb3MpO1xuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByZXN1bHQ7XG4gICAgICBtYXJrcyA9IHJlc3VsdC5tYXJrcywgcG9zID0gcmVzdWx0LnBvc2l0aW9uO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJeXCI6IHtcbiAgICAgIGZvciAocG9zKyssIG1hcmtzID0gW107IHN0cltwb3NdID09PSBcIi5cIiAmJiBzdHJbcG9zICsgMV0gPT09IFwiXlwiOyApXG4gICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcImRibHBhcmVudFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHBvcyArPSAyO1xuICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwicGFyZW50XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiQFwiOlxuICAgICAgbWFya3MgPSBbeyBuYW1lOiBcInRoaXNcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dLCBwb3MrKztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCIqXCI6XG4gICAgICBtYXJrcyA9IFt7IG5hbWU6IFwiZXZlcnl0aGluZ1wiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV0sIHBvcysrO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIiRcIjoge1xuICAgICAgbGV0IGlkZW50TGVuID0gcGFyc2VSZWdleChzdHIsIHBvcyArIDEsIElERU5UKTtcbiAgICAgIGlkZW50TGVuICYmIChwb3MgKz0gMSArIGlkZW50TGVuLCBtYXJrcyA9IFtcbiAgICAgICAgeyBuYW1lOiBcInBhcmFtXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9LFxuICAgICAgICB7IG5hbWU6IFwiaWRlbnRcIiwgcG9zaXRpb246IHN0YXJ0UG9zICsgMSB9LFxuICAgICAgICB7IG5hbWU6IFwiaWRlbnRfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfVxuICAgICAgXSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgbGV0IG51bUxlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MsIE5VTSk7XG4gICAgICBpZiAobnVtTGVuKSB7XG4gICAgICAgIHBvcyArPSBudW1MZW47XG4gICAgICAgIGxldCBuYW1lID0gXCJpbnRlZ2VyXCI7XG4gICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCIuXCIpIHtcbiAgICAgICAgICBsZXQgZnJhY0xlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MgKyAxLCBOVU0pO1xuICAgICAgICAgIGZyYWNMZW4gJiYgKG5hbWUgPSBcImZsb2F0XCIsIHBvcyArPSAxICsgZnJhY0xlbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cltwb3NdID09PSBcImVcIiB8fCBzdHJbcG9zXSA9PT0gXCJFXCIpIHtcbiAgICAgICAgICBuYW1lID0gXCJzY2lcIiwgcG9zKyssIChzdHJbcG9zXSA9PT0gXCIrXCIgfHwgc3RyW3Bvc10gPT09IFwiLVwiKSAmJiBwb3MrKztcbiAgICAgICAgICBsZXQgZXhwTGVuID0gcGFyc2VSZWdleChzdHIsIHBvcywgTlVNKTtcbiAgICAgICAgICBpZiAoIWV4cExlbikgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgICAgICAgcG9zICs9IGV4cExlbjtcbiAgICAgICAgfVxuICAgICAgICBtYXJrcyA9IFtcbiAgICAgICAgICB7IG5hbWUsIHBvc2l0aW9uOiBzdGFydFBvcyB9LFxuICAgICAgICAgIHsgbmFtZTogbmFtZSArIFwiX2VuZFwiLCBwb3NpdGlvbjogcG9zIH1cbiAgICAgICAgXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBsZXQgaWRlbnRMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgcG9zLCBJREVOVCk7XG4gICAgICBpZiAoaWRlbnRMZW4pIHtcbiAgICAgICAgc3dpdGNoIChwb3MgKz0gaWRlbnRMZW4sIHN0cltwb3NdKSB7XG4gICAgICAgICAgY2FzZSBcIjpcIjpcbiAgICAgICAgICBjYXNlIFwiKFwiOiB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gcGFyc2VGdW5jQ2FsbChzdHIsIHN0YXJ0UG9zLCBwb3MpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICBtYXJrcyA9IHJlc3VsdC5tYXJrcywgcG9zID0gcmVzdWx0LnBvc2l0aW9uO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBtYXJrcyA9IFtcbiAgICAgICAgICAgICAgeyBuYW1lOiBcInRoaXNfYXR0clwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSxcbiAgICAgICAgICAgICAgeyBuYW1lOiBcImlkZW50XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9LFxuICAgICAgICAgICAgICB7IG5hbWU6IFwiaWRlbnRfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFtYXJrcylcbiAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgbGV0IGxoc0xldmVsID0gMTIsIHRyYXY7XG4gIGxvb3A6IGZvciAoOyA7ICkge1xuICAgIGxldCBpbm5lclBvcyA9IHNraXBXUyhzdHIsIHBvcyk7XG4gICAgaWYgKGlubmVyUG9zID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICBwb3MgPSBpbm5lclBvcztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAodHJhdiA9IHBhcnNlVHJhdmVyc2FsKHN0ciwgaW5uZXJQb3MpLCB0cmF2LnR5cGUgPT09IFwic3VjY2Vzc1wiKSB7XG4gICAgICBmb3IgKG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcInRyYXZlcnNlXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTsgdHJhdi50eXBlID09PSBcInN1Y2Nlc3NcIjsgKVxuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdCh0cmF2Lm1hcmtzKSwgcG9zID0gdHJhdi5wb3NpdGlvbiwgdHJhdiA9IHBhcnNlVHJhdmVyc2FsKHN0ciwgc2tpcFdTKHN0ciwgcG9zKSk7XG4gICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJ0cmF2ZXJzYWxfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgc3dpdGNoIChzdHJbaW5uZXJQb3NdKSB7XG4gICAgICBjYXNlIFwiPVwiOiB7XG4gICAgICAgIHN3aXRjaCAoc3RyW2lubmVyUG9zICsgMV0pIHtcbiAgICAgICAgICBjYXNlIFwiPlwiOiB7XG4gICAgICAgICAgICBpZiAobGV2ZWwgPiAxIHx8IGxoc0xldmVsIDw9IDEpIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgMSk7XG4gICAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyksIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcInBhaXJcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBwb3MgPSByaHMucG9zaXRpb24sIGxoc0xldmVsID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiPVwiOiB7XG4gICAgICAgICAgICBpZiAobGV2ZWwgPiA0IHx8IGxoc0xldmVsIDw9IDQpIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgNSk7XG4gICAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImNvbXBcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBtYXJrcy5wdXNoKHsgbmFtZTogXCJvcFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgfSwgeyBuYW1lOiBcIm9wX2VuZFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgKyAyIH0pLCBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpLCBwb3MgPSByaHMucG9zaXRpb24sIGxoc0xldmVsID0gNDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCIrXCI6IHtcbiAgICAgICAgaWYgKGxldmVsID4gNiB8fCBsaHNMZXZlbCA8IDYpIGJyZWFrIGxvb3A7XG4gICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCA3KTtcbiAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyksIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImFkZFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHBvcyA9IHJocy5wb3NpdGlvbiwgbGhzTGV2ZWwgPSA2O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCItXCI6IHtcbiAgICAgICAgaWYgKGxldmVsID4gNiB8fCBsaHNMZXZlbCA8IDYpIGJyZWFrIGxvb3A7XG4gICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCA3KTtcbiAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyksIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcInN1YlwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHBvcyA9IHJocy5wb3NpdGlvbiwgbGhzTGV2ZWwgPSA2O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCIqXCI6IHtcbiAgICAgICAgaWYgKHN0cltpbm5lclBvcyArIDFdID09PSBcIipcIikge1xuICAgICAgICAgIGlmIChsZXZlbCA+IDggfHwgbGhzTGV2ZWwgPD0gOCkgYnJlYWsgbG9vcDtcbiAgICAgICAgICBsZXQgcmhzMiA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMiksIDgpO1xuICAgICAgICAgIGlmIChyaHMyLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJoczI7XG4gICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzMi5tYXJrcyksIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcInBvd1wiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHBvcyA9IHJoczIucG9zaXRpb24sIGxoc0xldmVsID0gODtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGV2ZWwgPiA3IHx8IGxoc0xldmVsIDwgNykgYnJlYWsgbG9vcDtcbiAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIDgpO1xuICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKSwgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwibXVsXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgcG9zID0gcmhzLnBvc2l0aW9uLCBsaHNMZXZlbCA9IDc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIi9cIjoge1xuICAgICAgICBpZiAobGV2ZWwgPiA3IHx8IGxoc0xldmVsIDwgNykgYnJlYWsgbG9vcDtcbiAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIDgpO1xuICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKSwgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiZGl2XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgcG9zID0gcmhzLnBvc2l0aW9uLCBsaHNMZXZlbCA9IDc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIiVcIjoge1xuICAgICAgICBpZiAobGV2ZWwgPiA3IHx8IGxoc0xldmVsIDwgNykgYnJlYWsgbG9vcDtcbiAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIDgpO1xuICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKSwgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwibW9kXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgcG9zID0gcmhzLnBvc2l0aW9uLCBsaHNMZXZlbCA9IDc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIjxcIjpcbiAgICAgIGNhc2UgXCI+XCI6IHtcbiAgICAgICAgaWYgKGxldmVsID4gNCB8fCBsaHNMZXZlbCA8PSA0KSBicmVhayBsb29wO1xuICAgICAgICBsZXQgbmV4dFBvcyA9IGlubmVyUG9zICsgMTtcbiAgICAgICAgc3RyW25leHRQb3NdID09PSBcIj1cIiAmJiBuZXh0UG9zKys7XG4gICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBuZXh0UG9zKSwgNSk7XG4gICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJjb21wXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgbWFya3MucHVzaCh7IG5hbWU6IFwib3BcIiwgcG9zaXRpb246IGlubmVyUG9zIH0sIHsgbmFtZTogXCJvcF9lbmRcIiwgcG9zaXRpb246IG5leHRQb3MgfSksIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyksIHBvcyA9IHJocy5wb3NpdGlvbiwgbGhzTGV2ZWwgPSA0O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJ8XCI6IHtcbiAgICAgICAgaWYgKHN0cltpbm5lclBvcyArIDFdID09PSBcInxcIikge1xuICAgICAgICAgIGlmIChsZXZlbCA+IDIgfHwgbGhzTGV2ZWwgPCAyKSBicmVhayBsb29wO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCAzKTtcbiAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpLCBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJvclwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHBvcyA9IHJocy5wb3NpdGlvbiwgbGhzTGV2ZWwgPSAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChsZXZlbCA+IDExIHx8IGxoc0xldmVsIDwgMTEpIGJyZWFrIGxvb3A7XG4gICAgICAgICAgbGV0IGlkZW50UG9zID0gc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAxKSwgaWRlbnRMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgaWRlbnRQb3MsIElERU5UKTtcbiAgICAgICAgICBpZiAoIWlkZW50TGVuKSByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBpZGVudFBvcyB9O1xuICAgICAgICAgIGlmIChwb3MgPSBpZGVudFBvcyArIGlkZW50TGVuLCBzdHJbcG9zXSA9PT0gXCIoXCIgfHwgc3RyW3Bvc10gPT09IFwiOlwiKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gcGFyc2VGdW5jQ2FsbChzdHIsIGlkZW50UG9zLCBwb3MpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyZXN1bHQubWFya3MpLCBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJwaXBlY2FsbFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHBvcyA9IHJlc3VsdC5wb3NpdGlvbiwgbGhzTGV2ZWwgPSAxMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiJlwiOiB7XG4gICAgICAgIGlmIChzdHJbaW5uZXJQb3MgKyAxXSAhPSBcIiZcIiB8fCBsZXZlbCA+IDMgfHwgbGhzTGV2ZWwgPCAzKSBicmVhayBsb29wO1xuICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgNCk7XG4gICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpLCBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJhbmRcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBwb3MgPSByaHMucG9zaXRpb24sIGxoc0xldmVsID0gMztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiIVwiOiB7XG4gICAgICAgIGlmIChzdHJbaW5uZXJQb3MgKyAxXSAhPT0gXCI9XCIgfHwgbGV2ZWwgPiA0IHx8IGxoc0xldmVsIDw9IDQpIGJyZWFrIGxvb3A7XG4gICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCA1KTtcbiAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImNvbXBcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBtYXJrcy5wdXNoKHsgbmFtZTogXCJvcFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgfSwgeyBuYW1lOiBcIm9wX2VuZFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgKyAyIH0pLCBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpLCBwb3MgPSByaHMucG9zaXRpb24sIGxoc0xldmVsID0gNDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiZFwiOiB7XG4gICAgICAgIGlmIChzdHIuc2xpY2UoaW5uZXJQb3MsIGlubmVyUG9zICsgNCkgIT09IFwiZGVzY1wiIHx8IGxldmVsID4gNCB8fCBsaHNMZXZlbCA8IDQpIGJyZWFrIGxvb3A7XG4gICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImRlc2NcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBwb3MgPSBpbm5lclBvcyArIDQsIGxoc0xldmVsID0gNDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiYVwiOiB7XG4gICAgICAgIGlmIChzdHIuc2xpY2UoaW5uZXJQb3MsIGlubmVyUG9zICsgMykgIT09IFwiYXNjXCIgfHwgbGV2ZWwgPiA0IHx8IGxoc0xldmVsIDwgNCkgYnJlYWsgbG9vcDtcbiAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiYXNjXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgcG9zID0gaW5uZXJQb3MgKyAzLCBsaHNMZXZlbCA9IDQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgc3dpdGNoIChwYXJzZVJlZ2V4U3RyKHN0ciwgaW5uZXJQb3MsIElERU5UKSkge1xuICAgICAgICAgIGNhc2UgXCJpblwiOiB7XG4gICAgICAgICAgICBpZiAobGV2ZWwgPiA0IHx8IGxoc0xldmVsIDw9IDQpIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpO1xuICAgICAgICAgICAgbGV0IGlzR3JvdXAgPSAhMTtcbiAgICAgICAgICAgIHN0cltwb3NdID09PSBcIihcIiAmJiAoaXNHcm91cCA9ICEwLCBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKSk7XG4gICAgICAgICAgICBsZXQgcmFuZ2VQb3MgPSBwb3MsIHJlc3VsdCA9IHBhcnNlRXhwcihzdHIsIHBvcywgNSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIGlmIChwb3MgPSBza2lwV1Moc3RyLCByZXN1bHQucG9zaXRpb24pLCBzdHJbcG9zXSA9PT0gXCIuXCIgJiYgc3RyW3BvcyArIDFdID09PSBcIi5cIikge1xuICAgICAgICAgICAgICBsZXQgdHlwZSA9IFwiaW5jX3JhbmdlXCI7XG4gICAgICAgICAgICAgIHN0cltwb3MgKyAyXSA9PT0gXCIuXCIgPyAodHlwZSA9IFwiZXhjX3JhbmdlXCIsIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDMpKSA6IHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDIpO1xuICAgICAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgcG9zLCA1KTtcbiAgICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImluX3JhbmdlXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgbWFya3MgPSBtYXJrcy5jb25jYXQoeyBuYW1lOiB0eXBlLCBwb3NpdGlvbjogcmFuZ2VQb3MgfSwgcmVzdWx0Lm1hcmtzLCByaHMubWFya3MpLCBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiY29tcFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIG1hcmtzLnB1c2goeyBuYW1lOiBcIm9wXCIsIHBvc2l0aW9uOiBpbm5lclBvcyB9LCB7IG5hbWU6IFwib3BfZW5kXCIsIHBvc2l0aW9uOiBpbm5lclBvcyArIDIgfSksIG1hcmtzID0gbWFya3MuY29uY2F0KHJlc3VsdC5tYXJrcyk7XG4gICAgICAgICAgICBpZiAoaXNHcm91cCkge1xuICAgICAgICAgICAgICBpZiAocG9zID0gc2tpcFdTKHN0ciwgcG9zKSwgc3RyW3Bvc10gIT09IFwiKVwiKSByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaHNMZXZlbCA9IDQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIm1hdGNoXCI6IHtcbiAgICAgICAgICAgIGlmIChsZXZlbCA+IDQgfHwgbGhzTGV2ZWwgPD0gNCkgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDUpLCA1KTtcbiAgICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiY29tcFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIG1hcmtzLnB1c2goeyBuYW1lOiBcIm9wXCIsIHBvc2l0aW9uOiBpbm5lclBvcyB9LCB7IG5hbWU6IFwib3BfZW5kXCIsIHBvc2l0aW9uOiBpbm5lclBvcyArIDUgfSksIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyksIHBvcyA9IHJocy5wb3NpdGlvbiwgbGhzTGV2ZWwgPSA0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICB9XG4gICAgfVxuICB9XG4gIGxldCBmYWlsUG9zaXRpb24gPSB0cmF2Py50eXBlID09PSBcImVycm9yXCIgJiYgdHJhdi5wb3NpdGlvbjtcbiAgcmV0dXJuIHsgdHlwZTogXCJzdWNjZXNzXCIsIG1hcmtzLCBwb3NpdGlvbjogcG9zLCBmYWlsUG9zaXRpb24gfTtcbn1cbmZ1bmN0aW9uIHBhcnNlVHJhdmVyc2FsKHN0ciwgcG9zKSB7XG4gIGxldCBzdGFydFBvcyA9IHBvcztcbiAgc3dpdGNoIChzdHJbcG9zXSkge1xuICAgIGNhc2UgXCIuXCI6IHtcbiAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgbGV0IGlkZW50U3RhcnQgPSBwb3MsIGlkZW50TGVuMiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MsIElERU5UKTtcbiAgICAgIHJldHVybiBpZGVudExlbjIgPyAocG9zICs9IGlkZW50TGVuMiwge1xuICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgbWFya3M6IFtcbiAgICAgICAgICB7IG5hbWU6IFwiYXR0cl9hY2Nlc3NcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0sXG4gICAgICAgICAgeyBuYW1lOiBcImlkZW50XCIsIHBvc2l0aW9uOiBpZGVudFN0YXJ0IH0sXG4gICAgICAgICAgeyBuYW1lOiBcImlkZW50X2VuZFwiLCBwb3NpdGlvbjogcG9zIH1cbiAgICAgICAgXSxcbiAgICAgICAgcG9zaXRpb246IHBvc1xuICAgICAgfSkgOiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xuICAgIH1cbiAgICBjYXNlIFwiLVwiOlxuICAgICAgaWYgKHN0cltwb3MgKyAxXSAhPT0gXCI+XCIpIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xuICAgICAgbGV0IG1hcmtzID0gW3sgbmFtZTogXCJkZXJlZlwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV07XG4gICAgICBwb3MgKz0gMjtcbiAgICAgIGxldCBpZGVudFBvcyA9IHNraXBXUyhzdHIsIHBvcyksIGlkZW50TGVuID0gcGFyc2VSZWdleChzdHIsIGlkZW50UG9zLCBJREVOVCk7XG4gICAgICByZXR1cm4gaWRlbnRMZW4gJiYgKHBvcyA9IGlkZW50UG9zICsgaWRlbnRMZW4sIG1hcmtzLnB1c2goXG4gICAgICAgIHsgbmFtZTogXCJkZXJlZl9hdHRyXCIsIHBvc2l0aW9uOiBpZGVudFBvcyB9LFxuICAgICAgICB7IG5hbWU6IFwiaWRlbnRcIiwgcG9zaXRpb246IGlkZW50UG9zIH0sXG4gICAgICAgIHsgbmFtZTogXCJpZGVudF9lbmRcIiwgcG9zaXRpb246IHBvcyB9XG4gICAgICApKSwge1xuICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgbWFya3MsXG4gICAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICAgIH07XG4gICAgY2FzZSBcIltcIjoge1xuICAgICAgaWYgKHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpLCBzdHJbcG9zXSA9PT0gXCJdXCIpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgICAgbWFya3M6IFt7IG5hbWU6IFwiYXJyYXlfcG9zdGZpeFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV0sXG4gICAgICAgICAgcG9zaXRpb246IHBvcyArIDFcbiAgICAgICAgfTtcbiAgICAgIGxldCByYW5nZVBvcyA9IHBvcywgcmVzdWx0ID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmVzdWx0O1xuICAgICAgaWYgKHBvcyA9IHNraXBXUyhzdHIsIHJlc3VsdC5wb3NpdGlvbiksIHN0cltwb3NdID09PSBcIi5cIiAmJiBzdHJbcG9zICsgMV0gPT09IFwiLlwiKSB7XG4gICAgICAgIGxldCB0eXBlID0gXCJpbmNfcmFuZ2VcIjtcbiAgICAgICAgc3RyW3BvcyArIDJdID09PSBcIi5cIiA/ICh0eXBlID0gXCJleGNfcmFuZ2VcIiwgcG9zICs9IDMpIDogcG9zICs9IDIsIHBvcyA9IHNraXBXUyhzdHIsIHBvcyk7XG4gICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xuICAgICAgICByZXR1cm4gcmhzLnR5cGUgPT09IFwiZXJyb3JcIiA/IHJocyA6IChwb3MgPSBza2lwV1Moc3RyLCByaHMucG9zaXRpb24pLCBzdHJbcG9zXSAhPT0gXCJdXCIgPyB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9IDoge1xuICAgICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgICAgIG1hcmtzOiBbXG4gICAgICAgICAgICB7IG5hbWU6IFwic2xpY2VcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0sXG4gICAgICAgICAgICB7IG5hbWU6IHR5cGUsIHBvc2l0aW9uOiByYW5nZVBvcyB9XG4gICAgICAgICAgXS5jb25jYXQocmVzdWx0Lm1hcmtzLCByaHMubWFya3MpLFxuICAgICAgICAgIHBvc2l0aW9uOiBwb3MgKyAxXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cltwb3NdICE9PSBcIl1cIiA/IHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH0gOiB7XG4gICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgICBtYXJrczogW3sgbmFtZTogXCJzcXVhcmVfYnJhY2tldFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV0uY29uY2F0KHJlc3VsdC5tYXJrcyksXG4gICAgICAgIHBvc2l0aW9uOiBwb3MgKyAxXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwifFwiOiB7XG4gICAgICBpZiAocG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSksIHN0cltwb3NdID09PSBcIntcIikge1xuICAgICAgICBsZXQgcmVzdWx0ID0gcGFyc2VPYmplY3Qoc3RyLCBwb3MpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIiB8fCByZXN1bHQubWFya3MudW5zaGlmdCh7IG5hbWU6IFwicHJvamVjdGlvblwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwie1wiOiB7XG4gICAgICBsZXQgcmVzdWx0ID0gcGFyc2VPYmplY3Qoc3RyLCBwb3MpO1xuICAgICAgcmV0dXJuIHJlc3VsdC50eXBlID09PSBcImVycm9yXCIgfHwgcmVzdWx0Lm1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcInByb2plY3Rpb25cIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCByZXN1bHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xufVxuZnVuY3Rpb24gcGFyc2VGdW5jQ2FsbChzdHIsIHN0YXJ0UG9zLCBwb3MpIHtcbiAgbGV0IG1hcmtzID0gW107XG4gIGlmIChtYXJrcy5wdXNoKHsgbmFtZTogXCJmdW5jX2NhbGxcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBzdHJbcG9zXSA9PT0gXCI6XCIgJiYgc3RyW3BvcyArIDFdID09PSBcIjpcIikge1xuICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcIm5hbWVzcGFjZVwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIG1hcmtzLnB1c2goeyBuYW1lOiBcImlkZW50XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9LCB7IG5hbWU6IFwiaWRlbnRfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSksIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDIpO1xuICAgIGxldCBuYW1lTGVuID0gcGFyc2VSZWdleChzdHIsIHBvcywgSURFTlQpO1xuICAgIGlmICghbmFtZUxlbikgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgaWYgKG1hcmtzLnB1c2goeyBuYW1lOiBcImlkZW50XCIsIHBvc2l0aW9uOiBwb3MgfSwgeyBuYW1lOiBcImlkZW50X2VuZFwiLCBwb3NpdGlvbjogcG9zICsgbmFtZUxlbiB9KSwgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgbmFtZUxlbiksIHN0cltwb3NdICE9PSBcIihcIikgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgcG9zKyssIHBvcyA9IHNraXBXUyhzdHIsIHBvcyk7XG4gIH0gZWxzZVxuICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcImlkZW50XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9LCB7IG5hbWU6IFwiaWRlbnRfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSksIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICBsZXQgbGFzdFBvcyA9IHBvcztcbiAgaWYgKHN0cltwb3NdICE9PSBcIilcIilcbiAgICBmb3IgKDsgOyApIHtcbiAgICAgIGxldCByZXN1bHQgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByZXN1bHQ7XG4gICAgICBpZiAobWFya3MgPSBtYXJrcy5jb25jYXQocmVzdWx0Lm1hcmtzKSwgbGFzdFBvcyA9IHJlc3VsdC5wb3NpdGlvbiwgcG9zID0gc2tpcFdTKHN0ciwgcmVzdWx0LnBvc2l0aW9uKSwgc3RyW3Bvc10gIT09IFwiLFwiIHx8IChwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKSwgc3RyW3Bvc10gPT09IFwiKVwiKSkgYnJlYWs7XG4gICAgfVxuICByZXR1cm4gc3RyW3Bvc10gIT09IFwiKVwiID8geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfSA6IChtYXJrcy5wdXNoKHsgbmFtZTogXCJmdW5jX2FyZ3NfZW5kXCIsIHBvc2l0aW9uOiBsYXN0UG9zIH0pLCB7XG4gICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgbWFya3MsXG4gICAgcG9zaXRpb246IHBvcyArIDFcbiAgfSk7XG59XG5mdW5jdGlvbiBwYXJzZU9iamVjdChzdHIsIHBvcykge1xuICBsZXQgbWFya3MgPSBbeyBuYW1lOiBcIm9iamVjdFwiLCBwb3NpdGlvbjogcG9zIH1dO1xuICBmb3IgKHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpOyBzdHJbcG9zXSAhPT0gXCJ9XCI7ICkge1xuICAgIGxldCBwYWlyUG9zID0gcG9zO1xuICAgIGlmIChzdHIuc2xpY2UocG9zLCBwb3MgKyAzKSA9PT0gXCIuLi5cIilcbiAgICAgIGlmIChwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAzKSwgc3RyW3Bvc10gIT09IFwifVwiICYmIHN0cltwb3NdICE9PSBcIixcIikge1xuICAgICAgICBsZXQgZXhwciA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICAgIGlmIChleHByLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIGV4cHI7XG4gICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcIm9iamVjdF9zcGxhdFwiLCBwb3NpdGlvbjogcGFpclBvcyB9KSwgbWFya3MgPSBtYXJrcy5jb25jYXQoZXhwci5tYXJrcyksIHBvcyA9IGV4cHIucG9zaXRpb247XG4gICAgICB9IGVsc2VcbiAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwib2JqZWN0X3NwbGF0X3RoaXNcIiwgcG9zaXRpb246IHBhaXJQb3MgfSk7XG4gICAgZWxzZSB7XG4gICAgICBsZXQgZXhwciA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICBpZiAoZXhwci50eXBlID09PSBcImVycm9yXCIpIHJldHVybiBleHByO1xuICAgICAgbGV0IG5leHRQb3MgPSBza2lwV1Moc3RyLCBleHByLnBvc2l0aW9uKTtcbiAgICAgIGlmIChleHByLm1hcmtzWzBdLm5hbWUgPT09IFwic3RyXCIgJiYgc3RyW25leHRQb3NdID09PSBcIjpcIikge1xuICAgICAgICBsZXQgdmFsdWUgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBuZXh0UG9zICsgMSksIDApO1xuICAgICAgICBpZiAodmFsdWUudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gdmFsdWU7XG4gICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcIm9iamVjdF9wYWlyXCIsIHBvc2l0aW9uOiBwYWlyUG9zIH0pLCBtYXJrcyA9IG1hcmtzLmNvbmNhdChleHByLm1hcmtzLCB2YWx1ZS5tYXJrcyksIHBvcyA9IHZhbHVlLnBvc2l0aW9uO1xuICAgICAgfSBlbHNlXG4gICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHsgbmFtZTogXCJvYmplY3RfZXhwclwiLCBwb3NpdGlvbjogcG9zIH0sIGV4cHIubWFya3MpLCBwb3MgPSBleHByLnBvc2l0aW9uO1xuICAgIH1cbiAgICBpZiAocG9zID0gc2tpcFdTKHN0ciwgcG9zKSwgc3RyW3Bvc10gIT09IFwiLFwiKSBicmVhaztcbiAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgfVxuICByZXR1cm4gc3RyW3Bvc10gIT09IFwifVwiID8geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfSA6IChwb3MrKywgbWFya3MucHVzaCh7IG5hbWU6IFwib2JqZWN0X2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pLCB7IHR5cGU6IFwic3VjY2Vzc1wiLCBtYXJrcywgcG9zaXRpb246IHBvcyB9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nKHN0ciwgcG9zKSB7XG4gIGxldCB0b2tlbiA9IHN0cltwb3NdO1xuICBwb3MgPSBwb3MgKyAxO1xuICBjb25zdCBtYXJrcyA9IFt7IG5hbWU6IFwic3RyXCIsIHBvc2l0aW9uOiBwb3MgfV07XG4gIHN0cjogZm9yICg7IDsgcG9zKyspIHtcbiAgICBpZiAocG9zID4gc3RyLmxlbmd0aCkgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgc3dpdGNoIChzdHJbcG9zXSkge1xuICAgICAgY2FzZSB0b2tlbjoge1xuICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJzdHJfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSksIHBvcysrO1xuICAgICAgICBicmVhayBzdHI7XG4gICAgICB9XG4gICAgICBjYXNlIFwiXFxcXFwiOlxuICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJzdHJfcGF1c2VcIiwgcG9zaXRpb246IHBvcyB9KSwgc3RyW3BvcyArIDFdID09PSBcInVcIiA/IHN0cltwb3MgKyAyXSA9PT0gXCJ7XCIgPyAobWFya3MucHVzaCh7IG5hbWU6IFwidW5pY29kZV9oZXhcIiwgcG9zaXRpb246IHBvcyArIDMgfSksIHBvcyA9IHN0ci5pbmRleE9mKFwifVwiLCBwb3MgKyAzKSwgbWFya3MucHVzaCh7IG5hbWU6IFwidW5pY29kZV9oZXhfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSkpIDogKG1hcmtzLnB1c2goeyBuYW1lOiBcInVuaWNvZGVfaGV4XCIsIHBvc2l0aW9uOiBwb3MgKyAyIH0pLCBtYXJrcy5wdXNoKHsgbmFtZTogXCJ1bmljb2RlX2hleF9lbmRcIiwgcG9zaXRpb246IHBvcyArIDYgfSksIHBvcyArPSA1KSA6IChtYXJrcy5wdXNoKHsgbmFtZTogXCJzaW5nbGVfZXNjYXBlXCIsIHBvc2l0aW9uOiBwb3MgKyAxIH0pLCBwb3MgKz0gMSksIG1hcmtzLnB1c2goeyBuYW1lOiBcInN0cl9zdGFydFwiLCBwb3NpdGlvbjogcG9zICsgMSB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgdHlwZTogXCJzdWNjZXNzXCIsIG1hcmtzLCBwb3NpdGlvbjogcG9zIH07XG59XG5mdW5jdGlvbiBza2lwV1Moc3RyLCBwb3MpIHtcbiAgcmV0dXJuIHBvcyArIHBhcnNlUmVnZXgoc3RyLCBwb3MsIFdTKTtcbn1cbmZ1bmN0aW9uIHBhcnNlUmVnZXgoc3RyLCBwb3MsIHJlKSB7XG4gIGxldCBtID0gcmUuZXhlYyhzdHIuc2xpY2UocG9zKSk7XG4gIHJldHVybiBtID8gbVswXS5sZW5ndGggOiAwO1xufVxuZnVuY3Rpb24gcGFyc2VSZWdleFN0cihzdHIsIHBvcywgcmUpIHtcbiAgbGV0IG0gPSByZS5leGVjKHN0ci5zbGljZShwb3MpKTtcbiAgcmV0dXJuIG0gPyBtWzBdIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGpvaW4oYSwgYikge1xuICByZXR1cm4gKGJhc2UpID0+IGIoYShiYXNlKSk7XG59XG5mdW5jdGlvbiBtYXAoaW5uZXIpIHtcbiAgcmV0dXJuIChiYXNlKSA9PiAoeyB0eXBlOiBcIk1hcFwiLCBiYXNlLCBleHByOiBpbm5lcih7IHR5cGU6IFwiVGhpc1wiIH0pIH0pO1xufVxuZnVuY3Rpb24gZmxhdE1hcChpbm5lcikge1xuICByZXR1cm4gKGJhc2UpID0+ICh7IHR5cGU6IFwiRmxhdE1hcFwiLCBiYXNlLCBleHByOiBpbm5lcih7IHR5cGU6IFwiVGhpc1wiIH0pIH0pO1xufVxuZnVuY3Rpb24gdHJhdmVyc2VBcnJheShidWlsZCwgcmlnaHQpIHtcbiAgaWYgKCFyaWdodClcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJhLWFcIixcbiAgICAgIGJ1aWxkXG4gICAgfTtcbiAgc3dpdGNoIChyaWdodC50eXBlKSB7XG4gICAgY2FzZSBcImEtYVwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhLWFcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4oYnVpbGQsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYS1iXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYlwiLFxuICAgICAgICBidWlsZDogam9pbihidWlsZCwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGNhc2UgXCJiLWJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1hXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKGJ1aWxkLCBtYXAocmlnaHQuYnVpbGQpKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYi1hXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYVwiLFxuICAgICAgICBidWlsZDogam9pbihidWlsZCwgZmxhdE1hcChyaWdodC5idWlsZCkpXG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gdHlwZTogJHtyaWdodC50eXBlfWApO1xuICB9XG59XG5mdW5jdGlvbiB0cmF2ZXJzZVBsYWluKG1hcHBlciwgcmlnaHQpIHtcbiAgaWYgKCFyaWdodClcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJiLWJcIixcbiAgICAgIGJ1aWxkOiBtYXBwZXJcbiAgICB9O1xuICBzd2l0Y2ggKHJpZ2h0LnR5cGUpIHtcbiAgICBjYXNlIFwiYS1hXCI6XG4gICAgY2FzZSBcImItYVwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJiLWFcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwcGVyLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgY2FzZSBcImEtYlwiOlxuICAgIGNhc2UgXCJiLWJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYi1iXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gdHlwZTogJHtyaWdodC50eXBlfWApO1xuICB9XG59XG5mdW5jdGlvbiB0cmF2ZXJzZUVsZW1lbnQobWFwcGVyLCByaWdodCkge1xuICBpZiAoIXJpZ2h0KVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImEtYlwiLFxuICAgICAgYnVpbGQ6IG1hcHBlclxuICAgIH07XG4gIHN3aXRjaCAocmlnaHQudHlwZSkge1xuICAgIGNhc2UgXCJhLWFcIjpcbiAgICBjYXNlIFwiYi1hXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYVwiLFxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYS1iXCI6XG4gICAgY2FzZSBcImItYlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhLWJcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwcGVyLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biB0eXBlOiAke3JpZ2h0LnR5cGV9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHRyYXZlcnNlUHJvamVjdGlvbihtYXBwZXIsIHJpZ2h0KSB7XG4gIGlmICghcmlnaHQpXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYi1iXCIsXG4gICAgICBidWlsZDogbWFwcGVyXG4gICAgfTtcbiAgc3dpdGNoIChyaWdodC50eXBlKSB7XG4gICAgY2FzZSBcImEtYVwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhLWFcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwKG1hcHBlciksIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYS1iXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYlwiLFxuICAgICAgICBidWlsZDogam9pbihtYXAobWFwcGVyKSwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGNhc2UgXCJiLWFcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYi1hXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGNhc2UgXCJiLWJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYi1iXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gdHlwZTogJHtyaWdodC50eXBlfWApO1xuICB9XG59XG5jb25zdCBFU0NBUEVfU0VRVUVOQ0UgPSB7XG4gIFwiJ1wiOiBcIidcIixcbiAgJ1wiJzogJ1wiJyxcbiAgXCJcXFxcXCI6IFwiXFxcXFwiLFxuICBcIi9cIjogXCIvXCIsXG4gIGI6IFwiXFxiXCIsXG4gIGY6IFwiXFxmXCIsXG4gIG46IGBcbmAsXG4gIHI6IFwiXFxyXCIsXG4gIHQ6IFwiXHRcIlxufTtcbmZ1bmN0aW9uIGV4cGFuZEhleChzdHIpIHtcbiAgY29uc3QgY2hhckNvZGUgPSBwYXJzZUludChzdHIsIDE2KTtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xufVxuY2xhc3MgR3JvcVF1ZXJ5RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIG5hbWUgPSBcIkdyb3FRdWVyeUVycm9yXCI7XG59XG5jb25zdCBFWFBSX0JVSUxERVIgPSB7XG4gIGdyb3VwKHApIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJHcm91cFwiLFxuICAgICAgYmFzZTogcC5wcm9jZXNzKEVYUFJfQlVJTERFUilcbiAgICB9O1xuICB9LFxuICBldmVyeXRoaW5nKCkge1xuICAgIHJldHVybiB7IHR5cGU6IFwiRXZlcnl0aGluZ1wiIH07XG4gIH0sXG4gIHRoaXMoKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJUaGlzXCIgfTtcbiAgfSxcbiAgcGFyZW50KCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlBhcmVudFwiLFxuICAgICAgbjogMVxuICAgIH07XG4gIH0sXG4gIGRibHBhcmVudChwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiUGFyZW50XCIsXG4gICAgICBuOiBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKS5uICsgMVxuICAgIH07XG4gIH0sXG4gIHRyYXZlcnNlKHApIHtcbiAgICBjb25zdCBiYXNlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUiksIHRyYXZlcnNhbExpc3QgPSBbXTtcbiAgICBmb3IgKDsgcC5nZXRNYXJrKCkubmFtZSAhPT0gXCJ0cmF2ZXJzYWxfZW5kXCI7IClcbiAgICAgIHRyYXZlcnNhbExpc3QucHVzaChwLnByb2Nlc3MoVFJBVkVSU0VfQlVJTERFUikpO1xuICAgIHAuc2hpZnQoKTtcbiAgICBsZXQgdHJhdmVyc2FsID0gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gdHJhdmVyc2FsTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgIHRyYXZlcnNhbCA9IHRyYXZlcnNhbExpc3RbaV0odHJhdmVyc2FsKTtcbiAgICBpZiAoKGJhc2UudHlwZSA9PT0gXCJFdmVyeXRoaW5nXCIgfHwgYmFzZS50eXBlID09PSBcIkFycmF5XCIgfHwgYmFzZS50eXBlID09PSBcIlBpcGVGdW5jQ2FsbFwiKSAmJiAodHJhdmVyc2FsID0gdHJhdmVyc2VBcnJheSgodmFsKSA9PiB2YWwsIHRyYXZlcnNhbCkpLCB0cmF2ZXJzYWwgPT09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIkJVRzogdW5leHBlY3RlZCBlbXB0eSB0cmF2ZXJzYWxcIik7XG4gICAgcmV0dXJuIHRyYXZlcnNhbC5idWlsZChiYXNlKTtcbiAgfSxcbiAgdGhpc19hdHRyKHApIHtcbiAgICBjb25zdCBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgcmV0dXJuIG5hbWUgPT09IFwibnVsbFwiID8geyB0eXBlOiBcIlZhbHVlXCIsIHZhbHVlOiBudWxsIH0gOiBuYW1lID09PSBcInRydWVcIiA/IHsgdHlwZTogXCJWYWx1ZVwiLCB2YWx1ZTogITAgfSA6IG5hbWUgPT09IFwiZmFsc2VcIiA/IHsgdHlwZTogXCJWYWx1ZVwiLCB2YWx1ZTogITEgfSA6IHtcbiAgICAgIHR5cGU6IFwiQWNjZXNzQXR0cmlidXRlXCIsXG4gICAgICBuYW1lXG4gICAgfTtcbiAgfSxcbiAgbmVnKHApIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJOZWdcIixcbiAgICAgIGJhc2U6IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpXG4gICAgfTtcbiAgfSxcbiAgcG9zKHApIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJQb3NcIixcbiAgICAgIGJhc2U6IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpXG4gICAgfTtcbiAgfSxcbiAgYWRkKHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUiksIHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT3BDYWxsXCIsXG4gICAgICBvcDogXCIrXCIsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBzdWIocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPcENhbGxcIixcbiAgICAgIG9wOiBcIi1cIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIG11bChwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpLCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxuICAgICAgb3A6IFwiKlwiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgZGl2KHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUiksIHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT3BDYWxsXCIsXG4gICAgICBvcDogXCIvXCIsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBtb2QocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPcENhbGxcIixcbiAgICAgIG9wOiBcIiVcIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIHBvdyhwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpLCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxuICAgICAgb3A6IFwiKipcIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIGNvbXAocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgb3AgPSBwLnByb2Nlc3NTdHJpbmcoKSwgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPcENhbGxcIixcbiAgICAgIG9wLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgaW5fcmFuZ2UocCkge1xuICAgIGNvbnN0IGJhc2UgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgaXNJbmNsdXNpdmUgPSBwLmdldE1hcmsoKS5uYW1lID09PSBcImluY19yYW5nZVwiO1xuICAgIHAuc2hpZnQoKTtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUiksIHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiSW5SYW5nZVwiLFxuICAgICAgYmFzZSxcbiAgICAgIGxlZnQsXG4gICAgICByaWdodCxcbiAgICAgIGlzSW5jbHVzaXZlXG4gICAgfTtcbiAgfSxcbiAgc3RyKHApIHtcbiAgICBsZXQgdmFsdWUgPSBcIlwiO1xuICAgIGxvb3A6IGZvciAoOyBwLmhhc01hcmsoKTsgKSB7XG4gICAgICBjb25zdCBtYXJrID0gcC5nZXRNYXJrKCk7XG4gICAgICBzd2l0Y2ggKG1hcmsubmFtZSkge1xuICAgICAgICBjYXNlIFwic3RyX2VuZFwiOlxuICAgICAgICAgIHZhbHVlICs9IHAucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgIGNhc2UgXCJzdHJfcGF1c2VcIjpcbiAgICAgICAgICB2YWx1ZSArPSBwLnByb2Nlc3NTdHJpbmdFbmQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInN0cl9zdGFydFwiOlxuICAgICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNpbmdsZV9lc2NhcGVcIjoge1xuICAgICAgICAgIGNvbnN0IGNoYXIgPSBwLnNsaWNlKDEpO1xuICAgICAgICAgIHAuc2hpZnQoKSwgdmFsdWUgKz0gRVNDQVBFX1NFUVVFTkNFW2NoYXJdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ1bmljb2RlX2hleFwiOlxuICAgICAgICAgIHAuc2hpZnQoKSwgdmFsdWUgKz0gZXhwYW5kSGV4KHAucHJvY2Vzc1N0cmluZ0VuZCgpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuZXhwZWN0ZWQgbWFyazogJHttYXJrLm5hbWV9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6IFwiVmFsdWVcIiwgdmFsdWUgfTtcbiAgfSxcbiAgaW50ZWdlcihwKSB7XG4gICAgY29uc3Qgc3RyVmFsdWUgPSBwLnByb2Nlc3NTdHJpbmdFbmQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJWYWx1ZVwiLFxuICAgICAgdmFsdWU6IE51bWJlcihzdHJWYWx1ZSlcbiAgICB9O1xuICB9LFxuICBmbG9hdChwKSB7XG4gICAgY29uc3Qgc3RyVmFsdWUgPSBwLnByb2Nlc3NTdHJpbmdFbmQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJWYWx1ZVwiLFxuICAgICAgdmFsdWU6IE51bWJlcihzdHJWYWx1ZSlcbiAgICB9O1xuICB9LFxuICBzY2kocCkge1xuICAgIGNvbnN0IHN0clZhbHVlID0gcC5wcm9jZXNzU3RyaW5nRW5kKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiVmFsdWVcIixcbiAgICAgIHZhbHVlOiBOdW1iZXIoc3RyVmFsdWUpXG4gICAgfTtcbiAgfSxcbiAgb2JqZWN0KHApIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gW107XG4gICAgZm9yICg7IHAuZ2V0TWFyaygpLm5hbWUgIT09IFwib2JqZWN0X2VuZFwiOyApXG4gICAgICBhdHRyaWJ1dGVzLnB1c2gocC5wcm9jZXNzKE9CSkVDVF9CVUlMREVSKSk7XG4gICAgcmV0dXJuIHAuc2hpZnQoKSwge1xuICAgICAgdHlwZTogXCJPYmplY3RcIixcbiAgICAgIGF0dHJpYnV0ZXNcbiAgICB9O1xuICB9LFxuICBhcnJheShwKSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgICBmb3IgKDsgcC5nZXRNYXJrKCkubmFtZSAhPT0gXCJhcnJheV9lbmRcIjsgKSB7XG4gICAgICBsZXQgaXNTcGxhdCA9ICExO1xuICAgICAgcC5nZXRNYXJrKCkubmFtZSA9PT0gXCJhcnJheV9zcGxhdFwiICYmIChpc1NwbGF0ID0gITAsIHAuc2hpZnQoKSk7XG4gICAgICBjb25zdCB2YWx1ZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgZWxlbWVudHMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwiQXJyYXlFbGVtZW50XCIsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBpc1NwbGF0XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHAuc2hpZnQoKSwge1xuICAgICAgdHlwZTogXCJBcnJheVwiLFxuICAgICAgZWxlbWVudHNcbiAgICB9O1xuICB9LFxuICB0dXBsZShwKSB7XG4gICAgY29uc3QgbWVtYmVycyA9IFtdO1xuICAgIGZvciAoOyBwLmdldE1hcmsoKS5uYW1lICE9PSBcInR1cGxlX2VuZFwiOyApXG4gICAgICBtZW1iZXJzLnB1c2gocC5wcm9jZXNzKEVYUFJfQlVJTERFUikpO1xuICAgIHJldHVybiBwLnNoaWZ0KCksIHtcbiAgICAgIHR5cGU6IFwiVHVwbGVcIixcbiAgICAgIG1lbWJlcnNcbiAgICB9O1xuICB9LFxuICBmdW5jX2NhbGwocCkge1xuICAgIGxldCBuYW1lc3BhY2UgPSBcImdsb2JhbFwiO1xuICAgIHAuZ2V0TWFyaygpLm5hbWUgPT09IFwibmFtZXNwYWNlXCIgJiYgKHAuc2hpZnQoKSwgbmFtZXNwYWNlID0gcC5wcm9jZXNzU3RyaW5nKCkpO1xuICAgIGNvbnN0IG5hbWUgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICBpZiAobmFtZXNwYWNlID09PSBcImdsb2JhbFwiICYmIG5hbWUgPT09IFwic2VsZWN0XCIpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgdHlwZTogXCJTZWxlY3RcIixcbiAgICAgICAgYWx0ZXJuYXRpdmVzOiBbXVxuICAgICAgfTtcbiAgICAgIGZvciAoOyBwLmdldE1hcmsoKS5uYW1lICE9PSBcImZ1bmNfYXJnc19lbmRcIjsgKVxuICAgICAgICBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gXCJwYWlyXCIpIHtcbiAgICAgICAgICBpZiAocmVzdWx0LmZhbGxiYWNrKSB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJ1bmV4cGVjdGVkIGFyZ3VtZW50IHRvIHNlbGVjdCgpXCIpO1xuICAgICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgICBjb25zdCBjb25kaXRpb24gPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgICByZXN1bHQuYWx0ZXJuYXRpdmVzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogXCJTZWxlY3RBbHRlcm5hdGl2ZVwiLFxuICAgICAgICAgICAgY29uZGl0aW9uLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocmVzdWx0LmZhbGxiYWNrKSB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJ1bmV4cGVjdGVkIGFyZ3VtZW50IHRvIHNlbGVjdCgpXCIpO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgICAgcmVzdWx0LmZhbGxiYWNrID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBwLnNoaWZ0KCksIHJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgYXJncyA9IFtdO1xuICAgIGZvciAoOyBwLmdldE1hcmsoKS5uYW1lICE9PSBcImZ1bmNfYXJnc19lbmRcIjsgKVxuICAgICAgYXJndW1lbnRTaG91bGRCZVNlbGVjdG9yKG5hbWVzcGFjZSwgbmFtZSwgYXJncy5sZW5ndGgpID8gKHAucHJvY2VzcyhTRUxFQ1RPUl9CVUlMREVSKSwgYXJncy5wdXNoKHsgdHlwZTogXCJTZWxlY3RvclwiIH0pKSA6IGFyZ3MucHVzaChwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSk7XG4gICAgaWYgKHAuc2hpZnQoKSwgbmFtZXNwYWNlID09PSBcImdsb2JhbFwiICYmIChuYW1lID09PSBcImJlZm9yZVwiIHx8IG5hbWUgPT09IFwiYWZ0ZXJcIikgJiYgcC5wYXJzZU9wdGlvbnMubW9kZSA9PT0gXCJkZWx0YVwiKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJDb250ZXh0XCIsXG4gICAgICAgIGtleTogbmFtZVxuICAgICAgfTtcbiAgICBpZiAobmFtZXNwYWNlID09PSBcImdsb2JhbFwiICYmIG5hbWUgPT09IFwiYm9vc3RcIiAmJiAhcC5hbGxvd0Jvb3N0KVxuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwidW5leHBlY3RlZCBib29zdFwiKTtcbiAgICBjb25zdCBmdW5jcyA9IG5hbWVzcGFjZXNbbmFtZXNwYWNlXTtcbiAgICBpZiAoIWZ1bmNzKVxuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKGBVbmRlZmluZWQgbmFtZXNwYWNlOiAke25hbWVzcGFjZX1gKTtcbiAgICBjb25zdCBmdW5jID0gZnVuY3NbbmFtZV07XG4gICAgaWYgKCFmdW5jKVxuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKGBVbmRlZmluZWQgZnVuY3Rpb246ICR7bmFtZX1gKTtcbiAgICBpZiAoZnVuYy5hcml0eSAhPT0gdm9pZCAwICYmIHZhbGlkYXRlQXJpdHkobmFtZSwgZnVuYy5hcml0eSwgYXJncy5sZW5ndGgpLCBmdW5jLm1vZGUgIT09IHZvaWQgMCAmJiBmdW5jLm1vZGUgIT09IHAucGFyc2VPcHRpb25zLm1vZGUpXG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoYFVuZGVmaW5lZCBmdW5jdGlvbjogJHtuYW1lfWApO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkZ1bmNDYWxsXCIsXG4gICAgICBmdW5jLFxuICAgICAgbmFtZXNwYWNlLFxuICAgICAgbmFtZSxcbiAgICAgIGFyZ3NcbiAgICB9O1xuICB9LFxuICBwaXBlY2FsbChwKSB7XG4gICAgY29uc3QgYmFzZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHAuc2hpZnQoKTtcbiAgICBsZXQgbmFtZXNwYWNlID0gXCJnbG9iYWxcIjtcbiAgICBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gXCJuYW1lc3BhY2VcIiAmJiAocC5zaGlmdCgpLCBuYW1lc3BhY2UgPSBwLnByb2Nlc3NTdHJpbmcoKSksIG5hbWVzcGFjZSAhPT0gXCJnbG9iYWxcIilcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgVW5kZWZpbmVkIG5hbWVzcGFjZTogJHtuYW1lc3BhY2V9YCk7XG4gICAgY29uc3QgbmFtZSA9IHAucHJvY2Vzc1N0cmluZygpLCBhcmdzID0gW10sIG9sZEFsbG93Qm9vc3QgPSBwLmFsbG93Qm9vc3Q7XG4gICAgZm9yIChuYW1lID09PSBcInNjb3JlXCIgJiYgKHAuYWxsb3dCb29zdCA9ICEwKTsgOyApIHtcbiAgICAgIGNvbnN0IG1hcmtOYW1lID0gcC5nZXRNYXJrKCkubmFtZTtcbiAgICAgIGlmIChtYXJrTmFtZSA9PT0gXCJmdW5jX2FyZ3NfZW5kXCIpXG4gICAgICAgIGJyZWFrO1xuICAgICAgaWYgKG5hbWUgPT09IFwib3JkZXJcIikge1xuICAgICAgICBpZiAobWFya05hbWUgPT09IFwiYXNjXCIpIHtcbiAgICAgICAgICBwLnNoaWZ0KCksIGFyZ3MucHVzaCh7IHR5cGU6IFwiQXNjXCIsIGJhc2U6IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpIH0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKG1hcmtOYW1lID09PSBcImRlc2NcIikge1xuICAgICAgICAgIHAuc2hpZnQoKSwgYXJncy5wdXNoKHsgdHlwZTogXCJEZXNjXCIsIGJhc2U6IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpIH0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhcmdzLnB1c2gocC5wcm9jZXNzKEVYUFJfQlVJTERFUikpO1xuICAgIH1cbiAgICBwLnNoaWZ0KCksIHAuYWxsb3dCb29zdCA9IG9sZEFsbG93Qm9vc3Q7XG4gICAgY29uc3QgZnVuYyA9IHBpcGVGdW5jdGlvbnNbbmFtZV07XG4gICAgaWYgKCFmdW5jKVxuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKGBVbmRlZmluZWQgcGlwZSBmdW5jdGlvbjogJHtuYW1lfWApO1xuICAgIHJldHVybiBmdW5jLmFyaXR5ICYmIHZhbGlkYXRlQXJpdHkobmFtZSwgZnVuYy5hcml0eSwgYXJncy5sZW5ndGgpLCB7XG4gICAgICB0eXBlOiBcIlBpcGVGdW5jQ2FsbFwiLFxuICAgICAgZnVuYyxcbiAgICAgIGJhc2UsXG4gICAgICBuYW1lLFxuICAgICAgYXJnc1xuICAgIH07XG4gIH0sXG4gIHBhaXIoKSB7XG4gICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwidW5leHBlY3RlZCA9PlwiKTtcbiAgfSxcbiAgYW5kKHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUiksIHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiQW5kXCIsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBvcihwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpLCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9yXCIsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBub3QocCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk5vdFwiLFxuICAgICAgYmFzZTogcC5wcm9jZXNzKEVYUFJfQlVJTERFUilcbiAgICB9O1xuICB9LFxuICBhc2MoKSB7XG4gICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwidW5leHBlY3RlZCBhc2NcIik7XG4gIH0sXG4gIGRlc2MoKSB7XG4gICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwidW5leHBlY3RlZCBkZXNjXCIpO1xuICB9LFxuICBwYXJhbShwKSB7XG4gICAgY29uc3QgbmFtZSA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgIHJldHVybiBwLnBhcnNlT3B0aW9ucy5wYXJhbXMgJiYgcC5wYXJzZU9wdGlvbnMucGFyYW1zLmhhc093blByb3BlcnR5KG5hbWUpID8ge1xuICAgICAgdHlwZTogXCJWYWx1ZVwiLFxuICAgICAgdmFsdWU6IHAucGFyc2VPcHRpb25zLnBhcmFtc1tuYW1lXVxuICAgIH0gOiB7XG4gICAgICB0eXBlOiBcIlBhcmFtZXRlclwiLFxuICAgICAgbmFtZVxuICAgIH07XG4gIH1cbn0sIE9CSkVDVF9CVUlMREVSID0ge1xuICBvYmplY3RfZXhwcihwKSB7XG4gICAgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09IFwicGFpclwiKSB7XG4gICAgICBwLnNoaWZ0KCk7XG4gICAgICBjb25zdCBjb25kaXRpb24gPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgdmFsdWUyID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIk9iamVjdENvbmRpdGlvbmFsU3BsYXRcIixcbiAgICAgICAgY29uZGl0aW9uLFxuICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9iamVjdEF0dHJpYnV0ZVZhbHVlXCIsXG4gICAgICBuYW1lOiBleHRyYWN0UHJvcGVydHlLZXkodmFsdWUpLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9LFxuICBvYmplY3RfcGFpcihwKSB7XG4gICAgY29uc3QgbmFtZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGlmIChuYW1lLnR5cGUgIT09IFwiVmFsdWVcIikgdGhyb3cgbmV3IEVycm9yKFwibmFtZSBtdXN0IGJlIHN0cmluZ1wiKTtcbiAgICBjb25zdCB2YWx1ZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9iamVjdEF0dHJpYnV0ZVZhbHVlXCIsXG4gICAgICBuYW1lOiBuYW1lLnZhbHVlLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9LFxuICBvYmplY3Rfc3BsYXQocCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9iamVjdFNwbGF0XCIsXG4gICAgICB2YWx1ZTogcC5wcm9jZXNzKEVYUFJfQlVJTERFUilcbiAgICB9O1xuICB9LFxuICBvYmplY3Rfc3BsYXRfdGhpcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPYmplY3RTcGxhdFwiLFxuICAgICAgdmFsdWU6IHsgdHlwZTogXCJUaGlzXCIgfVxuICAgIH07XG4gIH1cbn0sIFRSQVZFUlNFX0JVSUxERVIgPSB7XG4gIHNxdWFyZV9icmFja2V0KHApIHtcbiAgICBjb25zdCBleHByID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUiksIHZhbHVlID0gdHJ5Q29uc3RhbnRFdmFsdWF0ZShleHByKTtcbiAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWUudHlwZSA9PT0gXCJudW1iZXJcIiA/IChyaWdodCkgPT4gdHJhdmVyc2VFbGVtZW50KChiYXNlKSA9PiAoeyB0eXBlOiBcIkFjY2Vzc0VsZW1lbnRcIiwgYmFzZSwgaW5kZXg6IHZhbHVlLmRhdGEgfSksIHJpZ2h0KSA6IHZhbHVlICYmIHZhbHVlLnR5cGUgPT09IFwic3RyaW5nXCIgPyAocmlnaHQpID0+IHRyYXZlcnNlUGxhaW4oKGJhc2UpID0+ICh7IHR5cGU6IFwiQWNjZXNzQXR0cmlidXRlXCIsIGJhc2UsIG5hbWU6IHZhbHVlLmRhdGEgfSksIHJpZ2h0KSA6IChyaWdodCkgPT4gdHJhdmVyc2VBcnJheShcbiAgICAgIChiYXNlKSA9PiAoe1xuICAgICAgICB0eXBlOiBcIkZpbHRlclwiLFxuICAgICAgICBiYXNlLFxuICAgICAgICBleHByXG4gICAgICB9KSxcbiAgICAgIHJpZ2h0XG4gICAgKTtcbiAgfSxcbiAgc2xpY2UocCkge1xuICAgIGNvbnN0IGlzSW5jbHVzaXZlID0gcC5nZXRNYXJrKCkubmFtZSA9PT0gXCJpbmNfcmFuZ2VcIjtcbiAgICBwLnNoaWZ0KCk7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpLCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpLCBsZWZ0VmFsdWUgPSB0cnlDb25zdGFudEV2YWx1YXRlKGxlZnQpLCByaWdodFZhbHVlID0gdHJ5Q29uc3RhbnRFdmFsdWF0ZShyaWdodCk7XG4gICAgaWYgKCFsZWZ0VmFsdWUgfHwgIXJpZ2h0VmFsdWUgfHwgbGVmdFZhbHVlLnR5cGUgIT09IFwibnVtYmVyXCIgfHwgcmlnaHRWYWx1ZS50eXBlICE9PSBcIm51bWJlclwiKVxuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwic2xpY2luZyBtdXN0IHVzZSBjb25zdGFudCBudW1iZXJzXCIpO1xuICAgIHJldHVybiAocmhzKSA9PiB0cmF2ZXJzZUFycmF5KFxuICAgICAgKGJhc2UpID0+ICh7XG4gICAgICAgIHR5cGU6IFwiU2xpY2VcIixcbiAgICAgICAgYmFzZSxcbiAgICAgICAgbGVmdDogbGVmdFZhbHVlLmRhdGEsXG4gICAgICAgIHJpZ2h0OiByaWdodFZhbHVlLmRhdGEsXG4gICAgICAgIGlzSW5jbHVzaXZlXG4gICAgICB9KSxcbiAgICAgIHJoc1xuICAgICk7XG4gIH0sXG4gIHByb2plY3Rpb24ocCkge1xuICAgIGNvbnN0IG9iaiA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiAocmlnaHQpID0+IHRyYXZlcnNlUHJvamVjdGlvbigoYmFzZSkgPT4gKHsgdHlwZTogXCJQcm9qZWN0aW9uXCIsIGJhc2UsIGV4cHI6IG9iaiB9KSwgcmlnaHQpO1xuICB9LFxuICBhdHRyX2FjY2VzcyhwKSB7XG4gICAgY29uc3QgbmFtZSA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgIHJldHVybiAocmlnaHQpID0+IHRyYXZlcnNlUGxhaW4oKGJhc2UpID0+ICh7IHR5cGU6IFwiQWNjZXNzQXR0cmlidXRlXCIsIGJhc2UsIG5hbWUgfSksIHJpZ2h0KTtcbiAgfSxcbiAgZGVyZWYocCkge1xuICAgIGxldCBhdHRyID0gbnVsbDtcbiAgICBwLmdldE1hcmsoKS5uYW1lID09PSBcImRlcmVmX2F0dHJcIiAmJiAocC5zaGlmdCgpLCBhdHRyID0gcC5wcm9jZXNzU3RyaW5nKCkpO1xuICAgIGNvbnN0IHdyYXAgPSAoYmFzZSkgPT4gYXR0ciA/IHsgdHlwZTogXCJBY2Nlc3NBdHRyaWJ1dGVcIiwgYmFzZSwgbmFtZTogYXR0ciB9IDogYmFzZTtcbiAgICByZXR1cm4gKHJpZ2h0KSA9PiB0cmF2ZXJzZVBsYWluKFxuICAgICAgKGJhc2UpID0+IHdyYXAoe1xuICAgICAgICB0eXBlOiBcIkRlcmVmXCIsXG4gICAgICAgIGJhc2VcbiAgICAgIH0pLFxuICAgICAgcmlnaHRcbiAgICApO1xuICB9LFxuICBhcnJheV9wb3N0Zml4KCkge1xuICAgIHJldHVybiAocmlnaHQpID0+IHRyYXZlcnNlQXJyYXkoKGJhc2UpID0+ICh7IHR5cGU6IFwiQXJyYXlDb2VyY2VcIiwgYmFzZSB9KSwgcmlnaHQpO1xuICB9XG59LCBTRUxFQ1RPUl9CVUlMREVSID0ge1xuICBncm91cChwKSB7XG4gICAgcmV0dXJuIHAucHJvY2VzcyhTRUxFQ1RPUl9CVUlMREVSKSwgbnVsbDtcbiAgfSxcbiAgZXZlcnl0aGluZygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgdGhpcygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgcGFyZW50KCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBkYmxwYXJlbnQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHRyYXZlcnNlKHApIHtcbiAgICBmb3IgKHAucHJvY2VzcyhTRUxFQ1RPUl9CVUlMREVSKTsgcC5nZXRNYXJrKCkubmFtZSAhPT0gXCJ0cmF2ZXJzYWxfZW5kXCI7IClcbiAgICAgIHAucHJvY2VzcyhUUkFWRVJTRV9CVUlMREVSKTtcbiAgICByZXR1cm4gcC5zaGlmdCgpLCBudWxsO1xuICB9LFxuICB0aGlzX2F0dHIocCkge1xuICAgIHJldHVybiBwLnByb2Nlc3NTdHJpbmcoKSwgbnVsbDtcbiAgfSxcbiAgbmVnKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBwb3MoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGFkZCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgc3ViKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBtdWwoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGRpdigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgbW9kKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBwb3coKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGNvbXAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGluX3JhbmdlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBzdHIoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGludGVnZXIoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGZsb2F0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBzY2koKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIG9iamVjdCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgYXJyYXkoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHR1cGxlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBmdW5jX2NhbGwocCwgbWFyaykge1xuICAgIGNvbnN0IGZ1bmMgPSBFWFBSX0JVSUxERVIuZnVuY19jYWxsKHAsIG1hcmspO1xuICAgIGlmIChmdW5jLm5hbWUgPT09IFwiYW55d2hlcmVcIiAmJiBmdW5jLmFyZ3MubGVuZ3RoID09PSAxKSByZXR1cm4gbnVsbDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgcGlwZWNhbGwoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHBhaXIoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGFuZCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgb3IoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIG5vdCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgYXNjKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBkZXNjKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBwYXJhbSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGV4dHJhY3RQcm9wZXJ0eUtleShub2RlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IFwiQWNjZXNzQXR0cmlidXRlXCIgJiYgIW5vZGUuYmFzZSlcbiAgICByZXR1cm4gbm9kZS5uYW1lO1xuICBpZiAobm9kZS50eXBlID09PSBcIlBpcGVGdW5jQ2FsbFwiIHx8IG5vZGUudHlwZSA9PT0gXCJEZXJlZlwiIHx8IG5vZGUudHlwZSA9PT0gXCJNYXBcIiB8fCBub2RlLnR5cGUgPT09IFwiUHJvamVjdGlvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJTbGljZVwiIHx8IG5vZGUudHlwZSA9PT0gXCJGaWx0ZXJcIiB8fCBub2RlLnR5cGUgPT09IFwiQWNjZXNzRWxlbWVudFwiIHx8IG5vZGUudHlwZSA9PT0gXCJBcnJheUNvZXJjZVwiIHx8IG5vZGUudHlwZSA9PT0gXCJHcm91cFwiKVxuICAgIHJldHVybiBleHRyYWN0UHJvcGVydHlLZXkobm9kZS5iYXNlKTtcbiAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKGBDYW5ub3QgZGV0ZXJtaW5lIHByb3BlcnR5IGtleSBmb3IgdHlwZTogJHtub2RlLnR5cGV9YCk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUFyaXR5KG5hbWUsIGFyaXR5LCBjb3VudCkge1xuICBpZiAodHlwZW9mIGFyaXR5ID09IFwibnVtYmVyXCIpIHtcbiAgICBpZiAoY291bnQgIT09IGFyaXR5KVxuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFxuICAgICAgICBgSW5jb3JyZWN0IG51bWJlciBvZiBhcmd1bWVudHMgdG8gZnVuY3Rpb24gJHtuYW1lfSgpLiBFeHBlY3RlZCAke2FyaXR5fSwgZ290ICR7Y291bnR9LmBcbiAgICAgICk7XG4gIH0gZWxzZSBpZiAoYXJpdHkgJiYgIWFyaXR5KGNvdW50KSlcbiAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoYEluY29ycmVjdCBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGZ1bmN0aW9uICR7bmFtZX0oKS5gKTtcbn1cbmZ1bmN0aW9uIGFyZ3VtZW50U2hvdWxkQmVTZWxlY3RvcihuYW1lc3BhY2UsIGZ1bmN0aW9uTmFtZSwgYXJnQ291bnQpIHtcbiAgY29uc3QgZnVuY3Rpb25zUmVxdWlyaW5nU2VsZWN0b3JzID0gW1wiY2hhbmdlZEFueVwiLCBcImNoYW5nZWRPbmx5XCJdO1xuICByZXR1cm4gbmFtZXNwYWNlID09IFwiZGlmZlwiICYmIGFyZ0NvdW50ID09IDIgJiYgZnVuY3Rpb25zUmVxdWlyaW5nU2VsZWN0b3JzLmluY2x1ZGVzKGZ1bmN0aW9uTmFtZSk7XG59XG5jbGFzcyBHcm9xU3ludGF4RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIHBvc2l0aW9uO1xuICBuYW1lID0gXCJHcm9xU3ludGF4RXJyb3JcIjtcbiAgY29uc3RydWN0b3IocG9zaXRpb24pIHtcbiAgICBzdXBlcihgU3ludGF4IGVycm9yIGluIEdST1EgcXVlcnkgYXQgcG9zaXRpb24gJHtwb3NpdGlvbn1gKSwgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZShpbnB1dCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHBhcnNlJDEoaW5wdXQpO1xuICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICB0aHJvdyBuZXcgR3JvcVN5bnRheEVycm9yKHJlc3VsdC5wb3NpdGlvbik7XG4gIHJldHVybiBuZXcgTWFya1Byb2Nlc3NvcihpbnB1dCwgcmVzdWx0Lm1hcmtzLCBvcHRpb25zKS5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG59XG5jb25zdCB7IGNvbXBhcmUgfSA9IG5ldyBJbnRsLkNvbGxhdG9yKFwiZW5cIik7XG5mdW5jdGlvbiB0eXBlTm9kZXNTb3J0ZXIoYSwgYikge1xuICByZXR1cm4gYS50eXBlID09PSBcIm51bGxcIiA/IDEgOiBjb21wYXJlKGhhc2hGaWVsZChhKSwgaGFzaEZpZWxkKGIpKTtcbn1cbmNvbnN0IGhhc2hDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gaGFzaEZpZWxkKGZpZWxkKSB7XG4gIGlmIChoYXNoQ2FjaGUuaGFzKGZpZWxkKSlcbiAgICByZXR1cm4gaGFzaENhY2hlLmdldChmaWVsZCk7XG4gIGNvbnN0IGhhc2ggPSBjYWxjdWxhdGVGaWVsZEhhc2goZmllbGQpO1xuICByZXR1cm4gaGFzaENhY2hlLnNldChmaWVsZCwgaGFzaCksIGhhc2g7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVGaWVsZEhhc2goZmllbGQpIHtcbiAgc3dpdGNoIChmaWVsZC50eXBlKSB7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgcmV0dXJuIGZpZWxkLnZhbHVlICE9PSB2b2lkIDAgPyBgJHtmaWVsZC50eXBlfSgke2ZpZWxkLnZhbHVlfSlgIDogYCR7ZmllbGQudHlwZX1gO1xuICAgIGNhc2UgXCJudWxsXCI6XG4gICAgY2FzZSBcInVua25vd25cIjpcbiAgICAgIHJldHVybiBmaWVsZC50eXBlO1xuICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgcmV0dXJuIGAke2ZpZWxkLnR5cGV9KCR7aGFzaEZpZWxkKGZpZWxkLm9mKX0pYDtcbiAgICBjYXNlIFwib2JqZWN0XCI6IHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBPYmplY3QuZW50cmllcyhmaWVsZC5hdHRyaWJ1dGVzKTtcbiAgICAgIHJldHVybiBhdHRyaWJ1dGVzLnNvcnQoKFthXSwgW2JdKSA9PiBjb21wYXJlKGEsIGIpKSwgYCR7ZmllbGQudHlwZX06KCR7YXR0cmlidXRlcy5tYXAoXG4gICAgICAgIChba2V5LCB2YWx1ZV0pID0+IGAke2tleX06JHtoYXNoRmllbGQodmFsdWUudmFsdWUpfSgke3ZhbHVlLm9wdGlvbmFsID8gXCJvcHRpb25hbFwiIDogXCJub24tb3B0aW9uYWxcIn0pYFxuICAgICAgKS5qb2luKFwiLFwiKX0pOnJlZi0ke2ZpZWxkLmRlcmVmZXJlbmNlc1RvfToke2ZpZWxkLnJlc3QgPyBoYXNoRmllbGQoZmllbGQucmVzdCkgOiBcIm5vLXJlc3RcIn1gO1xuICAgIH1cbiAgICBjYXNlIFwidW5pb25cIjoge1xuICAgICAgY29uc3Qgc29ydGVkID0gWy4uLmZpZWxkLm9mXTtcbiAgICAgIHJldHVybiBzb3J0ZWQuc29ydCh0eXBlTm9kZXNTb3J0ZXIpLCBgJHtmaWVsZC50eXBlfSgke3NvcnRlZC5tYXAoaGFzaEZpZWxkKS5qb2luKFwiLFwiKX0pYDtcbiAgICB9XG4gICAgY2FzZSBcImlubGluZVwiOlxuICAgICAgcmV0dXJuIGAke2ZpZWxkLnR5cGV9KCR7ZmllbGQubmFtZX0pYDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZpZWxkLnR5cGU7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZUR1cGxpY2F0ZVR5cGVOb2Rlcyh0eXBlTm9kZXMpIHtcbiAgY29uc3Qgc2VlblR5cGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSwgbmV3VHlwZU5vZGVzID0gW10sIHNvcnRlZFR5cGVOb2RlcyA9IFsuLi50eXBlTm9kZXNdO1xuICBzb3J0ZWRUeXBlTm9kZXMuc29ydCh0eXBlTm9kZXNTb3J0ZXIpO1xuICBmb3IgKGNvbnN0IHR5cGVOb2RlIG9mIHNvcnRlZFR5cGVOb2Rlcykge1xuICAgIGNvbnN0IGhhc2ggPSBoYXNoRmllbGQodHlwZU5vZGUpO1xuICAgIGlmIChoYXNoID09PSBudWxsKSB7XG4gICAgICBuZXdUeXBlTm9kZXMucHVzaCh0eXBlTm9kZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgc2VlblR5cGVzLmhhcyhoYXNoKSB8fCAoc2VlblR5cGVzLmFkZChoYXNoKSwgbmV3VHlwZU5vZGVzLnB1c2godHlwZU5vZGUpKTtcbiAgfVxuICByZXR1cm4gbmV3VHlwZU5vZGVzO1xufVxuZnVuY3Rpb24gb3B0aW1pemVVbmlvbnMoZmllbGQpIHtcbiAgaWYgKGZpZWxkLnR5cGUgPT09IFwidW5pb25cIikge1xuICAgIGlmIChmaWVsZC5vZi5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gZmllbGQ7XG4gICAgaWYgKGZpZWxkLm9mID0gcmVtb3ZlRHVwbGljYXRlVHlwZU5vZGVzKGZpZWxkLm9mKSwgZmllbGQub2YubGVuZ3RoID09PSAxKVxuICAgICAgcmV0dXJuIG9wdGltaXplVW5pb25zKGZpZWxkLm9mWzBdKTtcbiAgICBmb3IgKGxldCBpZHggPSAwOyBmaWVsZC5vZi5sZW5ndGggPiBpZHg7IGlkeCsrKSB7XG4gICAgICBjb25zdCBzdWJGaWVsZCA9IGZpZWxkLm9mW2lkeF07XG4gICAgICBpZiAoc3ViRmllbGQudHlwZSA9PT0gXCJ1bmlvblwiKSB7XG4gICAgICAgIGZpZWxkLm9mLnNwbGljZShpZHgsIDEsIC4uLnN1YkZpZWxkLm9mKSwgaWR4LS07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZmllbGQub2ZbaWR4XSA9IG9wdGltaXplVW5pb25zKHN1YkZpZWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkLm9mLnNvcnQoKGEsIGIpID0+IGEudHlwZSA9PT0gXCJudWxsXCIgPyAxIDogY29tcGFyZShoYXNoRmllbGQoYSksIGhhc2hGaWVsZChiKSkpLCBmaWVsZDtcbiAgfVxuICBpZiAoZmllbGQudHlwZSA9PT0gXCJhcnJheVwiKVxuICAgIHJldHVybiBmaWVsZC5vZiA9IG9wdGltaXplVW5pb25zKGZpZWxkLm9mKSwgZmllbGQ7XG4gIGlmIChmaWVsZC50eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgZm9yIChjb25zdCBpZHggaW4gZmllbGQuYXR0cmlidXRlcylcbiAgICAgIE9iamVjdC5oYXNPd24oZmllbGQuYXR0cmlidXRlcywgaWR4KSAmJiAoZmllbGQuYXR0cmlidXRlc1tpZHhdLnZhbHVlID0gb3B0aW1pemVVbmlvbnMoZmllbGQuYXR0cmlidXRlc1tpZHhdLnZhbHVlKSk7XG4gICAgcmV0dXJuIGZpZWxkO1xuICB9XG4gIHJldHVybiBmaWVsZDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlZmVyZW5jZVR5cGVOb2RlKG5hbWUsIGluQXJyYXkgPSAhMSkge1xuICBjb25zdCBhdHRyaWJ1dGVzID0ge1xuICAgIF9yZWY6IHtcbiAgICAgIHR5cGU6IFwib2JqZWN0QXR0cmlidXRlXCIsXG4gICAgICB2YWx1ZToge1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICB9XG4gICAgfSxcbiAgICBfdHlwZToge1xuICAgICAgdHlwZTogXCJvYmplY3RBdHRyaWJ1dGVcIixcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIHZhbHVlOiBcInJlZmVyZW5jZVwiXG4gICAgICB9XG4gICAgfSxcbiAgICBfd2Vhazoge1xuICAgICAgdHlwZTogXCJvYmplY3RBdHRyaWJ1dGVcIixcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIHR5cGU6IFwiYm9vbGVhblwiXG4gICAgICB9LFxuICAgICAgb3B0aW9uYWw6ICEwXG4gICAgfVxuICB9O1xuICByZXR1cm4gaW5BcnJheSAmJiAoYXR0cmlidXRlcy5fa2V5ID0ge1xuICAgIHR5cGU6IFwib2JqZWN0QXR0cmlidXRlXCIsXG4gICAgdmFsdWU6IHtcbiAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICB9XG4gIH0pLCB7XG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBhdHRyaWJ1dGVzLFxuICAgIGRlcmVmZXJlbmNlc1RvOiBuYW1lXG4gIH07XG59XG5mdW5jdGlvbiBudWxsVW5pb24obm9kZSkge1xuICByZXR1cm4gbm9kZS50eXBlID09PSBcInVuaW9uXCIgPyB1bmlvbk9mKC4uLm5vZGUub2YsIHsgdHlwZTogXCJudWxsXCIgfSkgOiB1bmlvbk9mKG5vZGUsIHsgdHlwZTogXCJudWxsXCIgfSk7XG59XG5mdW5jdGlvbiB1bmlvbk9mKC4uLm5vZGVzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ1bmlvblwiLFxuICAgIG9mOiBub2Rlc1xuICB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZUlubGluZShub2RlLCBzY29wZSkge1xuICBpZiAobm9kZS50eXBlID09PSBcImlubGluZVwiKSB7XG4gICAgY29uc3QgcmVzb2x2ZWRJbmxpbmUgPSBzY29wZS5jb250ZXh0Lmxvb2t1cFR5cGVEZWNsYXJhdGlvbihub2RlKTtcbiAgICByZXR1cm4gcmVzb2x2ZUlubGluZShyZXNvbHZlZElubGluZSwgc2NvcGUpO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gbWFwTm9kZShub2RlLCBzY29wZSwgbWFwcGVyLCBtZXJnZVVuaW9ucyA9IChub2RlcykgPT4gb3B0aW1pemVVbmlvbnMoeyB0eXBlOiBcInVuaW9uXCIsIG9mOiBub2RlcyB9KSkge1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgY2FzZSBcImFycmF5XCI6XG4gICAgY2FzZSBcIm51bGxcIjpcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICBjYXNlIFwidW5rbm93blwiOlxuICAgICAgcmV0dXJuIG1hcHBlcihub2RlKTtcbiAgICBjYXNlIFwidW5pb25cIjpcbiAgICAgIHJldHVybiBtZXJnZVVuaW9ucyhub2RlLm9mLm1hcCgoaW5uZXIpID0+IG1hcE5vZGUoaW5uZXIsIHNjb3BlLCBtYXBwZXIpLCBtZXJnZVVuaW9ucykpO1xuICAgIGNhc2UgXCJpbmxpbmVcIjoge1xuICAgICAgY29uc3QgcmVzb2x2ZWRJbmxpbmUgPSByZXNvbHZlSW5saW5lKG5vZGUsIHNjb3BlKTtcbiAgICAgIHJldHVybiBtYXBOb2RlKHJlc29sdmVkSW5saW5lLCBzY29wZSwgbWFwcGVyLCBtZXJnZVVuaW9ucyk7XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gdHlwZTogJHtub2RlLnR5cGV9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzRnVuY0NhbGwobm9kZSwgbmFtZSkge1xuICByZXR1cm4gbm9kZS50eXBlID09PSBcIkdyb3VwXCIgPyBpc0Z1bmNDYWxsKG5vZGUuYmFzZSwgbmFtZSkgOiBub2RlLnR5cGUgPT09IFwiRnVuY0NhbGxcIiAmJiBgJHtub2RlLm5hbWVzcGFjZX06OiR7bm9kZS5uYW1lfWAgPT09IG5hbWU7XG59XG5mdW5jdGlvbiBib29sZWFuVmFsdWUobm9kZSwgc2NvcGUpIHtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwidW5rbm93blwiOlxuICAgICAgcmV0dXJuIHsgY2FuQmVUcnVlOiAhMCwgY2FuQmVGYWxzZTogITAsIGNhbkJlTnVsbDogITAgfTtcbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgcmV0dXJuIG5vZGUudmFsdWUgPT09ICEwID8geyBjYW5CZVRydWU6ICEwLCBjYW5CZUZhbHNlOiAhMSwgY2FuQmVOdWxsOiAhMSB9IDogbm9kZS52YWx1ZSA9PT0gITEgPyB7IGNhbkJlVHJ1ZTogITEsIGNhbkJlRmFsc2U6ICEwLCBjYW5CZU51bGw6ICExIH0gOiB7IGNhbkJlVHJ1ZTogITAsIGNhbkJlRmFsc2U6ICEwLCBjYW5CZU51bGw6ICExIH07XG4gICAgY2FzZSBcInVuaW9uXCI6IHtcbiAgICAgIGNvbnN0IHZhbHVlID0geyBjYW5CZVRydWU6ICExLCBjYW5CZUZhbHNlOiAhMSwgY2FuQmVOdWxsOiAhMSB9O1xuICAgICAgZm9yIChjb25zdCBzdWIgb2Ygbm9kZS5vZikge1xuICAgICAgICBjb25zdCBtYXRjaDIgPSBib29sZWFuVmFsdWUoc3ViLCBzY29wZSk7XG4gICAgICAgIG1hdGNoMi5jYW5CZU51bGwgJiYgKHZhbHVlLmNhbkJlTnVsbCA9ICEwKSwgbWF0Y2gyLmNhbkJlVHJ1ZSAmJiAodmFsdWUuY2FuQmVUcnVlID0gITApLCBtYXRjaDIuY2FuQmVGYWxzZSAmJiAodmFsdWUuY2FuQmVGYWxzZSA9ICEwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY2FzZSBcImlubGluZVwiOiB7XG4gICAgICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVJbmxpbmUobm9kZSwgc2NvcGUpO1xuICAgICAgcmV0dXJuIGJvb2xlYW5WYWx1ZShyZXNvbHZlZCwgc2NvcGUpO1xuICAgIH1cbiAgICBjYXNlIFwibnVsbFwiOlxuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgcmV0dXJuIHsgY2FuQmVUcnVlOiAhMSwgY2FuQmVGYWxzZTogITEsIGNhbkJlTnVsbDogITAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIG5vZGUgdHlwZSAke25vZGUudHlwZX1gKTtcbiAgfVxufVxuZnVuY3Rpb24gYm9vbGVhbk9yKGxlZnQsIHJpZ2h0KSB7XG4gIHJldHVybiBsZWZ0LmNhbkJlVHJ1ZSAmJiAhbGVmdC5jYW5CZUZhbHNlICYmICFsZWZ0LmNhbkJlTnVsbCA/IGxlZnQgOiByaWdodC5jYW5CZVRydWUgJiYgIXJpZ2h0LmNhbkJlRmFsc2UgJiYgIXJpZ2h0LmNhbkJlTnVsbCA/IHJpZ2h0IDoge1xuICAgIC8vIEVpdGhlciBzaWRlIGNhbiBiZSB0cnVlIGZvciB0aGUgZXhwcmVzc2lvbiB0byBiZSB0cnVlXG4gICAgY2FuQmVUcnVlOiBsZWZ0LmNhbkJlVHJ1ZSB8fCByaWdodC5jYW5CZVRydWUsXG4gICAgLy8gQm90aCBzaWRlcyBtdXN0IGJlIGZhbHNlIGZvciB0aGUgZXhwcmVzc2lvbiB0byBiZSBmYWxzZVxuICAgIGNhbkJlRmFsc2U6IGxlZnQuY2FuQmVGYWxzZSAmJiByaWdodC5jYW5CZUZhbHNlLFxuICAgIC8vIGlmIGVpdGhlciBzaWRlIGNhbiBiZSBudWxsLCB0aGUgZXhwcmVzc2lvbiBjYW4gYmUgbnVsbCBpZiB0aGUgb3RoZXIgc2lkZSBjYW4ndCBvbmx5IGJlIHRydWVcbiAgICBjYW5CZU51bGw6IGxlZnQuY2FuQmVOdWxsIHx8IHJpZ2h0LmNhbkJlTnVsbFxuICB9O1xufVxuZnVuY3Rpb24gYm9vbGVhbkFuZChsZWZ0LCByaWdodCkge1xuICByZXR1cm4gbGVmdC5jYW5CZUZhbHNlICYmICFsZWZ0LmNhbkJlVHJ1ZSAmJiAhbGVmdC5jYW5CZU51bGwgPyBsZWZ0IDogcmlnaHQuY2FuQmVGYWxzZSAmJiAhcmlnaHQuY2FuQmVUcnVlICYmICFyaWdodC5jYW5CZU51bGwgPyByaWdodCA6IHtcbiAgICAvLyBCb3RoIHNpZGVzIG11c3QgYmUgdHJ1ZSBmb3IgdGhlIGV4cHJlc3Npb24gdG8gYmUgdHJ1ZVxuICAgIGNhbkJlVHJ1ZTogbGVmdC5jYW5CZVRydWUgJiYgcmlnaHQuY2FuQmVUcnVlLFxuICAgIC8vIGlmIGVpdGhlciBzaWRlIGNhbiBiZSBmYWxzZSwgdGhlIGV4cHJlc3Npb24gY2FuIGJlIGZhbHNlXG4gICAgY2FuQmVGYWxzZTogbGVmdC5jYW5CZUZhbHNlIHx8IHJpZ2h0LmNhbkJlRmFsc2UsXG4gICAgLy8gaWYgZWl0aGVyIHNpZGUgY2FuIGJlIG51bGwsIHRoZSBleHByZXNzaW9uIGNhbiBiZSBudWxsXG4gICAgY2FuQmVOdWxsOiBsZWZ0LmNhbkJlTnVsbCB8fCByaWdodC5jYW5CZU51bGxcbiAgfTtcbn1cbmZ1bmN0aW9uIGJvb2xlYW5JbnRlcnByZXRhdGlvblRvVHlwZU5vZGUoYm9vbCkge1xuICByZXR1cm4gYm9vbC5jYW5CZVRydWUgPyBib29sLmNhbkJlRmFsc2UgPyBib29sLmNhbkJlTnVsbCA/IG51bGxVbmlvbih7IHR5cGU6IFwiYm9vbGVhblwiIH0pIDogeyB0eXBlOiBcImJvb2xlYW5cIiB9IDogYm9vbC5jYW5CZU51bGwgPyBudWxsVW5pb24oeyB0eXBlOiBcImJvb2xlYW5cIiwgdmFsdWU6ICEwIH0pIDogeyB0eXBlOiBcImJvb2xlYW5cIiwgdmFsdWU6ICEwIH0gOiBib29sLmNhbkJlRmFsc2UgPyBib29sLmNhbkJlTnVsbCA/IG51bGxVbmlvbih7IHR5cGU6IFwiYm9vbGVhblwiLCB2YWx1ZTogITEgfSkgOiB7IHR5cGU6IFwiYm9vbGVhblwiLCB2YWx1ZTogITEgfSA6IHsgdHlwZTogXCJudWxsXCIgfTtcbn1cbmNvbnN0ICR0cmFjZSQxID0gZGVidWcoXCJ0eXBlRXZhbHVhdG9yOnNjb3BlOnRyYWNlXCIpO1xuJHRyYWNlJDEubG9nID0gY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbmNsYXNzIENvbnRleHQge1xuICBzY2hlbWE7XG4gIGNvbnN0cnVjdG9yKHNjaGVtYSkge1xuICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICB9XG4gIGxvb2t1cFJlZihyZWZUbykge1xuICAgIGZvciAoY29uc3QgdmFsIG9mIHRoaXMuc2NoZW1hKVxuICAgICAgaWYgKHZhbC50eXBlID09PSBcImRvY3VtZW50XCIgJiYgdmFsLm5hbWUgPT09IHJlZlRvKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgYXR0cmlidXRlczogdmFsLmF0dHJpYnV0ZXNcbiAgICAgICAgfTtcbiAgICByZXR1cm4geyB0eXBlOiBcIm51bGxcIiB9O1xuICB9XG4gIGxvb2t1cFR5cGVEZWNsYXJhdGlvbihhbGlhcykge1xuICAgIGZvciAoY29uc3QgdmFsIG9mIHRoaXMuc2NoZW1hKVxuICAgICAgaWYgKHZhbC50eXBlID09PSBcInR5cGVcIiAmJiB2YWwubmFtZSA9PT0gYWxpYXMubmFtZSlcbiAgICAgICAgcmV0dXJuIHZhbC52YWx1ZTtcbiAgICByZXR1cm4geyB0eXBlOiBcIm51bGxcIiB9O1xuICB9XG59XG5jbGFzcyBTY29wZTIge1xuICB2YWx1ZTtcbiAgcGFyZW50O1xuICBjb250ZXh0O1xuICBpc0hpZGRlbjtcbiAgY29uc3RydWN0b3IodmFsdWUsIHBhcmVudCwgY29udGV4dCkge1xuICAgIHRoaXMudmFsdWUgPSB7IHR5cGU6IFwidW5pb25cIiwgb2Y6IHZhbHVlIH0sIHRoaXMucGFyZW50ID0gcGFyZW50LCB0aGlzLmNvbnRleHQgPSBjb250ZXh0IHx8IHBhcmVudD8uY29udGV4dCB8fCBuZXcgQ29udGV4dChbXSksIHRoaXMuaXNIaWRkZW4gPSAhMTtcbiAgfVxuICBjcmVhdGVOZXN0ZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5pc0hpZGRlbiA/IG5ldyBTY29wZTIodmFsdWUsIHRoaXMucGFyZW50LCB0aGlzLmNvbnRleHQpIDogbmV3IFNjb3BlMih2YWx1ZSwgdGhpcywgdGhpcy5jb250ZXh0KTtcbiAgfVxuICBjcmVhdGVIaWRkZW4odmFsdWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLmNyZWF0ZU5lc3RlZCh2YWx1ZSk7XG4gICAgcmV0dXJuIHJlc3VsdC5pc0hpZGRlbiA9ICEwLCByZXN1bHQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHVuaW9uV2l0aG91dE51bGwodW5pb25UeXBlTm9kZSkge1xuICByZXR1cm4gdW5pb25UeXBlTm9kZS50eXBlID09PSBcInVuaW9uXCIgPyB7XG4gICAgdHlwZTogXCJ1bmlvblwiLFxuICAgIG9mOiB1bmlvblR5cGVOb2RlLm9mLmZpbHRlcigodHlwZSkgPT4gdHlwZS50eXBlICE9PSBcIm51bGxcIilcbiAgfSA6IHVuaW9uVHlwZU5vZGU7XG59XG5mdW5jdGlvbiBoYW5kbGVGdW5jQ2FsbE5vZGUobm9kZSwgc2NvcGUpIHtcbiAgc3dpdGNoIChgJHtub2RlLm5hbWVzcGFjZX0uJHtub2RlLm5hbWV9YCkge1xuICAgIGNhc2UgXCJhcnJheS5jb21wYWN0XCI6IHtcbiAgICAgIGNvbnN0IGFyZyA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUoYXJnLCBzY29wZSwgKGFyZzIpID0+IHtcbiAgICAgICAgaWYgKGFyZzIudHlwZSA9PT0gXCJ1bmtub3duXCIpXG4gICAgICAgICAgcmV0dXJuIG51bGxVbmlvbih7IHR5cGU6IFwiYXJyYXlcIiwgb2Y6IHsgdHlwZTogXCJ1bmtub3duXCIgfSB9KTtcbiAgICAgICAgaWYgKGFyZzIudHlwZSAhPT0gXCJhcnJheVwiKVxuICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwibnVsbFwiIH07XG4gICAgICAgIGNvbnN0IG9mID0gbWFwTm9kZShhcmcyLm9mLCBzY29wZSwgKG9mMikgPT4gb2YyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgb2Y6IHVuaW9uV2l0aG91dE51bGwob2YpXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gICAgY2FzZSBcImFycmF5LmpvaW5cIjoge1xuICAgICAgY29uc3QgYXJyYXlBcmcgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzBdLCBzY29wZSB9KSwgc2VwQXJnID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1sxXSwgc2NvcGUgfSk7XG4gICAgICByZXR1cm4gbWFwTm9kZShcbiAgICAgICAgYXJyYXlBcmcsXG4gICAgICAgIHNjb3BlLFxuICAgICAgICAoYXJyYXlBcmcyKSA9PiBtYXBOb2RlKHNlcEFyZywgc2NvcGUsIChzZXBBcmcyKSA9PiBhcnJheUFyZzIudHlwZSA9PT0gXCJ1bmtub3duXCIgfHwgc2VwQXJnMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwic3RyaW5nXCIgfSkgOiBhcnJheUFyZzIudHlwZSAhPT0gXCJhcnJheVwiIHx8IHNlcEFyZzIudHlwZSAhPT0gXCJzdHJpbmdcIiA/IHsgdHlwZTogXCJudWxsXCIgfSA6IG1hcE5vZGUoYXJyYXlBcmcyLm9mLCBzY29wZSwgKG9mKSA9PiBvZi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwic3RyaW5nXCIgfSkgOiBvZi50eXBlICE9PSBcInN0cmluZ1wiICYmIG9mLnR5cGUgIT09IFwibnVtYmVyXCIgJiYgb2YudHlwZSAhPT0gXCJib29sZWFuXCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiB7IHR5cGU6IFwic3RyaW5nXCIgfSkpXG4gICAgICApO1xuICAgIH1cbiAgICBjYXNlIFwiYXJyYXkudW5pcXVlXCI6IHtcbiAgICAgIGNvbnN0IGFyZyA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUoYXJnLCBzY29wZSwgKGFyZzIpID0+IGFyZzIudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcImFycmF5XCIsIG9mOiB7IHR5cGU6IFwidW5rbm93blwiIH0gfSkgOiBhcmcyLnR5cGUgIT09IFwiYXJyYXlcIiA/IHsgdHlwZTogXCJudWxsXCIgfSA6IGFyZzIpO1xuICAgIH1cbiAgICBjYXNlIFwiYXJyYXkuaW50ZXJzZWN0c1wiOiB7XG4gICAgICBjb25zdCBhcmcxID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1swXSwgc2NvcGUgfSksIGFyZzIgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzFdLCBzY29wZSB9KTtcbiAgICAgIHJldHVybiBtYXBOb2RlKFxuICAgICAgICBhcmcxLFxuICAgICAgICBzY29wZSxcbiAgICAgICAgKGFyZzEyKSA9PiBtYXBOb2RlKGFyZzIsIHNjb3BlLCAoYXJnMjIpID0+IGFyZzEyLnR5cGUgIT09IFwiYXJyYXlcIiA/IHsgdHlwZTogXCJudWxsXCIgfSA6IGFyZzIyLnR5cGUgIT09IFwiYXJyYXlcIiA/IHsgdHlwZTogXCJudWxsXCIgfSA6IHsgdHlwZTogXCJib29sZWFuXCIgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIGNhc2UgXCJnbG9iYWwubG93ZXJcIjoge1xuICAgICAgY29uc3QgYXJnID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1swXSwgc2NvcGUgfSk7XG4gICAgICByZXR1cm4gbWFwTm9kZShhcmcsIHNjb3BlLCAoYXJnMikgPT4gYXJnMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwic3RyaW5nXCIgfSkgOiBhcmcyLnR5cGUgIT09IFwic3RyaW5nXCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiBhcmcyLnZhbHVlICE9PSB2b2lkIDAgPyB7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIHZhbHVlOiBhcmcyLnZhbHVlLnRvTG93ZXJDYXNlKClcbiAgICAgIH0gOiB7IHR5cGU6IFwic3RyaW5nXCIgfSk7XG4gICAgfVxuICAgIGNhc2UgXCJnbG9iYWwudXBwZXJcIjoge1xuICAgICAgY29uc3QgYXJnID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1swXSwgc2NvcGUgfSk7XG4gICAgICByZXR1cm4gbWFwTm9kZShhcmcsIHNjb3BlLCAoYXJnMikgPT4gYXJnMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwic3RyaW5nXCIgfSkgOiBhcmcyLnR5cGUgIT09IFwic3RyaW5nXCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiBhcmcyLnZhbHVlICE9PSB2b2lkIDAgPyB7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIHZhbHVlOiBhcmcyLnZhbHVlLnRvVXBwZXJDYXNlKClcbiAgICAgIH0gOiB7IHR5cGU6IFwic3RyaW5nXCIgfSk7XG4gICAgfVxuICAgIGNhc2UgXCJkYXRlVGltZS5ub3dcIjpcbiAgICAgIHJldHVybiB7IHR5cGU6IFwic3RyaW5nXCIgfTtcbiAgICBjYXNlIFwiZ2xvYmFsLm5vd1wiOlxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJzdHJpbmdcIiB9O1xuICAgIGNhc2UgXCJnbG9iYWwuZGVmaW5lZFwiOiB7XG4gICAgICBjb25zdCBhcmcgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzBdLCBzY29wZSB9KTtcbiAgICAgIHJldHVybiBtYXBOb2RlKGFyZywgc2NvcGUsIChub2RlMikgPT4gbm9kZTIudHlwZSA9PT0gXCJ1bmtub3duXCIgPyB7IHR5cGU6IFwiYm9vbGVhblwiIH0gOiB7IHR5cGU6IFwiYm9vbGVhblwiLCB2YWx1ZTogbm9kZTIudHlwZSAhPT0gXCJudWxsXCIgfSk7XG4gICAgfVxuICAgIGNhc2UgXCJnbG9iYWwucGF0aFwiOiB7XG4gICAgICBjb25zdCBhcmcgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzBdLCBzY29wZSB9KTtcbiAgICAgIHJldHVybiBtYXBOb2RlKGFyZywgc2NvcGUsIChhcmcyKSA9PiBhcmcyLnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJzdHJpbmdcIiB9KSA6IGFyZzIudHlwZSA9PT0gXCJzdHJpbmdcIiA/IHsgdHlwZTogXCJzdHJpbmdcIiB9IDogeyB0eXBlOiBcIm51bGxcIiB9KTtcbiAgICB9XG4gICAgY2FzZSBcImdsb2JhbC5jb2FsZXNjZVwiOiB7XG4gICAgICBpZiAobm9kZS5hcmdzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJudWxsXCIgfTtcbiAgICAgIGNvbnN0IHR5cGVOb2RlcyA9IFtdO1xuICAgICAgbGV0IGNhbkJlTnVsbCA9ICEwO1xuICAgICAgZm9yIChjb25zdCBhcmcgb2Ygbm9kZS5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGFyZ05vZGUgPSBvcHRpbWl6ZVVuaW9ucyh3YWxrKHsgbm9kZTogYXJnLCBzY29wZSB9KSksIGFsbE51bGwgPSBhcmdOb2RlLnR5cGUgPT09IFwibnVsbFwiIHx8IGFyZ05vZGUudHlwZSA9PT0gXCJ1bmlvblwiICYmIGFyZ05vZGUub2YuZXZlcnkoKHQpID0+IHQudHlwZSA9PT0gXCJudWxsXCIpO1xuICAgICAgICBpZiAoY2FuQmVOdWxsID0gYWxsTnVsbCB8fCBhcmdOb2RlLnR5cGUgPT09IFwidW5rbm93blwiIHx8IGFyZ05vZGUudHlwZSA9PT0gXCJ1bmlvblwiICYmIGFyZ05vZGUub2Yuc29tZSgodCkgPT4gdC50eXBlID09PSBcIm51bGxcIiB8fCB0LnR5cGUgPT09IFwidW5rbm93blwiKSwgYWxsTnVsbCB8fCB0eXBlTm9kZXMucHVzaCh1bmlvbldpdGhvdXROdWxsKGFyZ05vZGUpKSwgIWNhbkJlTnVsbClcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYW5CZU51bGwgJiYgdHlwZU5vZGVzLnB1c2goeyB0eXBlOiBcIm51bGxcIiB9KSwge1xuICAgICAgICB0eXBlOiBcInVuaW9uXCIsXG4gICAgICAgIG9mOiB0eXBlTm9kZXNcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJnbG9iYWwuY291bnRcIjoge1xuICAgICAgY29uc3QgYXJnID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1swXSwgc2NvcGUgfSk7XG4gICAgICByZXR1cm4gbWFwTm9kZShhcmcsIHNjb3BlLCAoYXJnMikgPT4gYXJnMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwic3RyaW5nXCIgfSkgOiBhcmcyLnR5cGUgPT09IFwiYXJyYXlcIiA/IHsgdHlwZTogXCJudW1iZXJcIiB9IDogeyB0eXBlOiBcIm51bGxcIiB9KTtcbiAgICB9XG4gICAgY2FzZSBcImdsb2JhbC5kYXRlVGltZVwiOiB7XG4gICAgICBjb25zdCBhcmcgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzBdLCBzY29wZSB9KTtcbiAgICAgIHJldHVybiBtYXBOb2RlKGFyZywgc2NvcGUsIChhcmcyKSA9PiBhcmcyLnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJzdHJpbmdcIiB9KSA6IGFyZzIudHlwZSA9PT0gXCJzdHJpbmdcIiA/IG51bGxVbmlvbih7IHR5cGU6IFwic3RyaW5nXCIgfSkgOiB7IHR5cGU6IFwibnVsbFwiIH0pO1xuICAgIH1cbiAgICBjYXNlIFwiZ2xvYmFsLmxlbmd0aFwiOiB7XG4gICAgICBjb25zdCBhcmcgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzBdLCBzY29wZSB9KTtcbiAgICAgIHJldHVybiBtYXBOb2RlKGFyZywgc2NvcGUsIChhcmcyKSA9PiBhcmcyLnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJudW1iZXJcIiB9KSA6IGFyZzIudHlwZSA9PT0gXCJhcnJheVwiIHx8IGFyZzIudHlwZSA9PT0gXCJzdHJpbmdcIiA/IHsgdHlwZTogXCJudW1iZXJcIiB9IDogeyB0eXBlOiBcIm51bGxcIiB9KTtcbiAgICB9XG4gICAgY2FzZSBcImdsb2JhbC5yZWZlcmVuY2VzXCI6XG4gICAgICByZXR1cm4geyB0eXBlOiBcImJvb2xlYW5cIiB9O1xuICAgIGNhc2UgXCJnbG9iYWwucm91bmRcIjoge1xuICAgICAgY29uc3QgbnVtTm9kZSA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUobnVtTm9kZSwgc2NvcGUsIChudW0pID0+IHtcbiAgICAgICAgaWYgKG51bS50eXBlID09PSBcInVua25vd25cIilcbiAgICAgICAgICByZXR1cm4gbnVsbFVuaW9uKHsgdHlwZTogXCJudW1iZXJcIiB9KTtcbiAgICAgICAgaWYgKG51bS50eXBlICE9PSBcIm51bWJlclwiKVxuICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwibnVsbFwiIH07XG4gICAgICAgIGlmIChub2RlLmFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgY29uc3QgcHJlY2lzaW9uTm9kZSA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMV0sIHNjb3BlIH0pO1xuICAgICAgICAgIHJldHVybiBtYXBOb2RlKHByZWNpc2lvbk5vZGUsIHNjb3BlLCAocHJlY2lzaW9uKSA9PiBwcmVjaXNpb24udHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcIm51bWJlclwiIH0pIDogcHJlY2lzaW9uLnR5cGUgIT09IFwibnVtYmVyXCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiB7IHR5cGU6IFwibnVtYmVyXCIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJudW1iZXJcIiB9O1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNhc2UgXCJnbG9iYWwuc3RyaW5nXCI6IHtcbiAgICAgIGNvbnN0IGFyZyA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUoYXJnLCBzY29wZSwgKG5vZGUyKSA9PiBub2RlMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwic3RyaW5nXCIgfSkgOiBub2RlMi50eXBlID09PSBcInN0cmluZ1wiIHx8IG5vZGUyLnR5cGUgPT09IFwibnVtYmVyXCIgfHwgbm9kZTIudHlwZSA9PT0gXCJib29sZWFuXCIgPyBub2RlMi52YWx1ZSA/IHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgdmFsdWU6IG5vZGUyLnZhbHVlLnRvU3RyaW5nKClcbiAgICAgIH0gOiB7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgIH0gOiB7IHR5cGU6IFwibnVsbFwiIH0pO1xuICAgIH1cbiAgICBjYXNlIFwibWF0aC5zdW1cIjoge1xuICAgICAgY29uc3QgdmFsdWVzID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1swXSwgc2NvcGUgfSk7XG4gICAgICByZXR1cm4gbWFwTm9kZSh2YWx1ZXMsIHNjb3BlLCAobm9kZTIpID0+IG5vZGUyLnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJudW1iZXJcIiB9KSA6IG5vZGUyLnR5cGUgIT09IFwiYXJyYXlcIiA/IHsgdHlwZTogXCJudWxsXCIgfSA6IG1hcE5vZGUobm9kZTIub2YsIHNjb3BlLCAobm9kZTMpID0+IG5vZGUzLnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJudW1iZXJcIiB9KSA6IG5vZGUzLnR5cGUgPT09IFwibnVtYmVyXCIgfHwgbm9kZTMudHlwZSA9PT0gXCJudWxsXCIgPyB7IHR5cGU6IFwibnVtYmVyXCIgfSA6IHsgdHlwZTogXCJudWxsXCIgfSkpO1xuICAgIH1cbiAgICBjYXNlIFwibWF0aC5hdmdcIjoge1xuICAgICAgY29uc3QgdmFsdWVzID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1swXSwgc2NvcGUgfSk7XG4gICAgICByZXR1cm4gbWFwTm9kZSh2YWx1ZXMsIHNjb3BlLCAobm9kZTIpID0+IG5vZGUyLnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJudW1iZXJcIiB9KSA6IG5vZGUyLnR5cGUgIT09IFwiYXJyYXlcIiA/IHsgdHlwZTogXCJudWxsXCIgfSA6IG1hcE5vZGUobm9kZTIub2YsIHNjb3BlLCAobm9kZTMpID0+IG5vZGUzLnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJudW1iZXJcIiB9KSA6IG5vZGUzLnR5cGUgPT09IFwibnVtYmVyXCIgPyB7IHR5cGU6IFwibnVtYmVyXCIgfSA6IHsgdHlwZTogXCJudWxsXCIgfSkpO1xuICAgIH1cbiAgICBjYXNlIFwibWF0aC5tYXhcIjpcbiAgICBjYXNlIFwibWF0aC5taW5cIjoge1xuICAgICAgY29uc3QgdmFsdWVzID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1swXSwgc2NvcGUgfSk7XG4gICAgICByZXR1cm4gbWFwTm9kZSh2YWx1ZXMsIHNjb3BlLCAobm9kZTIpID0+IG5vZGUyLnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJudW1iZXJcIiB9KSA6IG5vZGUyLnR5cGUgIT09IFwiYXJyYXlcIiA/IHsgdHlwZTogXCJudWxsXCIgfSA6IG1hcE5vZGUobm9kZTIub2YsIHNjb3BlLCAobm9kZTMpID0+IG5vZGUzLnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJudW1iZXJcIiB9KSA6IG5vZGUzLnR5cGUgPT09IFwibnVtYmVyXCIgPyBub2RlMyA6IHsgdHlwZTogXCJudWxsXCIgfSkpO1xuICAgIH1cbiAgICBjYXNlIFwicHQudGV4dFwiOlxuICAgICAgcmV0dXJuIG5vZGUuYXJncy5sZW5ndGggPT09IDAgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiB7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgIH07XG4gICAgY2FzZSBcInN0cmluZy5zdGFydHNXaXRoXCI6IHtcbiAgICAgIGNvbnN0IHN0clR5cGVOb2RlID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1swXSwgc2NvcGUgfSksIHByZWZpeFR5cGVOb2RlID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1sxXSwgc2NvcGUgfSk7XG4gICAgICByZXR1cm4gbWFwTm9kZShzdHJUeXBlTm9kZSwgc2NvcGUsIChzdHJOb2RlKSA9PiBtYXBOb2RlKHByZWZpeFR5cGVOb2RlLCBzY29wZSwgKHByZWZpeE5vZGUpID0+IHN0ck5vZGUudHlwZSA9PT0gXCJ1bmtub3duXCIgfHwgcHJlZml4Tm9kZS50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwiYm9vbGVhblwiIH0pIDogc3RyTm9kZS50eXBlICE9PSBcInN0cmluZ1wiIHx8IHByZWZpeE5vZGUudHlwZSAhPT0gXCJzdHJpbmdcIiA/IHsgdHlwZTogXCJudWxsXCIgfSA6IHsgdHlwZTogXCJib29sZWFuXCIgfSkpO1xuICAgIH1cbiAgICBjYXNlIFwic3RyaW5nLnNwbGl0XCI6IHtcbiAgICAgIGNvbnN0IHN0clR5cGVOb2RlID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1swXSwgc2NvcGUgfSksIHNlcFR5cGVOb2RlID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1sxXSwgc2NvcGUgfSk7XG4gICAgICByZXR1cm4gbWFwTm9kZShzdHJUeXBlTm9kZSwgc2NvcGUsIChzdHJOb2RlKSA9PiBtYXBOb2RlKHNlcFR5cGVOb2RlLCBzY29wZSwgKHNlcE5vZGUpID0+IHN0ck5vZGUudHlwZSA9PT0gXCJ1bmtub3duXCIgfHwgc2VwTm9kZS50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwiYXJyYXlcIiwgb2Y6IHsgdHlwZTogXCJzdHJpbmdcIiB9IH0pIDogc3RyTm9kZS50eXBlICE9PSBcInN0cmluZ1wiIHx8IHNlcE5vZGUudHlwZSAhPT0gXCJzdHJpbmdcIiA/IHsgdHlwZTogXCJudWxsXCIgfSA6IHsgdHlwZTogXCJhcnJheVwiLCBvZjogeyB0eXBlOiBcInN0cmluZ1wiIH0gfSkpO1xuICAgIH1cbiAgICBjYXNlIFwic2FuaXR5LnZlcnNpb25PZlwiOiB7XG4gICAgICBjb25zdCB0eXBlTm9kZSA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUodHlwZU5vZGUsIHNjb3BlLCAodHlwZU5vZGUyKSA9PiB0eXBlTm9kZTIudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcImJvb2xlYW5cIiB9KSA6IHR5cGVOb2RlMi50eXBlICE9PSBcInN0cmluZ1wiID8geyB0eXBlOiBcIm51bGxcIiB9IDogeyB0eXBlOiBcImJvb2xlYW5cIiB9KTtcbiAgICB9XG4gICAgY2FzZSBcInNhbml0eS5wYXJ0T2ZSZWxlYXNlXCI6IHtcbiAgICAgIGNvbnN0IHR5cGVOb2RlID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1swXSwgc2NvcGUgfSk7XG4gICAgICByZXR1cm4gbWFwTm9kZSh0eXBlTm9kZSwgc2NvcGUsICh0eXBlTm9kZTIpID0+IHR5cGVOb2RlMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwiYm9vbGVhblwiIH0pIDogdHlwZU5vZGUyLnR5cGUgIT09IFwic3RyaW5nXCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiB7IHR5cGU6IFwiYm9vbGVhblwiIH0pO1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ1bmtub3duXCIgfTtcbiAgfVxufVxuZnVuY3Rpb24gbWF0Y2gobGVmdCwgcmlnaHQpIHtcbiAgbGV0IHRva2VucyA9IFtdLCBwYXR0ZXJucyA9IFtdO1xuICBpZiAobGVmdC50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKGxlZnQudmFsdWUgPT09IHZvaWQgMClcbiAgICAgIHJldHVybjtcbiAgICB0b2tlbnMgPSB0b2tlbnMuY29uY2F0KG1hdGNoVG9rZW5pemUobGVmdC52YWx1ZSkpO1xuICB9XG4gIGlmIChsZWZ0LnR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgIGlmIChsZWZ0Lm9mLnR5cGUgPT09IFwidW5rbm93blwiKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChsZWZ0Lm9mLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmIChsZWZ0Lm9mLnZhbHVlID09PSB2b2lkIDApXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRva2VucyA9IHRva2Vucy5jb25jYXQobWF0Y2hUb2tlbml6ZShsZWZ0Lm9mLnZhbHVlKSk7XG4gICAgfVxuICAgIGlmIChsZWZ0Lm9mLnR5cGUgPT09IFwidW5pb25cIilcbiAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBsZWZ0Lm9mLm9mKVxuICAgICAgICBub2RlLnR5cGUgPT09IFwic3RyaW5nXCIgJiYgbm9kZS52YWx1ZSAhPT0gdm9pZCAwICYmICh0b2tlbnMgPSB0b2tlbnMuY29uY2F0KG1hdGNoVG9rZW5pemUobm9kZS52YWx1ZSkpKTtcbiAgfVxuICBpZiAocmlnaHQudHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChyaWdodC52YWx1ZSA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuO1xuICAgIHBhdHRlcm5zID0gcGF0dGVybnMuY29uY2F0KG1hdGNoQW5hbHl6ZVBhdHRlcm4ocmlnaHQudmFsdWUpKTtcbiAgfVxuICBpZiAocmlnaHQudHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgaWYgKHJpZ2h0Lm9mLnR5cGUgPT09IFwidW5rbm93blwiKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChyaWdodC5vZi50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAocmlnaHQub2YudmFsdWUgPT09IHZvaWQgMClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgcGF0dGVybnMgPSBwYXR0ZXJucy5jb25jYXQobWF0Y2hBbmFseXplUGF0dGVybihyaWdodC5vZi52YWx1ZSkpO1xuICAgIH1cbiAgICBpZiAocmlnaHQub2YudHlwZSA9PT0gXCJ1bmlvblwiKVxuICAgICAgZm9yIChjb25zdCBub2RlIG9mIHJpZ2h0Lm9mLm9mKSB7XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBpZiAobm9kZS52YWx1ZSA9PT0gdm9pZCAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIHBhdHRlcm5zID0gcGF0dGVybnMuY29uY2F0KG1hdGNoQW5hbHl6ZVBhdHRlcm4obm9kZS52YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnR5cGUgIT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICB9XG4gIHJldHVybiBtYXRjaFRleHQodG9rZW5zLCBwYXR0ZXJucyk7XG59XG5jb25zdCAkdHJhY2UgPSBkZWJ1ZyhcInR5cGVFdmFsdWF0b3I6ZXZhbHVhdGU6dHJhY2VcIik7XG4kdHJhY2UubG9nID0gY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbmNvbnN0ICRkZWJ1ZyA9IGRlYnVnKFwidHlwZUV2YWx1YXRvcjpldmFsdWF0ZTpkZWJ1Z1wiKTtcbiRkZWJ1Zy5sb2cgPSBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuY29uc3QgJHdhcm4gPSBkZWJ1ZyhcInR5cGVFdmFsdWF0b3I6ZXZhbHVhdGU6d2FyblwiKTtcbmZ1bmN0aW9uIHR5cGVFdmFsdWF0ZShhc3QsIHNjaGVtYSkge1xuICAkZGVidWcoXCJldmFsdWF0ZVF1ZXJ5VHlwZS5hc3QgJU9cIiwgYXN0KSwgJGRlYnVnKFwiZXZhbHVhdGVRdWVyeVR5cGUuc2NoZW1hICVPXCIsIHNjaGVtYSk7XG4gIGNvbnN0IHBhcnNlZCA9IHdhbGsoe1xuICAgIG5vZGU6IGFzdCxcbiAgICBzY29wZTogbmV3IFNjb3BlMihbXSwgdm9pZCAwLCBuZXcgQ29udGV4dChzY2hlbWEpKVxuICB9KTtcbiAgJHRyYWNlKFwiZXZhbHVhdGVRdWVyeVR5cGUucGFyc2VkICVPXCIsIHBhcnNlZCk7XG4gIGNvbnN0IG9wdGltaXplZCA9IG9wdGltaXplVW5pb25zKHBhcnNlZCk7XG4gIHJldHVybiAkZGVidWcoXCJldmFsdWF0ZVF1ZXJ5VHlwZS5vcHRpbWl6ZWQgJU9cIiwgb3B0aW1pemVkKSwgb3B0aW1pemVkO1xufVxuZnVuY3Rpb24gbWFwRGVyZWYoYmFzZSwgc2NvcGUpIHtcbiAgcmV0dXJuIGJhc2UudHlwZSA9PT0gXCJ1bmlvblwiID8ge1xuICAgIHR5cGU6IFwidW5pb25cIixcbiAgICBvZjogYmFzZS5vZi5tYXAoKG5vZGUpID0+IG1hcERlcmVmKG5vZGUsIHNjb3BlKSlcbiAgfSA6IGJhc2UudHlwZSA9PT0gXCJhcnJheVwiID8ge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBvZjogbWFwRGVyZWYoYmFzZS5vZiwgc2NvcGUpXG4gIH0gOiBiYXNlLnR5cGUgPT09IFwib2JqZWN0XCIgJiYgYmFzZS5kZXJlZmVyZW5jZXNUbyAhPT0gdm9pZCAwID8gc2NvcGUuY29udGV4dC5sb29rdXBSZWYoYmFzZS5kZXJlZmVyZW5jZXNUbykgOiB7IHR5cGU6IFwibnVsbFwiIH07XG59XG5mdW5jdGlvbiBoYW5kbGVEZXJlZk5vZGUobm9kZSwgc2NvcGUpIHtcbiAgJHRyYWNlKFwiZGVyZWYubm9kZSAlT1wiLCBub2RlKTtcbiAgY29uc3QgYmFzZSA9IHdhbGsoeyBub2RlOiBub2RlLmJhc2UsIHNjb3BlIH0pO1xuICBpZiAoJHRyYWNlKFwiZGVyZWYuYmFzZSAlT1wiLCBiYXNlKSwgYmFzZS50eXBlID09PSBcIm51bGxcIiB8fCBiYXNlLnR5cGUgPT09IFwidW5rbm93blwiKVxuICAgIHJldHVybiB7IHR5cGU6IFwibnVsbFwiIH07XG4gIGNvbnN0IGRlcmVmZWROb2RlID0gbWFwRGVyZWYoYmFzZSwgc2NvcGUpO1xuICByZXR1cm4gJHRyYWNlKFwiZGVyZWYuZGVyZWZlZE5vZGUgJU9cIiwgZGVyZWZlZE5vZGUpLCBkZXJlZmVkTm9kZTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU9iamVjdFNwbGF0Tm9kZShhdHRyLCBzY29wZSkge1xuICBjb25zdCB2YWx1ZSA9IHdhbGsoeyBub2RlOiBhdHRyLnZhbHVlLCBzY29wZSB9KTtcbiAgcmV0dXJuICR0cmFjZShcIm9iamVjdC5zcGxhdC52YWx1ZSAlT1wiLCB2YWx1ZSksIG1hcE5vZGUodmFsdWUsIHNjb3BlLCAobm9kZSkgPT4ge1xuICAgIGlmIChub2RlLnR5cGUgPT09IFwidW5rbm93blwiKVxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ1bmtub3duXCIgfTtcbiAgICBpZiAobm9kZS50eXBlICE9PSBcIm9iamVjdFwiKVxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJvYmplY3RcIiwgYXR0cmlidXRlczoge30gfTtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0ge307XG4gICAgZm9yIChjb25zdCBuYW1lIGluIG5vZGUuYXR0cmlidXRlcylcbiAgICAgIG5vZGUuYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiAoYXR0cmlidXRlc1tuYW1lXSA9IG5vZGUuYXR0cmlidXRlc1tuYW1lXSk7XG4gICAgaWYgKG5vZGUucmVzdCAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCByZXNvbHZlZFJlc3QgPSByZXNvbHZlSW5saW5lKG5vZGUucmVzdCwgc2NvcGUpO1xuICAgICAgaWYgKHJlc29sdmVkUmVzdC50eXBlID09PSBcInVua25vd25cIilcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJ1bmtub3duXCIgfTtcbiAgICAgIGlmIChyZXNvbHZlZFJlc3QudHlwZSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJudWxsXCIgfTtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBpbiByZXNvbHZlZFJlc3QuYXR0cmlidXRlcylcbiAgICAgICAgcmVzb2x2ZWRSZXN0LmF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgKGF0dHJpYnV0ZXNbbmFtZV0gPSByZXNvbHZlZFJlc3QuYXR0cmlidXRlc1tuYW1lXSk7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6IFwib2JqZWN0XCIsIGF0dHJpYnV0ZXMgfTtcbiAgfSk7XG59XG5mdW5jdGlvbiBoYW5kbGVPYmplY3ROb2RlKG5vZGUsIHNjb3BlKSB7XG4gIGlmICgkdHJhY2UoXCJvYmplY3Qubm9kZSAlT1wiLCBub2RlKSwgbm9kZS5hdHRyaWJ1dGVzLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgIGF0dHJpYnV0ZXM6IHt9XG4gICAgfTtcbiAgY29uc3Qgb2JqZWN0QXR0cmlidXRlcyA9IFtdLCBzcGxhdFZhcmlhbnRzID0gW10sIGNvbmRpdGlvbmFsVmFyaWFudHMgPSBbXTtcbiAgZm9yIChjb25zdCBbaWR4LCBhdHRyXSBvZiBub2RlLmF0dHJpYnV0ZXMuZW50cmllcygpKSB7XG4gICAgaWYgKGF0dHIudHlwZSA9PT0gXCJPYmplY3RBdHRyaWJ1dGVWYWx1ZVwiKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVOb2RlID0gd2Fsayh7IG5vZGU6IGF0dHIudmFsdWUsIHNjb3BlIH0pO1xuICAgICAgb2JqZWN0QXR0cmlidXRlcy5wdXNoKFtcbiAgICAgICAgaWR4LFxuICAgICAgICBhdHRyLm5hbWUsXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcIm9iamVjdEF0dHJpYnV0ZVwiLFxuICAgICAgICAgIHZhbHVlOiBhdHRyaWJ1dGVOb2RlXG4gICAgICAgIH1cbiAgICAgIF0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChhdHRyLnR5cGUgPT09IFwiT2JqZWN0U3BsYXRcIikge1xuICAgICAgY29uc3QgYXR0cmlidXRlTm9kZSA9IGhhbmRsZU9iamVjdFNwbGF0Tm9kZShhdHRyLCBzY29wZSk7XG4gICAgICBzd2l0Y2ggKCR0cmFjZShcIm9iamVjdC5zcGxhdC5yZXN1bHQgJU9cIiwgYXR0cmlidXRlTm9kZSksIGF0dHJpYnV0ZU5vZGUudHlwZSkge1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6IHtcbiAgICAgICAgICBzcGxhdFZhcmlhbnRzLnB1c2goW2lkeCwgYXR0cmlidXRlTm9kZV0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ1bmlvblwiOiB7XG4gICAgICAgICAgZm9yIChjb25zdCBub2RlMiBvZiBhdHRyaWJ1dGVOb2RlLm9mKVxuICAgICAgICAgICAgaWYgKG5vZGUyLnR5cGUgPT09IFwidW5rbm93blwiKVxuICAgICAgICAgICAgICByZXR1cm4gbm9kZTI7XG4gICAgICAgICAgc3BsYXRWYXJpYW50cy5wdXNoKFtpZHgsIGF0dHJpYnV0ZU5vZGVdKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwidW5rbm93blwiIH07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhdHRyLnR5cGUgPT09IFwiT2JqZWN0Q29uZGl0aW9uYWxTcGxhdFwiKSB7XG4gICAgICBjb25zdCBjb25kaXRpb24gPSBib29sZWFuVmFsdWUod2Fsayh7IG5vZGU6IGF0dHIuY29uZGl0aW9uLCBzY29wZSB9KSwgc2NvcGUpO1xuICAgICAgaWYgKCR0cmFjZShcIm9iamVjdC5jb25kaXRpb25hbC5zcGxhdC5jb25kaXRpb24gJU9cIiwgY29uZGl0aW9uKSwgY29uZGl0aW9uLmNhbkJlVHJ1ZSA9PT0gITEpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgYXR0cmlidXRlTm9kZSA9IGhhbmRsZU9iamVjdFNwbGF0Tm9kZShhdHRyLCBzY29wZSk7XG4gICAgICBpZiAoJHRyYWNlKFwib2JqZWN0LmNvbmRpdGlvbmFsLnNwbGF0LnJlc3VsdCAlT1wiLCBhdHRyaWJ1dGVOb2RlKSwgY29uZGl0aW9uLmNhbkJlRmFsc2UgPT09ICExICYmIGNvbmRpdGlvbi5jYW5CZU51bGwgPT09ICExKVxuICAgICAgICBzd2l0Y2ggKGF0dHJpYnV0ZU5vZGUudHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjoge1xuICAgICAgICAgICAgc3BsYXRWYXJpYW50cy5wdXNoKFtpZHgsIGF0dHJpYnV0ZU5vZGVdKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwidW5pb25cIjoge1xuICAgICAgICAgICAgZm9yIChjb25zdCBub2RlMiBvZiBhdHRyaWJ1dGVOb2RlLm9mKVxuICAgICAgICAgICAgICBpZiAobm9kZTIudHlwZSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcInVua25vd25cIiB9O1xuICAgICAgICAgICAgc3BsYXRWYXJpYW50cy5wdXNoKFtpZHgsIGF0dHJpYnV0ZU5vZGVdKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJ1bmtub3duXCIgfTtcbiAgICAgICAgfVxuICAgICAgY29uc3QgdmFyaWFudCA9IG1hcE5vZGUoYXR0cmlidXRlTm9kZSwgc2NvcGUsIChhdHRyaWJ1dGVOb2RlMikgPT4gKCR0cmFjZShcIm9iamVjdC5jb25kaXRpb25hbC5zcGxhdC5yZXN1bHQuY29uY3JldGUgJU9cIiwgYXR0cmlidXRlTm9kZTIpLCBhdHRyaWJ1dGVOb2RlMi50eXBlICE9PSBcIm9iamVjdFwiID8geyB0eXBlOiBcInVua25vd25cIiB9IDoge1xuICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVOb2RlMi5hdHRyaWJ1dGVzXG4gICAgICB9KSk7XG4gICAgICBpZiAodmFyaWFudC50eXBlID09PSBcInVuaW9uXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBub2RlMiBvZiB2YXJpYW50Lm9mKVxuICAgICAgICAgIGlmIChub2RlMi50eXBlICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJ1bmtub3duXCIgfTtcbiAgICAgICAgdmFyaWFudC5vZi5wdXNoKHsgdHlwZTogXCJvYmplY3RcIiwgYXR0cmlidXRlczoge30gfSksIGNvbmRpdGlvbmFsVmFyaWFudHMucHVzaChbaWR4LCB2YXJpYW50XSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHZhcmlhbnQudHlwZSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJ1bmtub3duXCIgfTtcbiAgICAgIGNvbmRpdGlvbmFsVmFyaWFudHMucHVzaChbXG4gICAgICAgIGlkeCxcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwidW5pb25cIixcbiAgICAgICAgICBvZjogW3sgdHlwZTogXCJvYmplY3RcIiwgYXR0cmlidXRlczoge30gfSwgdmFyaWFudF1cbiAgICAgICAgfVxuICAgICAgXSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIG9iamVjdCBhdHRyaWJ1dGUgdHlwZTogJHthdHRyLnR5cGV9YCk7XG4gIH1cbiAgY29uc3QgZ3VhcmFudGVlZEF0dHJpYnV0ZXMgPSBbXTtcbiAgZ3VhcmFudGVlZEF0dHJpYnV0ZXMucHVzaCguLi5vYmplY3RBdHRyaWJ1dGVzKTtcbiAgZm9yIChjb25zdCBbaWR4LCBzcGxhdE5vZGVdIG9mIHNwbGF0VmFyaWFudHMpIHtcbiAgICBpZiAoc3BsYXROb2RlLnR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBzcGxhdE5vZGUuYXR0cmlidXRlcykge1xuICAgICAgICBpZiAoIXNwbGF0Tm9kZS5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KG5hbWUpKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGUgPSBzcGxhdE5vZGUuYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgZ3VhcmFudGVlZEF0dHJpYnV0ZXMucHVzaChbaWR4LCBuYW1lLCBhdHRyaWJ1dGVdKTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25kaXRpb25hbFZhcmlhbnRzLnB1c2goW2lkeCwgc3BsYXROb2RlXSk7XG4gIH1cbiAgaWYgKGd1YXJhbnRlZWRBdHRyaWJ1dGVzLnNvcnQoKFthXSwgW2JdKSA9PiBhIC0gYiksIGNvbmRpdGlvbmFsVmFyaWFudHMubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgYXR0cmlidXRlczogT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICBndWFyYW50ZWVkQXR0cmlidXRlcy5tYXAoKFssIG5hbWUsIGF0dHJpYnV0ZV0pID0+IFtuYW1lLCBhdHRyaWJ1dGVdKVxuICAgICAgKVxuICAgIH07XG4gIGNvbnN0IG1hdHJpeCA9IFtdO1xuICBmb3IgKGNvbnN0IFt1bmlvbklkeCwgdW5pb25dIG9mIGNvbmRpdGlvbmFsVmFyaWFudHMpIHtcbiAgICBjb25zdCB1bmlvbkd1YXJhbnRlZWRCZWZvcmUgPSBbXSwgdW5pb25HdWFyYW50ZWVkQWZ0ZXIgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtndWFyYW50ZWVkSW5kZXgsIG5hbWUsIGF0dHJpYnV0ZV0gb2YgZ3VhcmFudGVlZEF0dHJpYnV0ZXMpXG4gICAgICBndWFyYW50ZWVkSW5kZXggPCB1bmlvbklkeCAmJiB1bmlvbkd1YXJhbnRlZWRCZWZvcmUucHVzaChbZ3VhcmFudGVlZEluZGV4LCBuYW1lLCBhdHRyaWJ1dGVdKSwgZ3VhcmFudGVlZEluZGV4ID4gdW5pb25JZHggJiYgdW5pb25HdWFyYW50ZWVkQWZ0ZXIucHVzaChbZ3VhcmFudGVlZEluZGV4LCBuYW1lLCBhdHRyaWJ1dGVdKTtcbiAgICBjb25zdCBhbGxWYXJpYW50c0F0dHJpYnV0ZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtjb25kaXRpb25hbFZhcmlhbnRJZHgsIG90aGVyVW5pb25dIG9mIGNvbmRpdGlvbmFsVmFyaWFudHMpIHtcbiAgICAgIGNvbnN0IHZhcmlhbnRBdHRyaWJ1dGVzID0gW107XG4gICAgICBmb3IgKGNvbnN0IG5vZGUyIG9mIG90aGVyVW5pb24ub2YpXG4gICAgICAgIHZhcmlhbnRBdHRyaWJ1dGVzLnB1c2gobm9kZTIuYXR0cmlidXRlcyk7XG4gICAgICBhbGxWYXJpYW50c0F0dHJpYnV0ZXMucHVzaChbY29uZGl0aW9uYWxWYXJpYW50SWR4LCB2YXJpYW50QXR0cmlidXRlc10pO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG5vZGUyIG9mIHVuaW9uLm9mKSB7XG4gICAgICBtYXRyaXgucHVzaCh7XG4gICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAuLi5PYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgICB1bmlvbkd1YXJhbnRlZWRCZWZvcmUubWFwKChbLCBuYW1lLCBhdHRyaWJ1dGVdKSA9PiBbbmFtZSwgYXR0cmlidXRlXSlcbiAgICAgICAgICApLFxuICAgICAgICAgIC4uLm5vZGUyLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgLi4uT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgICAgdW5pb25HdWFyYW50ZWVkQWZ0ZXIubWFwKChbLCBuYW1lLCBhdHRyaWJ1dGVdKSA9PiBbbmFtZSwgYXR0cmlidXRlXSlcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZm9yIChjb25zdCBbb3V0ZXJJZHgsIG91dGVyQXR0cmlidXRlc10gb2YgYWxsVmFyaWFudHNBdHRyaWJ1dGVzKVxuICAgICAgICBmb3IgKGNvbnN0IG91dGVyIG9mIG91dGVyQXR0cmlidXRlcylcbiAgICAgICAgICBmb3IgKGNvbnN0IFtpbm5lcklkeCwgaW5uZXJBdHRyaWJ1dGVzXSBvZiBhbGxWYXJpYW50c0F0dHJpYnV0ZXMpXG4gICAgICAgICAgICBpZiAob3V0ZXJJZHggIT09IGlubmVySWR4KVxuICAgICAgICAgICAgICBmb3IgKGNvbnN0IGlubmVyIG9mIGlubmVyQXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IF9iZWZvcmUgPSBbLi4udW5pb25HdWFyYW50ZWVkQmVmb3JlXSwgX2FmdGVyID0gWy4uLnVuaW9uR3VhcmFudGVlZEFmdGVyXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gb3V0ZXIpXG4gICAgICAgICAgICAgICAgICBvdXRlci5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBvdXRlcklkeCAhPT0gdW5pb25JZHggJiYgKG91dGVySWR4IDwgdW5pb25JZHggJiYgX2JlZm9yZS5wdXNoKFtvdXRlcklkeCwgbmFtZSwgb3V0ZXJbbmFtZV1dKSwgb3V0ZXJJZHggPiB1bmlvbklkeCAmJiBfYWZ0ZXIucHVzaChbb3V0ZXJJZHgsIG5hbWUsIG91dGVyW25hbWVdXSkpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBpbm5lcilcbiAgICAgICAgICAgICAgICAgIGlubmVyLmhhc093blByb3BlcnR5KG5hbWUpICYmIG91dGVySWR4ICE9PSB1bmlvbklkeCAmJiAoaW5uZXJJZHggPCB1bmlvbklkeCAmJiBfYmVmb3JlLnB1c2goW2lubmVySWR4LCBuYW1lLCBpbm5lcltuYW1lXV0pLCBpbm5lcklkeCA+IHVuaW9uSWR4ICYmIF9hZnRlci5wdXNoKFtpbm5lcklkeCwgbmFtZSwgaW5uZXJbbmFtZV1dKSk7XG4gICAgICAgICAgICAgICAgX2JlZm9yZS5zb3J0KChbYV0sIFtiXSkgPT4gYSAtIGIpLCBfYWZ0ZXIuc29ydCgoW2FdLCBbYl0pID0+IGEgLSBiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBiZWZvcmUgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgICAgICAgICBfYmVmb3JlLm1hcCgoWywgbmFtZSwgYXR0cmlidXRlXSkgPT4gW25hbWUsIGF0dHJpYnV0ZV0pXG4gICAgICAgICAgICAgICAgKSwgYWZ0ZXIgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgICAgICAgICBfYWZ0ZXIubWFwKChbLCBuYW1lLCBhdHRyaWJ1dGVdKSA9PiBbbmFtZSwgYXR0cmlidXRlXSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIG1hdHJpeC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmJlZm9yZSxcbiAgICAgICAgICAgICAgICAgICAgLi4ubm9kZTIuYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgLi4uYWZ0ZXJcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3B0aW1pemVVbmlvbnMoe1xuICAgIHR5cGU6IFwidW5pb25cIixcbiAgICBvZjogbWF0cml4XG4gIH0pO1xufVxuZnVuY3Rpb24gaGFuZGxlT3BDYWxsTm9kZShub2RlLCBzY29wZSkge1xuICAkdHJhY2UoXCJvcGNhbGwubm9kZSAlT1wiLCBub2RlKTtcbiAgY29uc3QgbGhzID0gd2Fsayh7IG5vZGU6IG5vZGUubGVmdCwgc2NvcGUgfSksIHJocyA9IHdhbGsoeyBub2RlOiBub2RlLnJpZ2h0LCBzY29wZSB9KTtcbiAgcmV0dXJuIG1hcE5vZGUoXG4gICAgbGhzLFxuICAgIHNjb3BlLFxuICAgIChsZWZ0KSA9PiAoXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eSwgbWF4LXN0YXRlbWVudHNcbiAgICAgIG1hcE5vZGUocmhzLCBzY29wZSwgKHJpZ2h0KSA9PiB7XG4gICAgICAgIHN3aXRjaCAoJHRyYWNlKCdvcGNhbGwubm9kZS5jb25jcmV0ZSBcIiVzXCIgJU8nLCBub2RlLm9wLCB7IGxlZnQsIHJpZ2h0IH0pLCBub2RlLm9wKSB7XG4gICAgICAgICAgY2FzZSBcIj09XCI6XG4gICAgICAgICAgICByZXR1cm4gbGVmdC50eXBlID09PSBcInVua25vd25cIiB8fCByaWdodC50eXBlID09PSBcInVua25vd25cIiA/IHsgdHlwZTogXCJib29sZWFuXCIgfSA6IGxlZnQudHlwZSAhPT0gcmlnaHQudHlwZSA/IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiAhMVxuICAgICAgICAgICAgfSA6IGxlZnQudHlwZSA9PT0gXCJudWxsXCIgPyB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICB2YWx1ZTogITBcbiAgICAgICAgICAgIH0gOiAhaXNQcmltaXRpdmVUeXBlTm9kZShsZWZ0KSB8fCAhaXNQcmltaXRpdmVUeXBlTm9kZShyaWdodCkgPyB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICB2YWx1ZTogITFcbiAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZXZhbHVhdGVDb21wYXJpc29uKG5vZGUub3AsIGxlZnQsIHJpZ2h0KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICBjYXNlIFwiIT1cIjoge1xuICAgICAgICAgICAgaWYgKGxlZnQudHlwZSA9PT0gXCJ1bmtub3duXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJ1bmtub3duXCIpXG4gICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiYm9vbGVhblwiIH07XG4gICAgICAgICAgICBpZiAobGVmdC50eXBlICE9PSByaWdodC50eXBlKVxuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAhMFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGxlZnQudHlwZSA9PT0gXCJudWxsXCIpXG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICExXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIWlzUHJpbWl0aXZlVHlwZU5vZGUobGVmdCkgfHwgIWlzUHJpbWl0aXZlVHlwZU5vZGUocmlnaHQpKVxuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAhMFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gZXZhbHVhdGVDb21wYXJpc29uKFwiPT1cIiwgbGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB2b2lkIDAgJiYgKHZhbHVlID0gIXZhbHVlKSwge1xuICAgICAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCI+XCI6XG4gICAgICAgICAgY2FzZSBcIj49XCI6XG4gICAgICAgICAgY2FzZSBcIjxcIjpcbiAgICAgICAgICBjYXNlIFwiPD1cIjpcbiAgICAgICAgICAgIHJldHVybiBsZWZ0LnR5cGUgPT09IFwidW5rbm93blwiIHx8IHJpZ2h0LnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJib29sZWFuXCIgfSkgOiBsZWZ0LnR5cGUgIT09IHJpZ2h0LnR5cGUgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiAhaXNQcmltaXRpdmVUeXBlTm9kZShsZWZ0KSB8fCAhaXNQcmltaXRpdmVUeXBlTm9kZShyaWdodCkgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZXZhbHVhdGVDb21wYXJpc29uKG5vZGUub3AsIGxlZnQsIHJpZ2h0KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICBjYXNlIFwiaW5cIjpcbiAgICAgICAgICAgIHJldHVybiBsZWZ0LnR5cGUgPT09IFwidW5rbm93blwiIHx8IHJpZ2h0LnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJib29sZWFuXCIgfSkgOiByaWdodC50eXBlICE9PSBcImFycmF5XCIgPyBpc0Z1bmNDYWxsKG5vZGUucmlnaHQsIFwiZ2xvYmFsOjpwYXRoXCIpID8geyB0eXBlOiBcImJvb2xlYW5cIiB9IDogeyB0eXBlOiBcIm51bGxcIiB9IDogIWlzUHJpbWl0aXZlVHlwZU5vZGUobGVmdCkgJiYgbGVmdC50eXBlICE9PSBcIm51bGxcIiA/IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiAhMVxuICAgICAgICAgICAgfSA6IG1hcE5vZGUocmlnaHQub2YsIHNjb3BlLCAoYXJyYXlUeXBlTm9kZSkgPT4gYXJyYXlUeXBlTm9kZS50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwiYm9vbGVhblwiIH0pIDogbGVmdC50eXBlID09PSBcIm51bGxcIiA/IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBhcnJheVR5cGVOb2RlLnR5cGUgPT09IFwibnVsbFwiXG4gICAgICAgICAgICB9IDogbGVmdC52YWx1ZSA9PT0gdm9pZCAwID8ge1xuICAgICAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIlxuICAgICAgICAgICAgfSA6IGlzUHJpbWl0aXZlVHlwZU5vZGUoYXJyYXlUeXBlTm9kZSkgPyBhcnJheVR5cGVOb2RlLnZhbHVlID09PSB2b2lkIDAgPyB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiXG4gICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgdmFsdWU6IGxlZnQudmFsdWUgPT09IGFycmF5VHlwZU5vZGUudmFsdWVcbiAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICB2YWx1ZTogITFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIGNhc2UgXCJtYXRjaFwiOlxuICAgICAgICAgICAgcmV0dXJuIGxlZnQudHlwZSA9PT0gXCJ1bmtub3duXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJ1bmtub3duXCIgPyB7IHR5cGU6IFwiYm9vbGVhblwiIH0gOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICB2YWx1ZTogbWF0Y2gobGVmdCwgcmlnaHQpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgICAgICByZXR1cm4gbGVmdC50eXBlID09PSBcInVua25vd25cIiB8fCByaWdodC50eXBlID09PSBcInVua25vd25cIiA/IHsgdHlwZTogXCJ1bmtub3duXCIgfSA6IGxlZnQudHlwZSA9PT0gXCJzdHJpbmdcIiAmJiByaWdodC50eXBlID09PSBcInN0cmluZ1wiID8ge1xuICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogbGVmdC52YWx1ZSAhPT0gdm9pZCAwICYmIHJpZ2h0LnZhbHVlICE9PSB2b2lkIDAgPyBsZWZ0LnZhbHVlICsgcmlnaHQudmFsdWUgOiB2b2lkIDBcbiAgICAgICAgICAgIH0gOiBsZWZ0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIiA/IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGxlZnQudmFsdWUgIT09IHZvaWQgMCAmJiByaWdodC52YWx1ZSAhPT0gdm9pZCAwID8gbGVmdC52YWx1ZSArIHJpZ2h0LnZhbHVlIDogdm9pZCAwXG4gICAgICAgICAgICB9IDogbGVmdC50eXBlID09PSBcImFycmF5XCIgJiYgcmlnaHQudHlwZSA9PT0gXCJhcnJheVwiID8ge1xuICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgIG9mOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1bmlvblwiLFxuICAgICAgICAgICAgICAgIG9mOiBbbGVmdC5vZiwgcmlnaHQub2ZdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gOiBsZWZ0LnR5cGUgPT09IFwib2JqZWN0XCIgJiYgcmlnaHQudHlwZSA9PT0gXCJvYmplY3RcIiA/IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgYXR0cmlidXRlczogeyAuLi5sZWZ0LmF0dHJpYnV0ZXMsIC4uLnJpZ2h0LmF0dHJpYnV0ZXMgfVxuICAgICAgICAgICAgfSA6IHsgdHlwZTogXCJudWxsXCIgfTtcbiAgICAgICAgICBjYXNlIFwiLVwiOlxuICAgICAgICAgICAgcmV0dXJuIGxlZnQudHlwZSA9PT0gXCJ1bmtub3duXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcIm51bWJlclwiIH0pIDogbGVmdC50eXBlID09PSBcIm51bWJlclwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIgPyB7XG4gICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBsZWZ0LnZhbHVlICE9PSB2b2lkIDAgJiYgcmlnaHQudmFsdWUgIT09IHZvaWQgMCA/IGxlZnQudmFsdWUgLSByaWdodC52YWx1ZSA6IHZvaWQgMFxuICAgICAgICAgICAgfSA6IHsgdHlwZTogXCJudWxsXCIgfTtcbiAgICAgICAgICBjYXNlIFwiKlwiOlxuICAgICAgICAgICAgcmV0dXJuIGxlZnQudHlwZSA9PT0gXCJ1bmtub3duXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcIm51bWJlclwiIH0pIDogbGVmdC50eXBlID09PSBcIm51bWJlclwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIgPyB7XG4gICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBsZWZ0LnZhbHVlICE9PSB2b2lkIDAgJiYgcmlnaHQudmFsdWUgIT09IHZvaWQgMCA/IGxlZnQudmFsdWUgKiByaWdodC52YWx1ZSA6IHZvaWQgMFxuICAgICAgICAgICAgfSA6IHsgdHlwZTogXCJudWxsXCIgfTtcbiAgICAgICAgICBjYXNlIFwiL1wiOlxuICAgICAgICAgICAgcmV0dXJuIGxlZnQudHlwZSA9PT0gXCJ1bmtub3duXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcIm51bWJlclwiIH0pIDogbGVmdC50eXBlID09PSBcIm51bWJlclwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIgPyB7XG4gICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBsZWZ0LnZhbHVlICE9PSB2b2lkIDAgJiYgcmlnaHQudmFsdWUgIT09IHZvaWQgMCA/IGxlZnQudmFsdWUgLyByaWdodC52YWx1ZSA6IHZvaWQgMFxuICAgICAgICAgICAgfSA6IHsgdHlwZTogXCJudWxsXCIgfTtcbiAgICAgICAgICBjYXNlIFwiKipcIjpcbiAgICAgICAgICAgIHJldHVybiBsZWZ0LnR5cGUgPT09IFwidW5rbm93blwiIHx8IHJpZ2h0LnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJudW1iZXJcIiB9KSA6IGxlZnQudHlwZSA9PT0gXCJudW1iZXJcIiAmJiByaWdodC50eXBlID09PSBcIm51bWJlclwiID8ge1xuICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICB2YWx1ZTogbGVmdC52YWx1ZSAhPT0gdm9pZCAwICYmIHJpZ2h0LnZhbHVlICE9PSB2b2lkIDAgPyBsZWZ0LnZhbHVlICoqIHJpZ2h0LnZhbHVlIDogdm9pZCAwXG4gICAgICAgICAgICB9IDogeyB0eXBlOiBcIm51bGxcIiB9O1xuICAgICAgICAgIGNhc2UgXCIlXCI6XG4gICAgICAgICAgICByZXR1cm4gbGVmdC50eXBlID09PSBcInVua25vd25cIiB8fCByaWdodC50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwibnVtYmVyXCIgfSkgOiBsZWZ0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIiA/IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGxlZnQudmFsdWUgIT09IHZvaWQgMCAmJiByaWdodC52YWx1ZSAhPT0gdm9pZCAwID8gbGVmdC52YWx1ZSAlIHJpZ2h0LnZhbHVlIDogdm9pZCAwXG4gICAgICAgICAgICB9IDogeyB0eXBlOiBcIm51bGxcIiB9O1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiBcInVua25vd25cIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApXG4gICk7XG59XG5mdW5jdGlvbiBoYW5kbGVTZWxlY3ROb2RlKG5vZGUsIHNjb3BlKSB7XG4gIGNvbnN0IHZhbHVlcyA9IFtdO1xuICBsZXQgZ3VhcmFudGVlZCA9ICExO1xuICBmb3IgKGNvbnN0IGFsdGVybmF0aXZlIG9mIG5vZGUuYWx0ZXJuYXRpdmVzKSB7XG4gICAgY29uc3QgY29uZGl0aW9uVmFsdWUgPSB3YWxrKHsgbm9kZTogYWx0ZXJuYXRpdmUuY29uZGl0aW9uLCBzY29wZSB9KSwgY29uZGl0aW9uU2NvcGUgPSByZXNvbHZlRmlsdGVyKGFsdGVybmF0aXZlLmNvbmRpdGlvbiwgc2NvcGUpO1xuICAgIGNvbmRpdGlvblNjb3BlLnR5cGUgPT09IFwidW5pb25cIiAmJiBjb25kaXRpb25TY29wZS5vZi5sZW5ndGggPiAwICYmIHZhbHVlcy5wdXNoKHdhbGsoeyBub2RlOiBhbHRlcm5hdGl2ZS52YWx1ZSwgc2NvcGU6IHNjb3BlLmNyZWF0ZUhpZGRlbihjb25kaXRpb25TY29wZS5vZikgfSkpLCBjb25kaXRpb25WYWx1ZS50eXBlID09PSBcImJvb2xlYW5cIiAmJiBjb25kaXRpb25WYWx1ZS52YWx1ZSA9PT0gITAgJiYgKGd1YXJhbnRlZWQgPSAhMCk7XG4gIH1cbiAgcmV0dXJuIG5vZGUuZmFsbGJhY2sgJiYgIWd1YXJhbnRlZWQgJiYgdmFsdWVzLnB1c2god2Fsayh7IG5vZGU6IG5vZGUuZmFsbGJhY2ssIHNjb3BlIH0pKSwgdmFsdWVzLmxlbmd0aCA9PT0gMCA/IHsgdHlwZTogXCJudWxsXCIgfSA6IHtcbiAgICB0eXBlOiBcInVuaW9uXCIsXG4gICAgb2Y6IHZhbHVlc1xuICB9O1xufVxuZnVuY3Rpb24gaGFuZGxlQXJyYXlDb2VyY2VOb2RlKG5vZGUsIHNjb3BlKSB7XG4gIGNvbnN0IGJhc2UgPSB3YWxrKHsgbm9kZTogbm9kZS5iYXNlLCBzY29wZSB9KTtcbiAgcmV0dXJuICR0cmFjZShcImFycmF5Q29lcmNlLmJhc2UgJU9cIiwgYmFzZSksIG1hcEFycmF5KGJhc2UsIHNjb3BlLCAoYmFzZTIpID0+IGJhc2UyKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUZsYXRNYXAobm9kZSwgc2NvcGUpIHtcbiAgY29uc3QgYmFzZSA9IHdhbGsoeyBub2RlOiBub2RlLmJhc2UsIHNjb3BlIH0pO1xuICByZXR1cm4gbWFwQXJyYXkoYmFzZSwgc2NvcGUsIChiYXNlMikgPT4ge1xuICAgIGNvbnN0IGlubmVyID0gd2Fsayh7IG5vZGU6IG5vZGUuZXhwciwgc2NvcGU6IHNjb3BlLmNyZWF0ZUhpZGRlbihbYmFzZTIub2ZdKSB9KTtcbiAgICByZXR1cm4gbWFwTm9kZShcbiAgICAgIGlubmVyLFxuICAgICAgc2NvcGUsXG4gICAgICAoaW5uZXIyKSA9PiBpbm5lcjIudHlwZSA9PT0gXCJhcnJheVwiID8gaW5uZXIyIDogeyB0eXBlOiBcImFycmF5XCIsIG9mOiBpbm5lcjIgfSxcbiAgICAgIChub2RlcykgPT4ge1xuICAgICAgICBjb25zdCBpbm5lcjIgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBub2RlMiBvZiBub2Rlcykge1xuICAgICAgICAgIGlmIChub2RlMi50eXBlID09PSBcInVua25vd25cIikgcmV0dXJuIHsgdHlwZTogXCJhcnJheVwiLCBvZjogbm9kZTIgfTtcbiAgICAgICAgICBpZiAobm9kZTIudHlwZSAhPT0gXCJhcnJheVwiKSB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgdHlwZTogJHtub2RlMi50eXBlfWApO1xuICAgICAgICAgIGlubmVyMi5wdXNoKG5vZGUyLm9mKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICBvZjogb3B0aW1pemVVbmlvbnMoeyB0eXBlOiBcInVuaW9uXCIsIG9mOiBpbm5lcjIgfSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICApO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU1hcChub2RlLCBzY29wZSkge1xuICBjb25zdCBiYXNlID0gd2Fsayh7IG5vZGU6IG5vZGUuYmFzZSwgc2NvcGUgfSk7XG4gIHJldHVybiAkdHJhY2UoXCJtYXAuYmFzZSAlT1wiLCBiYXNlKSwgbWFwQXJyYXkoYmFzZSwgc2NvcGUsIChiYXNlMikgPT4gKHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgb2Y6IHdhbGsoeyBub2RlOiBub2RlLmV4cHIsIHNjb3BlOiBzY29wZS5jcmVhdGVIaWRkZW4oW2Jhc2UyLm9mXSkgfSlcbiAgfSkpO1xufVxuZnVuY3Rpb24gaGFuZGxlUHJvamVjdGlvbk5vZGUobm9kZSwgc2NvcGUpIHtcbiAgY29uc3QgYmFzZSA9IHdhbGsoeyBub2RlOiBub2RlLmJhc2UsIHNjb3BlIH0pO1xuICByZXR1cm4gJHRyYWNlKFwicHJvamVjdGlvbi5iYXNlICVPXCIsIGJhc2UpLCBtYXBPYmplY3QoXG4gICAgYmFzZSxcbiAgICBzY29wZSxcbiAgICAoYmFzZTIpID0+IHdhbGsoeyBub2RlOiBub2RlLmV4cHIsIHNjb3BlOiBzY29wZS5jcmVhdGVOZXN0ZWQoW2Jhc2UyXSkgfSlcbiAgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpbHRlclNjb3BlKGJhc2UsIHNjb3BlKSB7XG4gIHJldHVybiBiYXNlLnR5cGUgPT09IFwiYXJyYXlcIiA/IGJhc2Uub2YudHlwZSA9PT0gXCJ1bmlvblwiID8gc2NvcGUuY3JlYXRlTmVzdGVkKGJhc2Uub2Yub2YpIDogc2NvcGUuY3JlYXRlTmVzdGVkKFtiYXNlLm9mXSkgOiBzY29wZS5jcmVhdGVOZXN0ZWQoW2Jhc2VdKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUZpbHRlck5vZGUobm9kZSwgc2NvcGUpIHtcbiAgY29uc3QgYmFzZSA9IHdhbGsoeyBub2RlOiBub2RlLmJhc2UsIHNjb3BlIH0pO1xuICByZXR1cm4gJHRyYWNlKFwiZmlsdGVyLmJhc2UgJU9cIiwgYmFzZSksIG1hcE5vZGUoYmFzZSwgc2NvcGUsIChiYXNlMikgPT4ge1xuICAgIGlmICgkdHJhY2UoXCJmaWx0ZXIucmVzb2x2aW5nICVPXCIsIGJhc2UyKSwgYmFzZTIudHlwZSA9PT0gXCJudWxsXCIpXG4gICAgICByZXR1cm4gYmFzZTI7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSByZXNvbHZlRmlsdGVyKG5vZGUuZXhwciwgY3JlYXRlRmlsdGVyU2NvcGUoYmFzZTIsIHNjb3BlKSk7XG4gICAgcmV0dXJuICR0cmFjZShcImZpbHRlci5yZXNvbHZlZCAlT1wiLCByZXNvbHZlZCksIHtcbiAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgIG9mOiByZXNvbHZlZFxuICAgIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gaGFuZGxlQWNjZXNzQXR0cmlidXRlTm9kZShub2RlLCBzY29wZSkge1xuICBsZXQgYXR0cmlidXRlQmFzZSA9IHNjb3BlLnZhbHVlO1xuICByZXR1cm4gbm9kZS5iYXNlICYmIChhdHRyaWJ1dGVCYXNlID0gd2Fsayh7IG5vZGU6IG5vZGUuYmFzZSwgc2NvcGUgfSkpLCAkdHJhY2UoXCJhY2Nlc3NBdHRyaWJ1dGUuYmFzZSAlcyAlT1wiLCBub2RlLm5hbWUsIGF0dHJpYnV0ZUJhc2UpLCBoYW5kbGVBY2Nlc3NBdHRyaWJ1dGVCYXNlKGF0dHJpYnV0ZUJhc2UsIG5vZGUubmFtZSwgc2NvcGUpO1xufVxuZnVuY3Rpb24gaGFuZGxlQWNjZXNzQXR0cmlidXRlQmFzZShiYXNlLCBuYW1lLCBzY29wZSkge1xuICByZXR1cm4gbWFwT2JqZWN0KGJhc2UsIHNjb3BlLCAoYmFzZTIpID0+IHtcbiAgICAkdHJhY2UoJ0xvb2tpbmcgZm9yIGF0dHJpYnV0ZSBcIiVzXCIgaW4gb2JqZWN0ICVPJywgbmFtZSwgYmFzZTIpO1xuICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGJhc2UyLmF0dHJpYnV0ZXNbbmFtZV07XG4gICAgcmV0dXJuIGF0dHJpYnV0ZSAhPT0gdm9pZCAwID8gKCRkZWJ1ZyhgYWNjZXNzQXR0cmlidXRlLmF0dHJpYnV0ZSBmb3VuZCAke25hbWV9ICVPYCwgYXR0cmlidXRlKSwgYXR0cmlidXRlLm9wdGlvbmFsID8gbnVsbFVuaW9uKGF0dHJpYnV0ZS52YWx1ZSkgOiBhdHRyaWJ1dGUudmFsdWUpIDogYmFzZTIucmVzdCA/IGhhbmRsZUFjY2Vzc0F0dHJpYnV0ZUJhc2UoYmFzZTIucmVzdCwgbmFtZSwgc2NvcGUpIDogKCR3YXJuKGBhdHRyaWJ1dGUgXCIke25hbWV9XCIgbm90IGZvdW5kIGluIG9iamVjdGApLCB7IHR5cGU6IFwibnVsbFwiIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUFjY2Vzc0VsZW1lbnROb2RlKG5vZGUsIHNjb3BlKSB7XG4gIGNvbnN0IGJhc2UgPSB3YWxrKHsgbm9kZTogbm9kZS5iYXNlLCBzY29wZSB9KTtcbiAgcmV0dXJuICR0cmFjZShcImFjY2Vzc0VsZW1lbnQuYmFzZSAlT1wiLCBiYXNlKSwgbWFwQXJyYXkoYmFzZSwgc2NvcGUsIChiYXNlMikgPT4gbnVsbFVuaW9uKGJhc2UyLm9mKSk7XG59XG5mdW5jdGlvbiBoYW5kbGVBcnJheU5vZGUobm9kZSwgc2NvcGUpIHtcbiAgY29uc3Qgb2YgPSBbXTtcbiAgZm9yIChjb25zdCBlbCBvZiBub2RlLmVsZW1lbnRzKSB7XG4gICAgY29uc3Qgbm9kZTIgPSB3YWxrKHsgbm9kZTogZWwudmFsdWUsIHNjb3BlIH0pO1xuICAgIG5vZGUyICE9PSBudWxsICYmIG9mLnB1c2gobm9kZTIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIG9mOiB7XG4gICAgICB0eXBlOiBcInVuaW9uXCIsXG4gICAgICBvZlxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZVZhbHVlTm9kZShub2RlLCBzY29wZSkge1xuICBpZiAobm9kZS52YWx1ZSA9PT0gbnVsbClcbiAgICByZXR1cm4geyB0eXBlOiBcIm51bGxcIiB9O1xuICBzd2l0Y2ggKHR5cGVvZiBub2RlLnZhbHVlKSB7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgdmFsdWU6IG5vZGUudmFsdWVcbiAgICAgIH07XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgdmFsdWU6IG5vZGUudmFsdWVcbiAgICAgIH07XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICB2YWx1ZTogbm9kZS52YWx1ZVxuICAgICAgfTtcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICByZXR1cm4gbm9kZS52YWx1ZSA9PT0gbnVsbCA/IHsgdHlwZTogXCJudWxsXCIgfSA6IEFycmF5LmlzQXJyYXkobm9kZS52YWx1ZSkgPyB7XG4gICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgb2Y6IHtcbiAgICAgICAgICB0eXBlOiBcInVuaW9uXCIsXG4gICAgICAgICAgb2Y6IG5vZGUudmFsdWUubWFwKCh2YWx1ZSkgPT4gd2Fsayh7IG5vZGU6IHsgdHlwZTogXCJWYWx1ZVwiLCB2YWx1ZSB9LCBzY29wZSB9KSlcbiAgICAgICAgfVxuICAgICAgfSA6IHtcbiAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgYXR0cmlidXRlczogT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgIE9iamVjdC5lbnRyaWVzKG5vZGUudmFsdWUpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBbXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0QXR0cmlidXRlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiB3YWxrKHsgbm9kZTogeyB0eXBlOiBcIlZhbHVlXCIsIHZhbHVlIH0sIHNjb3BlIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXSlcbiAgICAgICAgKVxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ1bmtub3duXCIgfTtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlU2xpY2Uobm9kZSwgc2NvcGUpIHtcbiAgJHRyYWNlKFwic2xpY2Uubm9kZSAlT1wiLCBub2RlKTtcbiAgY29uc3QgYmFzZSA9IHdhbGsoeyBub2RlOiBub2RlLmJhc2UsIHNjb3BlIH0pO1xuICByZXR1cm4gbWFwQXJyYXkoYmFzZSwgc2NvcGUsIChiYXNlMikgPT4gYmFzZTIpO1xufVxuZnVuY3Rpb24gaGFuZGxlUGFyZW50Tm9kZSh7IG4gfSwgc2NvcGUpIHtcbiAgJHRyYWNlKFwiaGFuZGxlLnBhcmVudC5jdXJyZW50U2NvcGUgJWQgJU9cIiwgbiwgc2NvcGUpO1xuICBsZXQgY3VycmVudCA9IHNjb3BlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIGZvciAoOyBjdXJyZW50Py5pc0hpZGRlbjsgKVxuICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgIGN1cnJlbnQgPSBjdXJyZW50Py5wYXJlbnQ7XG4gIH1cbiAgcmV0dXJuICR0cmFjZShcImhhbmRsZS5wYXJlbnQubmV3U2NvcGUgJWQgJU9cIiwgbiwgY3VycmVudCksIGN1cnJlbnQgPyBjdXJyZW50LnZhbHVlLm9mLmxlbmd0aCA9PT0gMCA/IHsgdHlwZTogXCJudWxsXCIgfSA6IGN1cnJlbnQudmFsdWUgOiB7IHR5cGU6IFwibnVsbFwiIH07XG59XG5mdW5jdGlvbiBoYW5kbGVOb3ROb2RlKG5vZGUsIHNjb3BlKSB7XG4gIGNvbnN0IGJhc2UgPSB3YWxrKHsgbm9kZTogbm9kZS5iYXNlLCBzY29wZSB9KTtcbiAgcmV0dXJuIG1hcE5vZGUoYmFzZSwgc2NvcGUsIChiYXNlMikgPT4gYmFzZTIudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcImJvb2xlYW5cIiB9KSA6IGJhc2UyLnR5cGUgPT09IFwiYm9vbGVhblwiID8gYmFzZTIudmFsdWUgIT09IHZvaWQgMCA/IHsgdHlwZTogXCJib29sZWFuXCIsIHZhbHVlOiBiYXNlMi52YWx1ZSA9PT0gITEgfSA6IHsgdHlwZTogXCJib29sZWFuXCIgfSA6IHsgdHlwZTogXCJudWxsXCIgfSk7XG59XG5mdW5jdGlvbiBoYW5kbGVOZWdOb2RlKG5vZGUsIHNjb3BlKSB7XG4gIGNvbnN0IGJhc2UgPSB3YWxrKHsgbm9kZTogbm9kZS5iYXNlLCBzY29wZSB9KTtcbiAgcmV0dXJuIG1hcE5vZGUoYmFzZSwgc2NvcGUsIChiYXNlMikgPT4gYmFzZTIudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcIm51bWJlclwiIH0pIDogYmFzZTIudHlwZSAhPT0gXCJudW1iZXJcIiA/IHsgdHlwZTogXCJudWxsXCIgfSA6IGJhc2UyLnZhbHVlICE9PSB2b2lkIDAgPyB7IHR5cGU6IFwibnVtYmVyXCIsIHZhbHVlOiAtYmFzZTIudmFsdWUgfSA6IGJhc2UyKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZVBvc05vZGUobm9kZSwgc2NvcGUpIHtcbiAgY29uc3QgYmFzZSA9IHdhbGsoeyBub2RlOiBub2RlLmJhc2UsIHNjb3BlIH0pO1xuICByZXR1cm4gbWFwTm9kZShiYXNlLCBzY29wZSwgKGJhc2UyKSA9PiBiYXNlMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwibnVtYmVyXCIgfSkgOiBiYXNlMi50eXBlICE9PSBcIm51bWJlclwiID8geyB0eXBlOiBcIm51bGxcIiB9IDogYmFzZTIpO1xufVxuZnVuY3Rpb24gaGFuZGxlRXZlcnl0aGluZ05vZGUoXywgc2NvcGUpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgb2Y6IHtcbiAgICAgIHR5cGU6IFwidW5pb25cIixcbiAgICAgIG9mOiBzY29wZS5jb250ZXh0LnNjaGVtYS5maWx0ZXIoKG9iaikgPT4gb2JqLnR5cGUgPT09IFwiZG9jdW1lbnRcIikubWFwKChkb2MpID0+ICh7XG4gICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgIGF0dHJpYnV0ZXM6IGRvYy5hdHRyaWJ1dGVzXG4gICAgICB9KSlcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBoYW5kbGVBbmROb2RlKG5vZGUsIHNjb3BlKSB7XG4gIGNvbnN0IGxlZnQgPSB3YWxrKHsgbm9kZTogbm9kZS5sZWZ0LCBzY29wZSB9KSwgcmlnaHQgPSB3YWxrKHsgbm9kZTogbm9kZS5yaWdodCwgc2NvcGUgfSk7XG4gIHJldHVybiBtYXBOb2RlKFxuICAgIGxlZnQsXG4gICAgc2NvcGUsXG4gICAgKGxocykgPT4gbWFwTm9kZShyaWdodCwgc2NvcGUsIChyaHMpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gYm9vbGVhbkFuZChib29sZWFuVmFsdWUobGhzLCBzY29wZSksIGJvb2xlYW5WYWx1ZShyaHMsIHNjb3BlKSk7XG4gICAgICByZXR1cm4gYm9vbGVhbkludGVycHJldGF0aW9uVG9UeXBlTm9kZSh2YWx1ZSk7XG4gICAgfSlcbiAgKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU9yTm9kZShub2RlLCBzY29wZSkge1xuICBjb25zdCBsZWZ0ID0gd2Fsayh7IG5vZGU6IG5vZGUubGVmdCwgc2NvcGUgfSksIHJpZ2h0ID0gd2Fsayh7IG5vZGU6IG5vZGUucmlnaHQsIHNjb3BlIH0pO1xuICByZXR1cm4gbWFwTm9kZShcbiAgICBsZWZ0LFxuICAgIHNjb3BlLFxuICAgIChsaHMpID0+IG1hcE5vZGUocmlnaHQsIHNjb3BlLCAocmhzKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGJvb2xlYW5Pcihib29sZWFuVmFsdWUobGhzLCBzY29wZSksIGJvb2xlYW5WYWx1ZShyaHMsIHNjb3BlKSk7XG4gICAgICByZXR1cm4gYm9vbGVhbkludGVycHJldGF0aW9uVG9UeXBlTm9kZSh2YWx1ZSk7XG4gICAgfSlcbiAgKTtcbn1cbmNvbnN0IE9WRVJSSURFX1RZUEVfU1lNQk9MID0gU3ltYm9sKFwiZ3JvcS1qcy50eXBlXCIpO1xuZnVuY3Rpb24gd2Fsayh7IG5vZGUsIHNjb3BlIH0pIHtcbiAgaWYgKE9WRVJSSURFX1RZUEVfU1lNQk9MIGluIG5vZGUpXG4gICAgcmV0dXJuIG5vZGVbT1ZFUlJJREVfVFlQRV9TWU1CT0xdO1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIC8vIEZpbHRlcmluZywgdHJhdmVyc2FsICYgcHJvamVjdGlvbnNcbiAgICBjYXNlIFwiTWFwXCI6XG4gICAgICByZXR1cm4gaGFuZGxlTWFwKG5vZGUsIHNjb3BlKTtcbiAgICBjYXNlIFwiUHJvamVjdGlvblwiOlxuICAgICAgcmV0dXJuIGhhbmRsZVByb2plY3Rpb25Ob2RlKG5vZGUsIHNjb3BlKTtcbiAgICBjYXNlIFwiRmlsdGVyXCI6XG4gICAgICByZXR1cm4gaGFuZGxlRmlsdGVyTm9kZShub2RlLCBzY29wZSk7XG4gICAgY2FzZSBcIkFjY2Vzc0F0dHJpYnV0ZVwiOlxuICAgICAgcmV0dXJuIG9wdGltaXplVW5pb25zKGhhbmRsZUFjY2Vzc0F0dHJpYnV0ZU5vZGUobm9kZSwgc2NvcGUpKTtcbiAgICBjYXNlIFwiQWNjZXNzRWxlbWVudFwiOlxuICAgICAgcmV0dXJuIGhhbmRsZUFjY2Vzc0VsZW1lbnROb2RlKG5vZGUsIHNjb3BlKTtcbiAgICBjYXNlIFwiQXJyYXlDb2VyY2VcIjpcbiAgICAgIHJldHVybiBoYW5kbGVBcnJheUNvZXJjZU5vZGUobm9kZSwgc2NvcGUpO1xuICAgIGNhc2UgXCJGbGF0TWFwXCI6XG4gICAgICByZXR1cm4gaGFuZGxlRmxhdE1hcChub2RlLCBzY29wZSk7XG4gICAgLy8gT3BlcmF0aW9uc1xuICAgIGNhc2UgXCJPcENhbGxcIjpcbiAgICAgIHJldHVybiBoYW5kbGVPcENhbGxOb2RlKG5vZGUsIHNjb3BlKTtcbiAgICBjYXNlIFwiQW5kXCI6XG4gICAgICByZXR1cm4gaGFuZGxlQW5kTm9kZShub2RlLCBzY29wZSk7XG4gICAgY2FzZSBcIk9yXCI6XG4gICAgICByZXR1cm4gaGFuZGxlT3JOb2RlKG5vZGUsIHNjb3BlKTtcbiAgICBjYXNlIFwiU2VsZWN0XCI6XG4gICAgICByZXR1cm4gaGFuZGxlU2VsZWN0Tm9kZShub2RlLCBzY29wZSk7XG4gICAgY2FzZSBcIlBpcGVGdW5jQ2FsbFwiOlxuICAgICAgcmV0dXJuIHdhbGsoeyBub2RlOiBub2RlLmJhc2UsIHNjb3BlIH0pO1xuICAgIC8vIFZhbHVlc1xuICAgIGNhc2UgXCJEZXJlZlwiOlxuICAgICAgcmV0dXJuIGhhbmRsZURlcmVmTm9kZShub2RlLCBzY29wZSk7XG4gICAgY2FzZSBcIk9iamVjdFwiOlxuICAgICAgcmV0dXJuIGhhbmRsZU9iamVjdE5vZGUobm9kZSwgc2NvcGUpO1xuICAgIGNhc2UgXCJWYWx1ZVwiOlxuICAgICAgcmV0dXJuIGhhbmRsZVZhbHVlTm9kZShub2RlLCBzY29wZSk7XG4gICAgY2FzZSBcIkFycmF5XCI6XG4gICAgICByZXR1cm4gaGFuZGxlQXJyYXlOb2RlKG5vZGUsIHNjb3BlKTtcbiAgICAvLyBTcGVjaWFsIGNhc2VzXG4gICAgY2FzZSBcIkV2ZXJ5dGhpbmdcIjpcbiAgICAgIHJldHVybiBoYW5kbGVFdmVyeXRoaW5nTm9kZShub2RlLCBzY29wZSk7XG4gICAgY2FzZSBcIlRoaXNcIjpcbiAgICAgIHJldHVybiAkdHJhY2UoXCJ0aGlzICVPXCIsIHNjb3BlLnZhbHVlKSwgc2NvcGUudmFsdWU7XG4gICAgY2FzZSBcIlBhcmVudFwiOlxuICAgICAgcmV0dXJuIGhhbmRsZVBhcmVudE5vZGUobm9kZSwgc2NvcGUpO1xuICAgIGNhc2UgXCJGdW5jQ2FsbFwiOlxuICAgICAgcmV0dXJuIGhhbmRsZUZ1bmNDYWxsTm9kZShub2RlLCBzY29wZSk7XG4gICAgY2FzZSBcIkdyb3VwXCI6XG4gICAgICByZXR1cm4gd2Fsayh7IG5vZGU6IG5vZGUuYmFzZSwgc2NvcGUgfSk7XG4gICAgY2FzZSBcIk5vdFwiOlxuICAgICAgcmV0dXJuIGhhbmRsZU5vdE5vZGUobm9kZSwgc2NvcGUpO1xuICAgIGNhc2UgXCJQYXJhbWV0ZXJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwidW5rbm93blwiXG4gICAgICB9O1xuICAgIGNhc2UgXCJTbGljZVwiOlxuICAgICAgcmV0dXJuIGhhbmRsZVNsaWNlKG5vZGUsIHNjb3BlKTtcbiAgICBjYXNlIFwiTmVnXCI6XG4gICAgICByZXR1cm4gaGFuZGxlTmVnTm9kZShub2RlLCBzY29wZSk7XG4gICAgY2FzZSBcIlBvc1wiOlxuICAgICAgcmV0dXJuIGhhbmRsZVBvc05vZGUobm9kZSwgc2NvcGUpO1xuICAgIC8vIGV2ZXJ5dGhpbmcgZWxzZVxuICAgIGNhc2UgXCJBc2NcIjpcbiAgICBjYXNlIFwiRGVzY1wiOlxuICAgIGNhc2UgXCJDb250ZXh0XCI6XG4gICAgY2FzZSBcIlR1cGxlXCI6XG4gICAgY2FzZSBcIlNlbGVjdG9yXCI6XG4gICAgY2FzZSBcIkluUmFuZ2VcIjpcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidW5rbm93blwiIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biBub2RlIHR5cGUgJHtub2RlLnR5cGV9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlVHlwZU5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZS50eXBlID09PSBcInN0cmluZ1wiIHx8IG5vZGUudHlwZSA9PT0gXCJudW1iZXJcIiB8fCBub2RlLnR5cGUgPT09IFwiYm9vbGVhblwiO1xufVxuZnVuY3Rpb24gZXZhbHVhdGVDb21wYXJpc29uKG9wY2FsbCwgbGVmdCwgcmlnaHQpIHtcbiAgaWYgKCEobGVmdC52YWx1ZSA9PT0gdm9pZCAwIHx8IHJpZ2h0LnZhbHVlID09PSB2b2lkIDApKVxuICAgIHN3aXRjaCAob3BjYWxsKSB7XG4gICAgICBjYXNlIFwiPT1cIjpcbiAgICAgICAgcmV0dXJuIGxlZnQudmFsdWUgPT09IHJpZ2h0LnZhbHVlO1xuICAgICAgY2FzZSBcIjxcIjpcbiAgICAgICAgcmV0dXJuIGxlZnQudmFsdWUgPCByaWdodC52YWx1ZTtcbiAgICAgIGNhc2UgXCI8PVwiOlxuICAgICAgICByZXR1cm4gbGVmdC52YWx1ZSA8PSByaWdodC52YWx1ZTtcbiAgICAgIGNhc2UgXCI+XCI6XG4gICAgICAgIHJldHVybiBsZWZ0LnZhbHVlID4gcmlnaHQudmFsdWU7XG4gICAgICBjYXNlIFwiPj1cIjpcbiAgICAgICAgcmV0dXJuIGxlZnQudmFsdWUgPj0gcmlnaHQudmFsdWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gY29tcGFyaXNvbiBvcGVyYXRvciAke29wY2FsbH1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXNvbHZlRmlsdGVyKGV4cHIsIHNjb3BlKSB7XG4gICR0cmFjZShcInJlc29sdmVGaWx0ZXIuZXhwciAlT1wiLCBleHByKTtcbiAgY29uc3QgZmlsdGVyZWQgPSBzY29wZS52YWx1ZS5vZi5maWx0ZXIoKG5vZGUpID0+IHtcbiAgICBjb25zdCBzdWJTY29wZSA9IHNjb3BlLmNyZWF0ZUhpZGRlbihbbm9kZV0pLCBjb25kID0gd2Fsayh7IG5vZGU6IGV4cHIsIHNjb3BlOiBzdWJTY29wZSB9KTtcbiAgICByZXR1cm4gYm9vbGVhblZhbHVlKGNvbmQsIHN1YlNjb3BlKS5jYW5CZVRydWU7XG4gIH0pO1xuICByZXR1cm4gJHRyYWNlKFxuICAgIGByZXNvbHZlRmlsdGVyICR7ZXhwci50eXBlID09PSBcIk9wQ2FsbFwiID8gYCR7ZXhwci50eXBlfS8ke2V4cHIub3B9YCA6IGV4cHIudHlwZX0gJU9gLFxuICAgIGZpbHRlcmVkXG4gICksIHsgdHlwZTogXCJ1bmlvblwiLCBvZjogZmlsdGVyZWQgfTtcbn1cbmZ1bmN0aW9uIG1hcEFycmF5KG5vZGUsIHNjb3BlLCBtYXBwZXIpIHtcbiAgcmV0dXJuIG1hcE5vZGUobm9kZSwgc2NvcGUsIChiYXNlKSA9PiBiYXNlLnR5cGUgPT09IFwidW5rbm93blwiID8gYmFzZSA6IGJhc2UudHlwZSA9PT0gXCJhcnJheVwiID8gbWFwcGVyKGJhc2UpIDogeyB0eXBlOiBcIm51bGxcIiB9KTtcbn1cbmZ1bmN0aW9uIG1hcE9iamVjdChub2RlLCBzY29wZSwgbWFwcGVyKSB7XG4gIHJldHVybiBtYXBOb2RlKG5vZGUsIHNjb3BlLCAoYmFzZSkgPT4gYmFzZS50eXBlID09PSBcInVua25vd25cIiA/IGJhc2UgOiBiYXNlLnR5cGUgPT09IFwib2JqZWN0XCIgPyBtYXBwZXIoYmFzZSkgOiB7IHR5cGU6IFwibnVsbFwiIH0pO1xufVxuZXhwb3J0IHtcbiAgRGF0ZVRpbWUsXG4gIFBhdGgsXG4gIGNyZWF0ZVJlZmVyZW5jZVR5cGVOb2RlLFxuICBldmFsdWF0ZVF1ZXJ5IGFzIGV2YWx1YXRlLFxuICBwYXJzZSxcbiAgdHlwZUV2YWx1YXRlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9MS5tanMubWFwXG4iXSwibmFtZXMiOlsiZGVidWciLCJlc2NhcGVSZWdFeHAiLCJzdHJpbmciLCJyZXBsYWNlIiwicGF0aFJlZ0V4cCIsInBhdHRlcm4iLCJyZSIsInBhcnQiLCJzcGxpdCIsInB1c2giLCJSZWdFeHAiLCJqb2luIiwiUGF0aCIsImNvbnN0cnVjdG9yIiwicGF0dGVyblJlIiwibWF0Y2hlcyIsInN0ciIsInRlc3QiLCJ0b0pTT04iLCJTdHJlYW1WYWx1ZSIsImdlbmVyYXRvciIsInR5cGUiLCJ0aWNrZXIiLCJpc0RvbmUiLCJkYXRhIiwiaXNBcnJheSIsImdldCIsInJlc3VsdCIsInZhbHVlIiwiU3ltYm9sIiwiYXN5bmNJdGVyYXRvciIsImkiLCJsZW5ndGgiLCJfbmV4dFRpY2siLCJjdXJyZW50UmVzb2x2ZXIiLCJzZXR1cFRpY2tlciIsIlByb21pc2UiLCJyZXNvbHZlIiwidGljayIsImZldGNoIiwiUkZDMzMzOV9SRUdFWCIsInBhcnNlUkZDMzMzOSIsIkRhdGUiLCJmb3JtYXRSRkMzMzM5IiwiZCIsInllYXIiLCJhZGRMZWFkaW5nWmVybyIsImdldFVUQ0Z1bGxZZWFyIiwibW9udGgiLCJnZXRVVENNb250aCIsImRheSIsImdldFVUQ0RhdGUiLCJob3VyIiwiZ2V0VVRDSG91cnMiLCJtaW51dGUiLCJnZXRVVENNaW51dGVzIiwic2Vjb25kIiwiZ2V0VVRDU2Vjb25kcyIsImZyYWN0aW9uYWxTZWNvbmQiLCJtaWxsaXMiLCJnZXRNaWxsaXNlY29uZHMiLCJudW0iLCJ0YXJnZXRMZW5ndGgiLCJ0b1N0cmluZyIsIlN0YXRpY1ZhbHVlIiwiQXJyYXkiLCJlbGVtZW50IiwiZnJvbUpTIiwiRXJyb3IiLCJOVUxMX1ZBTFVFIiwiVFJVRV9WQUxVRSIsIkZBTFNFX1ZBTFVFIiwiRGF0ZVRpbWUiLCJkYXRlIiwicGFyc2VUb1ZhbHVlIiwiZXF1YWxzIiwib3RoZXIiLCJnZXRUaW1lIiwiYWRkIiwic2VjcyIsImNvcHkiLCJzZXRUaW1lIiwiZGlmZmVyZW5jZSIsImNvbXBhcmVUbyIsImZyb21OdW1iZXIiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsImZyb21TdHJpbmciLCJmcm9tRGF0ZVRpbWUiLCJkdCIsImZyb21QYXRoIiwicGF0aCIsImlzSXRlcmF0b3IiLCJvYmoiLCJuZXh0IiwidmFsIiwiZ2V0VHlwZSIsImlzRXF1YWwiLCJhIiwiYiIsIkNIQVJTIiwiQ0hBUlNfV0lUSF9XSUxEQ0FSRCIsIkVER0VfQ0hBUlMiLCJtYXRjaFRleHQiLCJ0b2tlbnMiLCJwYXR0ZXJucyIsImV2ZXJ5IiwibWF0Y2hUb2tlbml6ZSIsInRleHQyIiwibWF0Y2giLCJtYXRjaEFuYWx5emVQYXR0ZXJuIiwibWF0Y2hQYXR0ZXJuUmVnZXgiLCJtYXAiLCJzb21lIiwidG9rZW4iLCJ0ZXJtIiwic2xpY2UiLCJnYXRoZXJUZXh0IiwiY2IiLCJzdWNjZXNzIiwiVFlQRV9PUkRFUiIsImRhdGV0aW1lIiwibnVtYmVyIiwiYm9vbGVhbiIsInBhcnRpYWxDb21wYXJlIiwiYVR5cGUiLCJiVHlwZSIsInRvdGFsQ29tcGFyZSIsImFUeXBlT3JkZXIiLCJiVHlwZU9yZGVyIiwib3BlcmF0b3JzIiwibGVmdCIsInJpZ2h0IiwiaW4iLCJjb25jYXQiLCJudW1lcmljT3BlcmF0b3IiLCJNYXRoIiwicG93IiwiaW1wbCIsIlNjb3BlJDEiLCJTY29wZSIsInBhcmFtcyIsInNvdXJjZSIsImNvbnRleHQiLCJwYXJlbnQiLCJpc0hpZGRlbiIsImNyZWF0ZU5lc3RlZCIsImNyZWF0ZUhpZGRlbiIsImV2YWx1YXRlIiwibm9kZSIsInNjb3BlIiwiZXhlY3V0ZSIsImZ1bmMiLCJFWEVDVVRPUlMiLCJwcm9taXNlbGVzc0FwcGx5IiwidGhlbiIsIlRoaXMiLCJfIiwiU2VsZWN0b3IiLCJFdmVyeXRoaW5nIiwiUGFyYW1ldGVyIiwibmFtZSIsIkNvbnRleHQiLCJrZXkiLCJQYXJlbnQiLCJuIiwiY3VycmVudCIsIk9wQ2FsbCIsIm9wIiwibGVmdFZhbHVlIiwicmlnaHRWYWx1ZSIsIlNlbGVjdCIsImFsdGVybmF0aXZlcyIsImZhbGxiYWNrIiwiYWx0IiwiYWx0Q29uZCIsImNvbmRpdGlvbiIsIkluUmFuZ2UiLCJiYXNlIiwiaXNJbmNsdXNpdmUiLCJsZWZ0Q21wIiwicmlnaHRDbXAiLCJGaWx0ZXIiLCJleHByIiwiYmFzZVZhbHVlIiwiZWxlbSIsIm5ld1Njb3BlIiwiZXhwclZhbHVlIiwiUHJvamVjdGlvbiIsIkZ1bmNDYWxsIiwiYXJncyIsIlBpcGVGdW5jQ2FsbCIsIkFjY2Vzc0F0dHJpYnV0ZSIsImhhc093blByb3BlcnR5IiwiQWNjZXNzRWxlbWVudCIsImluZGV4IiwiZmluYWxJbmRleCIsIlNsaWNlIiwiYXJyYXkyIiwibGVmdElkeCIsInJpZ2h0SWR4IiwiRGVyZWYiLCJpZCIsIl9yZWYiLCJkZXJlZmVyZW5jZSIsImRvYyIsIl9pZCIsIlZhbHVlIiwiR3JvdXAiLCJPYmplY3QiLCJhdHRyaWJ1dGVzIiwiYXR0ciIsImF0dHJUeXBlIiwiY29uZCIsImFzc2lnbiIsImVsZW1lbnRzIiwiaXNTcGxhdCIsInYiLCJUdXBsZSIsIk9yIiwiQW5kIiwiTm90IiwiTmVnIiwiUG9zIiwiQXNjIiwiRGVzYyIsIkFycmF5Q29lcmNlIiwiTWFwIiwiRmxhdE1hcCIsImlubmVyVmFsdWUiLCJpbm5lciIsImV2YWx1YXRlUXVlcnkiLCJ0cmVlIiwib3B0aW9ucyIsInJvb3QiLCJkYXRhc2V0IiwidGltZXN0YW1wIiwiaWRlbnRpdHkiLCJzYW5pdHkiLCJhZnRlciIsImJlZm9yZSIsImNhbkNvbnN0YW50RXZhbHVhdGUiLCJEVU1NWV9TQ09QRSIsInRyeUNvbnN0YW50RXZhbHVhdGUiLCJjb25zdGFudEV2YWx1YXRlIiwicG9ydGFibGVUZXh0Q29udGVudCIsImJsb2NrVGV4dCIsInRleHRzIiwiYXJyYXlUZXh0IiwiYmxvY2siLCJfdHlwZSIsImNoaWxkcmVuIiwiY2hpbGQiLCJ0ZXh0IiwiQk0yNWsiLCJldmFsdWF0ZVNjb3JlIiwiZXZhbHVhdGVNYXRjaFNjb3JlIiwiaW5uZXJTY29yZSIsImJvb3N0IiwibGVmdFNjb3JlIiwicmlnaHRTY29yZSIsInJlcyIsInRlcm1zIiwic2NvcmUiLCJmcmVxIiwicmVkdWNlIiwiYyIsImhhc1JlZmVyZW5jZSIsInBhdGhTZXQiLCJoYXMiLCJ2YWx1ZXMiLCJjb3VudFVURjgiLCJjb3VudDIiLCJjb2RlIiwiY2hhckNvZGVBdCIsIl9nbG9iYWwiLCJhbnl3aGVyZSIsImFyaXR5IiwiY29hbGVzY2UiLCJhcmciLCJjb3VudCIsImRhdGVUaW1lIiwiZGVmaW5lZCIsIl9hcmdzIiwicmVmZXJlbmNlcyIsIlNldCIsInBhdGgyIiwic2l6ZSIsInNjb3BlVmFsdWUiLCJyb3VuZCIsInByZWMiLCJwcmVjVmFsdWUiLCJpc0ludGVnZXIiLCJ0b0ZpeGVkIiwibm93IiwidG9JU09TdHJpbmciLCJzdHJpbmcyIiwibG93ZXIiLCJ0b0xvd2VyQ2FzZSIsInVwcGVyIiwidG9VcHBlckNhc2UiLCJzZXAiLCJmcm9tIiwic3RhcnRzV2l0aCIsInByZWZpeCIsImFycmF5IiwiYXJyIiwiYnVmIiwibmVlZFNlcCIsImNvbXBhY3QiLCJ1bmlxdWUiLCJhZGRlZCIsIml0ZXIiLCJpbnRlcnNlY3RzIiwiYXJyMSIsImFycjIiLCJ2MSIsInYyIiwicHQiLCJwcm9qZWN0SWQiLCJ2ZXJzaW9uT2YiLCJiYXNlSWQiLCJjb21wb25lbnRzIiwicGFydE9mUmVsZWFzZSIsInJlbGVhc2VzIiwiYWxsIiwiYWxsUmVsZWFzZXMiLCJwaXBlRnVuY3Rpb25zIiwib3JkZXIiLCJtYXBwZXJzIiwiZGlyZWN0aW9ucyIsIm1hcHBlciIsImRpcmVjdGlvbiIsImF1eCIsImlkeCIsInR1cGxlIiwic29ydCIsImFUdXBsZSIsImJUdXBsZSIsInVua25vd24iLCJzY29yZWQiLCJ2YWx1ZVNjb3JlIiwiX3Njb3JlIiwibmV3T2JqZWN0IiwiZGVsdGEiLCJvcGVyYXRpb24iLCJoYXNCZWZvcmUiLCJoYXNBZnRlciIsImNoYW5nZWRBbnkiLCJtb2RlIiwiY2hhbmdlZE9ubHkiLCJkaWZmIiwibWF0aCIsIm1pbiIsIm1heCIsInN1bSIsImF2ZyIsImRhdGVUaW1lMiIsInF1ZXJ5IiwibmFtZXNwYWNlcyIsImdsb2JhbCIsIk1hcmtQcm9jZXNzb3IiLCJtYXJrcyIsInBhcnNlT3B0aW9ucyIsImFsbG93Qm9vc3QiLCJoYXNNYXJrIiwicG9zIiwiZ2V0TWFyayIsInNoaWZ0IiwicHJvY2VzcyIsInZpc2l0b3IiLCJtYXJrIiwiY2FsbCIsInByb2Nlc3NTdHJpbmciLCJwcm9jZXNzU3RyaW5nRW5kIiwicHJldiIsImN1cnIiLCJwb3NpdGlvbiIsImxlbiIsIldTIiwiTlVNIiwiSURFTlQiLCJwYXJzZSQxIiwic2tpcFdTIiwicGFyc2VFeHByIiwiZmFpbFBvc2l0aW9uIiwibGV2ZWwiLCJzdGFydFBvcyIsInJocyIsInBhcnNlT2JqZWN0IiwicGFyc2VTdHJpbmciLCJpZGVudExlbiIsInBhcnNlUmVnZXgiLCJudW1MZW4iLCJmcmFjTGVuIiwiZXhwTGVuIiwicGFyc2VGdW5jQ2FsbCIsImxoc0xldmVsIiwidHJhdiIsImxvb3AiLCJpbm5lclBvcyIsInBhcnNlVHJhdmVyc2FsIiwidW5zaGlmdCIsInJoczIiLCJuZXh0UG9zIiwiaWRlbnRQb3MiLCJwYXJzZVJlZ2V4U3RyIiwiaXNHcm91cCIsInJhbmdlUG9zIiwiaWRlbnRTdGFydCIsImlkZW50TGVuMiIsIm5hbWVMZW4iLCJsYXN0UG9zIiwicGFpclBvcyIsImluZGV4T2YiLCJtIiwiZXhlYyIsImZsYXRNYXAiLCJ0cmF2ZXJzZUFycmF5IiwiYnVpbGQiLCJ0cmF2ZXJzZVBsYWluIiwidHJhdmVyc2VFbGVtZW50IiwidHJhdmVyc2VQcm9qZWN0aW9uIiwiRVNDQVBFX1NFUVVFTkNFIiwiZiIsInIiLCJ0IiwiZXhwYW5kSGV4IiwiY2hhckNvZGUiLCJwYXJzZUludCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIkdyb3FRdWVyeUVycm9yIiwiRVhQUl9CVUlMREVSIiwiZ3JvdXAiLCJwIiwiZXZlcnl0aGluZyIsInRoaXMiLCJkYmxwYXJlbnQiLCJ0cmF2ZXJzZSIsInRyYXZlcnNhbExpc3QiLCJUUkFWRVJTRV9CVUlMREVSIiwidHJhdmVyc2FsIiwidGhpc19hdHRyIiwibmVnIiwic3ViIiwibXVsIiwiZGl2IiwibW9kIiwiY29tcCIsImluX3JhbmdlIiwiY2hhciIsImludGVnZXIiLCJzdHJWYWx1ZSIsImZsb2F0Iiwic2NpIiwib2JqZWN0IiwiT0JKRUNUX0JVSUxERVIiLCJtZW1iZXJzIiwiZnVuY19jYWxsIiwibmFtZXNwYWNlIiwiYXJndW1lbnRTaG91bGRCZVNlbGVjdG9yIiwiU0VMRUNUT1JfQlVJTERFUiIsImZ1bmNzIiwidmFsaWRhdGVBcml0eSIsInBpcGVjYWxsIiwib2xkQWxsb3dCb29zdCIsIm1hcmtOYW1lIiwicGFpciIsImFuZCIsIm9yIiwibm90IiwiYXNjIiwiZGVzYyIsInBhcmFtIiwib2JqZWN0X2V4cHIiLCJ2YWx1ZTIiLCJleHRyYWN0UHJvcGVydHlLZXkiLCJvYmplY3RfcGFpciIsIm9iamVjdF9zcGxhdCIsIm9iamVjdF9zcGxhdF90aGlzIiwic3F1YXJlX2JyYWNrZXQiLCJwcm9qZWN0aW9uIiwiYXR0cl9hY2Nlc3MiLCJkZXJlZiIsIndyYXAiLCJhcnJheV9wb3N0Zml4IiwiZnVuY3Rpb25OYW1lIiwiYXJnQ291bnQiLCJmdW5jdGlvbnNSZXF1aXJpbmdTZWxlY3RvcnMiLCJpbmNsdWRlcyIsIkdyb3FTeW50YXhFcnJvciIsInBhcnNlIiwiaW5wdXQiLCJjb21wYXJlIiwiSW50bCIsIkNvbGxhdG9yIiwidHlwZU5vZGVzU29ydGVyIiwiaGFzaEZpZWxkIiwiaGFzaENhY2hlIiwiV2Vha01hcCIsImZpZWxkIiwiaGFzaCIsImNhbGN1bGF0ZUZpZWxkSGFzaCIsInNldCIsIm9mIiwiZW50cmllcyIsIm9wdGlvbmFsIiwiZGVyZWZlcmVuY2VzVG8iLCJyZXN0Iiwic29ydGVkIiwicmVtb3ZlRHVwbGljYXRlVHlwZU5vZGVzIiwidHlwZU5vZGVzIiwic2VlblR5cGVzIiwibmV3VHlwZU5vZGVzIiwic29ydGVkVHlwZU5vZGVzIiwidHlwZU5vZGUiLCJvcHRpbWl6ZVVuaW9ucyIsInN1YkZpZWxkIiwic3BsaWNlIiwiaGFzT3duIiwiY3JlYXRlUmVmZXJlbmNlVHlwZU5vZGUiLCJpbkFycmF5IiwiX3dlYWsiLCJfa2V5IiwibnVsbFVuaW9uIiwidW5pb25PZiIsIm5vZGVzIiwicmVzb2x2ZUlubGluZSIsInJlc29sdmVkSW5saW5lIiwibG9va3VwVHlwZURlY2xhcmF0aW9uIiwibWFwTm9kZSIsIm1lcmdlVW5pb25zIiwiaXNGdW5jQ2FsbCIsImJvb2xlYW5WYWx1ZSIsImNhbkJlVHJ1ZSIsImNhbkJlRmFsc2UiLCJjYW5CZU51bGwiLCJtYXRjaDIiLCJyZXNvbHZlZCIsImJvb2xlYW5PciIsImJvb2xlYW5BbmQiLCJib29sZWFuSW50ZXJwcmV0YXRpb25Ub1R5cGVOb2RlIiwiYm9vbCIsIiR0cmFjZSQxIiwibG9nIiwiY29uc29sZSIsImJpbmQiLCJzY2hlbWEiLCJsb29rdXBSZWYiLCJyZWZUbyIsImFsaWFzIiwiU2NvcGUyIiwidW5pb25XaXRob3V0TnVsbCIsInVuaW9uVHlwZU5vZGUiLCJmaWx0ZXIiLCJoYW5kbGVGdW5jQ2FsbE5vZGUiLCJ3YWxrIiwiYXJnMiIsIm9mMiIsImFycmF5QXJnIiwic2VwQXJnIiwiYXJyYXlBcmcyIiwic2VwQXJnMiIsImFyZzEiLCJhcmcxMiIsImFyZzIyIiwibm9kZTIiLCJhcmdOb2RlIiwiYWxsTnVsbCIsIm51bU5vZGUiLCJwcmVjaXNpb25Ob2RlIiwicHJlY2lzaW9uIiwibm9kZTMiLCJzdHJUeXBlTm9kZSIsInByZWZpeFR5cGVOb2RlIiwic3RyTm9kZSIsInByZWZpeE5vZGUiLCJzZXBUeXBlTm9kZSIsInNlcE5vZGUiLCJ0eXBlTm9kZTIiLCIkdHJhY2UiLCIkZGVidWciLCIkd2FybiIsInR5cGVFdmFsdWF0ZSIsImFzdCIsInBhcnNlZCIsIm9wdGltaXplZCIsIm1hcERlcmVmIiwiaGFuZGxlRGVyZWZOb2RlIiwiZGVyZWZlZE5vZGUiLCJoYW5kbGVPYmplY3RTcGxhdE5vZGUiLCJyZXNvbHZlZFJlc3QiLCJoYW5kbGVPYmplY3ROb2RlIiwib2JqZWN0QXR0cmlidXRlcyIsInNwbGF0VmFyaWFudHMiLCJjb25kaXRpb25hbFZhcmlhbnRzIiwiYXR0cmlidXRlTm9kZSIsInZhcmlhbnQiLCJhdHRyaWJ1dGVOb2RlMiIsImd1YXJhbnRlZWRBdHRyaWJ1dGVzIiwic3BsYXROb2RlIiwiYXR0cmlidXRlIiwiZnJvbUVudHJpZXMiLCJtYXRyaXgiLCJ1bmlvbklkeCIsInVuaW9uIiwidW5pb25HdWFyYW50ZWVkQmVmb3JlIiwidW5pb25HdWFyYW50ZWVkQWZ0ZXIiLCJndWFyYW50ZWVkSW5kZXgiLCJhbGxWYXJpYW50c0F0dHJpYnV0ZXMiLCJjb25kaXRpb25hbFZhcmlhbnRJZHgiLCJvdGhlclVuaW9uIiwidmFyaWFudEF0dHJpYnV0ZXMiLCJvdXRlcklkeCIsIm91dGVyQXR0cmlidXRlcyIsIm91dGVyIiwiaW5uZXJJZHgiLCJpbm5lckF0dHJpYnV0ZXMiLCJfYmVmb3JlIiwiX2FmdGVyIiwiaGFuZGxlT3BDYWxsTm9kZSIsImxocyIsImlzUHJpbWl0aXZlVHlwZU5vZGUiLCJldmFsdWF0ZUNvbXBhcmlzb24iLCJhcnJheVR5cGVOb2RlIiwiaGFuZGxlU2VsZWN0Tm9kZSIsImd1YXJhbnRlZWQiLCJhbHRlcm5hdGl2ZSIsImNvbmRpdGlvblZhbHVlIiwiY29uZGl0aW9uU2NvcGUiLCJyZXNvbHZlRmlsdGVyIiwiaGFuZGxlQXJyYXlDb2VyY2VOb2RlIiwibWFwQXJyYXkiLCJiYXNlMiIsImhhbmRsZUZsYXRNYXAiLCJpbm5lcjIiLCJoYW5kbGVNYXAiLCJoYW5kbGVQcm9qZWN0aW9uTm9kZSIsIm1hcE9iamVjdCIsImNyZWF0ZUZpbHRlclNjb3BlIiwiaGFuZGxlRmlsdGVyTm9kZSIsImhhbmRsZUFjY2Vzc0F0dHJpYnV0ZU5vZGUiLCJhdHRyaWJ1dGVCYXNlIiwiaGFuZGxlQWNjZXNzQXR0cmlidXRlQmFzZSIsImhhbmRsZUFjY2Vzc0VsZW1lbnROb2RlIiwiaGFuZGxlQXJyYXlOb2RlIiwiZWwiLCJoYW5kbGVWYWx1ZU5vZGUiLCJoYW5kbGVTbGljZSIsImhhbmRsZVBhcmVudE5vZGUiLCJoYW5kbGVOb3ROb2RlIiwiaGFuZGxlTmVnTm9kZSIsImhhbmRsZVBvc05vZGUiLCJoYW5kbGVFdmVyeXRoaW5nTm9kZSIsImhhbmRsZUFuZE5vZGUiLCJoYW5kbGVPck5vZGUiLCJPVkVSUklERV9UWVBFX1NZTUJPTCIsIm9wY2FsbCIsImZpbHRlcmVkIiwic3ViU2NvcGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/groq-js/dist/1.mjs\n");

/***/ })

};
;