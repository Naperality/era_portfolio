"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/doc-path";
exports.ids = ["vendor-chunks/doc-path"];
exports.modules = {

/***/ "(ssr)/./node_modules/doc-path/lib/path.js":
/*!*******************************************!*\
  !*** ./node_modules/doc-path/lib/path.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * @license MIT\n * doc-path <https://github.com/mrodrig/doc-path>\n * Copyright (c) 2015-present, Michael Rodrigues.\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.setPath = exports.evaluatePath = void 0;\n/**\n * Main function that evaluates the path in a particular object\n * @throws {Error} possible error if call stack size is exceeded\n */ function evaluatePath(obj, kp) {\n    if (!obj) {\n        return null;\n    }\n    const { dotIndex, key, remaining } = state(kp);\n    const kpVal = typeof obj === \"object\" && kp in obj ? obj[kp] : undefined;\n    const keyVal = typeof obj === \"object\" && key in obj ? obj[key] : undefined;\n    if (dotIndex >= 0 && typeof obj === \"object\" && !(kp in obj)) {\n        const { key: nextKey } = state(remaining);\n        const nextKeyAsInt = parseInt(nextKey);\n        // If there's an array at the current key in the object, then iterate over those items evaluating the remaining path\n        if (Array.isArray(keyVal) && isNaN(nextKeyAsInt)) {\n            return keyVal.map((doc)=>evaluatePath(doc, remaining));\n        }\n        // Otherwise, we can just recur\n        return evaluatePath(keyVal, remaining);\n    } else if (Array.isArray(obj)) {\n        const keyAsInt = parseInt(key);\n        if (kp === key && dotIndex === -1 && !isNaN(keyAsInt)) {\n            return keyVal;\n        }\n        // If this object is actually an array, then iterate over those items evaluating the path\n        return obj.map((doc)=>evaluatePath(doc, kp));\n    } else if (dotIndex >= 0 && kp !== key && typeof obj === \"object\" && key in obj) {\n        // If there's a field with a non-nested dot, then recur into that sub-value\n        return evaluatePath(keyVal, remaining);\n    } else if (dotIndex === -1 && typeof obj === \"object\" && key in obj && !(kp in obj)) {\n        // If the field is here, but the key was escaped\n        return keyVal;\n    }\n    // Otherwise, we can just return value directly\n    return kpVal;\n}\nexports.evaluatePath = evaluatePath;\n/**\n * Main function that performs validation before passing off to _sp\n * @throws {Error} possible error if call stack size is exceeded\n */ function setPath(obj, kp, v) {\n    if (!obj) {\n        throw new Error(\"No object was provided.\");\n    } else if (!kp) {\n        throw new Error(\"No keyPath was provided.\");\n    }\n    return _sp(obj, kp, v);\n}\nexports.setPath = setPath;\n// Helper function that will set the value in the provided object/array.\nfunction _sp(obj, kp, v) {\n    const { dotIndex, key, remaining } = state(kp);\n    // If this is clearly a prototype pollution attempt, then refuse to modify the path\n    if (kp.startsWith(\"__proto__\") || kp.startsWith(\"constructor\") || kp.startsWith(\"prototype\")) {\n        return obj;\n    }\n    if (dotIndex >= 0) {\n        const keyAsInt = parseInt(key);\n        // If there is a '.' in the key path, recur on the subdoc and ...\n        if (typeof obj === \"object\" && obj !== null && !(key in obj) && Array.isArray(obj) && !isNaN(keyAsInt)) {\n            // If there's no value at obj[key] then populate an empty object\n            obj[key] = obj[key] ?? {};\n            // Continue iterating on the rest of the key path to set the appropriate value where intended and then return\n            _sp(obj[key], remaining, v);\n            return obj;\n        } else if (typeof obj === \"object\" && obj !== null && !(key in obj) && Array.isArray(obj)) {\n            // If this is an array and there are multiple levels of keys to iterate over, recur.\n            obj.forEach((doc)=>_sp(doc, kp, v));\n            return obj;\n        } else if (typeof obj === \"object\" && obj !== null && !(key in obj) && !Array.isArray(obj)) {\n            const { key: nextKey } = state(remaining);\n            const nextKeyAsInt = parseInt(nextKey);\n            if (!isNaN(nextKeyAsInt)) {\n                // If the current key doesn't exist yet and the next key is a number (likely array index), populate an empty array\n                obj[key] = [];\n            } else if (remaining === \"\") {\n                // If the remaining key is empty, then a `.` character appeared right at the end of the path and wasn't actually indicating a separate level\n                obj[kp] = v;\n                return obj;\n            } else {\n                // If the current key doesn't exist yet, populate it\n                obj[key] = {};\n            }\n        }\n        _sp(obj[key], remaining, v);\n    } else if (Array.isArray(obj)) {\n        const keyAsInt = parseInt(key);\n        // If the object is an array and this key is an int (likely array index), then set the value directly and return\n        if (kp === key && dotIndex === -1 && !isNaN(keyAsInt)) {\n            obj[key] = v;\n            return obj;\n        }\n        // If this \"obj\" is actually an array, then we can loop over each of the values and set the path\n        obj.forEach((doc)=>_sp(doc, remaining, v));\n        return obj;\n    } else {\n        // Otherwise, we can set the path directly\n        obj[key] = v;\n    }\n    return obj;\n}\n// Helper function that returns some information necessary to evaluate or set a path  based on the provided keyPath value\nfunction state(kp) {\n    const dotIndex = findFirstNonEscapedDotIndex(kp);\n    return {\n        dotIndex,\n        key: kp.slice(0, dotIndex >= 0 ? dotIndex : undefined).replace(/\\\\./g, \".\"),\n        remaining: kp.slice(dotIndex + 1)\n    };\n}\nfunction findFirstNonEscapedDotIndex(kp) {\n    for(let i = 0; i < kp.length; i++){\n        const previousChar = i > 0 ? kp[i - 1] : \"\", currentChar = kp[i];\n        if (currentChar === \".\" && previousChar !== \"\\\\\") return i;\n    }\n    return -1;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jLXBhdGgvbGliL3BhdGguanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Q0FJQyxHQUNEO0FBQ0FBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxlQUFlLEdBQUdBLG9CQUFvQixHQUFHLEtBQUs7QUFDOUM7OztDQUdDLEdBQ0QsU0FBU0csYUFBYUMsR0FBRyxFQUFFQyxFQUFFO0lBQ3pCLElBQUksQ0FBQ0QsS0FBSztRQUNOLE9BQU87SUFDWDtJQUNBLE1BQU0sRUFBRUUsUUFBUSxFQUFFQyxHQUFHLEVBQUVDLFNBQVMsRUFBRSxHQUFHQyxNQUFNSjtJQUMzQyxNQUFNSyxRQUFRLE9BQU9OLFFBQVEsWUFBWUMsTUFBTUQsTUFBTUEsR0FBRyxDQUFDQyxHQUFHLEdBQUdNO0lBQy9ELE1BQU1DLFNBQVMsT0FBT1IsUUFBUSxZQUFZRyxPQUFPSCxNQUFNQSxHQUFHLENBQUNHLElBQUksR0FBR0k7SUFDbEUsSUFBSUwsWUFBWSxLQUFLLE9BQU9GLFFBQVEsWUFBWSxDQUFFQyxDQUFBQSxNQUFNRCxHQUFFLEdBQUk7UUFDMUQsTUFBTSxFQUFFRyxLQUFLTSxPQUFPLEVBQUUsR0FBR0osTUFBTUQ7UUFDL0IsTUFBTU0sZUFBZUMsU0FBU0Y7UUFDOUIsb0hBQW9IO1FBQ3BILElBQUlHLE1BQU1DLE9BQU8sQ0FBQ0wsV0FBV00sTUFBTUosZUFBZTtZQUM5QyxPQUFPRixPQUFPTyxHQUFHLENBQUMsQ0FBQ0MsTUFBUWpCLGFBQWFpQixLQUFLWjtRQUNqRDtRQUNBLCtCQUErQjtRQUMvQixPQUFPTCxhQUFhUyxRQUFRSjtJQUNoQyxPQUNLLElBQUlRLE1BQU1DLE9BQU8sQ0FBQ2IsTUFBTTtRQUN6QixNQUFNaUIsV0FBV04sU0FBU1I7UUFDMUIsSUFBSUYsT0FBT0UsT0FBT0QsYUFBYSxDQUFDLEtBQUssQ0FBQ1ksTUFBTUcsV0FBVztZQUNuRCxPQUFPVDtRQUNYO1FBQ0EseUZBQXlGO1FBQ3pGLE9BQU9SLElB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QUFNRyxXQUFXO1lBQ25EakIsR0FBRyxDQUFDRyxJQUFJLEdBQUdlO1lBQ1gsT0FBT2xCO1FBQ1g7UUFDQSxnR0FBZ0c7UUFDaEdBLElBQUlzQixPQUFPLENBQUMsQ0FBQ04sTUFBUUksSUFBSUosS0FBS1osV0FBV2M7UUFDekMsT0FBT2xCO0lBQ1gsT0FDSztRQUNELDBDQUEwQztRQUMxQ0EsR0FBRyxDQUFDRyxJQUFJLEdBQUdlO0lBQ2Y7SUFDQSxPQUFPbEI7QUFDWDtBQUNBLHlIQUF5SDtBQUN6SCxTQUFTSyxNQUFNSixFQUFFO0lBQ2IsTUFBTUMsV0FBV3FCLDRCQUE0QnRCO0lBQzdDLE9BQU87UUFDSEM7UUFDQUMsS0FBS0YsR0FBR3VCLEtBQUssQ0FBQyxHQUFHdEIsWUFBWSxJQUFJQSxXQUFXSyxXQUFXa0IsT0FBTyxDQUFDLFFBQVE7UUFDdkVyQixXQUFXSCxHQUFHdUIsS0FBSyxDQUFDdEIsV0FBVztJQUNuQztBQUNKO0FBQ0EsU0FBU3FCLDRCQUE0QnRCLEVBQUU7SUFDbkMsSUFBSyxJQUFJeUIsSUFBSSxHQUFHQSxJQUFJekIsR0FBRzBCLE1BQU0sRUFBRUQsSUFBSztRQUNoQyxNQUFNRSxlQUFlRixJQUFJLElBQUl6QixFQUFFLENBQUN5QixJQUFJLEVBQUUsR0FBRyxJQUFJRyxjQUFjNUIsRUFBRSxDQUFDeUIsRUFBRTtRQUNoRSxJQUFJRyxnQkFBZ0IsT0FBT0QsaUJBQWlCLE1BQ3hDLE9BQU9GO0lBQ2Y7SUFDQSxPQUFPLENBQUM7QUFDWiIsInNvdXJjZXMiOlsid2VicGFjazovL2VyYS1wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvZG9jLXBhdGgvbGliL3BhdGguanM/YjM5OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIE1JVFxuICogZG9jLXBhdGggPGh0dHBzOi8vZ2l0aHViLmNvbS9tcm9kcmlnL2RvYy1wYXRoPlxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIE1pY2hhZWwgUm9kcmlndWVzLlxuICovXG4ndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNldFBhdGggPSBleHBvcnRzLmV2YWx1YXRlUGF0aCA9IHZvaWQgMDtcbi8qKlxuICogTWFpbiBmdW5jdGlvbiB0aGF0IGV2YWx1YXRlcyB0aGUgcGF0aCBpbiBhIHBhcnRpY3VsYXIgb2JqZWN0XG4gKiBAdGhyb3dzIHtFcnJvcn0gcG9zc2libGUgZXJyb3IgaWYgY2FsbCBzdGFjayBzaXplIGlzIGV4Y2VlZGVkXG4gKi9cbmZ1bmN0aW9uIGV2YWx1YXRlUGF0aChvYmosIGtwKSB7XG4gICAgaWYgKCFvYmopIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHsgZG90SW5kZXgsIGtleSwgcmVtYWluaW5nIH0gPSBzdGF0ZShrcCk7XG4gICAgY29uc3Qga3BWYWwgPSB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBrcCBpbiBvYmogPyBvYmpba3BdIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IGtleVZhbCA9IHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIGtleSBpbiBvYmogPyBvYmpba2V5XSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoZG90SW5kZXggPj0gMCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiAhKGtwIGluIG9iaikpIHtcbiAgICAgICAgY29uc3QgeyBrZXk6IG5leHRLZXkgfSA9IHN0YXRlKHJlbWFpbmluZyk7XG4gICAgICAgIGNvbnN0IG5leHRLZXlBc0ludCA9IHBhcnNlSW50KG5leHRLZXkpO1xuICAgICAgICAvLyBJZiB0aGVyZSdzIGFuIGFycmF5IGF0IHRoZSBjdXJyZW50IGtleSBpbiB0aGUgb2JqZWN0LCB0aGVuIGl0ZXJhdGUgb3ZlciB0aG9zZSBpdGVtcyBldmFsdWF0aW5nIHRoZSByZW1haW5pbmcgcGF0aFxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShrZXlWYWwpICYmIGlzTmFOKG5leHRLZXlBc0ludCkpIHtcbiAgICAgICAgICAgIHJldHVybiBrZXlWYWwubWFwKChkb2MpID0+IGV2YWx1YXRlUGF0aChkb2MsIHJlbWFpbmluZykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwgd2UgY2FuIGp1c3QgcmVjdXJcbiAgICAgICAgcmV0dXJuIGV2YWx1YXRlUGF0aChrZXlWYWwsIHJlbWFpbmluZyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICBjb25zdCBrZXlBc0ludCA9IHBhcnNlSW50KGtleSk7XG4gICAgICAgIGlmIChrcCA9PT0ga2V5ICYmIGRvdEluZGV4ID09PSAtMSAmJiAhaXNOYU4oa2V5QXNJbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5VmFsO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoaXMgb2JqZWN0IGlzIGFjdHVhbGx5IGFuIGFycmF5LCB0aGVuIGl0ZXJhdGUgb3ZlciB0aG9zZSBpdGVtcyBldmFsdWF0aW5nIHRoZSBwYXRoXG4gICAgICAgIHJldHVybiBvYmoubWFwKChkb2MpID0+IGV2YWx1YXRlUGF0aChkb2MsIGtwKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRvdEluZGV4ID49IDAgJiYga3AgIT09IGtleSAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBrZXkgaW4gb2JqKSB7XG4gICAgICAgIC8vIElmIHRoZXJlJ3MgYSBmaWVsZCB3aXRoIGEgbm9uLW5lc3RlZCBkb3QsIHRoZW4gcmVjdXIgaW50byB0aGF0IHN1Yi12YWx1ZVxuICAgICAgICByZXR1cm4gZXZhbHVhdGVQYXRoKGtleVZhbCwgcmVtYWluaW5nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZG90SW5kZXggPT09IC0xICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIGtleSBpbiBvYmogJiYgIShrcCBpbiBvYmopKSB7XG4gICAgICAgIC8vIElmIHRoZSBmaWVsZCBpcyBoZXJlLCBidXQgdGhlIGtleSB3YXMgZXNjYXBlZFxuICAgICAgICByZXR1cm4ga2V5VmFsO1xuICAgIH1cbiAgICAvLyBPdGhlcndpc2UsIHdlIGNhbiBqdXN0IHJldHVybiB2YWx1ZSBkaXJlY3RseVxuICAgIHJldHVybiBrcFZhbDtcbn1cbmV4cG9ydHMuZXZhbHVhdGVQYXRoID0gZXZhbHVhdGVQYXRoO1xuLyoqXG4gKiBNYWluIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgdmFsaWRhdGlvbiBiZWZvcmUgcGFzc2luZyBvZmYgdG8gX3NwXG4gKiBAdGhyb3dzIHtFcnJvcn0gcG9zc2libGUgZXJyb3IgaWYgY2FsbCBzdGFjayBzaXplIGlzIGV4Y2VlZGVkXG4gKi9cbmZ1bmN0aW9uIHNldFBhdGgob2JqLCBrcCwgdikge1xuICAgIGlmICghb2JqKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gb2JqZWN0IHdhcyBwcm92aWRlZC4nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWtwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8ga2V5UGF0aCB3YXMgcHJvdmlkZWQuJyk7XG4gICAgfVxuICAgIHJldHVybiBfc3Aob2JqLCBrcCwgdik7XG59XG5leHBvcnRzLnNldFBhdGggPSBzZXRQYXRoO1xuLy8gSGVscGVyIGZ1bmN0aW9uIHRoYXQgd2lsbCBzZXQgdGhlIHZhbHVlIGluIHRoZSBwcm92aWRlZCBvYmplY3QvYXJyYXkuXG5mdW5jdGlvbiBfc3Aob2JqLCBrcCwgdikge1xuICAgIGNvbnN0IHsgZG90SW5kZXgsIGtleSwgcmVtYWluaW5nIH0gPSBzdGF0ZShrcCk7XG4gICAgLy8gSWYgdGhpcyBpcyBjbGVhcmx5IGEgcHJvdG90eXBlIHBvbGx1dGlvbiBhdHRlbXB0LCB0aGVuIHJlZnVzZSB0byBtb2RpZnkgdGhlIHBhdGhcbiAgICBpZiAoa3Auc3RhcnRzV2l0aCgnX19wcm90b19fJykgfHwga3Auc3RhcnRzV2l0aCgnY29uc3RydWN0b3InKSB8fCBrcC5zdGFydHNXaXRoKCdwcm90b3R5cGUnKSkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBpZiAoZG90SW5kZXggPj0gMCkge1xuICAgICAgICBjb25zdCBrZXlBc0ludCA9IHBhcnNlSW50KGtleSk7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGEgJy4nIGluIHRoZSBrZXkgcGF0aCwgcmVjdXIgb24gdGhlIHN1YmRvYyBhbmQgLi4uXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGwgJiYgIShrZXkgaW4gb2JqKSAmJiBBcnJheS5pc0FycmF5KG9iaikgJiYgIWlzTmFOKGtleUFzSW50KSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBubyB2YWx1ZSBhdCBvYmpba2V5XSB0aGVuIHBvcHVsYXRlIGFuIGVtcHR5IG9iamVjdFxuICAgICAgICAgICAgb2JqW2tleV0gPSBvYmpba2V5XSA/PyB7fTtcbiAgICAgICAgICAgIC8vIENvbnRpbnVlIGl0ZXJhdGluZyBvbiB0aGUgcmVzdCBvZiB0aGUga2V5IHBhdGggdG8gc2V0IHRoZSBhcHByb3ByaWF0ZSB2YWx1ZSB3aGVyZSBpbnRlbmRlZCBhbmQgdGhlbiByZXR1cm5cbiAgICAgICAgICAgIF9zcChvYmpba2V5XSwgcmVtYWluaW5nLCB2KTtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsICYmICEoa2V5IGluIG9iaikgJiYgQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGFuIGFycmF5IGFuZCB0aGVyZSBhcmUgbXVsdGlwbGUgbGV2ZWxzIG9mIGtleXMgdG8gaXRlcmF0ZSBvdmVyLCByZWN1ci5cbiAgICAgICAgICAgIG9iai5mb3JFYWNoKChkb2MpID0+IF9zcChkb2MsIGtwLCB2KSk7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCAmJiAhKGtleSBpbiBvYmopICYmICFBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgIGNvbnN0IHsga2V5OiBuZXh0S2V5IH0gPSBzdGF0ZShyZW1haW5pbmcpO1xuICAgICAgICAgICAgY29uc3QgbmV4dEtleUFzSW50ID0gcGFyc2VJbnQobmV4dEtleSk7XG4gICAgICAgICAgICBpZiAoIWlzTmFOKG5leHRLZXlBc0ludCkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY3VycmVudCBrZXkgZG9lc24ndCBleGlzdCB5ZXQgYW5kIHRoZSBuZXh0IGtleSBpcyBhIG51bWJlciAobGlrZWx5IGFycmF5IGluZGV4KSwgcG9wdWxhdGUgYW4gZW1wdHkgYXJyYXlcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVtYWluaW5nID09PSAnJykge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZW1haW5pbmcga2V5IGlzIGVtcHR5LCB0aGVuIGEgYC5gIGNoYXJhY3RlciBhcHBlYXJlZCByaWdodCBhdCB0aGUgZW5kIG9mIHRoZSBwYXRoIGFuZCB3YXNuJ3QgYWN0dWFsbHkgaW5kaWNhdGluZyBhIHNlcGFyYXRlIGxldmVsXG4gICAgICAgICAgICAgICAgb2JqW2twXSA9IHY7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjdXJyZW50IGtleSBkb2Vzbid0IGV4aXN0IHlldCwgcG9wdWxhdGUgaXRcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF9zcChvYmpba2V5XSwgcmVtYWluaW5nLCB2KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgIGNvbnN0IGtleUFzSW50ID0gcGFyc2VJbnQoa2V5KTtcbiAgICAgICAgLy8gSWYgdGhlIG9iamVjdCBpcyBhbiBhcnJheSBhbmQgdGhpcyBrZXkgaXMgYW4gaW50IChsaWtlbHkgYXJyYXkgaW5kZXgpLCB0aGVuIHNldCB0aGUgdmFsdWUgZGlyZWN0bHkgYW5kIHJldHVyblxuICAgICAgICBpZiAoa3AgPT09IGtleSAmJiBkb3RJbmRleCA9PT0gLTEgJiYgIWlzTmFOKGtleUFzSW50KSkge1xuICAgICAgICAgICAgb2JqW2tleV0gPSB2O1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGlzIFwib2JqXCIgaXMgYWN0dWFsbHkgYW4gYXJyYXksIHRoZW4gd2UgY2FuIGxvb3Agb3ZlciBlYWNoIG9mIHRoZSB2YWx1ZXMgYW5kIHNldCB0aGUgcGF0aFxuICAgICAgICBvYmouZm9yRWFjaCgoZG9jKSA9PiBfc3AoZG9jLCByZW1haW5pbmcsIHYpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgd2UgY2FuIHNldCB0aGUgcGF0aCBkaXJlY3RseVxuICAgICAgICBvYmpba2V5XSA9IHY7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG4vLyBIZWxwZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHNvbWUgaW5mb3JtYXRpb24gbmVjZXNzYXJ5IHRvIGV2YWx1YXRlIG9yIHNldCBhIHBhdGggIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBrZXlQYXRoIHZhbHVlXG5mdW5jdGlvbiBzdGF0ZShrcCkge1xuICAgIGNvbnN0IGRvdEluZGV4ID0gZmluZEZpcnN0Tm9uRXNjYXBlZERvdEluZGV4KGtwKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkb3RJbmRleCxcbiAgICAgICAga2V5OiBrcC5zbGljZSgwLCBkb3RJbmRleCA+PSAwID8gZG90SW5kZXggOiB1bmRlZmluZWQpLnJlcGxhY2UoL1xcXFwuL2csICcuJyksXG4gICAgICAgIHJlbWFpbmluZzoga3Auc2xpY2UoZG90SW5kZXggKyAxKVxuICAgIH07XG59XG5mdW5jdGlvbiBmaW5kRmlyc3ROb25Fc2NhcGVkRG90SW5kZXgoa3ApIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzQ2hhciA9IGkgPiAwID8ga3BbaSAtIDFdIDogJycsIGN1cnJlbnRDaGFyID0ga3BbaV07XG4gICAgICAgIGlmIChjdXJyZW50Q2hhciA9PT0gJy4nICYmIHByZXZpb3VzQ2hhciAhPT0gJ1xcXFwnKVxuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInNldFBhdGgiLCJldmFsdWF0ZVBhdGgiLCJvYmoiLCJrcCIsImRvdEluZGV4Iiwia2V5IiwicmVtYWluaW5nIiwic3RhdGUiLCJrcFZhbCIsInVuZGVmaW5lZCIsImtleVZhbCIsIm5leHRLZXkiLCJuZXh0S2V5QXNJbnQiLCJwYXJzZUludCIsIkFycmF5IiwiaXNBcnJheSIsImlzTmFOIiwibWFwIiwiZG9jIiwia2V5QXNJbnQiLCJ2IiwiRXJyb3IiLCJfc3AiLCJzdGFydHNXaXRoIiwiZm9yRWFjaCIsImZpbmRGaXJzdE5vbkVzY2FwZWREb3RJbmRleCIsInNsaWNlIiwicmVwbGFjZSIsImkiLCJsZW5ndGgiLCJwcmV2aW91c0NoYXIiLCJjdXJyZW50Q2hhciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/doc-path/lib/path.js\n");

/***/ })

};
;