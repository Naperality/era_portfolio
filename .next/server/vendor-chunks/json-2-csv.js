"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/json-2-csv";
exports.ids = ["vendor-chunks/json-2-csv"];
exports.modules = {

/***/ "(ssr)/./node_modules/json-2-csv/lib/constants.js":
/*!**************************************************!*\
  !*** ./node_modules/json-2-csv/lib/constants.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.excelBOM = exports.defaultCsv2JsonOptions = exports.defaultJson2CsvOptions = exports.errors = void 0;\nexports.errors = {\n    optionsRequired: \"Options were not passed and are required.\",\n    json2csv: {\n        cannotCallOn: \"Cannot call json2csv on\",\n        dataCheckFailure: \"Data provided was not an array of documents.\",\n        notSameSchema: \"Not all documents have the same schema.\"\n    },\n    csv2json: {\n        cannotCallOn: \"Cannot call csv2json on\",\n        dataCheckFailure: \"CSV is not a string.\"\n    }\n};\nexports.defaultJson2CsvOptions = {\n    arrayIndexesAsKeys: false,\n    checkSchemaDifferences: false,\n    delimiter: {\n        field: \",\",\n        wrap: '\"',\n        eol: \"\\n\"\n    },\n    emptyFieldValue: undefined,\n    escapeHeaderNestedDots: true,\n    excelBOM: false,\n    excludeKeys: [],\n    expandNestedObjects: true,\n    expandArrayObjects: false,\n    prependHeader: true,\n    preventCsvInjection: false,\n    sortHeader: false,\n    trimFieldValues: false,\n    trimHeaderFields: false,\n    unwindArrays: false,\n    useDateIso8601Format: false,\n    useLocaleFormat: false,\n    wrapBooleans: false\n};\nexports.defaultCsv2JsonOptions = {\n    delimiter: {\n        field: \",\",\n        wrap: '\"',\n        eol: \"\\n\"\n    },\n    excelBOM: false,\n    preventCsvInjection: false,\n    trimFieldValues: false,\n    trimHeaderFields: false\n};\nexports.excelBOM = \"\\uFEFF\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbi0yLWNzdi9saWIvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0FBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxnQkFBZ0IsR0FBR0EsOEJBQThCLEdBQUdBLDhCQUE4QixHQUFHQSxjQUFjLEdBQUcsS0FBSztBQUMzR0EsY0FBYyxHQUFHO0lBQ2JNLGlCQUFpQjtJQUNqQkMsVUFBVTtRQUNOQyxjQUFjO1FBQ2RDLGtCQUFrQjtRQUNsQkMsZUFBZTtJQUNuQjtJQUNBQyxVQUFVO1FBQ05ILGNBQWM7UUFDZEMsa0JBQWtCO0lBQ3RCO0FBQ0o7QUFDQVQsOEJBQThCLEdBQUc7SUFDN0JZLG9CQUFvQjtJQUNwQkMsd0JBQXdCO0lBQ3hCQyxXQUFXO1FBQ1BDLE9BQU87UUFDUEMsTUFBTTtRQUNOQyxLQUFLO0lBQ1Q7SUFDQUMsaUJBQWlCQztJQUNqQkMsd0JBQXdCO0lBQ3hCbEIsVUFBVTtJQUNWbUIsYUFBYSxFQUFFO0lBQ2ZDLHFCQUFxQjtJQUNyQkMsb0JBQW9CO0lBQ3BCQyxlQUFlO0lBQ2ZDLHFCQUFxQjtJQUNyQkMsWUFBWTtJQUNaQyxpQkFBaUI7SUFDakJDLGtCQUFrQjtJQUNsQkMsY0FBYztJQUNkQyxzQkFBc0I7SUFDdEJDLGlCQUFpQjtJQUNqQkMsY0FBYztBQUNsQjtBQUNBaEMsOEJBQThCLEdBQUc7SUFDN0JjLFdBQVc7UUFDUEMsT0FBTztRQUNQQyxNQUFNO1FBQ05DLEtBQUs7SUFDVDtJQUNBZixVQUFVO0lBQ1Z1QixxQkFBcUI7SUFDckJFLGlCQUFpQjtJQUNqQkMsa0JBQWtCO0FBQ3RCO0FBQ0E1QixnQkFBZ0IsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL2VyYS1wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvanNvbi0yLWNzdi9saWIvY29uc3RhbnRzLmpzP2QxNmQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5leGNlbEJPTSA9IGV4cG9ydHMuZGVmYXVsdENzdjJKc29uT3B0aW9ucyA9IGV4cG9ydHMuZGVmYXVsdEpzb24yQ3N2T3B0aW9ucyA9IGV4cG9ydHMuZXJyb3JzID0gdm9pZCAwO1xuZXhwb3J0cy5lcnJvcnMgPSB7XG4gICAgb3B0aW9uc1JlcXVpcmVkOiAnT3B0aW9ucyB3ZXJlIG5vdCBwYXNzZWQgYW5kIGFyZSByZXF1aXJlZC4nLFxuICAgIGpzb24yY3N2OiB7XG4gICAgICAgIGNhbm5vdENhbGxPbjogJ0Nhbm5vdCBjYWxsIGpzb24yY3N2IG9uJyxcbiAgICAgICAgZGF0YUNoZWNrRmFpbHVyZTogJ0RhdGEgcHJvdmlkZWQgd2FzIG5vdCBhbiBhcnJheSBvZiBkb2N1bWVudHMuJyxcbiAgICAgICAgbm90U2FtZVNjaGVtYTogJ05vdCBhbGwgZG9jdW1lbnRzIGhhdmUgdGhlIHNhbWUgc2NoZW1hLidcbiAgICB9LFxuICAgIGNzdjJqc29uOiB7XG4gICAgICAgIGNhbm5vdENhbGxPbjogJ0Nhbm5vdCBjYWxsIGNzdjJqc29uIG9uJyxcbiAgICAgICAgZGF0YUNoZWNrRmFpbHVyZTogJ0NTViBpcyBub3QgYSBzdHJpbmcuJ1xuICAgIH1cbn07XG5leHBvcnRzLmRlZmF1bHRKc29uMkNzdk9wdGlvbnMgPSB7XG4gICAgYXJyYXlJbmRleGVzQXNLZXlzOiBmYWxzZSxcbiAgICBjaGVja1NjaGVtYURpZmZlcmVuY2VzOiBmYWxzZSxcbiAgICBkZWxpbWl0ZXI6IHtcbiAgICAgICAgZmllbGQ6ICcsJyxcbiAgICAgICAgd3JhcDogJ1wiJyxcbiAgICAgICAgZW9sOiAnXFxuJ1xuICAgIH0sXG4gICAgZW1wdHlGaWVsZFZhbHVlOiB1bmRlZmluZWQsXG4gICAgZXNjYXBlSGVhZGVyTmVzdGVkRG90czogdHJ1ZSxcbiAgICBleGNlbEJPTTogZmFsc2UsXG4gICAgZXhjbHVkZUtleXM6IFtdLFxuICAgIGV4cGFuZE5lc3RlZE9iamVjdHM6IHRydWUsXG4gICAgZXhwYW5kQXJyYXlPYmplY3RzOiBmYWxzZSxcbiAgICBwcmVwZW5kSGVhZGVyOiB0cnVlLFxuICAgIHByZXZlbnRDc3ZJbmplY3Rpb246IGZhbHNlLFxuICAgIHNvcnRIZWFkZXI6IGZhbHNlLFxuICAgIHRyaW1GaWVsZFZhbHVlczogZmFsc2UsXG4gICAgdHJpbUhlYWRlckZpZWxkczogZmFsc2UsXG4gICAgdW53aW5kQXJyYXlzOiBmYWxzZSxcbiAgICB1c2VEYXRlSXNvODYwMUZvcm1hdDogZmFsc2UsXG4gICAgdXNlTG9jYWxlRm9ybWF0OiBmYWxzZSxcbiAgICB3cmFwQm9vbGVhbnM6IGZhbHNlLFxufTtcbmV4cG9ydHMuZGVmYXVsdENzdjJKc29uT3B0aW9ucyA9IHtcbiAgICBkZWxpbWl0ZXI6IHtcbiAgICAgICAgZmllbGQ6ICcsJyxcbiAgICAgICAgd3JhcDogJ1wiJyxcbiAgICAgICAgZW9sOiAnXFxuJ1xuICAgIH0sXG4gICAgZXhjZWxCT006IGZhbHNlLFxuICAgIHByZXZlbnRDc3ZJbmplY3Rpb246IGZhbHNlLFxuICAgIHRyaW1GaWVsZFZhbHVlczogZmFsc2UsXG4gICAgdHJpbUhlYWRlckZpZWxkczogZmFsc2UsXG59O1xuZXhwb3J0cy5leGNlbEJPTSA9ICdcXHVmZWZmJztcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImV4Y2VsQk9NIiwiZGVmYXVsdENzdjJKc29uT3B0aW9ucyIsImRlZmF1bHRKc29uMkNzdk9wdGlvbnMiLCJlcnJvcnMiLCJvcHRpb25zUmVxdWlyZWQiLCJqc29uMmNzdiIsImNhbm5vdENhbGxPbiIsImRhdGFDaGVja0ZhaWx1cmUiLCJub3RTYW1lU2NoZW1hIiwiY3N2Mmpzb24iLCJhcnJheUluZGV4ZXNBc0tleXMiLCJjaGVja1NjaGVtYURpZmZlcmVuY2VzIiwiZGVsaW1pdGVyIiwiZmllbGQiLCJ3cmFwIiwiZW9sIiwiZW1wdHlGaWVsZFZhbHVlIiwidW5kZWZpbmVkIiwiZXNjYXBlSGVhZGVyTmVzdGVkRG90cyIsImV4Y2x1ZGVLZXlzIiwiZXhwYW5kTmVzdGVkT2JqZWN0cyIsImV4cGFuZEFycmF5T2JqZWN0cyIsInByZXBlbmRIZWFkZXIiLCJwcmV2ZW50Q3N2SW5qZWN0aW9uIiwic29ydEhlYWRlciIsInRyaW1GaWVsZFZhbHVlcyIsInRyaW1IZWFkZXJGaWVsZHMiLCJ1bndpbmRBcnJheXMiLCJ1c2VEYXRlSXNvODYwMUZvcm1hdCIsInVzZUxvY2FsZUZvcm1hdCIsIndyYXBCb29sZWFucyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/json-2-csv/lib/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/json-2-csv/lib/converter.js":
/*!**************************************************!*\
  !*** ./node_modules/json-2-csv/lib/converter.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.csv2json = exports.json2csv = void 0;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/json-2-csv/lib/constants.js\");\nconst json2csv_1 = __webpack_require__(/*! ./json2csv */ \"(ssr)/./node_modules/json-2-csv/lib/json2csv.js\");\nconst csv2json_1 = __webpack_require__(/*! ./csv2json */ \"(ssr)/./node_modules/json-2-csv/lib/csv2json.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/json-2-csv/lib/utils.js\");\nfunction json2csv(data, options) {\n    const builtOptions = (0, utils_1.buildJ2COptions)(options ?? {});\n    // Validate the parameters before calling the converter's convert function\n    (0, utils_1.validate)(data, utils_1.isObject, constants_1.errors.json2csv);\n    return (0, json2csv_1.Json2Csv)(builtOptions).convert(data);\n}\nexports.json2csv = json2csv;\nfunction csv2json(data, options) {\n    const builtOptions = (0, utils_1.buildC2JOptions)(options ?? {});\n    // Validate the parameters before calling the converter's convert function\n    (0, utils_1.validate)(data, utils_1.isString, constants_1.errors.csv2json);\n    return (0, csv2json_1.Csv2Json)(builtOptions).convert(data);\n}\nexports.csv2json = csv2json;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbi0yLWNzdi9saWIvY29udmVydGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0FBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxnQkFBZ0IsR0FBR0EsZ0JBQWdCLEdBQUcsS0FBSztBQUMzQyxNQUFNSSxjQUFjQyxtQkFBT0EsQ0FBQyxxRUFBYTtBQUN6QyxNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQyxtRUFBWTtBQUN2QyxNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQyxtRUFBWTtBQUN2QyxNQUFNRyxVQUFVSCxtQkFBT0EsQ0FBQyw2REFBUztBQUNqQyxTQUFTRixTQUFTTSxJQUFJLEVBQUVDLE9BQU87SUFDM0IsTUFBTUMsZUFBZSxDQUFDLEdBQUdILFFBQVFJLGVBQWUsRUFBRUYsV0FBVyxDQUFDO0lBQzlELDBFQUEwRTtJQUN6RSxJQUFHRixRQUFRSyxRQUFRLEVBQUVKLE1BQU1ELFFBQVFNLFFBQVEsRUFBRVYsWUFBWVcsTUFBTSxDQUFDWixRQUFRO0lBQ3pFLE9BQU8sQ0FBQyxHQUFHRyxXQUFXVSxRQUFRLEVBQUVMLGNBQWNNLE9BQU8sQ0FBQ1I7QUFDMUQ7QUFDQVQsZ0JBQWdCLEdBQUdHO0FBQ25CLFNBQVNELFNBQVNPLElBQUksRUFBRUMsT0FBTztJQUMzQixNQUFNQyxlQUFlLENBQUMsR0FBR0gsUUFBUVUsZUFBZSxFQUFFUixXQUFXLENBQUM7SUFDOUQsMEVBQTBFO0lBQ3pFLElBQUdGLFFBQVFLLFFBQVEsRUFBRUosTUFBTUQsUUFBUVcsUUFBUSxFQUFFZixZQUFZVyxNQUFNLENBQUNiLFFBQVE7SUFDekUsT0FBTyxDQUFDLEdBQUdLLFdBQVdhLFFBQVEsRUFBRVQsY0FBY00sT0FBTyxDQUFDUjtBQUMxRDtBQUNBVCxnQkFBZ0IsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lcmEtcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL2pzb24tMi1jc3YvbGliL2NvbnZlcnRlci5qcz8zZTIzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3N2Mmpzb24gPSBleHBvcnRzLmpzb24yY3N2ID0gdm9pZCAwO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBqc29uMmNzdl8xID0gcmVxdWlyZShcIi4vanNvbjJjc3ZcIik7XG5jb25zdCBjc3YyanNvbl8xID0gcmVxdWlyZShcIi4vY3N2Mmpzb25cIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5mdW5jdGlvbiBqc29uMmNzdihkYXRhLCBvcHRpb25zKSB7XG4gICAgY29uc3QgYnVpbHRPcHRpb25zID0gKDAsIHV0aWxzXzEuYnVpbGRKMkNPcHRpb25zKShvcHRpb25zID8/IHt9KTtcbiAgICAvLyBWYWxpZGF0ZSB0aGUgcGFyYW1ldGVycyBiZWZvcmUgY2FsbGluZyB0aGUgY29udmVydGVyJ3MgY29udmVydCBmdW5jdGlvblxuICAgICgwLCB1dGlsc18xLnZhbGlkYXRlKShkYXRhLCB1dGlsc18xLmlzT2JqZWN0LCBjb25zdGFudHNfMS5lcnJvcnMuanNvbjJjc3YpO1xuICAgIHJldHVybiAoMCwganNvbjJjc3ZfMS5Kc29uMkNzdikoYnVpbHRPcHRpb25zKS5jb252ZXJ0KGRhdGEpO1xufVxuZXhwb3J0cy5qc29uMmNzdiA9IGpzb24yY3N2O1xuZnVuY3Rpb24gY3N2Mmpzb24oZGF0YSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGJ1aWx0T3B0aW9ucyA9ICgwLCB1dGlsc18xLmJ1aWxkQzJKT3B0aW9ucykob3B0aW9ucyA/PyB7fSk7XG4gICAgLy8gVmFsaWRhdGUgdGhlIHBhcmFtZXRlcnMgYmVmb3JlIGNhbGxpbmcgdGhlIGNvbnZlcnRlcidzIGNvbnZlcnQgZnVuY3Rpb25cbiAgICAoMCwgdXRpbHNfMS52YWxpZGF0ZSkoZGF0YSwgdXRpbHNfMS5pc1N0cmluZywgY29uc3RhbnRzXzEuZXJyb3JzLmNzdjJqc29uKTtcbiAgICByZXR1cm4gKDAsIGNzdjJqc29uXzEuQ3N2Mkpzb24pKGJ1aWx0T3B0aW9ucykuY29udmVydChkYXRhKTtcbn1cbmV4cG9ydHMuY3N2Mmpzb24gPSBjc3YyanNvbjtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNzdjJqc29uIiwianNvbjJjc3YiLCJjb25zdGFudHNfMSIsInJlcXVpcmUiLCJqc29uMmNzdl8xIiwiY3N2Mmpzb25fMSIsInV0aWxzXzEiLCJkYXRhIiwib3B0aW9ucyIsImJ1aWx0T3B0aW9ucyIsImJ1aWxkSjJDT3B0aW9ucyIsInZhbGlkYXRlIiwiaXNPYmplY3QiLCJlcnJvcnMiLCJKc29uMkNzdiIsImNvbnZlcnQiLCJidWlsZEMySk9wdGlvbnMiLCJpc1N0cmluZyIsIkNzdjJKc29uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/json-2-csv/lib/converter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/json-2-csv/lib/csv2json.js":
/*!*************************************************!*\
  !*** ./node_modules/json-2-csv/lib/csv2json.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Csv2Json = void 0;\nconst doc_path_1 = __webpack_require__(/*! doc-path */ \"(ssr)/./node_modules/doc-path/lib/path.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/json-2-csv/lib/constants.js\");\nconst utils = __importStar(__webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/json-2-csv/lib/utils.js\"));\nconst Csv2Json = function(options) {\n    const escapedWrapDelimiterRegex = new RegExp(options.delimiter.wrap + options.delimiter.wrap, \"g\"), excelBOMRegex = new RegExp(\"^\" + constants_1.excelBOM), valueParserFn = options.parseValue && typeof options.parseValue === \"function\" ? options.parseValue : JSON.parse;\n    /**\n     * Trims the header key, if specified by the user via the provided options\n     */ function processHeaderKey(headerKey) {\n        headerKey = removeWrapDelimitersFromValue(headerKey);\n        if (options.trimHeaderFields) {\n            return headerKey.split(\".\").map((component)=>component.trim()).join(\".\");\n        }\n        return headerKey;\n    }\n    /**\n     * Generate the JSON heading from the CSV\n     */ function retrieveHeading(lines) {\n        let headerFields = [];\n        if (options.headerFields) {\n            headerFields = options.headerFields.map((headerField, index)=>({\n                    value: processHeaderKey(headerField),\n                    index\n                }));\n        } else {\n            // Generate and return the heading keys\n            const headerRow = lines[0];\n            headerFields = headerRow.map((headerKey, index)=>({\n                    value: processHeaderKey(headerKey),\n                    index\n                }));\n            // If the user provided keys, filter the generated keys to just the user provided keys so we also have the key index\n            if (options.keys) {\n                const keys = options.keys; // TypeScript type checking work around to get it to recognize the option is not undefined\n                headerFields = headerFields.filter((headerKey)=>keys.includes(headerKey.value));\n            }\n        }\n        return {\n            lines,\n            headerFields,\n            recordLines: []\n        };\n    }\n    /**\n     * Removes the Excel BOM value, if specified by the options object\n     */ function stripExcelBOM(csv) {\n        if (options.excelBOM) {\n            return csv.replace(excelBOMRegex, \"\");\n        }\n        return csv;\n    }\n    /**\n     * Helper function that splits a line so that we can handle wrapped fields\n     */ function splitLines(csv) {\n        // Parse out the line...\n        const lines = [], lastCharacterIndex = csv.length - 1, eolDelimiterLength = options.delimiter.eol.length, stateVariables = {\n            insideWrapDelimiter: false,\n            parsingValue: true,\n            justParsedDoubleQuote: false,\n            startIndex: 0\n        };\n        let splitLine = [], character, charBefore, charAfter, nextNChar, index = 0;\n        // Loop through each character in the line to identify where to split the values\n        while(index < csv.length){\n            // Current character\n            character = csv[index];\n            // Previous character\n            charBefore = index ? csv[index - 1] : \"\";\n            // Next character\n            charAfter = index < lastCharacterIndex ? csv[index + 1] : \"\";\n            // Next n characters, including the current character, where n = length(EOL delimiter)\n            // This allows for the checking of an EOL delimiter when if it is more than a single character (eg. '\\r\\n')\n            nextNChar = utils.getNCharacters(csv, index, eolDelimiterLength);\n            if ((nextNChar === options.delimiter.eol && !stateVariables.insideWrapDelimiter || index === lastCharacterIndex) && charBefore === options.delimiter.field) {\n                // If we reached an EOL delimiter or the end of the csv and the previous character is a field delimiter...\n                // If the start index is the current index (and since the previous character is a comma),\n                //   then the value being parsed is an empty value accordingly, add an empty string\n                if (nextNChar === options.delimiter.eol && stateVariables.startIndex === index) {\n                    splitLine.push(\"\");\n                } else if (character === options.delimiter.field) {\n                    // If we reached the end of the CSV, there's no new line, and the current character is a comma\n                    // then add an empty string for the current value\n                    splitLine.push(\"\");\n                } else {\n                    // Otherwise, there's a valid value, and the start index isn't the current index, grab the whole value\n                    splitLine.push(csv.substring(stateVariables.startIndex));\n                }\n                // Since the last character is a comma, there's still an additional implied field value trailing the comma.\n                //   Since this value is empty, we push an extra empty value\n                splitLine.push(\"\");\n                // Finally, push the split line values into the lines array and clear the split line\n                lines.push(splitLine);\n                splitLine = [];\n                stateVariables.startIndex = index + eolDelimiterLength;\n                stateVariables.parsingValue = true;\n                stateVariables.insideWrapDelimiter = charAfter === options.delimiter.wrap;\n            } else if (index === lastCharacterIndex && character === options.delimiter.field) {\n                // If we reach the end of the CSV and the current character is a field delimiter\n                // Parse the previously seen value and add it to the line\n                const parsedValue = csv.substring(stateVariables.startIndex, index);\n                splitLine.push(parsedValue);\n                // Then add an empty string to the line since the last character being a field delimiter indicates an empty field\n                splitLine.push(\"\");\n                lines.push(splitLine);\n            } else if (index === lastCharacterIndex || nextNChar === options.delimiter.eol && // if we aren't inside wrap delimiters or if we are but the character before was a wrap delimiter and we didn't just see two\n            (!stateVariables.insideWrapDelimiter || stateVariables.insideWrapDelimiter && charBefore === options.delimiter.wrap && !stateVariables.justParsedDoubleQuote)) {\n                // Otherwise if we reached the end of the line or csv (and current character is not a field delimiter)\n                const toIndex = index !== lastCharacterIndex || charBefore === options.delimiter.wrap ? index : undefined;\n                // Retrieve the remaining value and add it to the split line list of values\n                splitLine.push(csv.substring(stateVariables.startIndex, toIndex));\n                // Finally, push the split line values into the lines array and clear the split line\n                lines.push(splitLine);\n                splitLine = [];\n                stateVariables.startIndex = index + eolDelimiterLength;\n                stateVariables.parsingValue = true;\n                stateVariables.insideWrapDelimiter = charAfter === options.delimiter.wrap;\n            } else if (character === options.delimiter.wrap && charBefore === options.delimiter.field && !stateVariables.insideWrapDelimiter && !stateVariables.parsingValue) {\n                // If we reached a wrap delimiter after a comma and we aren't inside a wrap delimiter\n                stateVariables.startIndex = index;\n                stateVariables.insideWrapDelimiter = true;\n                stateVariables.parsingValue = true;\n                // If the next character(s) are an EOL delimiter, then skip them so we don't parse what we've seen as another value\n                if (utils.getNCharacters(csv, index + 1, eolDelimiterLength) === options.delimiter.eol) {\n                    index += options.delimiter.eol.length + 1; // Skip past EOL\n                }\n            } else if (charBefore === options.delimiter.field && character === options.delimiter.wrap && charAfter === options.delimiter.eol) {\n                // We reached the start of a wrapped new field that begins with an EOL delimiter\n                // Retrieve the remaining value and add it to the split line list of values\n                splitLine.push(csv.substring(stateVariables.startIndex, index - 1));\n                stateVariables.startIndex = index;\n                stateVariables.parsingValue = true;\n                stateVariables.insideWrapDelimiter = true;\n                stateVariables.justParsedDoubleQuote = true;\n                index += 1;\n            } else if ((charBefore !== options.delimiter.wrap || stateVariables.justParsedDoubleQuote && charBefore === options.delimiter.wrap) && character === options.delimiter.wrap && utils.getNCharacters(csv, index + 1, eolDelimiterLength) === options.delimiter.eol) {\n                // If we reach a wrap which is not preceded by a wrap delim and the next character is an EOL delim (ie. *\"\\n)\n                stateVariables.insideWrapDelimiter = false;\n                stateVariables.parsingValue = false;\n            // Next iteration will substring, add the value to the line, and push the line onto the array of lines\n            } else if (character === options.delimiter.wrap && (index === 0 || utils.getNCharacters(csv, index - eolDelimiterLength, eolDelimiterLength) === options.delimiter.eol && !stateVariables.insideWrapDelimiter)) {\n                // If the line starts with a wrap delimiter (ie. \"*)\n                stateVariables.insideWrapDelimiter = true;\n                stateVariables.parsingValue = true;\n                stateVariables.startIndex = index;\n            } else if (character === options.delimiter.wrap && charAfter === options.delimiter.field && stateVariables.insideWrapDelimiter) {\n                // If we reached a wrap delimiter with a field delimiter after it (ie. *\",)\n                splitLine.push(csv.substring(stateVariables.startIndex, index + 1));\n                stateVariables.startIndex = index + 2; // next value starts after the field delimiter\n                stateVariables.insideWrapDelimiter = false;\n                stateVariables.parsingValue = false;\n            } else if (character === options.delimiter.wrap && charBefore === options.delimiter.field && !stateVariables.insideWrapDelimiter && stateVariables.parsingValue) {\n                // If we reached a wrap delimiter with a field delimiter after it (ie. ,\"*)\n                splitLine.push(csv.substring(stateVariables.startIndex, index - 1));\n                stateVariables.insideWrapDelimiter = true;\n                stateVariables.parsingValue = true;\n                stateVariables.startIndex = index;\n            } else if (character === options.delimiter.wrap && charAfter === options.delimiter.wrap && index !== stateVariables.startIndex) {\n                // If we run into an escaped quote (ie. \"\") skip past the second quote\n                index += 2;\n                stateVariables.justParsedDoubleQuote = true;\n                continue;\n            } else if (character === options.delimiter.field && charBefore !== options.delimiter.wrap && charAfter !== options.delimiter.wrap && !stateVariables.insideWrapDelimiter && stateVariables.parsingValue) {\n                // If we reached a field delimiter and are not inside the wrap delimiters (ie. *,*)\n                splitLine.push(csv.substring(stateVariables.startIndex, index));\n                stateVariables.startIndex = index + 1;\n            } else if (character === options.delimiter.field && charBefore === options.delimiter.wrap && charAfter !== options.delimiter.wrap && !stateVariables.parsingValue) {\n                // If we reached a field delimiter, the previous character was a wrap delimiter, and the\n                //   next character is not a wrap delimiter (ie. \",*)\n                stateVariables.insideWrapDelimiter = false;\n                stateVariables.parsingValue = true;\n                stateVariables.startIndex = index + 1;\n            }\n            // Otherwise increment to the next character\n            index++;\n            // Reset the double quote state variable\n            stateVariables.justParsedDoubleQuote = false;\n        }\n        return lines;\n    }\n    /**\n     * Retrieves the record lines from the split CSV lines and sets it on the params object\n     */ function retrieveRecordLines(params) {\n        if (options.headerFields) {\n            params.recordLines = params.lines;\n        } else {\n            params.recordLines = params.lines.splice(1);\n        }\n        return params;\n    }\n    /**\n     * Retrieves the value for the record from the line at the provided key.\n     */ function retrieveRecordValueFromLine(headerField, line) {\n        // If there is a value at the key's index, use it; otherwise, null\n        const value = line[headerField.index];\n        // Perform any necessary value conversions on the record value\n        return processRecordValue(value);\n    }\n    /**\n     * Processes the record's value by parsing the data to ensure the CSV is\n     * converted to the JSON that created it.\n     */ function processRecordValue(fieldValue) {\n        // If the value is an array representation, convert it\n        const parsedJson = parseValue(fieldValue);\n        // If parsedJson is anything aside from an error, then we want to use the parsed value\n        // This allows us to interpret values like 'null' --> null, 'false' --> false\n        if (!utils.isError(parsedJson) && !utils.isInvalid(parsedJson)) {\n            return parsedJson;\n        } else if (fieldValue === \"undefined\") {\n            return undefined;\n        }\n        return fieldValue;\n    }\n    /**\n     * Trims the record value, if specified by the user via the options object\n     */ function trimRecordValue(fieldValue) {\n        if (options.trimFieldValues && fieldValue !== null) {\n            return fieldValue.trim();\n        }\n        return fieldValue;\n    }\n    /**\n     * Create a JSON document with the given keys (designated by the CSV header)\n     *   and the values (from the given line)\n     * @returns {Object} created json document\n     */ function createDocument(headerFields, line) {\n        // Reduce the keys into a JSON document representing the given line\n        return headerFields.reduce((document, headerField)=>{\n            // If there is a value at the key's index in the line, set the value; otherwise null\n            const value = retrieveRecordValueFromLine(headerField, line);\n            try {\n                // Otherwise add the key and value to the document\n                return (0, doc_path_1.setPath)(document, headerField.value, value);\n            } catch (error) {\n                // Catch any errors where key paths are null or '' and continue\n                return document;\n            }\n        }, {});\n    }\n    /**\n     * Removes the outermost wrap delimiters from a value, if they are present\n     * Otherwise, the non-wrapped value is returned as is\n     */ function removeWrapDelimitersFromValue(fieldValue) {\n        const firstChar = fieldValue[0], lastIndex = fieldValue.length - 1, lastChar = fieldValue[lastIndex];\n        // If the field starts and ends with a wrap delimiter\n        if (firstChar === options.delimiter.wrap && lastChar === options.delimiter.wrap) {\n            // Handle the case where the field is just a pair of wrap delimiters \n            return fieldValue.length <= 2 ? \"\" : fieldValue.substring(1, lastIndex);\n        }\n        return fieldValue;\n    }\n    /**\n     * Unescapes wrap delimiters by replacing duplicates with a single (eg. \"\" -> \")\n     * This is done in order to parse RFC 4180 compliant CSV back to JSON\n     */ function unescapeWrapDelimiterInField(fieldValue) {\n        return fieldValue.replace(escapedWrapDelimiterRegex, options.delimiter.wrap);\n    }\n    /**\n     * Main helper function to convert the CSV to the JSON document array\n     */ function transformRecordLines(params) {\n        // For each line, create the document and add it to the array of documents\n        return params.recordLines.reduce((generatedJsonObjects, line)=>{\n            line = line.map((fieldValue)=>{\n                // Perform the necessary operations on each line\n                fieldValue = removeWrapDelimitersFromValue(fieldValue);\n                fieldValue = unescapeWrapDelimiterInField(fieldValue);\n                fieldValue = trimRecordValue(fieldValue);\n                return fieldValue;\n            });\n            const generatedDocument = createDocument(params.headerFields, line);\n            return generatedJsonObjects.concat(generatedDocument);\n        }, []);\n    }\n    /**\n     * Attempts to parse the provided value. If it is not parsable, then an error is returned\n     */ function parseValue(value) {\n        try {\n            if (utils.isStringRepresentation(value, options) && !utils.isDateRepresentation(value)) {\n                return value;\n            }\n            const parsedJson = valueParserFn(value);\n            // If the parsed value is an array, then we also need to trim record values, if specified\n            if (Array.isArray(parsedJson)) {\n                return parsedJson.map(trimRecordValue);\n            }\n            return parsedJson;\n        } catch (err) {\n            return err;\n        }\n    }\n    /**\n     * Internally exported csv2json function\n     */ function convert(data) {\n        // Split the CSV into lines using the specified EOL option\n        const stripped = stripExcelBOM(data);\n        const split = splitLines(stripped);\n        const heading = retrieveHeading(split); // Retrieve the headings from the CSV, unless the user specified the keys\n        const lines = retrieveRecordLines(heading); // Retrieve the record lines from the CSV\n        return transformRecordLines(lines); // Retrieve the JSON document array\n    }\n    return {\n        convert\n    };\n};\nexports.Csv2Json = Csv2Json;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbi0yLWNzdi9saWIvY3N2Mmpzb24uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxJQUFJQSxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQU1DLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQzFGLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCLElBQUlHLE9BQU9QLE9BQU9RLHdCQUF3QixDQUFDTCxHQUFHQztJQUM5QyxJQUFJLENBQUNHLFFBQVMsVUFBU0EsT0FBTyxDQUFDSixFQUFFTSxVQUFVLEdBQUdGLEtBQUtHLFFBQVEsSUFBSUgsS0FBS0ksWUFBWSxHQUFHO1FBQ2pGSixPQUFPO1lBQUVLLFlBQVk7WUFBTUMsS0FBSztnQkFBYSxPQUFPVixDQUFDLENBQUNDLEVBQUU7WUFBRTtRQUFFO0lBQzlEO0lBQ0FKLE9BQU9jLGNBQWMsQ0FBQ1osR0FBR0csSUFBSUU7QUFDakMsSUFBTSxTQUFTTCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQ3RCLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCRixDQUFDLENBQUNHLEdBQUcsR0FBR0YsQ0FBQyxDQUFDQyxFQUFFO0FBQ2hCLENBQUM7QUFDRCxJQUFJVyxxQkFBcUIsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxrQkFBa0IsSUFBTWYsQ0FBQUEsT0FBT0MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRWMsQ0FBQztJQUN6RmhCLE9BQU9jLGNBQWMsQ0FBQ1osR0FBRyxXQUFXO1FBQUVVLFlBQVk7UUFBTUssT0FBT0Q7SUFBRTtBQUNyRSxJQUFLLFNBQVNkLENBQUMsRUFBRWMsQ0FBQztJQUNkZCxDQUFDLENBQUMsVUFBVSxHQUFHYztBQUNuQjtBQUNBLElBQUlFLGVBQWUsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxZQUFZ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N0YsUUFBUTtnQkFDcEYsT0FBT0E7WUFDWDtZQUNBLE1BQU0wRSxhQUFhdEQsY0FBY3BCO1lBQ2pDLHlGQUF5RjtZQUN6RixJQUFJOEYsTUFBTUMsT0FBTyxDQUFDckIsYUFBYTtnQkFDM0IsT0FBT0EsV0FBVzdDLEdBQUcsQ0FBQ2dEO1lBQzFCO1lBQ0EsT0FBT0g7UUFDWCxFQUNBLE9BQU9zQixLQUFLO1lBQ1IsT0FBT0E7UUFDWDtJQUNKO0lBQ0E7O0tBRUMsR0FDRCxTQUFTQyxRQUFRQyxJQUFJO1FBQ2pCLDBEQUEwRDtRQUMxRCxNQUFNQyxXQUFXeEQsY0FBY3VEO1FBQy9CLE1BQU10RSxRQUFRa0IsV0FBV3FEO1FBQ3pCLE1BQU1DLFVBQVVuRSxnQkFBZ0JMLFFBQVEseUVBQXlFO1FBQ2pILE1BQU1NLFFBQVFpQyxvQkFBb0JpQyxVQUFVLHlDQUF5QztRQUNyRixPQUFPWixxQkFBcUJ0RCxRQUFRLG1DQUFtQztJQUMzRTtJQUNBLE9BQU87UUFDSCtEO0lBQ0o7QUFDSjtBQUNBMUYsZ0JBQWdCLEdBQUdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXJhLXBvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9qc29uLTItY3N2L2xpYi9jc3YyanNvbi5qcz9mMGNmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Dc3YySnNvbiA9IHZvaWQgMDtcbmNvbnN0IGRvY19wYXRoXzEgPSByZXF1aXJlKFwiZG9jLXBhdGhcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IHV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxzXCIpKTtcbmNvbnN0IENzdjJKc29uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBjb25zdCBlc2NhcGVkV3JhcERlbGltaXRlclJlZ2V4ID0gbmV3IFJlZ0V4cChvcHRpb25zLmRlbGltaXRlci53cmFwICsgb3B0aW9ucy5kZWxpbWl0ZXIud3JhcCwgJ2cnKSwgZXhjZWxCT01SZWdleCA9IG5ldyBSZWdFeHAoJ14nICsgY29uc3RhbnRzXzEuZXhjZWxCT00pLCB2YWx1ZVBhcnNlckZuID0gb3B0aW9ucy5wYXJzZVZhbHVlICYmIHR5cGVvZiBvcHRpb25zLnBhcnNlVmFsdWUgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLnBhcnNlVmFsdWUgOiBKU09OLnBhcnNlO1xuICAgIC8qKlxuICAgICAqIFRyaW1zIHRoZSBoZWFkZXIga2V5LCBpZiBzcGVjaWZpZWQgYnkgdGhlIHVzZXIgdmlhIHRoZSBwcm92aWRlZCBvcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0hlYWRlcktleShoZWFkZXJLZXkpIHtcbiAgICAgICAgaGVhZGVyS2V5ID0gcmVtb3ZlV3JhcERlbGltaXRlcnNGcm9tVmFsdWUoaGVhZGVyS2V5KTtcbiAgICAgICAgaWYgKG9wdGlvbnMudHJpbUhlYWRlckZpZWxkcykge1xuICAgICAgICAgICAgcmV0dXJuIGhlYWRlcktleS5zcGxpdCgnLicpXG4gICAgICAgICAgICAgICAgLm1hcCgoY29tcG9uZW50KSA9PiBjb21wb25lbnQudHJpbSgpKVxuICAgICAgICAgICAgICAgIC5qb2luKCcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYWRlcktleTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgdGhlIEpTT04gaGVhZGluZyBmcm9tIHRoZSBDU1ZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXRyaWV2ZUhlYWRpbmcobGluZXMpIHtcbiAgICAgICAgbGV0IGhlYWRlckZpZWxkcyA9IFtdO1xuICAgICAgICBpZiAob3B0aW9ucy5oZWFkZXJGaWVsZHMpIHtcbiAgICAgICAgICAgIGhlYWRlckZpZWxkcyA9IG9wdGlvbnMuaGVhZGVyRmllbGRzLm1hcCgoaGVhZGVyRmllbGQsIGluZGV4KSA9PiAoe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBwcm9jZXNzSGVhZGVyS2V5KGhlYWRlckZpZWxkKSxcbiAgICAgICAgICAgICAgICBpbmRleFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gR2VuZXJhdGUgYW5kIHJldHVybiB0aGUgaGVhZGluZyBrZXlzXG4gICAgICAgICAgICBjb25zdCBoZWFkZXJSb3cgPSBsaW5lc1swXTtcbiAgICAgICAgICAgIGhlYWRlckZpZWxkcyA9IGhlYWRlclJvdy5tYXAoKGhlYWRlcktleSwgaW5kZXgpID0+ICh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHByb2Nlc3NIZWFkZXJLZXkoaGVhZGVyS2V5KSxcbiAgICAgICAgICAgICAgICBpbmRleFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgcHJvdmlkZWQga2V5cywgZmlsdGVyIHRoZSBnZW5lcmF0ZWQga2V5cyB0byBqdXN0IHRoZSB1c2VyIHByb3ZpZGVkIGtleXMgc28gd2UgYWxzbyBoYXZlIHRoZSBrZXkgaW5kZXhcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmtleXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlzID0gb3B0aW9ucy5rZXlzOyAvLyBUeXBlU2NyaXB0IHR5cGUgY2hlY2tpbmcgd29yayBhcm91bmQgdG8gZ2V0IGl0IHRvIHJlY29nbml6ZSB0aGUgb3B0aW9uIGlzIG5vdCB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICBoZWFkZXJGaWVsZHMgPSBoZWFkZXJGaWVsZHMuZmlsdGVyKChoZWFkZXJLZXkpID0+IGtleXMuaW5jbHVkZXMoaGVhZGVyS2V5LnZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxpbmVzLFxuICAgICAgICAgICAgaGVhZGVyRmllbGRzLFxuICAgICAgICAgICAgcmVjb3JkTGluZXM6IFtdLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBFeGNlbCBCT00gdmFsdWUsIGlmIHNwZWNpZmllZCBieSB0aGUgb3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHJpcEV4Y2VsQk9NKGNzdikge1xuICAgICAgICBpZiAob3B0aW9ucy5leGNlbEJPTSkge1xuICAgICAgICAgICAgcmV0dXJuIGNzdi5yZXBsYWNlKGV4Y2VsQk9NUmVnZXgsICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3N2O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBzcGxpdHMgYSBsaW5lIHNvIHRoYXQgd2UgY2FuIGhhbmRsZSB3cmFwcGVkIGZpZWxkc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNwbGl0TGluZXMoY3N2KSB7XG4gICAgICAgIC8vIFBhcnNlIG91dCB0aGUgbGluZS4uLlxuICAgICAgICBjb25zdCBsaW5lcyA9IFtdLCBsYXN0Q2hhcmFjdGVySW5kZXggPSBjc3YubGVuZ3RoIC0gMSwgZW9sRGVsaW1pdGVyTGVuZ3RoID0gb3B0aW9ucy5kZWxpbWl0ZXIuZW9sLmxlbmd0aCwgc3RhdGVWYXJpYWJsZXMgPSB7XG4gICAgICAgICAgICBpbnNpZGVXcmFwRGVsaW1pdGVyOiBmYWxzZSxcbiAgICAgICAgICAgIHBhcnNpbmdWYWx1ZTogdHJ1ZSxcbiAgICAgICAgICAgIGp1c3RQYXJzZWREb3VibGVRdW90ZTogZmFsc2UsXG4gICAgICAgICAgICBzdGFydEluZGV4OiAwXG4gICAgICAgIH07XG4gICAgICAgIGxldCBzcGxpdExpbmUgPSBbXSwgY2hhcmFjdGVyLCBjaGFyQmVmb3JlLCBjaGFyQWZ0ZXIsIG5leHROQ2hhciwgaW5kZXggPSAwO1xuICAgICAgICAvLyBMb29wIHRocm91Z2ggZWFjaCBjaGFyYWN0ZXIgaW4gdGhlIGxpbmUgdG8gaWRlbnRpZnkgd2hlcmUgdG8gc3BsaXQgdGhlIHZhbHVlc1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBjc3YubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBDdXJyZW50IGNoYXJhY3RlclxuICAgICAgICAgICAgY2hhcmFjdGVyID0gY3N2W2luZGV4XTtcbiAgICAgICAgICAgIC8vIFByZXZpb3VzIGNoYXJhY3RlclxuICAgICAgICAgICAgY2hhckJlZm9yZSA9IGluZGV4ID8gY3N2W2luZGV4IC0gMV0gOiAnJztcbiAgICAgICAgICAgIC8vIE5leHQgY2hhcmFjdGVyXG4gICAgICAgICAgICBjaGFyQWZ0ZXIgPSBpbmRleCA8IGxhc3RDaGFyYWN0ZXJJbmRleCA/IGNzdltpbmRleCArIDFdIDogJyc7XG4gICAgICAgICAgICAvLyBOZXh0IG4gY2hhcmFjdGVycywgaW5jbHVkaW5nIHRoZSBjdXJyZW50IGNoYXJhY3Rlciwgd2hlcmUgbiA9IGxlbmd0aChFT0wgZGVsaW1pdGVyKVxuICAgICAgICAgICAgLy8gVGhpcyBhbGxvd3MgZm9yIHRoZSBjaGVja2luZyBvZiBhbiBFT0wgZGVsaW1pdGVyIHdoZW4gaWYgaXQgaXMgbW9yZSB0aGFuIGEgc2luZ2xlIGNoYXJhY3RlciAoZWcuICdcXHJcXG4nKVxuICAgICAgICAgICAgbmV4dE5DaGFyID0gdXRpbHMuZ2V0TkNoYXJhY3RlcnMoY3N2LCBpbmRleCwgZW9sRGVsaW1pdGVyTGVuZ3RoKTtcbiAgICAgICAgICAgIGlmICgobmV4dE5DaGFyID09PSBvcHRpb25zLmRlbGltaXRlci5lb2wgJiYgIXN0YXRlVmFyaWFibGVzLmluc2lkZVdyYXBEZWxpbWl0ZXIgfHxcbiAgICAgICAgICAgICAgICBpbmRleCA9PT0gbGFzdENoYXJhY3RlckluZGV4KSAmJiBjaGFyQmVmb3JlID09PSBvcHRpb25zLmRlbGltaXRlci5maWVsZCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYW4gRU9MIGRlbGltaXRlciBvciB0aGUgZW5kIG9mIHRoZSBjc3YgYW5kIHRoZSBwcmV2aW91cyBjaGFyYWN0ZXIgaXMgYSBmaWVsZCBkZWxpbWl0ZXIuLi5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgc3RhcnQgaW5kZXggaXMgdGhlIGN1cnJlbnQgaW5kZXggKGFuZCBzaW5jZSB0aGUgcHJldmlvdXMgY2hhcmFjdGVyIGlzIGEgY29tbWEpLFxuICAgICAgICAgICAgICAgIC8vICAgdGhlbiB0aGUgdmFsdWUgYmVpbmcgcGFyc2VkIGlzIGFuIGVtcHR5IHZhbHVlIGFjY29yZGluZ2x5LCBhZGQgYW4gZW1wdHkgc3RyaW5nXG4gICAgICAgICAgICAgICAgaWYgKG5leHROQ2hhciA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIuZW9sICYmIHN0YXRlVmFyaWFibGVzLnN0YXJ0SW5kZXggPT09IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHNwbGl0TGluZS5wdXNoKCcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhcmFjdGVyID09PSBvcHRpb25zLmRlbGltaXRlci5maWVsZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIENTViwgdGhlcmUncyBubyBuZXcgbGluZSwgYW5kIHRoZSBjdXJyZW50IGNoYXJhY3RlciBpcyBhIGNvbW1hXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZW4gYWRkIGFuIGVtcHR5IHN0cmluZyBmb3IgdGhlIGN1cnJlbnQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgc3BsaXRMaW5lLnB1c2goJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGVyZSdzIGEgdmFsaWQgdmFsdWUsIGFuZCB0aGUgc3RhcnQgaW5kZXggaXNuJ3QgdGhlIGN1cnJlbnQgaW5kZXgsIGdyYWIgdGhlIHdob2xlIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIHNwbGl0TGluZS5wdXNoKGNzdi5zdWJzdHJpbmcoc3RhdGVWYXJpYWJsZXMuc3RhcnRJbmRleCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTaW5jZSB0aGUgbGFzdCBjaGFyYWN0ZXIgaXMgYSBjb21tYSwgdGhlcmUncyBzdGlsbCBhbiBhZGRpdGlvbmFsIGltcGxpZWQgZmllbGQgdmFsdWUgdHJhaWxpbmcgdGhlIGNvbW1hLlxuICAgICAgICAgICAgICAgIC8vICAgU2luY2UgdGhpcyB2YWx1ZSBpcyBlbXB0eSwgd2UgcHVzaCBhbiBleHRyYSBlbXB0eSB2YWx1ZVxuICAgICAgICAgICAgICAgIHNwbGl0TGluZS5wdXNoKCcnKTtcbiAgICAgICAgICAgICAgICAvLyBGaW5hbGx5LCBwdXNoIHRoZSBzcGxpdCBsaW5lIHZhbHVlcyBpbnRvIHRoZSBsaW5lcyBhcnJheSBhbmQgY2xlYXIgdGhlIHNwbGl0IGxpbmVcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKHNwbGl0TGluZSk7XG4gICAgICAgICAgICAgICAgc3BsaXRMaW5lID0gW107XG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMuc3RhcnRJbmRleCA9IGluZGV4ICsgZW9sRGVsaW1pdGVyTGVuZ3RoO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLnBhcnNpbmdWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMuaW5zaWRlV3JhcERlbGltaXRlciA9IGNoYXJBZnRlciA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIud3JhcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGluZGV4ID09PSBsYXN0Q2hhcmFjdGVySW5kZXggJiYgY2hhcmFjdGVyID09PSBvcHRpb25zLmRlbGltaXRlci5maWVsZCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlYWNoIHRoZSBlbmQgb2YgdGhlIENTViBhbmQgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGlzIGEgZmllbGQgZGVsaW1pdGVyXG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIHByZXZpb3VzbHkgc2VlbiB2YWx1ZSBhbmQgYWRkIGl0IHRvIHRoZSBsaW5lXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkVmFsdWUgPSBjc3Yuc3Vic3RyaW5nKHN0YXRlVmFyaWFibGVzLnN0YXJ0SW5kZXgsIGluZGV4KTtcbiAgICAgICAgICAgICAgICBzcGxpdExpbmUucHVzaChwYXJzZWRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgLy8gVGhlbiBhZGQgYW4gZW1wdHkgc3RyaW5nIHRvIHRoZSBsaW5lIHNpbmNlIHRoZSBsYXN0IGNoYXJhY3RlciBiZWluZyBhIGZpZWxkIGRlbGltaXRlciBpbmRpY2F0ZXMgYW4gZW1wdHkgZmllbGRcbiAgICAgICAgICAgICAgICBzcGxpdExpbmUucHVzaCgnJyk7XG4gICAgICAgICAgICAgICAgbGluZXMucHVzaChzcGxpdExpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5kZXggPT09IGxhc3RDaGFyYWN0ZXJJbmRleCB8fCBuZXh0TkNoYXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLmVvbCAmJlxuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGFyZW4ndCBpbnNpZGUgd3JhcCBkZWxpbWl0ZXJzIG9yIGlmIHdlIGFyZSBidXQgdGhlIGNoYXJhY3RlciBiZWZvcmUgd2FzIGEgd3JhcCBkZWxpbWl0ZXIgYW5kIHdlIGRpZG4ndCBqdXN0IHNlZSB0d29cbiAgICAgICAgICAgICAgICAoIXN0YXRlVmFyaWFibGVzLmluc2lkZVdyYXBEZWxpbWl0ZXIgfHxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMuaW5zaWRlV3JhcERlbGltaXRlciAmJiBjaGFyQmVmb3JlID09PSBvcHRpb25zLmRlbGltaXRlci53cmFwICYmICFzdGF0ZVZhcmlhYmxlcy5qdXN0UGFyc2VkRG91YmxlUXVvdGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGlmIHdlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgbGluZSBvciBjc3YgKGFuZCBjdXJyZW50IGNoYXJhY3RlciBpcyBub3QgYSBmaWVsZCBkZWxpbWl0ZXIpXG4gICAgICAgICAgICAgICAgY29uc3QgdG9JbmRleCA9IGluZGV4ICE9PSBsYXN0Q2hhcmFjdGVySW5kZXggfHwgY2hhckJlZm9yZSA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIud3JhcCA/IGluZGV4IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIC8vIFJldHJpZXZlIHRoZSByZW1haW5pbmcgdmFsdWUgYW5kIGFkZCBpdCB0byB0aGUgc3BsaXQgbGluZSBsaXN0IG9mIHZhbHVlc1xuICAgICAgICAgICAgICAgIHNwbGl0TGluZS5wdXNoKGNzdi5zdWJzdHJpbmcoc3RhdGVWYXJpYWJsZXMuc3RhcnRJbmRleCwgdG9JbmRleCkpO1xuICAgICAgICAgICAgICAgIC8vIEZpbmFsbHksIHB1c2ggdGhlIHNwbGl0IGxpbmUgdmFsdWVzIGludG8gdGhlIGxpbmVzIGFycmF5IGFuZCBjbGVhciB0aGUgc3BsaXQgbGluZVxuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goc3BsaXRMaW5lKTtcbiAgICAgICAgICAgICAgICBzcGxpdExpbmUgPSBbXTtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5zdGFydEluZGV4ID0gaW5kZXggKyBlb2xEZWxpbWl0ZXJMZW5ndGg7XG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMucGFyc2luZ1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5pbnNpZGVXcmFwRGVsaW1pdGVyID0gY2hhckFmdGVyID09PSBvcHRpb25zLmRlbGltaXRlci53cmFwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhcmFjdGVyID09PSBvcHRpb25zLmRlbGltaXRlci53cmFwICYmIGNoYXJCZWZvcmUgPT09IG9wdGlvbnMuZGVsaW1pdGVyLmZpZWxkICYmXG4gICAgICAgICAgICAgICAgIXN0YXRlVmFyaWFibGVzLmluc2lkZVdyYXBEZWxpbWl0ZXIgJiYgIXN0YXRlVmFyaWFibGVzLnBhcnNpbmdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSB3cmFwIGRlbGltaXRlciBhZnRlciBhIGNvbW1hIGFuZCB3ZSBhcmVuJ3QgaW5zaWRlIGEgd3JhcCBkZWxpbWl0ZXJcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5zdGFydEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMuaW5zaWRlV3JhcERlbGltaXRlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMucGFyc2luZ1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbmV4dCBjaGFyYWN0ZXIocykgYXJlIGFuIEVPTCBkZWxpbWl0ZXIsIHRoZW4gc2tpcCB0aGVtIHNvIHdlIGRvbid0IHBhcnNlIHdoYXQgd2UndmUgc2VlbiBhcyBhbm90aGVyIHZhbHVlXG4gICAgICAgICAgICAgICAgaWYgKHV0aWxzLmdldE5DaGFyYWN0ZXJzKGNzdiwgaW5kZXggKyAxLCBlb2xEZWxpbWl0ZXJMZW5ndGgpID09PSBvcHRpb25zLmRlbGltaXRlci5lb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gb3B0aW9ucy5kZWxpbWl0ZXIuZW9sLmxlbmd0aCArIDE7IC8vIFNraXAgcGFzdCBFT0xcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFyQmVmb3JlID09PSBvcHRpb25zLmRlbGltaXRlci5maWVsZCAmJiBjaGFyYWN0ZXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXAgJiYgY2hhckFmdGVyID09PSBvcHRpb25zLmRlbGltaXRlci5lb2wpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSByZWFjaGVkIHRoZSBzdGFydCBvZiBhIHdyYXBwZWQgbmV3IGZpZWxkIHRoYXQgYmVnaW5zIHdpdGggYW4gRU9MIGRlbGltaXRlclxuICAgICAgICAgICAgICAgIC8vIFJldHJpZXZlIHRoZSByZW1haW5pbmcgdmFsdWUgYW5kIGFkZCBpdCB0byB0aGUgc3BsaXQgbGluZSBsaXN0IG9mIHZhbHVlc1xuICAgICAgICAgICAgICAgIHNwbGl0TGluZS5wdXNoKGNzdi5zdWJzdHJpbmcoc3RhdGVWYXJpYWJsZXMuc3RhcnRJbmRleCwgaW5kZXggLSAxKSk7XG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMuc3RhcnRJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLnBhcnNpbmdWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMuaW5zaWRlV3JhcERlbGltaXRlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMuanVzdFBhcnNlZERvdWJsZVF1b3RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpbmRleCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKGNoYXJCZWZvcmUgIT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXAgfHwgc3RhdGVWYXJpYWJsZXMuanVzdFBhcnNlZERvdWJsZVF1b3RlICYmIGNoYXJCZWZvcmUgPT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXApICYmXG4gICAgICAgICAgICAgICAgY2hhcmFjdGVyID09PSBvcHRpb25zLmRlbGltaXRlci53cmFwICYmIHV0aWxzLmdldE5DaGFyYWN0ZXJzKGNzdiwgaW5kZXggKyAxLCBlb2xEZWxpbWl0ZXJMZW5ndGgpID09PSBvcHRpb25zLmRlbGltaXRlci5lb2wpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSByZWFjaCBhIHdyYXAgd2hpY2ggaXMgbm90IHByZWNlZGVkIGJ5IGEgd3JhcCBkZWxpbSBhbmQgdGhlIG5leHQgY2hhcmFjdGVyIGlzIGFuIEVPTCBkZWxpbSAoaWUuICpcIlxcbilcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5pbnNpZGVXcmFwRGVsaW1pdGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMucGFyc2luZ1ZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gTmV4dCBpdGVyYXRpb24gd2lsbCBzdWJzdHJpbmcsIGFkZCB0aGUgdmFsdWUgdG8gdGhlIGxpbmUsIGFuZCBwdXNoIHRoZSBsaW5lIG9udG8gdGhlIGFycmF5IG9mIGxpbmVzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFyYWN0ZXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXAgJiYgKGluZGV4ID09PSAwIHx8IHV0aWxzLmdldE5DaGFyYWN0ZXJzKGNzdiwgaW5kZXggLSBlb2xEZWxpbWl0ZXJMZW5ndGgsIGVvbERlbGltaXRlckxlbmd0aCkgPT09IG9wdGlvbnMuZGVsaW1pdGVyLmVvbCAmJiAhc3RhdGVWYXJpYWJsZXMuaW5zaWRlV3JhcERlbGltaXRlcikpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbGluZSBzdGFydHMgd2l0aCBhIHdyYXAgZGVsaW1pdGVyIChpZS4gXCIqKVxuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLmluc2lkZVdyYXBEZWxpbWl0ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLnBhcnNpbmdWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMuc3RhcnRJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhcmFjdGVyID09PSBvcHRpb25zLmRlbGltaXRlci53cmFwICYmIGNoYXJBZnRlciA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIuZmllbGQgJiYgc3RhdGVWYXJpYWJsZXMuaW5zaWRlV3JhcERlbGltaXRlcikge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSB3cmFwIGRlbGltaXRlciB3aXRoIGEgZmllbGQgZGVsaW1pdGVyIGFmdGVyIGl0IChpZS4gKlwiLClcbiAgICAgICAgICAgICAgICBzcGxpdExpbmUucHVzaChjc3Yuc3Vic3RyaW5nKHN0YXRlVmFyaWFibGVzLnN0YXJ0SW5kZXgsIGluZGV4ICsgMSkpO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLnN0YXJ0SW5kZXggPSBpbmRleCArIDI7IC8vIG5leHQgdmFsdWUgc3RhcnRzIGFmdGVyIHRoZSBmaWVsZCBkZWxpbWl0ZXJcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5pbnNpZGVXcmFwRGVsaW1pdGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMucGFyc2luZ1ZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFyYWN0ZXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXAgJiYgY2hhckJlZm9yZSA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIuZmllbGQgJiZcbiAgICAgICAgICAgICAgICAhc3RhdGVWYXJpYWJsZXMuaW5zaWRlV3JhcERlbGltaXRlciAmJiBzdGF0ZVZhcmlhYmxlcy5wYXJzaW5nVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgd3JhcCBkZWxpbWl0ZXIgd2l0aCBhIGZpZWxkIGRlbGltaXRlciBhZnRlciBpdCAoaWUuICxcIiopXG4gICAgICAgICAgICAgICAgc3BsaXRMaW5lLnB1c2goY3N2LnN1YnN0cmluZyhzdGF0ZVZhcmlhYmxlcy5zdGFydEluZGV4LCBpbmRleCAtIDEpKTtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5pbnNpZGVXcmFwRGVsaW1pdGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5wYXJzaW5nVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLnN0YXJ0SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJhY3RlciA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIud3JhcCAmJiBjaGFyQWZ0ZXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXAgJiYgaW5kZXggIT09IHN0YXRlVmFyaWFibGVzLnN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBydW4gaW50byBhbiBlc2NhcGVkIHF1b3RlIChpZS4gXCJcIikgc2tpcCBwYXN0IHRoZSBzZWNvbmQgcXVvdGVcbiAgICAgICAgICAgICAgICBpbmRleCArPSAyO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLmp1c3RQYXJzZWREb3VibGVRdW90ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFyYWN0ZXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLmZpZWxkICYmIGNoYXJCZWZvcmUgIT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXAgJiZcbiAgICAgICAgICAgICAgICBjaGFyQWZ0ZXIgIT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXAgJiYgIXN0YXRlVmFyaWFibGVzLmluc2lkZVdyYXBEZWxpbWl0ZXIgJiZcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5wYXJzaW5nVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgZmllbGQgZGVsaW1pdGVyIGFuZCBhcmUgbm90IGluc2lkZSB0aGUgd3JhcCBkZWxpbWl0ZXJzIChpZS4gKiwqKVxuICAgICAgICAgICAgICAgIHNwbGl0TGluZS5wdXNoKGNzdi5zdWJzdHJpbmcoc3RhdGVWYXJpYWJsZXMuc3RhcnRJbmRleCwgaW5kZXgpKTtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5zdGFydEluZGV4ID0gaW5kZXggKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhcmFjdGVyID09PSBvcHRpb25zLmRlbGltaXRlci5maWVsZCAmJiBjaGFyQmVmb3JlID09PSBvcHRpb25zLmRlbGltaXRlci53cmFwICYmXG4gICAgICAgICAgICAgICAgY2hhckFmdGVyICE9PSBvcHRpb25zLmRlbGltaXRlci53cmFwICYmICFzdGF0ZVZhcmlhYmxlcy5wYXJzaW5nVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgZmllbGQgZGVsaW1pdGVyLCB0aGUgcHJldmlvdXMgY2hhcmFjdGVyIHdhcyBhIHdyYXAgZGVsaW1pdGVyLCBhbmQgdGhlXG4gICAgICAgICAgICAgICAgLy8gICBuZXh0IGNoYXJhY3RlciBpcyBub3QgYSB3cmFwIGRlbGltaXRlciAoaWUuIFwiLCopXG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMuaW5zaWRlV3JhcERlbGltaXRlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLnBhcnNpbmdWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMuc3RhcnRJbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBpbmNyZW1lbnQgdG8gdGhlIG5leHQgY2hhcmFjdGVyXG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGRvdWJsZSBxdW90ZSBzdGF0ZSB2YXJpYWJsZVxuICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMuanVzdFBhcnNlZERvdWJsZVF1b3RlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHJlY29yZCBsaW5lcyBmcm9tIHRoZSBzcGxpdCBDU1YgbGluZXMgYW5kIHNldHMgaXQgb24gdGhlIHBhcmFtcyBvYmplY3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXRyaWV2ZVJlY29yZExpbmVzKHBhcmFtcykge1xuICAgICAgICBpZiAob3B0aW9ucy5oZWFkZXJGaWVsZHMpIHsgLy8gVGhpcyBvcHRpb24gaXMgcGFzc2VkIGZvciBpbnN0YW5jZXMgd2hlcmUgdGhlIENTViBoYXMgbm8gaGVhZGVyIGxpbmVcbiAgICAgICAgICAgIHBhcmFtcy5yZWNvcmRMaW5lcyA9IHBhcmFtcy5saW5lcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gQWxsIGxpbmVzIGV4Y2VwdCBmb3IgdGhlIGhlYWRlciBsaW5lXG4gICAgICAgICAgICBwYXJhbXMucmVjb3JkTGluZXMgPSBwYXJhbXMubGluZXMuc3BsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgdmFsdWUgZm9yIHRoZSByZWNvcmQgZnJvbSB0aGUgbGluZSBhdCB0aGUgcHJvdmlkZWQga2V5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJldHJpZXZlUmVjb3JkVmFsdWVGcm9tTGluZShoZWFkZXJGaWVsZCwgbGluZSkge1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHZhbHVlIGF0IHRoZSBrZXkncyBpbmRleCwgdXNlIGl0OyBvdGhlcndpc2UsIG51bGxcbiAgICAgICAgY29uc3QgdmFsdWUgPSBsaW5lW2hlYWRlckZpZWxkLmluZGV4XTtcbiAgICAgICAgLy8gUGVyZm9ybSBhbnkgbmVjZXNzYXJ5IHZhbHVlIGNvbnZlcnNpb25zIG9uIHRoZSByZWNvcmQgdmFsdWVcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NSZWNvcmRWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3NlcyB0aGUgcmVjb3JkJ3MgdmFsdWUgYnkgcGFyc2luZyB0aGUgZGF0YSB0byBlbnN1cmUgdGhlIENTViBpc1xuICAgICAqIGNvbnZlcnRlZCB0byB0aGUgSlNPTiB0aGF0IGNyZWF0ZWQgaXQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1JlY29yZFZhbHVlKGZpZWxkVmFsdWUpIHtcbiAgICAgICAgLy8gSWYgdGhlIHZhbHVlIGlzIGFuIGFycmF5IHJlcHJlc2VudGF0aW9uLCBjb252ZXJ0IGl0XG4gICAgICAgIGNvbnN0IHBhcnNlZEpzb24gPSBwYXJzZVZhbHVlKGZpZWxkVmFsdWUpO1xuICAgICAgICAvLyBJZiBwYXJzZWRKc29uIGlzIGFueXRoaW5nIGFzaWRlIGZyb20gYW4gZXJyb3IsIHRoZW4gd2Ugd2FudCB0byB1c2UgdGhlIHBhcnNlZCB2YWx1ZVxuICAgICAgICAvLyBUaGlzIGFsbG93cyB1cyB0byBpbnRlcnByZXQgdmFsdWVzIGxpa2UgJ251bGwnIC0tPiBudWxsLCAnZmFsc2UnIC0tPiBmYWxzZVxuICAgICAgICBpZiAoIXV0aWxzLmlzRXJyb3IocGFyc2VkSnNvbikgJiYgIXV0aWxzLmlzSW52YWxpZChwYXJzZWRKc29uKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZEpzb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmllbGRWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpZWxkVmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyaW1zIHRoZSByZWNvcmQgdmFsdWUsIGlmIHNwZWNpZmllZCBieSB0aGUgdXNlciB2aWEgdGhlIG9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbVJlY29yZFZhbHVlKGZpZWxkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMudHJpbUZpZWxkVmFsdWVzICYmIGZpZWxkVmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWVsZFZhbHVlLnRyaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmllbGRWYWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgSlNPTiBkb2N1bWVudCB3aXRoIHRoZSBnaXZlbiBrZXlzIChkZXNpZ25hdGVkIGJ5IHRoZSBDU1YgaGVhZGVyKVxuICAgICAqICAgYW5kIHRoZSB2YWx1ZXMgKGZyb20gdGhlIGdpdmVuIGxpbmUpXG4gICAgICogQHJldHVybnMge09iamVjdH0gY3JlYXRlZCBqc29uIGRvY3VtZW50XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRG9jdW1lbnQoaGVhZGVyRmllbGRzLCBsaW5lKSB7XG4gICAgICAgIC8vIFJlZHVjZSB0aGUga2V5cyBpbnRvIGEgSlNPTiBkb2N1bWVudCByZXByZXNlbnRpbmcgdGhlIGdpdmVuIGxpbmVcbiAgICAgICAgcmV0dXJuIGhlYWRlckZpZWxkcy5yZWR1Y2UoKGRvY3VtZW50LCBoZWFkZXJGaWVsZCkgPT4ge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSB2YWx1ZSBhdCB0aGUga2V5J3MgaW5kZXggaW4gdGhlIGxpbmUsIHNldCB0aGUgdmFsdWU7IG90aGVyd2lzZSBudWxsXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJldHJpZXZlUmVjb3JkVmFsdWVGcm9tTGluZShoZWFkZXJGaWVsZCwgbGluZSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBhZGQgdGhlIGtleSBhbmQgdmFsdWUgdG8gdGhlIGRvY3VtZW50XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBkb2NfcGF0aF8xLnNldFBhdGgpKGRvY3VtZW50LCBoZWFkZXJGaWVsZC52YWx1ZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2F0Y2ggYW55IGVycm9ycyB3aGVyZSBrZXkgcGF0aHMgYXJlIG51bGwgb3IgJycgYW5kIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB7fSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIG91dGVybW9zdCB3cmFwIGRlbGltaXRlcnMgZnJvbSBhIHZhbHVlLCBpZiB0aGV5IGFyZSBwcmVzZW50XG4gICAgICogT3RoZXJ3aXNlLCB0aGUgbm9uLXdyYXBwZWQgdmFsdWUgaXMgcmV0dXJuZWQgYXMgaXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW1vdmVXcmFwRGVsaW1pdGVyc0Zyb21WYWx1ZShmaWVsZFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0Q2hhciA9IGZpZWxkVmFsdWVbMF0sIGxhc3RJbmRleCA9IGZpZWxkVmFsdWUubGVuZ3RoIC0gMSwgbGFzdENoYXIgPSBmaWVsZFZhbHVlW2xhc3RJbmRleF07XG4gICAgICAgIC8vIElmIHRoZSBmaWVsZCBzdGFydHMgYW5kIGVuZHMgd2l0aCBhIHdyYXAgZGVsaW1pdGVyXG4gICAgICAgIGlmIChmaXJzdENoYXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXAgJiYgbGFzdENoYXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXApIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0aGUgZmllbGQgaXMganVzdCBhIHBhaXIgb2Ygd3JhcCBkZWxpbWl0ZXJzIFxuICAgICAgICAgICAgcmV0dXJuIGZpZWxkVmFsdWUubGVuZ3RoIDw9IDIgPyAnJyA6IGZpZWxkVmFsdWUuc3Vic3RyaW5nKDEsIGxhc3RJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpZWxkVmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuZXNjYXBlcyB3cmFwIGRlbGltaXRlcnMgYnkgcmVwbGFjaW5nIGR1cGxpY2F0ZXMgd2l0aCBhIHNpbmdsZSAoZWcuIFwiXCIgLT4gXCIpXG4gICAgICogVGhpcyBpcyBkb25lIGluIG9yZGVyIHRvIHBhcnNlIFJGQyA0MTgwIGNvbXBsaWFudCBDU1YgYmFjayB0byBKU09OXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5lc2NhcGVXcmFwRGVsaW1pdGVySW5GaWVsZChmaWVsZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmaWVsZFZhbHVlLnJlcGxhY2UoZXNjYXBlZFdyYXBEZWxpbWl0ZXJSZWdleCwgb3B0aW9ucy5kZWxpbWl0ZXIud3JhcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1haW4gaGVscGVyIGZ1bmN0aW9uIHRvIGNvbnZlcnQgdGhlIENTViB0byB0aGUgSlNPTiBkb2N1bWVudCBhcnJheVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybVJlY29yZExpbmVzKHBhcmFtcykge1xuICAgICAgICAvLyBGb3IgZWFjaCBsaW5lLCBjcmVhdGUgdGhlIGRvY3VtZW50IGFuZCBhZGQgaXQgdG8gdGhlIGFycmF5IG9mIGRvY3VtZW50c1xuICAgICAgICByZXR1cm4gcGFyYW1zLnJlY29yZExpbmVzLnJlZHVjZSgoZ2VuZXJhdGVkSnNvbk9iamVjdHMsIGxpbmUpID0+IHtcbiAgICAgICAgICAgIGxpbmUgPSBsaW5lLm1hcCgoZmllbGRWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFBlcmZvcm0gdGhlIG5lY2Vzc2FyeSBvcGVyYXRpb25zIG9uIGVhY2ggbGluZVxuICAgICAgICAgICAgICAgIGZpZWxkVmFsdWUgPSByZW1vdmVXcmFwRGVsaW1pdGVyc0Zyb21WYWx1ZShmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgICAgICBmaWVsZFZhbHVlID0gdW5lc2NhcGVXcmFwRGVsaW1pdGVySW5GaWVsZChmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgICAgICBmaWVsZFZhbHVlID0gdHJpbVJlY29yZFZhbHVlKGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZFZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBnZW5lcmF0ZWREb2N1bWVudCA9IGNyZWF0ZURvY3VtZW50KHBhcmFtcy5oZWFkZXJGaWVsZHMsIGxpbmUpO1xuICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlZEpzb25PYmplY3RzLmNvbmNhdChnZW5lcmF0ZWREb2N1bWVudCk7XG4gICAgICAgIH0sIFtdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gcGFyc2UgdGhlIHByb3ZpZGVkIHZhbHVlLiBJZiBpdCBpcyBub3QgcGFyc2FibGUsIHRoZW4gYW4gZXJyb3IgaXMgcmV0dXJuZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmdSZXByZXNlbnRhdGlvbih2YWx1ZSwgb3B0aW9ucykgJiYgIXV0aWxzLmlzRGF0ZVJlcHJlc2VudGF0aW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEpzb24gPSB2YWx1ZVBhcnNlckZuKHZhbHVlKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBwYXJzZWQgdmFsdWUgaXMgYW4gYXJyYXksIHRoZW4gd2UgYWxzbyBuZWVkIHRvIHRyaW0gcmVjb3JkIHZhbHVlcywgaWYgc3BlY2lmaWVkXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJzZWRKc29uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWRKc29uLm1hcCh0cmltUmVjb3JkVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZEpzb247XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbGx5IGV4cG9ydGVkIGNzdjJqc29uIGZ1bmN0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29udmVydChkYXRhKSB7XG4gICAgICAgIC8vIFNwbGl0IHRoZSBDU1YgaW50byBsaW5lcyB1c2luZyB0aGUgc3BlY2lmaWVkIEVPTCBvcHRpb25cbiAgICAgICAgY29uc3Qgc3RyaXBwZWQgPSBzdHJpcEV4Y2VsQk9NKGRhdGEpO1xuICAgICAgICBjb25zdCBzcGxpdCA9IHNwbGl0TGluZXMoc3RyaXBwZWQpO1xuICAgICAgICBjb25zdCBoZWFkaW5nID0gcmV0cmlldmVIZWFkaW5nKHNwbGl0KTsgLy8gUmV0cmlldmUgdGhlIGhlYWRpbmdzIGZyb20gdGhlIENTViwgdW5sZXNzIHRoZSB1c2VyIHNwZWNpZmllZCB0aGUga2V5c1xuICAgICAgICBjb25zdCBsaW5lcyA9IHJldHJpZXZlUmVjb3JkTGluZXMoaGVhZGluZyk7IC8vIFJldHJpZXZlIHRoZSByZWNvcmQgbGluZXMgZnJvbSB0aGUgQ1NWXG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1SZWNvcmRMaW5lcyhsaW5lcyk7IC8vIFJldHJpZXZlIHRoZSBKU09OIGRvY3VtZW50IGFycmF5XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnZlcnQsXG4gICAgfTtcbn07XG5leHBvcnRzLkNzdjJKc29uID0gQ3N2Mkpzb247XG4iXSwibmFtZXMiOlsiX19jcmVhdGVCaW5kaW5nIiwiT2JqZWN0IiwiY3JlYXRlIiwibyIsIm0iLCJrIiwiazIiLCJ1bmRlZmluZWQiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiX19lc01vZHVsZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImdldCIsImRlZmluZVByb3BlcnR5IiwiX19zZXRNb2R1bGVEZWZhdWx0IiwidiIsInZhbHVlIiwiX19pbXBvcnRTdGFyIiwibW9kIiwicmVzdWx0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiZXhwb3J0cyIsIkNzdjJKc29uIiwiZG9jX3BhdGhfMSIsInJlcXVpcmUiLCJjb25zdGFudHNfMSIsInV0aWxzIiwib3B0aW9ucyIsImVzY2FwZWRXcmFwRGVsaW1pdGVyUmVnZXgiLCJSZWdFeHAiLCJkZWxpbWl0ZXIiLCJ3cmFwIiwiZXhjZWxCT01SZWdleCIsImV4Y2VsQk9NIiwidmFsdWVQYXJzZXJGbiIsInBhcnNlVmFsdWUiLCJKU09OIiwicGFyc2UiLCJwcm9jZXNzSGVhZGVyS2V5IiwiaGVhZGVyS2V5IiwicmVtb3ZlV3JhcERlbGltaXRlcnNGcm9tVmFsdWUiLCJ0cmltSGVhZGVyRmllbGRzIiwic3BsaXQiLCJtYXAiLCJjb21wb25lbnQiLCJ0cmltIiwiam9pbiIsInJldHJpZXZlSGVhZGluZyIsImxpbmVzIiwiaGVhZGVyRmllbGRzIiwiaGVhZGVyRmllbGQiLCJpbmRleCIsImhlYWRlclJvdyIsImtleXMiLCJmaWx0ZXIiLCJpbmNsdWRlcyIsInJlY29yZExpbmVzIiwic3RyaXBFeGNlbEJPTSIsImNzdiIsInJlcGxhY2UiLCJzcGxpdExpbmVzIiwibGFzdENoYXJhY3RlckluZGV4IiwibGVuZ3RoIiwiZW9sRGVsaW1pdGVyTGVuZ3RoIiwiZW9sIiwic3RhdGVWYXJpYWJsZXMiLCJpbnNpZGVXcmFwRGVsaW1pdGVyIiwicGFyc2luZ1ZhbHVlIiwianVzdFBhcnNlZERvdWJsZVF1b3RlIiwic3RhcnRJbmRleCIsInNwbGl0TGluZSIsImNoYXJhY3RlciIsImNoYXJCZWZvcmUiLCJjaGFyQWZ0ZXIiLCJuZXh0TkNoYXIiLCJnZXROQ2hhcmFjdGVycyIsImZpZWxkIiwicHVzaCIsInN1YnN0cmluZyIsInBhcnNlZFZhbHVlIiwidG9JbmRleCIsInJldHJpZXZlUmVjb3JkTGluZXMiLCJwYXJhbXMiLCJzcGxpY2UiLCJyZXRyaWV2ZVJlY29yZFZhbHVlRnJvbUxpbmUiLCJsaW5lIiwicHJvY2Vzc1JlY29yZFZhbHVlIiwiZmllbGRWYWx1ZSIsInBhcnNlZEpzb24iLCJpc0Vycm9yIiwiaXNJbnZhbGlkIiwidHJpbVJlY29yZFZhbHVlIiwidHJpbUZpZWxkVmFsdWVzIiwiY3JlYXRlRG9jdW1lbnQiLCJyZWR1Y2UiLCJkb2N1bWVudCIsInNldFBhdGgiLCJlcnJvciIsImZpcnN0Q2hhciIsImxhc3RJbmRleCIsImxhc3RDaGFyIiwidW5lc2NhcGVXcmFwRGVsaW1pdGVySW5GaWVsZCIsInRyYW5zZm9ybVJlY29yZExpbmVzIiwiZ2VuZXJhdGVkSnNvbk9iamVjdHMiLCJnZW5lcmF0ZWREb2N1bWVudCIsImNvbmNhdCIsImlzU3RyaW5nUmVwcmVzZW50YXRpb24iLCJpc0RhdGVSZXByZXNlbnRhdGlvbiIsIkFycmF5IiwiaXNBcnJheSIsImVyciIsImNvbnZlcnQiLCJkYXRhIiwic3RyaXBwZWQiLCJoZWFkaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/json-2-csv/lib/csv2json.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/json-2-csv/lib/json2csv.js":
/*!*************************************************!*\
  !*** ./node_modules/json-2-csv/lib/json2csv.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Json2Csv = void 0;\nconst doc_path_1 = __webpack_require__(/*! doc-path */ \"(ssr)/./node_modules/doc-path/lib/path.js\");\nconst deeks_1 = __webpack_require__(/*! deeks */ \"(ssr)/./node_modules/deeks/lib/deeks.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/json-2-csv/lib/constants.js\");\nconst utils = __importStar(__webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/json-2-csv/lib/utils.js\"));\nconst Json2Csv = function(options) {\n    const wrapDelimiterCheckRegex = new RegExp(options.delimiter.wrap, \"g\"), crlfSearchRegex = /\\r?\\n|\\r/, customValueParser = options.parseValue && typeof options.parseValue === \"function\" ? options.parseValue : null, expandingWithoutUnwinding = options.expandArrayObjects && !options.unwindArrays, deeksOptions = {\n        arrayIndexesAsKeys: options.arrayIndexesAsKeys,\n        expandNestedObjects: options.expandNestedObjects,\n        expandArrayObjects: expandingWithoutUnwinding,\n        ignoreEmptyArraysWhenExpanding: expandingWithoutUnwinding,\n        escapeNestedDots: true\n    };\n    /** HEADER FIELD FUNCTIONS **/ /**\n     * Returns the list of data field names of all documents in the provided list\n     */ function getFieldNameList(data) {\n        // If keys weren't specified, then we'll use the list of keys generated by the deeks module\n        return (0, deeks_1.deepKeysFromList)(data, deeksOptions);\n    }\n    /**\n     * Processes the schemas by checking for schema differences, if so desired.\n     * If schema differences are not to be checked, then it resolves the unique\n     * list of field names.\n     */ function processSchemas(documentSchemas) {\n        // If there are no document schemas then there is nothing to diff and no unique fields to get\n        if (documentSchemas.length === 0) {\n            return [];\n        }\n        // If the user wants to check for the same schema (regardless of schema ordering)\n        if (options.checkSchemaDifferences) {\n            return checkSchemaDifferences(documentSchemas);\n        } else {\n            // Otherwise, we do not care if the schemas are different, so we should get the unique list of keys\n            const uniqueFieldNames = utils.unique(utils.flatten(documentSchemas));\n            return uniqueFieldNames;\n        }\n    }\n    /**\n     * This function performs the schema difference check, if the user specifies that it should be checked.\n     * If there are no field names, then there are no differences.\n     * Otherwise, we get the first schema and the remaining list of schemas\n     */ function checkSchemaDifferences(documentSchemas) {\n        // have multiple documents - ensure only one schema (regardless of field ordering)\n        const firstDocSchema = documentSchemas[0], restOfDocumentSchemas = documentSchemas.slice(1), schemaDifferences = computeNumberOfSchemaDifferences(firstDocSchema, restOfDocumentSchemas);\n        // If there are schema inconsistencies, throw a schema not the same error\n        if (schemaDifferences) {\n            throw new Error(constants_1.errors.json2csv.notSameSchema);\n        }\n        return firstDocSchema;\n    }\n    /**\n     * Computes the number of schema differences\n     */ function computeNumberOfSchemaDifferences(firstDocSchema, restOfDocumentSchemas) {\n        return restOfDocumentSchemas.reduce((schemaDifferences, documentSchema)=>{\n            // If there is a difference between the schemas, increment the counter of schema inconsistencies\n            const numberOfDifferences = utils.computeSchemaDifferences(firstDocSchema, documentSchema).length;\n            return numberOfDifferences > 0 ? schemaDifferences + 1 : schemaDifferences;\n        }, 0);\n    }\n    /**\n     * If so specified, this filters the detected key paths to exclude any keys that have been specified\n     */ function filterExcludedKeys(keyPaths) {\n        if (options.excludeKeys) {\n            return keyPaths.filter((keyPath)=>{\n                for (const excludedKey of options.excludeKeys){\n                    // Only match if the excludedKey appears at the beginning of the string so we don't accidentally match a key farther down in a key path\n                    const regex = excludedKey instanceof RegExp ? excludedKey : new RegExp(`^${excludedKey}`);\n                    if (excludedKey === keyPath || keyPath.match(regex)) {\n                        return false; // Exclude the key\n                    }\n                }\n                return true; // Otherwise, include the key\n            });\n        }\n        return keyPaths;\n    }\n    /**\n     * If so specified, this sorts the header field names alphabetically\n     */ function sortHeaderFields(fieldNames) {\n        if (options.sortHeader && typeof options.sortHeader === \"function\") {\n            return fieldNames.sort(options.sortHeader);\n        } else if (options.sortHeader) {\n            return fieldNames.sort();\n        }\n        return fieldNames;\n    }\n    /**\n     * Trims the header fields, if the user desires them to be trimmed.\n     */ function trimHeaderFields(params) {\n        if (options.trimHeaderFields) {\n            params.headerFields = params.headerFields.map((field)=>field.split(\".\").map((component)=>component.trim()).join(\".\"));\n        }\n        return params;\n    }\n    /**\n     * Wrap the headings, if desired by the user.\n     */ function wrapHeaderFields(params) {\n        // only perform this if we are actually prepending the header\n        if (options.prependHeader) {\n            params.headerFields = params.headerFields.map(function(headingKey) {\n                return wrapFieldValueIfNecessary(headingKey);\n            });\n        }\n        return params;\n    }\n    /**\n     * Generates the CSV header string by joining the headerFields by the field delimiter\n     */ function generateCsvHeader(params) {\n        // #185 - generate a keys list to avoid finding native Map() methods\n        const fieldTitleMapKeys = Object.keys(options.fieldTitleMap);\n        params.header = params.headerFields.map(function(field) {\n            let headerKey = field;\n            // If a custom field title was provided for this field, use that\n            if (fieldTitleMapKeys.includes(field)) {\n                headerKey = options.fieldTitleMap[field];\n            } else if (!options.escapeHeaderNestedDots) {\n                // Otherwise, if the user doesn't want nested dots in keys to be escaped, then unescape them\n                headerKey = headerKey.replace(/\\\\\\./g, \".\");\n            }\n            return headerKey;\n        }).join(options.delimiter.field);\n        return params;\n    }\n    function convertKeysToHeaderFields() {\n        if (!options.keys) return [];\n        return options.keys.map((key)=>{\n            if (typeof key === \"object\" && \"field\" in key) {\n                options.fieldTitleMap[key.field] = key.title ?? key.field;\n                return key.field;\n            }\n            return key;\n        });\n    }\n    function extractWildcardMatchKeys() {\n        if (!options.keys) return [];\n        return options.keys.flatMap((item)=>{\n            if (typeof item === \"string\") {\n                // Exclude plain strings that were passed in options.keys\n                return [];\n            } else if (item?.wildcardMatch) {\n                // Return \"field\" value for objects with wildcardMatch: true\n                return item.field;\n            }\n            // Exclude other objects\n            return [];\n        });\n    }\n    /**\n     * Retrieve the headings for all documents and return it.\n     * This checks that all documents have the same schema.\n     */ function retrieveHeaderFields(data) {\n        const wildcardMatchKeys = extractWildcardMatchKeys();\n        const keyStrings = convertKeysToHeaderFields();\n        const fieldNames = getFieldNameList(data);\n        const processed = processSchemas(fieldNames);\n        if (options.keys) {\n            options.keys = keyStrings;\n            const matchedKeys = keyStrings.flatMap((userProvidedKey)=>{\n                // If this is not a wildcard matched key, then just return and include it in the resulting key list\n                if (!wildcardMatchKeys.includes(userProvidedKey)) {\n                    return userProvidedKey;\n                }\n                // Otherwise, identify all detected keys that match with the provided wildcard key:\n                const matches = [];\n                const regex = new RegExp(`^${userProvidedKey}`);\n                for (const detectedKey of processed){\n                    if (userProvidedKey === detectedKey || detectedKey.match(regex)) {\n                        matches.push(detectedKey);\n                    }\n                }\n                return matches;\n            });\n            if (!options.unwindArrays) {\n                const filtered = filterExcludedKeys(matchedKeys);\n                return sortHeaderFields(filtered);\n            }\n        }\n        const filtered = filterExcludedKeys(processed);\n        return sortHeaderFields(filtered);\n    }\n    /** RECORD FIELD FUNCTIONS **/ function stillNeedsUnwind(params) {\n        for (const record of params.records){\n            for (const field of params.headerFields){\n                const value = (0, doc_path_1.evaluatePath)(record, field);\n                if (Array.isArray(value)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    /**\n     * Unwinds objects in arrays within record objects if the user specifies the\n     * expandArrayObjects option. If not specified, this passes the params\n     * argument through to the next function in the promise chain.\n     *\n     * The `finalPass` parameter is used to trigger one last pass to ensure no more\n     * arrays need to be expanded\n     */ function unwindRecordsIfNecessary(params, finalPass = false) {\n        if (options.unwindArrays) {\n            // Unwind each document at each header field\n            params.headerFields.forEach((headerField)=>{\n                params.records = utils.unwind(params.records, headerField);\n            });\n            params.headerFields = retrieveHeaderFields(params.records);\n            // Continue unwinding if any nested arrays remain\n            if (stillNeedsUnwind(params)) {\n                return unwindRecordsIfNecessary(params, finalPass);\n            }\n            // Run a final time in case the earlier unwinding exposed additional\n            // arrays to unwind...\n            if (!finalPass) {\n                return unwindRecordsIfNecessary(params, true);\n            }\n            // If keys were provided, set the headerFields back to the provided keys after unwinding:\n            if (options.keys) {\n                const userSelectedFields = convertKeysToHeaderFields();\n                params.headerFields = filterExcludedKeys(userSelectedFields);\n            }\n            return params;\n        }\n        return params;\n    }\n    /**\n     * Main function which handles the processing of a record, or document to be converted to CSV format\n     * This function specifies and performs the necessary operations in the necessary order\n     * in order to obtain the data and convert it to CSV form while maintaining RFC 4180 compliance.\n     * * Order of operations:\n     * - Get fields from provided key list (as array of actual values)\n     * - Convert the values to csv/string representation [possible option here for custom converters?]\n     * - Trim fields\n     * - Determine if they need to be wrapped (& wrap if necessary)\n     * - Combine values for each line (by joining by field delimiter)\n     */ function processRecords(params) {\n        params.recordString = params.records.map((record)=>{\n            // Retrieve data for each of the headerFields from this record\n            const recordFieldData = retrieveRecordFieldData(record, params.headerFields), // Process the data in this record and return the\n            processedRecordData = recordFieldData.map((fieldValue)=>{\n                fieldValue = trimRecordFieldValue(fieldValue);\n                fieldValue = preventCsvInjection(fieldValue);\n                let stringified = customValueParser ? customValueParser(fieldValue, recordFieldValueToString) : recordFieldValueToString(fieldValue);\n                stringified = wrapFieldValueIfNecessary(stringified);\n                return stringified;\n            });\n            // Join the record data by the field delimiter\n            return generateCsvRowFromRecord(processedRecordData);\n        }).join(options.delimiter.eol);\n        return params;\n    }\n    /**\n     * Helper function intended to process *just* array values when the expandArrayObjects setting is set to true\n     */ function processRecordFieldDataForExpandedArrayObject(recordFieldValue) {\n        const filteredRecordFieldValue = utils.removeEmptyFields(recordFieldValue);\n        // If we have an array and it's either empty of full of empty values, then use an empty value representation\n        if (!recordFieldValue.length || !filteredRecordFieldValue.length) {\n            return options.emptyFieldValue || \"\";\n        } else if (filteredRecordFieldValue.length === 1) {\n            // Otherwise, we have an array of actual values...\n            // Since we are expanding array objects, we will want to key in on values of objects.\n            return filteredRecordFieldValue[0]; // Extract the single value in the array\n        }\n        return recordFieldValue;\n    }\n    /**\n     * Gets all field values from a particular record for the given list of fields\n     */ function retrieveRecordFieldData(record, fields) {\n        const recordValues = [];\n        fields.forEach((field)=>{\n            let recordFieldValue = (0, doc_path_1.evaluatePath)(record, field);\n            if (!utils.isUndefined(options.emptyFieldValue) && utils.isEmptyField(recordFieldValue)) {\n                recordFieldValue = options.emptyFieldValue;\n            } else if (options.expandArrayObjects && Array.isArray(recordFieldValue)) {\n                recordFieldValue = processRecordFieldDataForExpandedArrayObject(recordFieldValue);\n            }\n            recordValues.push(recordFieldValue);\n        });\n        return recordValues;\n    }\n    /**\n     * Converts a record field value to its string representation\n     */ function recordFieldValueToString(fieldValue) {\n        const isDate = fieldValue instanceof Date; // store to avoid checking twice\n        if (fieldValue === null || Array.isArray(fieldValue) || typeof fieldValue === \"object\" && !isDate) {\n            return JSON.stringify(fieldValue);\n        } else if (typeof fieldValue === \"undefined\") {\n            return \"undefined\";\n        } else if (isDate && options.useDateIso8601Format) {\n            return fieldValue.toISOString();\n        } else {\n            return !options.useLocaleFormat ? fieldValue.toString() : fieldValue.toLocaleString();\n        }\n    }\n    /**\n     * Trims the record field value, if specified by the user's provided options\n     */ function trimRecordFieldValue(fieldValue) {\n        if (options.trimFieldValues) {\n            if (Array.isArray(fieldValue)) {\n                return fieldValue.map(trimRecordFieldValue);\n            } else if (typeof fieldValue === \"string\") {\n                return fieldValue.trim();\n            }\n            return fieldValue;\n        }\n        return fieldValue;\n    }\n    /**\n     * Prevent CSV injection on strings if specified by the user's provided options.\n     * Mitigation will be done by ensuring that the first character doesn't being with:\n     * Equals (=), Plus (+), Minus (-), At (@), Tab (0x09), Carriage return (0x0D).\n     * More info: https://owasp.org/www-community/attacks/CSV_Injection\n     */ function preventCsvInjection(fieldValue) {\n        if (options.preventCsvInjection) {\n            if (Array.isArray(fieldValue)) {\n                return fieldValue.map(preventCsvInjection);\n            } else if (typeof fieldValue === \"string\" && !utils.isNumber(fieldValue)) {\n                return fieldValue.replace(/^[=+\\-@\\t\\r]+/g, \"\");\n            }\n            return fieldValue;\n        }\n        return fieldValue;\n    }\n    /**\n     * Escapes quotation marks in the field value, if necessary, and appropriately\n     * wraps the record field value if it contains a comma (field delimiter),\n     * quotation mark (wrap delimiter), or a line break (CRLF)\n     */ function wrapFieldValueIfNecessary(fieldValue) {\n        const wrapDelimiter = options.delimiter.wrap;\n        // eg. includes quotation marks (default delimiter)\n        if (fieldValue.includes(options.delimiter.wrap)) {\n            // add an additional quotation mark before each quotation mark appearing in the field value\n            fieldValue = fieldValue.replace(wrapDelimiterCheckRegex, wrapDelimiter + wrapDelimiter);\n        }\n        // if the field contains a comma (field delimiter), quotation mark (wrap delimiter), line break, or CRLF\n        //   then enclose it in quotation marks (wrap delimiter)\n        if (fieldValue.includes(options.delimiter.field) || fieldValue.includes(options.delimiter.wrap) || fieldValue.match(crlfSearchRegex) || options.wrapBooleans && (fieldValue === \"true\" || fieldValue === \"false\")) {\n            // wrap the field's value in a wrap delimiter (quotation marks by default)\n            fieldValue = wrapDelimiter + fieldValue + wrapDelimiter;\n        }\n        return fieldValue;\n    }\n    /**\n     * Generates the CSV record string by joining the field values together by the field delimiter\n     */ function generateCsvRowFromRecord(recordFieldValues) {\n        return recordFieldValues.join(options.delimiter.field);\n    }\n    /** CSV COMPONENT COMBINER/FINAL PROCESSOR **/ /**\n     * Performs the final CSV construction by combining the fields in the appropriate\n     * order depending on the provided options values and sends the generated CSV\n     * back to the user\n     */ function generateCsvFromComponents(params) {\n        const header = params.header, records = params.recordString, // If we are prepending the header, then add an EOL, otherwise just return the records\n        csv = (options.excelBOM ? constants_1.excelBOM : \"\") + (options.prependHeader ? header + options.delimiter.eol : \"\") + records;\n        return csv;\n    }\n    /** MAIN CONVERTER FUNCTION **/ /**\n     * Internally exported json2csv function\n     */ function convert(data) {\n        // Single document, not an array\n        if (!Array.isArray(data)) {\n            data = [\n                data\n            ]; // Convert to an array of the given document\n        }\n        // Retrieve the heading and then generate the CSV with the keys that are identified\n        const headerFields = {\n            headerFields: retrieveHeaderFields(data),\n            records: data,\n            header: \"\",\n            recordString: \"\"\n        };\n        const unwinded = unwindRecordsIfNecessary(headerFields);\n        const processed = processRecords(unwinded);\n        const wrapped = wrapHeaderFields(processed);\n        const trimmed = trimHeaderFields(wrapped);\n        const generated = generateCsvHeader(trimmed);\n        return generateCsvFromComponents(generated);\n    }\n    return {\n        convert\n    };\n};\nexports.Json2Csv = Json2Csv;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbi0yLWNzdi9saWIvanNvbjJjc3YuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxJQUFJQSxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQU1DLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQzFGLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCLElBQUlHLE9BQU9QLE9BQU9RLHdCQUF3QixDQUFDTCxHQUFHQztJQUM5QyxJQUFJLENBQUNHLFFBQVMsVUFBU0EsT0FBTyxDQUFDSixFQUFFTSxVQUFVLEdBQUdGLEtBQUtHLFFBQVEsSUFBSUgsS0FBS0ksWUFBWSxHQUFHO1FBQ2pGSixPQUFPO1lBQUVLLFlBQVk7WUFBTUMsS0FBSztnQkFBYSxPQUFPVixDQUFDLENBQUNDLEVBQUU7WUFBRTtRQUFFO0lBQzlEO0lBQ0FKLE9BQU9jLGNBQWMsQ0FBQ1osR0FBR0csSUFBSUU7QUFDakMsSUFBTSxTQUFTTCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQ3RCLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCRixDQUFDLENBQUNHLEdBQUcsR0FBR0YsQ0FBQyxDQUFDQyxFQUFFO0FBQ2hCLENBQUM7QUFDRCxJQUFJVyxxQkFBcUIsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxrQkFBa0IsSUFBTWYsQ0FBQUEsT0FBT0MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRWMsQ0FBQztJQUN6RmhCLE9BQU9jLGNBQWMsQ0FBQ1osR0FBRyxXQUFXO1FBQUVVLFlBQVk7UUFBTUssT0FBT0Q7SUFBRTtBQUNyRSxJQUFLLFNBQVNkLENBQUMsRUFBRWMsQ0FBQztJQUNkZCxDQUFDLENBQUMsVUFBVSxHQUFHYztBQUNuQjtBQUNBLElBQUlFLGVBQWUsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxZQUFZ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SixPQUFPOEM7SUFDWDtJQUNBLDZCQUE2QixHQUM3Qjs7S0FFQyxHQUNELFNBQVNFLFFBQVEzSCxJQUFJO1FBQ2pCLGdDQUFnQztRQUNoQyxJQUFJLENBQUM2RSxNQUFNQyxPQUFPLENBQUM5RSxPQUFPO1lBQ3RCQSxPQUFPO2dCQUFDQTthQUFLLEVBQUUsNENBQTRDO1FBQy9EO1FBQ0EsbUZBQW1GO1FBQ25GLE1BQU1vQyxlQUFlO1lBQ2pCQSxjQUFjMkIscUJBQXFCL0Q7WUFDbkMyRSxTQUFTM0U7WUFDVG1ELFFBQVE7WUFDUm1DLGNBQWM7UUFDbEI7UUFDQSxNQUFNc0MsV0FBVzdDLHlCQUF5QjNDO1FBQzFDLE1BQU04QixZQUFZbUIsZUFBZXVDO1FBQ2pDLE1BQU1DLFVBQVVsRixpQkFBaUJ1QjtRQUNqQyxNQUFNNEQsVUFBVTVGLGlCQUFpQjJGO1FBQ2pDLE1BQU1FLFlBQVloRixrQkFBa0IrRTtRQUNwQyxPQUFPTiwwQkFBMEJPO0lBQ3JDO0lBQ0EsT0FBTztRQUNISjtJQUNKO0FBQ0o7QUFDQW5KLGdCQUFnQixHQUFHQyIsInNvdXJjZXMiOlsid2VicGFjazovL2VyYS1wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvanNvbi0yLWNzdi9saWIvanNvbjJjc3YuanM/ZTllYyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSnNvbjJDc3YgPSB2b2lkIDA7XG5jb25zdCBkb2NfcGF0aF8xID0gcmVxdWlyZShcImRvYy1wYXRoXCIpO1xuY29uc3QgZGVla3NfMSA9IHJlcXVpcmUoXCJkZWVrc1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgdXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdXRpbHNcIikpO1xuY29uc3QgSnNvbjJDc3YgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIGNvbnN0IHdyYXBEZWxpbWl0ZXJDaGVja1JlZ2V4ID0gbmV3IFJlZ0V4cChvcHRpb25zLmRlbGltaXRlci53cmFwLCAnZycpLCBjcmxmU2VhcmNoUmVnZXggPSAvXFxyP1xcbnxcXHIvLCBjdXN0b21WYWx1ZVBhcnNlciA9IG9wdGlvbnMucGFyc2VWYWx1ZSAmJiB0eXBlb2Ygb3B0aW9ucy5wYXJzZVZhbHVlID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy5wYXJzZVZhbHVlIDogbnVsbCwgZXhwYW5kaW5nV2l0aG91dFVud2luZGluZyA9IG9wdGlvbnMuZXhwYW5kQXJyYXlPYmplY3RzICYmICFvcHRpb25zLnVud2luZEFycmF5cywgZGVla3NPcHRpb25zID0ge1xuICAgICAgICBhcnJheUluZGV4ZXNBc0tleXM6IG9wdGlvbnMuYXJyYXlJbmRleGVzQXNLZXlzLFxuICAgICAgICBleHBhbmROZXN0ZWRPYmplY3RzOiBvcHRpb25zLmV4cGFuZE5lc3RlZE9iamVjdHMsXG4gICAgICAgIGV4cGFuZEFycmF5T2JqZWN0czogZXhwYW5kaW5nV2l0aG91dFVud2luZGluZyxcbiAgICAgICAgaWdub3JlRW1wdHlBcnJheXNXaGVuRXhwYW5kaW5nOiBleHBhbmRpbmdXaXRob3V0VW53aW5kaW5nLFxuICAgICAgICBlc2NhcGVOZXN0ZWREb3RzOiB0cnVlLFxuICAgIH07XG4gICAgLyoqIEhFQURFUiBGSUVMRCBGVU5DVElPTlMgKiovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBkYXRhIGZpZWxkIG5hbWVzIG9mIGFsbCBkb2N1bWVudHMgaW4gdGhlIHByb3ZpZGVkIGxpc3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRGaWVsZE5hbWVMaXN0KGRhdGEpIHtcbiAgICAgICAgLy8gSWYga2V5cyB3ZXJlbid0IHNwZWNpZmllZCwgdGhlbiB3ZSdsbCB1c2UgdGhlIGxpc3Qgb2Yga2V5cyBnZW5lcmF0ZWQgYnkgdGhlIGRlZWtzIG1vZHVsZVxuICAgICAgICByZXR1cm4gKDAsIGRlZWtzXzEuZGVlcEtleXNGcm9tTGlzdCkoZGF0YSwgZGVla3NPcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvY2Vzc2VzIHRoZSBzY2hlbWFzIGJ5IGNoZWNraW5nIGZvciBzY2hlbWEgZGlmZmVyZW5jZXMsIGlmIHNvIGRlc2lyZWQuXG4gICAgICogSWYgc2NoZW1hIGRpZmZlcmVuY2VzIGFyZSBub3QgdG8gYmUgY2hlY2tlZCwgdGhlbiBpdCByZXNvbHZlcyB0aGUgdW5pcXVlXG4gICAgICogbGlzdCBvZiBmaWVsZCBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9jZXNzU2NoZW1hcyhkb2N1bWVudFNjaGVtYXMpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGRvY3VtZW50IHNjaGVtYXMgdGhlbiB0aGVyZSBpcyBub3RoaW5nIHRvIGRpZmYgYW5kIG5vIHVuaXF1ZSBmaWVsZHMgdG8gZ2V0XG4gICAgICAgIGlmIChkb2N1bWVudFNjaGVtYXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgd2FudHMgdG8gY2hlY2sgZm9yIHRoZSBzYW1lIHNjaGVtYSAocmVnYXJkbGVzcyBvZiBzY2hlbWEgb3JkZXJpbmcpXG4gICAgICAgIGlmIChvcHRpb25zLmNoZWNrU2NoZW1hRGlmZmVyZW5jZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVja1NjaGVtYURpZmZlcmVuY2VzKGRvY3VtZW50U2NoZW1hcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIHdlIGRvIG5vdCBjYXJlIGlmIHRoZSBzY2hlbWFzIGFyZSBkaWZmZXJlbnQsIHNvIHdlIHNob3VsZCBnZXQgdGhlIHVuaXF1ZSBsaXN0IG9mIGtleXNcbiAgICAgICAgICAgIGNvbnN0IHVuaXF1ZUZpZWxkTmFtZXMgPSB1dGlscy51bmlxdWUodXRpbHMuZmxhdHRlbihkb2N1bWVudFNjaGVtYXMpKTtcbiAgICAgICAgICAgIHJldHVybiB1bmlxdWVGaWVsZE5hbWVzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gcGVyZm9ybXMgdGhlIHNjaGVtYSBkaWZmZXJlbmNlIGNoZWNrLCBpZiB0aGUgdXNlciBzcGVjaWZpZXMgdGhhdCBpdCBzaG91bGQgYmUgY2hlY2tlZC5cbiAgICAgKiBJZiB0aGVyZSBhcmUgbm8gZmllbGQgbmFtZXMsIHRoZW4gdGhlcmUgYXJlIG5vIGRpZmZlcmVuY2VzLlxuICAgICAqIE90aGVyd2lzZSwgd2UgZ2V0IHRoZSBmaXJzdCBzY2hlbWEgYW5kIHRoZSByZW1haW5pbmcgbGlzdCBvZiBzY2hlbWFzXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hlY2tTY2hlbWFEaWZmZXJlbmNlcyhkb2N1bWVudFNjaGVtYXMpIHtcbiAgICAgICAgLy8gaGF2ZSBtdWx0aXBsZSBkb2N1bWVudHMgLSBlbnN1cmUgb25seSBvbmUgc2NoZW1hIChyZWdhcmRsZXNzIG9mIGZpZWxkIG9yZGVyaW5nKVxuICAgICAgICBjb25zdCBmaXJzdERvY1NjaGVtYSA9IGRvY3VtZW50U2NoZW1hc1swXSwgcmVzdE9mRG9jdW1lbnRTY2hlbWFzID0gZG9jdW1lbnRTY2hlbWFzLnNsaWNlKDEpLCBzY2hlbWFEaWZmZXJlbmNlcyA9IGNvbXB1dGVOdW1iZXJPZlNjaGVtYURpZmZlcmVuY2VzKGZpcnN0RG9jU2NoZW1hLCByZXN0T2ZEb2N1bWVudFNjaGVtYXMpO1xuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgc2NoZW1hIGluY29uc2lzdGVuY2llcywgdGhyb3cgYSBzY2hlbWEgbm90IHRoZSBzYW1lIGVycm9yXG4gICAgICAgIGlmIChzY2hlbWFEaWZmZXJlbmNlcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGNvbnN0YW50c18xLmVycm9ycy5qc29uMmNzdi5ub3RTYW1lU2NoZW1hKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlyc3REb2NTY2hlbWE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBudW1iZXIgb2Ygc2NoZW1hIGRpZmZlcmVuY2VzXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcHV0ZU51bWJlck9mU2NoZW1hRGlmZmVyZW5jZXMoZmlyc3REb2NTY2hlbWEsIHJlc3RPZkRvY3VtZW50U2NoZW1hcykge1xuICAgICAgICByZXR1cm4gcmVzdE9mRG9jdW1lbnRTY2hlbWFzLnJlZHVjZSgoc2NoZW1hRGlmZmVyZW5jZXMsIGRvY3VtZW50U2NoZW1hKSA9PiB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgc2NoZW1hcywgaW5jcmVtZW50IHRoZSBjb3VudGVyIG9mIHNjaGVtYSBpbmNvbnNpc3RlbmNpZXNcbiAgICAgICAgICAgIGNvbnN0IG51bWJlck9mRGlmZmVyZW5jZXMgPSB1dGlscy5jb21wdXRlU2NoZW1hRGlmZmVyZW5jZXMoZmlyc3REb2NTY2hlbWEsIGRvY3VtZW50U2NoZW1hKS5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyT2ZEaWZmZXJlbmNlcyA+IDBcbiAgICAgICAgICAgICAgICA/IHNjaGVtYURpZmZlcmVuY2VzICsgMVxuICAgICAgICAgICAgICAgIDogc2NoZW1hRGlmZmVyZW5jZXM7XG4gICAgICAgIH0sIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiBzbyBzcGVjaWZpZWQsIHRoaXMgZmlsdGVycyB0aGUgZGV0ZWN0ZWQga2V5IHBhdGhzIHRvIGV4Y2x1ZGUgYW55IGtleXMgdGhhdCBoYXZlIGJlZW4gc3BlY2lmaWVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlsdGVyRXhjbHVkZWRLZXlzKGtleVBhdGhzKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmV4Y2x1ZGVLZXlzKSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5UGF0aHMuZmlsdGVyKChrZXlQYXRoKSA9PiB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBleGNsdWRlZEtleSBvZiBvcHRpb25zLmV4Y2x1ZGVLZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgbWF0Y2ggaWYgdGhlIGV4Y2x1ZGVkS2V5IGFwcGVhcnMgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgc3RyaW5nIHNvIHdlIGRvbid0IGFjY2lkZW50YWxseSBtYXRjaCBhIGtleSBmYXJ0aGVyIGRvd24gaW4gYSBrZXkgcGF0aFxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IGV4Y2x1ZGVkS2V5IGluc3RhbmNlb2YgUmVnRXhwID8gZXhjbHVkZWRLZXkgOiBuZXcgUmVnRXhwKGBeJHtleGNsdWRlZEtleX1gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4Y2x1ZGVkS2V5ID09PSBrZXlQYXRoIHx8IGtleVBhdGgubWF0Y2gocmVnZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIEV4Y2x1ZGUgdGhlIGtleVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBPdGhlcndpc2UsIGluY2x1ZGUgdGhlIGtleVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleVBhdGhzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiBzbyBzcGVjaWZpZWQsIHRoaXMgc29ydHMgdGhlIGhlYWRlciBmaWVsZCBuYW1lcyBhbHBoYWJldGljYWxseVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRIZWFkZXJGaWVsZHMoZmllbGROYW1lcykge1xuICAgICAgICBpZiAob3B0aW9ucy5zb3J0SGVhZGVyICYmIHR5cGVvZiBvcHRpb25zLnNvcnRIZWFkZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWVsZE5hbWVzLnNvcnQob3B0aW9ucy5zb3J0SGVhZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLnNvcnRIZWFkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWVsZE5hbWVzLnNvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmllbGROYW1lcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJpbXMgdGhlIGhlYWRlciBmaWVsZHMsIGlmIHRoZSB1c2VyIGRlc2lyZXMgdGhlbSB0byBiZSB0cmltbWVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW1IZWFkZXJGaWVsZHMocGFyYW1zKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnRyaW1IZWFkZXJGaWVsZHMpIHtcbiAgICAgICAgICAgIHBhcmFtcy5oZWFkZXJGaWVsZHMgPSBwYXJhbXMuaGVhZGVyRmllbGRzLm1hcCgoZmllbGQpID0+IGZpZWxkLnNwbGl0KCcuJylcbiAgICAgICAgICAgICAgICAubWFwKChjb21wb25lbnQpID0+IGNvbXBvbmVudC50cmltKCkpXG4gICAgICAgICAgICAgICAgLmpvaW4oJy4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JhcCB0aGUgaGVhZGluZ3MsIGlmIGRlc2lyZWQgYnkgdGhlIHVzZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcEhlYWRlckZpZWxkcyhwYXJhbXMpIHtcbiAgICAgICAgLy8gb25seSBwZXJmb3JtIHRoaXMgaWYgd2UgYXJlIGFjdHVhbGx5IHByZXBlbmRpbmcgdGhlIGhlYWRlclxuICAgICAgICBpZiAob3B0aW9ucy5wcmVwZW5kSGVhZGVyKSB7XG4gICAgICAgICAgICBwYXJhbXMuaGVhZGVyRmllbGRzID0gcGFyYW1zLmhlYWRlckZpZWxkcy5tYXAoZnVuY3Rpb24gKGhlYWRpbmdLZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcEZpZWxkVmFsdWVJZk5lY2Vzc2FyeShoZWFkaW5nS2V5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyB0aGUgQ1NWIGhlYWRlciBzdHJpbmcgYnkgam9pbmluZyB0aGUgaGVhZGVyRmllbGRzIGJ5IHRoZSBmaWVsZCBkZWxpbWl0ZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUNzdkhlYWRlcihwYXJhbXMpIHtcbiAgICAgICAgLy8gIzE4NSAtIGdlbmVyYXRlIGEga2V5cyBsaXN0IHRvIGF2b2lkIGZpbmRpbmcgbmF0aXZlIE1hcCgpIG1ldGhvZHNcbiAgICAgICAgY29uc3QgZmllbGRUaXRsZU1hcEtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zLmZpZWxkVGl0bGVNYXApO1xuICAgICAgICBwYXJhbXMuaGVhZGVyID0gcGFyYW1zLmhlYWRlckZpZWxkc1xuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgICAgIGxldCBoZWFkZXJLZXkgPSBmaWVsZDtcbiAgICAgICAgICAgIC8vIElmIGEgY3VzdG9tIGZpZWxkIHRpdGxlIHdhcyBwcm92aWRlZCBmb3IgdGhpcyBmaWVsZCwgdXNlIHRoYXRcbiAgICAgICAgICAgIGlmIChmaWVsZFRpdGxlTWFwS2V5cy5pbmNsdWRlcyhmaWVsZCkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJLZXkgPSBvcHRpb25zLmZpZWxkVGl0bGVNYXBbZmllbGRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIW9wdGlvbnMuZXNjYXBlSGVhZGVyTmVzdGVkRG90cykge1xuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgaWYgdGhlIHVzZXIgZG9lc24ndCB3YW50IG5lc3RlZCBkb3RzIGluIGtleXMgdG8gYmUgZXNjYXBlZCwgdGhlbiB1bmVzY2FwZSB0aGVtXG4gICAgICAgICAgICAgICAgaGVhZGVyS2V5ID0gaGVhZGVyS2V5LnJlcGxhY2UoL1xcXFxcXC4vZywgJy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBoZWFkZXJLZXk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbihvcHRpb25zLmRlbGltaXRlci5maWVsZCk7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnZlcnRLZXlzVG9IZWFkZXJGaWVsZHMoKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5rZXlzKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5rZXlzLm1hcCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcgJiYgJ2ZpZWxkJyBpbiBrZXkpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmZpZWxkVGl0bGVNYXBba2V5LmZpZWxkXSA9IGtleS50aXRsZSA/PyBrZXkuZmllbGQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleS5maWVsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBleHRyYWN0V2lsZGNhcmRNYXRjaEtleXMoKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5rZXlzKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5rZXlzLmZsYXRNYXAoaXRlbSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy8gRXhjbHVkZSBwbGFpbiBzdHJpbmdzIHRoYXQgd2VyZSBwYXNzZWQgaW4gb3B0aW9ucy5rZXlzXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXRlbT8ud2lsZGNhcmRNYXRjaCkge1xuICAgICAgICAgICAgICAgIC8vIFJldHVybiBcImZpZWxkXCIgdmFsdWUgZm9yIG9iamVjdHMgd2l0aCB3aWxkY2FyZE1hdGNoOiB0cnVlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uZmllbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFeGNsdWRlIG90aGVyIG9iamVjdHNcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBoZWFkaW5ncyBmb3IgYWxsIGRvY3VtZW50cyBhbmQgcmV0dXJuIGl0LlxuICAgICAqIFRoaXMgY2hlY2tzIHRoYXQgYWxsIGRvY3VtZW50cyBoYXZlIHRoZSBzYW1lIHNjaGVtYS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXRyaWV2ZUhlYWRlckZpZWxkcyhkYXRhKSB7XG4gICAgICAgIGNvbnN0IHdpbGRjYXJkTWF0Y2hLZXlzID0gZXh0cmFjdFdpbGRjYXJkTWF0Y2hLZXlzKCk7XG4gICAgICAgIGNvbnN0IGtleVN0cmluZ3MgPSBjb252ZXJ0S2V5c1RvSGVhZGVyRmllbGRzKCk7XG4gICAgICAgIGNvbnN0IGZpZWxkTmFtZXMgPSBnZXRGaWVsZE5hbWVMaXN0KGRhdGEpO1xuICAgICAgICBjb25zdCBwcm9jZXNzZWQgPSBwcm9jZXNzU2NoZW1hcyhmaWVsZE5hbWVzKTtcbiAgICAgICAgaWYgKG9wdGlvbnMua2V5cykge1xuICAgICAgICAgICAgb3B0aW9ucy5rZXlzID0ga2V5U3RyaW5ncztcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZWRLZXlzID0ga2V5U3RyaW5ncy5mbGF0TWFwKCh1c2VyUHJvdmlkZWRLZXkpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGlzIG5vdCBhIHdpbGRjYXJkIG1hdGNoZWQga2V5LCB0aGVuIGp1c3QgcmV0dXJuIGFuZCBpbmNsdWRlIGl0IGluIHRoZSByZXN1bHRpbmcga2V5IGxpc3RcbiAgICAgICAgICAgICAgICBpZiAoIXdpbGRjYXJkTWF0Y2hLZXlzLmluY2x1ZGVzKHVzZXJQcm92aWRlZEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVzZXJQcm92aWRlZEtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpZGVudGlmeSBhbGwgZGV0ZWN0ZWQga2V5cyB0aGF0IG1hdGNoIHdpdGggdGhlIHByb3ZpZGVkIHdpbGRjYXJkIGtleTpcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gW107XG4gICAgICAgICAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKGBeJHt1c2VyUHJvdmlkZWRLZXl9YCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBkZXRlY3RlZEtleSBvZiBwcm9jZXNzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVzZXJQcm92aWRlZEtleSA9PT0gZGV0ZWN0ZWRLZXkgfHwgZGV0ZWN0ZWRLZXkubWF0Y2gocmVnZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2goZGV0ZWN0ZWRLZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMudW53aW5kQXJyYXlzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyZWQgPSBmaWx0ZXJFeGNsdWRlZEtleXMobWF0Y2hlZEtleXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzb3J0SGVhZGVyRmllbGRzKGZpbHRlcmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IGZpbHRlckV4Y2x1ZGVkS2V5cyhwcm9jZXNzZWQpO1xuICAgICAgICByZXR1cm4gc29ydEhlYWRlckZpZWxkcyhmaWx0ZXJlZCk7XG4gICAgfVxuICAgIC8qKiBSRUNPUkQgRklFTEQgRlVOQ1RJT05TICoqL1xuICAgIGZ1bmN0aW9uIHN0aWxsTmVlZHNVbndpbmQocGFyYW1zKSB7XG4gICAgICAgIGZvciAoY29uc3QgcmVjb3JkIG9mIHBhcmFtcy5yZWNvcmRzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIHBhcmFtcy5oZWFkZXJGaWVsZHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9ICgwLCBkb2NfcGF0aF8xLmV2YWx1YXRlUGF0aCkocmVjb3JkLCBmaWVsZCk7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVud2luZHMgb2JqZWN0cyBpbiBhcnJheXMgd2l0aGluIHJlY29yZCBvYmplY3RzIGlmIHRoZSB1c2VyIHNwZWNpZmllcyB0aGVcbiAgICAgKiBleHBhbmRBcnJheU9iamVjdHMgb3B0aW9uLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGlzIHBhc3NlcyB0aGUgcGFyYW1zXG4gICAgICogYXJndW1lbnQgdGhyb3VnaCB0byB0aGUgbmV4dCBmdW5jdGlvbiBpbiB0aGUgcHJvbWlzZSBjaGFpbi5cbiAgICAgKlxuICAgICAqIFRoZSBgZmluYWxQYXNzYCBwYXJhbWV0ZXIgaXMgdXNlZCB0byB0cmlnZ2VyIG9uZSBsYXN0IHBhc3MgdG8gZW5zdXJlIG5vIG1vcmVcbiAgICAgKiBhcnJheXMgbmVlZCB0byBiZSBleHBhbmRlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVud2luZFJlY29yZHNJZk5lY2Vzc2FyeShwYXJhbXMsIGZpbmFsUGFzcyA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnVud2luZEFycmF5cykge1xuICAgICAgICAgICAgLy8gVW53aW5kIGVhY2ggZG9jdW1lbnQgYXQgZWFjaCBoZWFkZXIgZmllbGRcbiAgICAgICAgICAgIHBhcmFtcy5oZWFkZXJGaWVsZHMuZm9yRWFjaCgoaGVhZGVyRmllbGQpID0+IHtcbiAgICAgICAgICAgICAgICBwYXJhbXMucmVjb3JkcyA9IHV0aWxzLnVud2luZChwYXJhbXMucmVjb3JkcywgaGVhZGVyRmllbGQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwYXJhbXMuaGVhZGVyRmllbGRzID0gcmV0cmlldmVIZWFkZXJGaWVsZHMocGFyYW1zLnJlY29yZHMpO1xuICAgICAgICAgICAgLy8gQ29udGludWUgdW53aW5kaW5nIGlmIGFueSBuZXN0ZWQgYXJyYXlzIHJlbWFpblxuICAgICAgICAgICAgaWYgKHN0aWxsTmVlZHNVbndpbmQocGFyYW1zKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bndpbmRSZWNvcmRzSWZOZWNlc3NhcnkocGFyYW1zLCBmaW5hbFBhc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUnVuIGEgZmluYWwgdGltZSBpbiBjYXNlIHRoZSBlYXJsaWVyIHVud2luZGluZyBleHBvc2VkIGFkZGl0aW9uYWxcbiAgICAgICAgICAgIC8vIGFycmF5cyB0byB1bndpbmQuLi5cbiAgICAgICAgICAgIGlmICghZmluYWxQYXNzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVud2luZFJlY29yZHNJZk5lY2Vzc2FyeShwYXJhbXMsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYga2V5cyB3ZXJlIHByb3ZpZGVkLCBzZXQgdGhlIGhlYWRlckZpZWxkcyBiYWNrIHRvIHRoZSBwcm92aWRlZCBrZXlzIGFmdGVyIHVud2luZGluZzpcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmtleXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1c2VyU2VsZWN0ZWRGaWVsZHMgPSBjb252ZXJ0S2V5c1RvSGVhZGVyRmllbGRzKCk7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmhlYWRlckZpZWxkcyA9IGZpbHRlckV4Y2x1ZGVkS2V5cyh1c2VyU2VsZWN0ZWRGaWVsZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWluIGZ1bmN0aW9uIHdoaWNoIGhhbmRsZXMgdGhlIHByb2Nlc3Npbmcgb2YgYSByZWNvcmQsIG9yIGRvY3VtZW50IHRvIGJlIGNvbnZlcnRlZCB0byBDU1YgZm9ybWF0XG4gICAgICogVGhpcyBmdW5jdGlvbiBzcGVjaWZpZXMgYW5kIHBlcmZvcm1zIHRoZSBuZWNlc3Nhcnkgb3BlcmF0aW9ucyBpbiB0aGUgbmVjZXNzYXJ5IG9yZGVyXG4gICAgICogaW4gb3JkZXIgdG8gb2J0YWluIHRoZSBkYXRhIGFuZCBjb252ZXJ0IGl0IHRvIENTViBmb3JtIHdoaWxlIG1haW50YWluaW5nIFJGQyA0MTgwIGNvbXBsaWFuY2UuXG4gICAgICogKiBPcmRlciBvZiBvcGVyYXRpb25zOlxuICAgICAqIC0gR2V0IGZpZWxkcyBmcm9tIHByb3ZpZGVkIGtleSBsaXN0IChhcyBhcnJheSBvZiBhY3R1YWwgdmFsdWVzKVxuICAgICAqIC0gQ29udmVydCB0aGUgdmFsdWVzIHRvIGNzdi9zdHJpbmcgcmVwcmVzZW50YXRpb24gW3Bvc3NpYmxlIG9wdGlvbiBoZXJlIGZvciBjdXN0b20gY29udmVydGVycz9dXG4gICAgICogLSBUcmltIGZpZWxkc1xuICAgICAqIC0gRGV0ZXJtaW5lIGlmIHRoZXkgbmVlZCB0byBiZSB3cmFwcGVkICgmIHdyYXAgaWYgbmVjZXNzYXJ5KVxuICAgICAqIC0gQ29tYmluZSB2YWx1ZXMgZm9yIGVhY2ggbGluZSAoYnkgam9pbmluZyBieSBmaWVsZCBkZWxpbWl0ZXIpXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1JlY29yZHMocGFyYW1zKSB7XG4gICAgICAgIHBhcmFtcy5yZWNvcmRTdHJpbmcgPSBwYXJhbXMucmVjb3Jkcy5tYXAoKHJlY29yZCkgPT4ge1xuICAgICAgICAgICAgLy8gUmV0cmlldmUgZGF0YSBmb3IgZWFjaCBvZiB0aGUgaGVhZGVyRmllbGRzIGZyb20gdGhpcyByZWNvcmRcbiAgICAgICAgICAgIGNvbnN0IHJlY29yZEZpZWxkRGF0YSA9IHJldHJpZXZlUmVjb3JkRmllbGREYXRhKHJlY29yZCwgcGFyYW1zLmhlYWRlckZpZWxkcyksIFxuICAgICAgICAgICAgLy8gUHJvY2VzcyB0aGUgZGF0YSBpbiB0aGlzIHJlY29yZCBhbmQgcmV0dXJuIHRoZVxuICAgICAgICAgICAgcHJvY2Vzc2VkUmVjb3JkRGF0YSA9IHJlY29yZEZpZWxkRGF0YS5tYXAoKGZpZWxkVmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBmaWVsZFZhbHVlID0gdHJpbVJlY29yZEZpZWxkVmFsdWUoZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgZmllbGRWYWx1ZSA9IHByZXZlbnRDc3ZJbmplY3Rpb24oZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgbGV0IHN0cmluZ2lmaWVkID0gY3VzdG9tVmFsdWVQYXJzZXIgPyBjdXN0b21WYWx1ZVBhcnNlcihmaWVsZFZhbHVlLCByZWNvcmRGaWVsZFZhbHVlVG9TdHJpbmcpIDogcmVjb3JkRmllbGRWYWx1ZVRvU3RyaW5nKGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgICAgIHN0cmluZ2lmaWVkID0gd3JhcEZpZWxkVmFsdWVJZk5lY2Vzc2FyeShzdHJpbmdpZmllZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmaWVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBKb2luIHRoZSByZWNvcmQgZGF0YSBieSB0aGUgZmllbGQgZGVsaW1pdGVyXG4gICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVDc3ZSb3dGcm9tUmVjb3JkKHByb2Nlc3NlZFJlY29yZERhdGEpO1xuICAgICAgICB9KS5qb2luKG9wdGlvbnMuZGVsaW1pdGVyLmVvbCk7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiBpbnRlbmRlZCB0byBwcm9jZXNzICpqdXN0KiBhcnJheSB2YWx1ZXMgd2hlbiB0aGUgZXhwYW5kQXJyYXlPYmplY3RzIHNldHRpbmcgaXMgc2V0IHRvIHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9jZXNzUmVjb3JkRmllbGREYXRhRm9yRXhwYW5kZWRBcnJheU9iamVjdChyZWNvcmRGaWVsZFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkUmVjb3JkRmllbGRWYWx1ZSA9IHV0aWxzLnJlbW92ZUVtcHR5RmllbGRzKHJlY29yZEZpZWxkVmFsdWUpO1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIGFuIGFycmF5IGFuZCBpdCdzIGVpdGhlciBlbXB0eSBvZiBmdWxsIG9mIGVtcHR5IHZhbHVlcywgdGhlbiB1c2UgYW4gZW1wdHkgdmFsdWUgcmVwcmVzZW50YXRpb25cbiAgICAgICAgaWYgKCFyZWNvcmRGaWVsZFZhbHVlLmxlbmd0aCB8fCAhZmlsdGVyZWRSZWNvcmRGaWVsZFZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZW1wdHlGaWVsZFZhbHVlIHx8ICcnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpbHRlcmVkUmVjb3JkRmllbGRWYWx1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2UgaGF2ZSBhbiBhcnJheSBvZiBhY3R1YWwgdmFsdWVzLi4uXG4gICAgICAgICAgICAvLyBTaW5jZSB3ZSBhcmUgZXhwYW5kaW5nIGFycmF5IG9iamVjdHMsIHdlIHdpbGwgd2FudCB0byBrZXkgaW4gb24gdmFsdWVzIG9mIG9iamVjdHMuXG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyZWRSZWNvcmRGaWVsZFZhbHVlWzBdOyAvLyBFeHRyYWN0IHRoZSBzaW5nbGUgdmFsdWUgaW4gdGhlIGFycmF5XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY29yZEZpZWxkVmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIGZpZWxkIHZhbHVlcyBmcm9tIGEgcGFydGljdWxhciByZWNvcmQgZm9yIHRoZSBnaXZlbiBsaXN0IG9mIGZpZWxkc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJldHJpZXZlUmVjb3JkRmllbGREYXRhKHJlY29yZCwgZmllbGRzKSB7XG4gICAgICAgIGNvbnN0IHJlY29yZFZhbHVlcyA9IFtdO1xuICAgICAgICBmaWVsZHMuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICAgICAgICAgIGxldCByZWNvcmRGaWVsZFZhbHVlID0gKDAsIGRvY19wYXRoXzEuZXZhbHVhdGVQYXRoKShyZWNvcmQsIGZpZWxkKTtcbiAgICAgICAgICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQob3B0aW9ucy5lbXB0eUZpZWxkVmFsdWUpICYmIHV0aWxzLmlzRW1wdHlGaWVsZChyZWNvcmRGaWVsZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJlY29yZEZpZWxkVmFsdWUgPSBvcHRpb25zLmVtcHR5RmllbGRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuZXhwYW5kQXJyYXlPYmplY3RzICYmIEFycmF5LmlzQXJyYXkocmVjb3JkRmllbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZWNvcmRGaWVsZFZhbHVlID0gcHJvY2Vzc1JlY29yZEZpZWxkRGF0YUZvckV4cGFuZGVkQXJyYXlPYmplY3QocmVjb3JkRmllbGRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWNvcmRWYWx1ZXMucHVzaChyZWNvcmRGaWVsZFZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZWNvcmRWYWx1ZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgcmVjb3JkIGZpZWxkIHZhbHVlIHRvIGl0cyBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWNvcmRGaWVsZFZhbHVlVG9TdHJpbmcoZmllbGRWYWx1ZSkge1xuICAgICAgICBjb25zdCBpc0RhdGUgPSBmaWVsZFZhbHVlIGluc3RhbmNlb2YgRGF0ZTsgLy8gc3RvcmUgdG8gYXZvaWQgY2hlY2tpbmcgdHdpY2VcbiAgICAgICAgaWYgKGZpZWxkVmFsdWUgPT09IG51bGwgfHwgQXJyYXkuaXNBcnJheShmaWVsZFZhbHVlKSB8fCB0eXBlb2YgZmllbGRWYWx1ZSA9PT0gJ29iamVjdCcgJiYgIWlzRGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGZpZWxkVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBmaWVsZFZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRGF0ZSAmJiBvcHRpb25zLnVzZURhdGVJc284NjAxRm9ybWF0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmllbGRWYWx1ZS50b0lTT1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICFvcHRpb25zLnVzZUxvY2FsZUZvcm1hdCA/IGZpZWxkVmFsdWUudG9TdHJpbmcoKSA6IGZpZWxkVmFsdWUudG9Mb2NhbGVTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmltcyB0aGUgcmVjb3JkIGZpZWxkIHZhbHVlLCBpZiBzcGVjaWZpZWQgYnkgdGhlIHVzZXIncyBwcm92aWRlZCBvcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbVJlY29yZEZpZWxkVmFsdWUoZmllbGRWYWx1ZSkge1xuICAgICAgICBpZiAob3B0aW9ucy50cmltRmllbGRWYWx1ZXMpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpZWxkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkVmFsdWUubWFwKHRyaW1SZWNvcmRGaWVsZFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBmaWVsZFZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZFZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaWVsZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWVsZFZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmV2ZW50IENTViBpbmplY3Rpb24gb24gc3RyaW5ncyBpZiBzcGVjaWZpZWQgYnkgdGhlIHVzZXIncyBwcm92aWRlZCBvcHRpb25zLlxuICAgICAqIE1pdGlnYXRpb24gd2lsbCBiZSBkb25lIGJ5IGVuc3VyaW5nIHRoYXQgdGhlIGZpcnN0IGNoYXJhY3RlciBkb2Vzbid0IGJlaW5nIHdpdGg6XG4gICAgICogRXF1YWxzICg9KSwgUGx1cyAoKyksIE1pbnVzICgtKSwgQXQgKEApLCBUYWIgKDB4MDkpLCBDYXJyaWFnZSByZXR1cm4gKDB4MEQpLlxuICAgICAqIE1vcmUgaW5mbzogaHR0cHM6Ly9vd2FzcC5vcmcvd3d3LWNvbW11bml0eS9hdHRhY2tzL0NTVl9JbmplY3Rpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcmV2ZW50Q3N2SW5qZWN0aW9uKGZpZWxkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMucHJldmVudENzdkluamVjdGlvbikge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmllbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmllbGRWYWx1ZS5tYXAocHJldmVudENzdkluamVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZmllbGRWYWx1ZSA9PT0gJ3N0cmluZycgJiYgIXV0aWxzLmlzTnVtYmVyKGZpZWxkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkVmFsdWUucmVwbGFjZSgvXls9K1xcLUBcXHRcXHJdKy9nLCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmllbGRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmllbGRWYWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXNjYXBlcyBxdW90YXRpb24gbWFya3MgaW4gdGhlIGZpZWxkIHZhbHVlLCBpZiBuZWNlc3NhcnksIGFuZCBhcHByb3ByaWF0ZWx5XG4gICAgICogd3JhcHMgdGhlIHJlY29yZCBmaWVsZCB2YWx1ZSBpZiBpdCBjb250YWlucyBhIGNvbW1hIChmaWVsZCBkZWxpbWl0ZXIpLFxuICAgICAqIHF1b3RhdGlvbiBtYXJrICh3cmFwIGRlbGltaXRlciksIG9yIGEgbGluZSBicmVhayAoQ1JMRilcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwRmllbGRWYWx1ZUlmTmVjZXNzYXJ5KGZpZWxkVmFsdWUpIHtcbiAgICAgICAgY29uc3Qgd3JhcERlbGltaXRlciA9IG9wdGlvbnMuZGVsaW1pdGVyLndyYXA7XG4gICAgICAgIC8vIGVnLiBpbmNsdWRlcyBxdW90YXRpb24gbWFya3MgKGRlZmF1bHQgZGVsaW1pdGVyKVxuICAgICAgICBpZiAoZmllbGRWYWx1ZS5pbmNsdWRlcyhvcHRpb25zLmRlbGltaXRlci53cmFwKSkge1xuICAgICAgICAgICAgLy8gYWRkIGFuIGFkZGl0aW9uYWwgcXVvdGF0aW9uIG1hcmsgYmVmb3JlIGVhY2ggcXVvdGF0aW9uIG1hcmsgYXBwZWFyaW5nIGluIHRoZSBmaWVsZCB2YWx1ZVxuICAgICAgICAgICAgZmllbGRWYWx1ZSA9IGZpZWxkVmFsdWUucmVwbGFjZSh3cmFwRGVsaW1pdGVyQ2hlY2tSZWdleCwgd3JhcERlbGltaXRlciArIHdyYXBEZWxpbWl0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSBmaWVsZCBjb250YWlucyBhIGNvbW1hIChmaWVsZCBkZWxpbWl0ZXIpLCBxdW90YXRpb24gbWFyayAod3JhcCBkZWxpbWl0ZXIpLCBsaW5lIGJyZWFrLCBvciBDUkxGXG4gICAgICAgIC8vICAgdGhlbiBlbmNsb3NlIGl0IGluIHF1b3RhdGlvbiBtYXJrcyAod3JhcCBkZWxpbWl0ZXIpXG4gICAgICAgIGlmIChmaWVsZFZhbHVlLmluY2x1ZGVzKG9wdGlvbnMuZGVsaW1pdGVyLmZpZWxkKSB8fFxuICAgICAgICAgICAgZmllbGRWYWx1ZS5pbmNsdWRlcyhvcHRpb25zLmRlbGltaXRlci53cmFwKSB8fFxuICAgICAgICAgICAgZmllbGRWYWx1ZS5tYXRjaChjcmxmU2VhcmNoUmVnZXgpIHx8XG4gICAgICAgICAgICBvcHRpb25zLndyYXBCb29sZWFucyAmJiAoZmllbGRWYWx1ZSA9PT0gJ3RydWUnIHx8IGZpZWxkVmFsdWUgPT09ICdmYWxzZScpKSB7XG4gICAgICAgICAgICAvLyB3cmFwIHRoZSBmaWVsZCdzIHZhbHVlIGluIGEgd3JhcCBkZWxpbWl0ZXIgKHF1b3RhdGlvbiBtYXJrcyBieSBkZWZhdWx0KVxuICAgICAgICAgICAgZmllbGRWYWx1ZSA9IHdyYXBEZWxpbWl0ZXIgKyBmaWVsZFZhbHVlICsgd3JhcERlbGltaXRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmllbGRWYWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIHRoZSBDU1YgcmVjb3JkIHN0cmluZyBieSBqb2luaW5nIHRoZSBmaWVsZCB2YWx1ZXMgdG9nZXRoZXIgYnkgdGhlIGZpZWxkIGRlbGltaXRlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdlbmVyYXRlQ3N2Um93RnJvbVJlY29yZChyZWNvcmRGaWVsZFZhbHVlcykge1xuICAgICAgICByZXR1cm4gcmVjb3JkRmllbGRWYWx1ZXMuam9pbihvcHRpb25zLmRlbGltaXRlci5maWVsZCk7XG4gICAgfVxuICAgIC8qKiBDU1YgQ09NUE9ORU5UIENPTUJJTkVSL0ZJTkFMIFBST0NFU1NPUiAqKi9cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyB0aGUgZmluYWwgQ1NWIGNvbnN0cnVjdGlvbiBieSBjb21iaW5pbmcgdGhlIGZpZWxkcyBpbiB0aGUgYXBwcm9wcmlhdGVcbiAgICAgKiBvcmRlciBkZXBlbmRpbmcgb24gdGhlIHByb3ZpZGVkIG9wdGlvbnMgdmFsdWVzIGFuZCBzZW5kcyB0aGUgZ2VuZXJhdGVkIENTVlxuICAgICAqIGJhY2sgdG8gdGhlIHVzZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUNzdkZyb21Db21wb25lbnRzKHBhcmFtcykge1xuICAgICAgICBjb25zdCBoZWFkZXIgPSBwYXJhbXMuaGVhZGVyLCByZWNvcmRzID0gcGFyYW1zLnJlY29yZFN0cmluZywgXG4gICAgICAgIC8vIElmIHdlIGFyZSBwcmVwZW5kaW5nIHRoZSBoZWFkZXIsIHRoZW4gYWRkIGFuIEVPTCwgb3RoZXJ3aXNlIGp1c3QgcmV0dXJuIHRoZSByZWNvcmRzXG4gICAgICAgIGNzdiA9IChvcHRpb25zLmV4Y2VsQk9NID8gY29uc3RhbnRzXzEuZXhjZWxCT00gOiAnJykgK1xuICAgICAgICAgICAgKG9wdGlvbnMucHJlcGVuZEhlYWRlciA/IGhlYWRlciArIG9wdGlvbnMuZGVsaW1pdGVyLmVvbCA6ICcnKSArXG4gICAgICAgICAgICByZWNvcmRzO1xuICAgICAgICByZXR1cm4gY3N2O1xuICAgIH1cbiAgICAvKiogTUFJTiBDT05WRVJURVIgRlVOQ1RJT04gKiovXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWxseSBleHBvcnRlZCBqc29uMmNzdiBmdW5jdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnZlcnQoZGF0YSkge1xuICAgICAgICAvLyBTaW5nbGUgZG9jdW1lbnQsIG5vdCBhbiBhcnJheVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgIGRhdGEgPSBbZGF0YV07IC8vIENvbnZlcnQgdG8gYW4gYXJyYXkgb2YgdGhlIGdpdmVuIGRvY3VtZW50XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0cmlldmUgdGhlIGhlYWRpbmcgYW5kIHRoZW4gZ2VuZXJhdGUgdGhlIENTViB3aXRoIHRoZSBrZXlzIHRoYXQgYXJlIGlkZW50aWZpZWRcbiAgICAgICAgY29uc3QgaGVhZGVyRmllbGRzID0ge1xuICAgICAgICAgICAgaGVhZGVyRmllbGRzOiByZXRyaWV2ZUhlYWRlckZpZWxkcyhkYXRhKSxcbiAgICAgICAgICAgIHJlY29yZHM6IGRhdGEsXG4gICAgICAgICAgICBoZWFkZXI6ICcnLFxuICAgICAgICAgICAgcmVjb3JkU3RyaW5nOiAnJyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdW53aW5kZWQgPSB1bndpbmRSZWNvcmRzSWZOZWNlc3NhcnkoaGVhZGVyRmllbGRzKTtcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0gcHJvY2Vzc1JlY29yZHModW53aW5kZWQpO1xuICAgICAgICBjb25zdCB3cmFwcGVkID0gd3JhcEhlYWRlckZpZWxkcyhwcm9jZXNzZWQpO1xuICAgICAgICBjb25zdCB0cmltbWVkID0gdHJpbUhlYWRlckZpZWxkcyh3cmFwcGVkKTtcbiAgICAgICAgY29uc3QgZ2VuZXJhdGVkID0gZ2VuZXJhdGVDc3ZIZWFkZXIodHJpbW1lZCk7XG4gICAgICAgIHJldHVybiBnZW5lcmF0ZUNzdkZyb21Db21wb25lbnRzKGdlbmVyYXRlZCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnZlcnQsXG4gICAgfTtcbn07XG5leHBvcnRzLkpzb24yQ3N2ID0gSnNvbjJDc3Y7XG4iXSwibmFtZXMiOlsiX19jcmVhdGVCaW5kaW5nIiwiT2JqZWN0IiwiY3JlYXRlIiwibyIsIm0iLCJrIiwiazIiLCJ1bmRlZmluZWQiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiX19lc01vZHVsZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImdldCIsImRlZmluZVByb3BlcnR5IiwiX19zZXRNb2R1bGVEZWZhdWx0IiwidiIsInZhbHVlIiwiX19pbXBvcnRTdGFyIiwibW9kIiwicmVzdWx0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiZXhwb3J0cyIsIkpzb24yQ3N2IiwiZG9jX3BhdGhfMSIsInJlcXVpcmUiLCJkZWVrc18xIiwiY29uc3RhbnRzXzEiLCJ1dGlscyIsIm9wdGlvbnMiLCJ3cmFwRGVsaW1pdGVyQ2hlY2tSZWdleCIsIlJlZ0V4cCIsImRlbGltaXRlciIsIndyYXAiLCJjcmxmU2VhcmNoUmVnZXgiLCJjdXN0b21WYWx1ZVBhcnNlciIsInBhcnNlVmFsdWUiLCJleHBhbmRpbmdXaXRob3V0VW53aW5kaW5nIiwiZXhwYW5kQXJyYXlPYmplY3RzIiwidW53aW5kQXJyYXlzIiwiZGVla3NPcHRpb25zIiwiYXJyYXlJbmRleGVzQXNLZXlzIiwiZXhwYW5kTmVzdGVkT2JqZWN0cyIsImlnbm9yZUVtcHR5QXJyYXlzV2hlbkV4cGFuZGluZyIsImVzY2FwZU5lc3RlZERvdHMiLCJnZXRGaWVsZE5hbWVMaXN0IiwiZGF0YSIsImRlZXBLZXlzRnJvbUxpc3QiLCJwcm9jZXNzU2NoZW1hcyIsImRvY3VtZW50U2NoZW1hcyIsImxlbmd0aCIsImNoZWNrU2NoZW1hRGlmZmVyZW5jZXMiLCJ1bmlxdWVGaWVsZE5hbWVzIiwidW5pcXVlIiwiZmxhdHRlbiIsImZpcnN0RG9jU2NoZW1hIiwicmVzdE9mRG9jdW1lbnRTY2hlbWFzIiwic2xpY2UiLCJzY2hlbWFEaWZmZXJlbmNlcyIsImNvbXB1dGVOdW1iZXJPZlNjaGVtYURpZmZlcmVuY2VzIiwiRXJyb3IiLCJlcnJvcnMiLCJqc29uMmNzdiIsIm5vdFNhbWVTY2hlbWEiLCJyZWR1Y2UiLCJkb2N1bWVudFNjaGVtYSIsIm51bWJlck9mRGlmZmVyZW5jZXMiLCJjb21wdXRlU2NoZW1hRGlmZmVyZW5jZXMiLCJmaWx0ZXJFeGNsdWRlZEtleXMiLCJrZXlQYXRocyIsImV4Y2x1ZGVLZXlzIiwiZmlsdGVyIiwia2V5UGF0aCIsImV4Y2x1ZGVkS2V5IiwicmVnZXgiLCJtYXRjaCIsInNvcnRIZWFkZXJGaWVsZHMiLCJmaWVsZE5hbWVzIiwic29ydEhlYWRlciIsInNvcnQiLCJ0cmltSGVhZGVyRmllbGRzIiwicGFyYW1zIiwiaGVhZGVyRmllbGRzIiwibWFwIiwiZmllbGQiLCJzcGxpdCIsImNvbXBvbmVudCIsInRyaW0iLCJqb2luIiwid3JhcEhlYWRlckZpZWxkcyIsInByZXBlbmRIZWFkZXIiLCJoZWFkaW5nS2V5Iiwid3JhcEZpZWxkVmFsdWVJZk5lY2Vzc2FyeSIsImdlbmVyYXRlQ3N2SGVhZGVyIiwiZmllbGRUaXRsZU1hcEtleXMiLCJrZXlzIiwiZmllbGRUaXRsZU1hcCIsImhlYWRlciIsImhlYWRlcktleSIsImluY2x1ZGVzIiwiZXNjYXBlSGVhZGVyTmVzdGVkRG90cyIsInJlcGxhY2UiLCJjb252ZXJ0S2V5c1RvSGVhZGVyRmllbGRzIiwia2V5IiwidGl0bGUiLCJleHRyYWN0V2lsZGNhcmRNYXRjaEtleXMiLCJmbGF0TWFwIiwiaXRlbSIsIndpbGRjYXJkTWF0Y2giLCJyZXRyaWV2ZUhlYWRlckZpZWxkcyIsIndpbGRjYXJkTWF0Y2hLZXlzIiwia2V5U3RyaW5ncyIsInByb2Nlc3NlZCIsIm1hdGNoZWRLZXlzIiwidXNlclByb3ZpZGVkS2V5IiwibWF0Y2hlcyIsImRldGVjdGVkS2V5IiwicHVzaCIsImZpbHRlcmVkIiwic3RpbGxOZWVkc1Vud2luZCIsInJlY29yZCIsInJlY29yZHMiLCJldmFsdWF0ZVBhdGgiLCJBcnJheSIsImlzQXJyYXkiLCJ1bndpbmRSZWNvcmRzSWZOZWNlc3NhcnkiLCJmaW5hbFBhc3MiLCJmb3JFYWNoIiwiaGVhZGVyRmllbGQiLCJ1bndpbmQiLCJ1c2VyU2VsZWN0ZWRGaWVsZHMiLCJwcm9jZXNzUmVjb3JkcyIsInJlY29yZFN0cmluZyIsInJlY29yZEZpZWxkRGF0YSIsInJldHJpZXZlUmVjb3JkRmllbGREYXRhIiwicHJvY2Vzc2VkUmVjb3JkRGF0YSIsImZpZWxkVmFsdWUiLCJ0cmltUmVjb3JkRmllbGRWYWx1ZSIsInByZXZlbnRDc3ZJbmplY3Rpb24iLCJzdHJpbmdpZmllZCIsInJlY29yZEZpZWxkVmFsdWVUb1N0cmluZyIsImdlbmVyYXRlQ3N2Um93RnJvbVJlY29yZCIsImVvbCIsInByb2Nlc3NSZWNvcmRGaWVsZERhdGFGb3JFeHBhbmRlZEFycmF5T2JqZWN0IiwicmVjb3JkRmllbGRWYWx1ZSIsImZpbHRlcmVkUmVjb3JkRmllbGRWYWx1ZSIsInJlbW92ZUVtcHR5RmllbGRzIiwiZW1wdHlGaWVsZFZhbHVlIiwiZmllbGRzIiwicmVjb3JkVmFsdWVzIiwiaXNVbmRlZmluZWQiLCJpc0VtcHR5RmllbGQiLCJpc0RhdGUiLCJEYXRlIiwiSlNPTiIsInN0cmluZ2lmeSIsInVzZURhdGVJc284NjAxRm9ybWF0IiwidG9JU09TdHJpbmciLCJ1c2VMb2NhbGVGb3JtYXQiLCJ0b1N0cmluZyIsInRvTG9jYWxlU3RyaW5nIiwidHJpbUZpZWxkVmFsdWVzIiwiaXNOdW1iZXIiLCJ3cmFwRGVsaW1pdGVyIiwid3JhcEJvb2xlYW5zIiwicmVjb3JkRmllbGRWYWx1ZXMiLCJnZW5lcmF0ZUNzdkZyb21Db21wb25lbnRzIiwiY3N2IiwiZXhjZWxCT00iLCJjb252ZXJ0IiwidW53aW5kZWQiLCJ3cmFwcGVkIiwidHJpbW1lZCIsImdlbmVyYXRlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/json-2-csv/lib/json2csv.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/json-2-csv/lib/utils.js":
/*!**********************************************!*\
  !*** ./node_modules/json-2-csv/lib/utils.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.isInvalid = exports.flatten = exports.unique = exports.arrayDifference = exports.isError = exports.isUndefined = exports.isNull = exports.isObject = exports.isString = exports.isNumber = exports.unwind = exports.getNCharacters = exports.removeEmptyFields = exports.isEmptyField = exports.computeSchemaDifferences = exports.isDateRepresentation = exports.isStringRepresentation = exports.deepCopy = exports.validate = exports.buildC2JOptions = exports.buildJ2COptions = void 0;\nconst doc_path_1 = __webpack_require__(/*! doc-path */ \"(ssr)/./node_modules/doc-path/lib/path.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/json-2-csv/lib/constants.js\");\nconst dateStringRegex = /\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}.\\d{3}Z/, MAX_ARRAY_LENGTH = 100000;\n/**\n * Build the options to be passed to the appropriate function\n * If a user does not provide custom options, then we use our default\n * If options are provided, then we set each valid key that was passed\n */ function buildJ2COptions(opts) {\n    return {\n        ...constants_1.defaultJson2CsvOptions,\n        ...opts,\n        delimiter: {\n            field: opts?.delimiter?.field ?? constants_1.defaultJson2CsvOptions.delimiter.field,\n            wrap: opts?.delimiter?.wrap || constants_1.defaultJson2CsvOptions.delimiter.wrap,\n            eol: opts?.delimiter?.eol || constants_1.defaultJson2CsvOptions.delimiter.eol\n        },\n        fieldTitleMap: Object.create({})\n    };\n}\nexports.buildJ2COptions = buildJ2COptions;\n/**\n * Build the options to be passed to the appropriate function\n * If a user does not provide custom options, then we use our default\n * If options are provided, then we set each valid key that was passed\n */ function buildC2JOptions(opts) {\n    return {\n        ...constants_1.defaultCsv2JsonOptions,\n        ...opts,\n        delimiter: {\n            field: opts?.delimiter?.field ?? constants_1.defaultCsv2JsonOptions.delimiter.field,\n            wrap: opts?.delimiter?.wrap || constants_1.defaultCsv2JsonOptions.delimiter.wrap,\n            eol: opts?.delimiter?.eol || constants_1.defaultCsv2JsonOptions.delimiter.eol\n        }\n    };\n}\nexports.buildC2JOptions = buildC2JOptions;\nfunction validate(data, validationFn, errorMessages) {\n    if (!data) throw new Error(`${errorMessages.cannotCallOn} ${data}.`);\n    if (!validationFn(data)) throw new Error(errorMessages.dataCheckFailure);\n    return true;\n}\nexports.validate = validate;\n/**\n * Utility function to deep copy an object, used by the module tests\n */ function deepCopy(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\nexports.deepCopy = deepCopy;\n/**\n * Helper function that determines whether the provided value is a representation\n *   of a string. Given the RFC4180 requirements, that means that the value is\n *   wrapped in value wrap delimiters (usually a quotation mark on each side).\n */ function isStringRepresentation(fieldValue, options) {\n    const firstChar = fieldValue[0], lastIndex = fieldValue.length - 1, lastChar = fieldValue[lastIndex];\n    // If the field starts and ends with a wrap delimiter\n    return firstChar === options.delimiter.wrap && lastChar === options.delimiter.wrap;\n}\nexports.isStringRepresentation = isStringRepresentation;\n/**\n * Helper function that determines whether the provided value is a representation\n *   of a date.\n */ function isDateRepresentation(fieldValue) {\n    return dateStringRegex.test(fieldValue);\n}\nexports.isDateRepresentation = isDateRepresentation;\n/**\n * Helper function that determines the schema differences between two objects.\n */ function computeSchemaDifferences(schemaA, schemaB) {\n    return arrayDifference(schemaA, schemaB).concat(arrayDifference(schemaB, schemaA));\n}\nexports.computeSchemaDifferences = computeSchemaDifferences;\n/**\n * Utility function to check if a field is considered empty so that the emptyFieldValue can be used instead\n */ function isEmptyField(fieldValue) {\n    return isUndefined(fieldValue) || isNull(fieldValue) || fieldValue === \"\";\n}\nexports.isEmptyField = isEmptyField;\n/**\n * Helper function that removes empty field values from an array.\n */ function removeEmptyFields(fields) {\n    return fields.filter((field)=>!isEmptyField(field));\n}\nexports.removeEmptyFields = removeEmptyFields;\n/**\n * Helper function that retrieves the next n characters from the start index in\n *   the string including the character at the start index. This is used to\n *   check if are currently at an EOL value, since it could be multiple\n *   characters in length (eg. '\\r\\n')\n */ function getNCharacters(str, start, n) {\n    return str.substring(start, start + n);\n}\nexports.getNCharacters = getNCharacters;\n/**\n * The following unwind functionality is a heavily modified version of @edwincen's\n * unwind extension for lodash. Since lodash is a large package to require in,\n * and all of the required functionality was already being imported, either\n * natively or with doc-path, I decided to rewrite the majority of the logic\n * so that an additional dependency would not be required. The original code\n * with the lodash dependency can be found here:\n *\n * https://github.com/edwincen/unwind/blob/master/index.js\n */ /**\n * Core function that unwinds an item at the provided path\n */ function unwindItem(accumulator, item, fieldPath) {\n    const valueToUnwind = (0, doc_path_1.evaluatePath)(item, fieldPath);\n    let cloned = deepCopy(item);\n    if (Array.isArray(valueToUnwind) && valueToUnwind.length) {\n        valueToUnwind.forEach((val)=>{\n            cloned = deepCopy(item);\n            accumulator.push((0, doc_path_1.setPath)(cloned, fieldPath, val));\n        });\n    } else if (Array.isArray(valueToUnwind) && valueToUnwind.length === 0) {\n        // Push an empty string so the value is empty since there are no values\n        (0, doc_path_1.setPath)(cloned, fieldPath, \"\");\n        accumulator.push(cloned);\n    } else {\n        accumulator.push(cloned);\n    }\n}\n/**\n * Main unwind function which takes an array and a field to unwind.\n */ function unwind(array, field) {\n    const result = [];\n    array.forEach((item)=>{\n        unwindItem(result, item, field);\n    });\n    return result;\n}\nexports.unwind = unwind;\n/**\n * Checks whether value can be converted to a number\n */ function isNumber(value) {\n    return !isNaN(Number(value));\n}\nexports.isNumber = isNumber;\n/*\n * Helper functions which were created to remove underscorejs from this package.\n */ function isString(value) {\n    return typeof value === \"string\";\n}\nexports.isString = isString;\nfunction isObject(value) {\n    return typeof value === \"object\";\n}\nexports.isObject = isObject;\nfunction isNull(value) {\n    return value === null;\n}\nexports.isNull = isNull;\nfunction isUndefined(value) {\n    return typeof value === \"undefined\";\n}\nexports.isUndefined = isUndefined;\nfunction isError(value) {\n    // TODO(mrodrig): test this possible change\n    // return value instanceof Error;\n    return Object.prototype.toString.call(value) === \"[object Error]\";\n}\nexports.isError = isError;\nfunction arrayDifference(a, b) {\n    return a.filter((x)=>!b.includes(x));\n}\nexports.arrayDifference = arrayDifference;\nfunction unique(array) {\n    return [\n        ...new Set(array)\n    ];\n}\nexports.unique = unique;\nfunction flatten(array) {\n    // Node 11+ - use the native array flattening function\n    if (array.flat) {\n        return array.flat();\n    }\n    // #167 - allow browsers to flatten very long 200k+ element arrays\n    if (array.length > MAX_ARRAY_LENGTH) {\n        let safeArray = [];\n        for(let a = 0; a < array.length; a += MAX_ARRAY_LENGTH){\n            safeArray = safeArray.concat(...array.slice(a, a + MAX_ARRAY_LENGTH));\n        }\n        return safeArray;\n    }\n    return array.reduce((accumulator, value)=>accumulator.concat(value), []);\n}\nexports.flatten = flatten;\n/**\n * Used to help avoid incorrect values returned by JSON.parse when converting\n * CSV back to JSON, such as '39e1804' which JSON.parse converts to Infinity\n */ function isInvalid(parsedJson) {\n    return parsedJson === Infinity || parsedJson === -Infinity;\n}\nexports.isInvalid = isInvalid;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbi0yLWNzdi9saWIvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQUEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGlCQUFpQixHQUFHQSxlQUFlLEdBQUdBLGNBQWMsR0FBR0EsdUJBQXVCLEdBQUdBLGVBQWUsR0FBR0EsbUJBQW1CLEdBQUdBLGNBQWMsR0FBR0EsZ0JBQWdCLEdBQUdBLGdCQUFnQixHQUFHQSxnQkFBZ0IsR0FBR0EsY0FBYyxHQUFHQSxzQkFBc0IsR0FBR0EseUJBQXlCLEdBQUdBLG9CQUFvQixHQUFHQSxnQ0FBZ0MsR0FBR0EsNEJBQTRCLEdBQUdBLDhCQUE4QixHQUFHQSxnQkFBZ0IsR0FBR0EsZ0JBQWdCLEdBQUdBLHVCQUF1QixHQUFHQSx1QkFBdUIsR0FBRyxLQUFLO0FBQ2xlLE1BQU11QixhQUFhQyxtQkFBT0EsQ0FBQywyREFBVTtBQUNyQyxNQUFNQyxjQUFjRCxtQkFBT0EsQ0FBQyxxRUFBYTtBQUN6QyxNQUFNRSxrQkFBa0IsOENBQThDQyxtQkFBbUI7QUFDekY7Ozs7Q0FJQyxHQUNELFNBQVNMLGdCQUFnQk0sSUFBSTtJQUN6QixPQUFPO1FBQ0gsR0FBR0gsWUFBWUksc0JBQXNCO1FBQ3JDLEdBQUdELElBQUk7UUFDUEUsV0FBVztZQUNQQyxPQUFPSCxNQUFNRSxXQUFXQyxTQUFTTixZQUFZSSxzQkFBc0IsQ0FBQ0MsU0FBUyxDQUFDQyxLQUFLO1lBQ25GQyxNQUFNSixNQUFNRSxXQUFXRSxRQUFRUCxZQUFZSSxzQkFBc0IsQ0FBQ0MsU0FBUyxDQUFDRSxJQUFJO1lBQ2hGQyxLQUFLTCxNQUFNRSxXQUFXRyxPQUFPUixZQUFZSSxzQkFBc0IsQ0FBQ0MsU0FBUyxDQUFDRyxHQUFHO1FBQ2pGO1FBQ0FDLGVBQWVwQyxPQUFPcUMsTUFBTSxDQUFDLENBQUM7SUFDbEM7QUFDSjtBQUNBbkMsdUJBQXVCLEdBQUdzQjtBQUMxQjs7OztDQUlDLEdBQ0QsU0FBU0Qs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Q0FBQyxFQUFFQyxDQUFDO0lBQ3pCLE9BQU9ELEVBQUV6QixNQUFNLENBQUMsQ0FBQzJCLElBQU0sQ0FBQ0QsRUFBRUUsUUFBUSxDQUFDRDtBQUN2QztBQUNBckYsdUJBQXVCLEdBQUdLO0FBQzFCLFNBQVNELE9BQU93RSxLQUFLO0lBQ2pCLE9BQU87V0FBSSxJQUFJVyxJQUFJWDtLQUFPO0FBQzlCO0FBQ0E1RSxjQUFjLEdBQUdJO0FBQ2pCLFNBQVNELFFBQVF5RSxLQUFLO0lBQ2xCLHNEQUFzRDtJQUN0RCxJQUFJQSxNQUFNWSxJQUFJLEVBQUU7UUFDWixPQUFPWixNQUFNWSxJQUFJO0lBQ3JCO0lBQ0Esa0VBQWtFO0lBQ2xFLElBQUlaLE1BQU16QixNQUFNLEdBQUd4QixrQkFBa0I7UUFDakMsSUFBSThELFlBQVksRUFBRTtRQUNsQixJQUFLLElBQUlOLElBQUksR0FBR0EsSUFBSVAsTUFBTXpCLE1BQU0sRUFBRWdDLEtBQUt4RCxpQkFBa0I7WUFDckQ4RCxZQUFZQSxVQUFVakMsTUFBTSxJQUFJb0IsTUFBTWMsS0FBSyxDQUFDUCxHQUFHQSxJQUFJeEQ7UUFDdkQ7UUFDQSxPQUFPOEQ7SUFDWDtJQUNBLE9BQU9iLE1BQU1lLE1BQU0sQ0FBQyxDQUFDM0IsYUFBYS9ELFFBQVUrRCxZQUFZUixNQUFNLENBQUN2RCxRQUFRLEVBQUU7QUFDN0U7QUFDQUQsZUFBZSxHQUFHRztBQUNsQjs7O0NBR0MsR0FDRCxTQUFTRCxVQUFVMEYsVUFBVTtJQUN6QixPQUFPQSxlQUFlQyxZQUNsQkQsZUFBZSxDQUFDQztBQUN4QjtBQUNBN0YsaUJBQWlCLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXJhLXBvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9qc29uLTItY3N2L2xpYi91dGlscy5qcz9hOTY4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNJbnZhbGlkID0gZXhwb3J0cy5mbGF0dGVuID0gZXhwb3J0cy51bmlxdWUgPSBleHBvcnRzLmFycmF5RGlmZmVyZW5jZSA9IGV4cG9ydHMuaXNFcnJvciA9IGV4cG9ydHMuaXNVbmRlZmluZWQgPSBleHBvcnRzLmlzTnVsbCA9IGV4cG9ydHMuaXNPYmplY3QgPSBleHBvcnRzLmlzU3RyaW5nID0gZXhwb3J0cy5pc051bWJlciA9IGV4cG9ydHMudW53aW5kID0gZXhwb3J0cy5nZXROQ2hhcmFjdGVycyA9IGV4cG9ydHMucmVtb3ZlRW1wdHlGaWVsZHMgPSBleHBvcnRzLmlzRW1wdHlGaWVsZCA9IGV4cG9ydHMuY29tcHV0ZVNjaGVtYURpZmZlcmVuY2VzID0gZXhwb3J0cy5pc0RhdGVSZXByZXNlbnRhdGlvbiA9IGV4cG9ydHMuaXNTdHJpbmdSZXByZXNlbnRhdGlvbiA9IGV4cG9ydHMuZGVlcENvcHkgPSBleHBvcnRzLnZhbGlkYXRlID0gZXhwb3J0cy5idWlsZEMySk9wdGlvbnMgPSBleHBvcnRzLmJ1aWxkSjJDT3B0aW9ucyA9IHZvaWQgMDtcbmNvbnN0IGRvY19wYXRoXzEgPSByZXF1aXJlKFwiZG9jLXBhdGhcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGRhdGVTdHJpbmdSZWdleCA9IC9cXGR7NH0tXFxkezJ9LVxcZHsyfVRcXGR7Mn06XFxkezJ9OlxcZHsyfS5cXGR7M31aLywgTUFYX0FSUkFZX0xFTkdUSCA9IDEwMDAwMDtcbi8qKlxuICogQnVpbGQgdGhlIG9wdGlvbnMgdG8gYmUgcGFzc2VkIHRvIHRoZSBhcHByb3ByaWF0ZSBmdW5jdGlvblxuICogSWYgYSB1c2VyIGRvZXMgbm90IHByb3ZpZGUgY3VzdG9tIG9wdGlvbnMsIHRoZW4gd2UgdXNlIG91ciBkZWZhdWx0XG4gKiBJZiBvcHRpb25zIGFyZSBwcm92aWRlZCwgdGhlbiB3ZSBzZXQgZWFjaCB2YWxpZCBrZXkgdGhhdCB3YXMgcGFzc2VkXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkSjJDT3B0aW9ucyhvcHRzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uY29uc3RhbnRzXzEuZGVmYXVsdEpzb24yQ3N2T3B0aW9ucyxcbiAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgZGVsaW1pdGVyOiB7XG4gICAgICAgICAgICBmaWVsZDogb3B0cz8uZGVsaW1pdGVyPy5maWVsZCA/PyBjb25zdGFudHNfMS5kZWZhdWx0SnNvbjJDc3ZPcHRpb25zLmRlbGltaXRlci5maWVsZCxcbiAgICAgICAgICAgIHdyYXA6IG9wdHM/LmRlbGltaXRlcj8ud3JhcCB8fCBjb25zdGFudHNfMS5kZWZhdWx0SnNvbjJDc3ZPcHRpb25zLmRlbGltaXRlci53cmFwLFxuICAgICAgICAgICAgZW9sOiBvcHRzPy5kZWxpbWl0ZXI/LmVvbCB8fCBjb25zdGFudHNfMS5kZWZhdWx0SnNvbjJDc3ZPcHRpb25zLmRlbGltaXRlci5lb2wsXG4gICAgICAgIH0sXG4gICAgICAgIGZpZWxkVGl0bGVNYXA6IE9iamVjdC5jcmVhdGUoe30pLFxuICAgIH07XG59XG5leHBvcnRzLmJ1aWxkSjJDT3B0aW9ucyA9IGJ1aWxkSjJDT3B0aW9ucztcbi8qKlxuICogQnVpbGQgdGhlIG9wdGlvbnMgdG8gYmUgcGFzc2VkIHRvIHRoZSBhcHByb3ByaWF0ZSBmdW5jdGlvblxuICogSWYgYSB1c2VyIGRvZXMgbm90IHByb3ZpZGUgY3VzdG9tIG9wdGlvbnMsIHRoZW4gd2UgdXNlIG91ciBkZWZhdWx0XG4gKiBJZiBvcHRpb25zIGFyZSBwcm92aWRlZCwgdGhlbiB3ZSBzZXQgZWFjaCB2YWxpZCBrZXkgdGhhdCB3YXMgcGFzc2VkXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkQzJKT3B0aW9ucyhvcHRzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uY29uc3RhbnRzXzEuZGVmYXVsdENzdjJKc29uT3B0aW9ucyxcbiAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgZGVsaW1pdGVyOiB7XG4gICAgICAgICAgICBmaWVsZDogb3B0cz8uZGVsaW1pdGVyPy5maWVsZCA/PyBjb25zdGFudHNfMS5kZWZhdWx0Q3N2Mkpzb25PcHRpb25zLmRlbGltaXRlci5maWVsZCxcbiAgICAgICAgICAgIHdyYXA6IG9wdHM/LmRlbGltaXRlcj8ud3JhcCB8fCBjb25zdGFudHNfMS5kZWZhdWx0Q3N2Mkpzb25PcHRpb25zLmRlbGltaXRlci53cmFwLFxuICAgICAgICAgICAgZW9sOiBvcHRzPy5kZWxpbWl0ZXI/LmVvbCB8fCBjb25zdGFudHNfMS5kZWZhdWx0Q3N2Mkpzb25PcHRpb25zLmRlbGltaXRlci5lb2wsXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydHMuYnVpbGRDMkpPcHRpb25zID0gYnVpbGRDMkpPcHRpb25zO1xuZnVuY3Rpb24gdmFsaWRhdGUoZGF0YSwgdmFsaWRhdGlvbkZuLCBlcnJvck1lc3NhZ2VzKSB7XG4gICAgaWYgKCFkYXRhKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZXJyb3JNZXNzYWdlcy5jYW5ub3RDYWxsT259ICR7ZGF0YX0uYCk7XG4gICAgaWYgKCF2YWxpZGF0aW9uRm4oZGF0YSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2VzLmRhdGFDaGVja0ZhaWx1cmUpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy52YWxpZGF0ZSA9IHZhbGlkYXRlO1xuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGRlZXAgY29weSBhbiBvYmplY3QsIHVzZWQgYnkgdGhlIG1vZHVsZSB0ZXN0c1xuICovXG5mdW5jdGlvbiBkZWVwQ29weShvYmopIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbn1cbmV4cG9ydHMuZGVlcENvcHkgPSBkZWVwQ29weTtcbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwcm92aWRlZCB2YWx1ZSBpcyBhIHJlcHJlc2VudGF0aW9uXG4gKiAgIG9mIGEgc3RyaW5nLiBHaXZlbiB0aGUgUkZDNDE4MCByZXF1aXJlbWVudHMsIHRoYXQgbWVhbnMgdGhhdCB0aGUgdmFsdWUgaXNcbiAqICAgd3JhcHBlZCBpbiB2YWx1ZSB3cmFwIGRlbGltaXRlcnMgKHVzdWFsbHkgYSBxdW90YXRpb24gbWFyayBvbiBlYWNoIHNpZGUpLlxuICovXG5mdW5jdGlvbiBpc1N0cmluZ1JlcHJlc2VudGF0aW9uKGZpZWxkVmFsdWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBmaXJzdENoYXIgPSBmaWVsZFZhbHVlWzBdLCBsYXN0SW5kZXggPSBmaWVsZFZhbHVlLmxlbmd0aCAtIDEsIGxhc3RDaGFyID0gZmllbGRWYWx1ZVtsYXN0SW5kZXhdO1xuICAgIC8vIElmIHRoZSBmaWVsZCBzdGFydHMgYW5kIGVuZHMgd2l0aCBhIHdyYXAgZGVsaW1pdGVyXG4gICAgcmV0dXJuIGZpcnN0Q2hhciA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIud3JhcCAmJiBsYXN0Q2hhciA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIud3JhcDtcbn1cbmV4cG9ydHMuaXNTdHJpbmdSZXByZXNlbnRhdGlvbiA9IGlzU3RyaW5nUmVwcmVzZW50YXRpb247XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgcHJvdmlkZWQgdmFsdWUgaXMgYSByZXByZXNlbnRhdGlvblxuICogICBvZiBhIGRhdGUuXG4gKi9cbmZ1bmN0aW9uIGlzRGF0ZVJlcHJlc2VudGF0aW9uKGZpZWxkVmFsdWUpIHtcbiAgICByZXR1cm4gZGF0ZVN0cmluZ1JlZ2V4LnRlc3QoZmllbGRWYWx1ZSk7XG59XG5leHBvcnRzLmlzRGF0ZVJlcHJlc2VudGF0aW9uID0gaXNEYXRlUmVwcmVzZW50YXRpb247XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgdGhlIHNjaGVtYSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHR3byBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBjb21wdXRlU2NoZW1hRGlmZmVyZW5jZXMoc2NoZW1hQSwgc2NoZW1hQikge1xuICAgIHJldHVybiBhcnJheURpZmZlcmVuY2Uoc2NoZW1hQSwgc2NoZW1hQilcbiAgICAgICAgLmNvbmNhdChhcnJheURpZmZlcmVuY2Uoc2NoZW1hQiwgc2NoZW1hQSkpO1xufVxuZXhwb3J0cy5jb21wdXRlU2NoZW1hRGlmZmVyZW5jZXMgPSBjb21wdXRlU2NoZW1hRGlmZmVyZW5jZXM7XG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gY2hlY2sgaWYgYSBmaWVsZCBpcyBjb25zaWRlcmVkIGVtcHR5IHNvIHRoYXQgdGhlIGVtcHR5RmllbGRWYWx1ZSBjYW4gYmUgdXNlZCBpbnN0ZWFkXG4gKi9cbmZ1bmN0aW9uIGlzRW1wdHlGaWVsZChmaWVsZFZhbHVlKSB7XG4gICAgcmV0dXJuIGlzVW5kZWZpbmVkKGZpZWxkVmFsdWUpIHx8IGlzTnVsbChmaWVsZFZhbHVlKSB8fCBmaWVsZFZhbHVlID09PSAnJztcbn1cbmV4cG9ydHMuaXNFbXB0eUZpZWxkID0gaXNFbXB0eUZpZWxkO1xuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCByZW1vdmVzIGVtcHR5IGZpZWxkIHZhbHVlcyBmcm9tIGFuIGFycmF5LlxuICovXG5mdW5jdGlvbiByZW1vdmVFbXB0eUZpZWxkcyhmaWVsZHMpIHtcbiAgICByZXR1cm4gZmllbGRzLmZpbHRlcigoZmllbGQpID0+ICFpc0VtcHR5RmllbGQoZmllbGQpKTtcbn1cbmV4cG9ydHMucmVtb3ZlRW1wdHlGaWVsZHMgPSByZW1vdmVFbXB0eUZpZWxkcztcbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgcmV0cmlldmVzIHRoZSBuZXh0IG4gY2hhcmFjdGVycyBmcm9tIHRoZSBzdGFydCBpbmRleCBpblxuICogICB0aGUgc3RyaW5nIGluY2x1ZGluZyB0aGUgY2hhcmFjdGVyIGF0IHRoZSBzdGFydCBpbmRleC4gVGhpcyBpcyB1c2VkIHRvXG4gKiAgIGNoZWNrIGlmIGFyZSBjdXJyZW50bHkgYXQgYW4gRU9MIHZhbHVlLCBzaW5jZSBpdCBjb3VsZCBiZSBtdWx0aXBsZVxuICogICBjaGFyYWN0ZXJzIGluIGxlbmd0aCAoZWcuICdcXHJcXG4nKVxuICovXG5mdW5jdGlvbiBnZXROQ2hhcmFjdGVycyhzdHIsIHN0YXJ0LCBuKSB7XG4gICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoc3RhcnQsIHN0YXJ0ICsgbik7XG59XG5leHBvcnRzLmdldE5DaGFyYWN0ZXJzID0gZ2V0TkNoYXJhY3RlcnM7XG4vKipcbiAqIFRoZSBmb2xsb3dpbmcgdW53aW5kIGZ1bmN0aW9uYWxpdHkgaXMgYSBoZWF2aWx5IG1vZGlmaWVkIHZlcnNpb24gb2YgQGVkd2luY2VuJ3NcbiAqIHVud2luZCBleHRlbnNpb24gZm9yIGxvZGFzaC4gU2luY2UgbG9kYXNoIGlzIGEgbGFyZ2UgcGFja2FnZSB0byByZXF1aXJlIGluLFxuICogYW5kIGFsbCBvZiB0aGUgcmVxdWlyZWQgZnVuY3Rpb25hbGl0eSB3YXMgYWxyZWFkeSBiZWluZyBpbXBvcnRlZCwgZWl0aGVyXG4gKiBuYXRpdmVseSBvciB3aXRoIGRvYy1wYXRoLCBJIGRlY2lkZWQgdG8gcmV3cml0ZSB0aGUgbWFqb3JpdHkgb2YgdGhlIGxvZ2ljXG4gKiBzbyB0aGF0IGFuIGFkZGl0aW9uYWwgZGVwZW5kZW5jeSB3b3VsZCBub3QgYmUgcmVxdWlyZWQuIFRoZSBvcmlnaW5hbCBjb2RlXG4gKiB3aXRoIHRoZSBsb2Rhc2ggZGVwZW5kZW5jeSBjYW4gYmUgZm91bmQgaGVyZTpcbiAqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZWR3aW5jZW4vdW53aW5kL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4gKi9cbi8qKlxuICogQ29yZSBmdW5jdGlvbiB0aGF0IHVud2luZHMgYW4gaXRlbSBhdCB0aGUgcHJvdmlkZWQgcGF0aFxuICovXG5mdW5jdGlvbiB1bndpbmRJdGVtKGFjY3VtdWxhdG9yLCBpdGVtLCBmaWVsZFBhdGgpIHtcbiAgICBjb25zdCB2YWx1ZVRvVW53aW5kID0gKDAsIGRvY19wYXRoXzEuZXZhbHVhdGVQYXRoKShpdGVtLCBmaWVsZFBhdGgpO1xuICAgIGxldCBjbG9uZWQgPSBkZWVwQ29weShpdGVtKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZVRvVW53aW5kKSAmJiB2YWx1ZVRvVW53aW5kLmxlbmd0aCkge1xuICAgICAgICB2YWx1ZVRvVW53aW5kLmZvckVhY2goKHZhbCkgPT4ge1xuICAgICAgICAgICAgY2xvbmVkID0gZGVlcENvcHkoaXRlbSk7XG4gICAgICAgICAgICBhY2N1bXVsYXRvci5wdXNoKCgwLCBkb2NfcGF0aF8xLnNldFBhdGgpKGNsb25lZCwgZmllbGRQYXRoLCB2YWwpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVUb1Vud2luZCkgJiYgdmFsdWVUb1Vud2luZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gUHVzaCBhbiBlbXB0eSBzdHJpbmcgc28gdGhlIHZhbHVlIGlzIGVtcHR5IHNpbmNlIHRoZXJlIGFyZSBubyB2YWx1ZXNcbiAgICAgICAgKDAsIGRvY19wYXRoXzEuc2V0UGF0aCkoY2xvbmVkLCBmaWVsZFBhdGgsICcnKTtcbiAgICAgICAgYWNjdW11bGF0b3IucHVzaChjbG9uZWQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYWNjdW11bGF0b3IucHVzaChjbG9uZWQpO1xuICAgIH1cbn1cbi8qKlxuICogTWFpbiB1bndpbmQgZnVuY3Rpb24gd2hpY2ggdGFrZXMgYW4gYXJyYXkgYW5kIGEgZmllbGQgdG8gdW53aW5kLlxuICovXG5mdW5jdGlvbiB1bndpbmQoYXJyYXksIGZpZWxkKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgYXJyYXkuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICB1bndpbmRJdGVtKHJlc3VsdCwgaXRlbSwgZmllbGQpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnVud2luZCA9IHVud2luZDtcbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdmFsdWUgY2FuIGJlIGNvbnZlcnRlZCB0byBhIG51bWJlclxuICovXG5mdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiAhaXNOYU4oTnVtYmVyKHZhbHVlKSk7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG4vKlxuICogSGVscGVyIGZ1bmN0aW9ucyB3aGljaCB3ZXJlIGNyZWF0ZWQgdG8gcmVtb3ZlIHVuZGVyc2NvcmVqcyBmcm9tIHRoaXMgcGFja2FnZS5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCc7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5mdW5jdGlvbiBpc051bGwodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5mdW5jdGlvbiBpc0Vycm9yKHZhbHVlKSB7XG4gICAgLy8gVE9ETyhtcm9kcmlnKTogdGVzdCB0aGlzIHBvc3NpYmxlIGNoYW5nZVxuICAgIC8vIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEVycm9yO1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBFcnJvcl0nO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcbmZ1bmN0aW9uIGFycmF5RGlmZmVyZW5jZShhLCBiKSB7XG4gICAgcmV0dXJuIGEuZmlsdGVyKCh4KSA9PiAhYi5pbmNsdWRlcyh4KSk7XG59XG5leHBvcnRzLmFycmF5RGlmZmVyZW5jZSA9IGFycmF5RGlmZmVyZW5jZTtcbmZ1bmN0aW9uIHVuaXF1ZShhcnJheSkge1xuICAgIHJldHVybiBbLi4ubmV3IFNldChhcnJheSldO1xufVxuZXhwb3J0cy51bmlxdWUgPSB1bmlxdWU7XG5mdW5jdGlvbiBmbGF0dGVuKGFycmF5KSB7XG4gICAgLy8gTm9kZSAxMSsgLSB1c2UgdGhlIG5hdGl2ZSBhcnJheSBmbGF0dGVuaW5nIGZ1bmN0aW9uXG4gICAgaWYgKGFycmF5LmZsYXQpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5LmZsYXQoKTtcbiAgICB9XG4gICAgLy8gIzE2NyAtIGFsbG93IGJyb3dzZXJzIHRvIGZsYXR0ZW4gdmVyeSBsb25nIDIwMGsrIGVsZW1lbnQgYXJyYXlzXG4gICAgaWYgKGFycmF5Lmxlbmd0aCA+IE1BWF9BUlJBWV9MRU5HVEgpIHtcbiAgICAgICAgbGV0IHNhZmVBcnJheSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBhID0gMDsgYSA8IGFycmF5Lmxlbmd0aDsgYSArPSBNQVhfQVJSQVlfTEVOR1RIKSB7XG4gICAgICAgICAgICBzYWZlQXJyYXkgPSBzYWZlQXJyYXkuY29uY2F0KC4uLmFycmF5LnNsaWNlKGEsIGEgKyBNQVhfQVJSQVlfTEVOR1RIKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNhZmVBcnJheTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5LnJlZHVjZSgoYWNjdW11bGF0b3IsIHZhbHVlKSA9PiBhY2N1bXVsYXRvci5jb25jYXQodmFsdWUpLCBbXSk7XG59XG5leHBvcnRzLmZsYXR0ZW4gPSBmbGF0dGVuO1xuLyoqXG4gKiBVc2VkIHRvIGhlbHAgYXZvaWQgaW5jb3JyZWN0IHZhbHVlcyByZXR1cm5lZCBieSBKU09OLnBhcnNlIHdoZW4gY29udmVydGluZ1xuICogQ1NWIGJhY2sgdG8gSlNPTiwgc3VjaCBhcyAnMzllMTgwNCcgd2hpY2ggSlNPTi5wYXJzZSBjb252ZXJ0cyB0byBJbmZpbml0eVxuICovXG5mdW5jdGlvbiBpc0ludmFsaWQocGFyc2VkSnNvbikge1xuICAgIHJldHVybiBwYXJzZWRKc29uID09PSBJbmZpbml0eSB8fFxuICAgICAgICBwYXJzZWRKc29uID09PSAtSW5maW5pdHk7XG59XG5leHBvcnRzLmlzSW52YWxpZCA9IGlzSW52YWxpZDtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImlzSW52YWxpZCIsImZsYXR0ZW4iLCJ1bmlxdWUiLCJhcnJheURpZmZlcmVuY2UiLCJpc0Vycm9yIiwiaXNVbmRlZmluZWQiLCJpc051bGwiLCJpc09iamVjdCIsImlzU3RyaW5nIiwiaXNOdW1iZXIiLCJ1bndpbmQiLCJnZXROQ2hhcmFjdGVycyIsInJlbW92ZUVtcHR5RmllbGRzIiwiaXNFbXB0eUZpZWxkIiwiY29tcHV0ZVNjaGVtYURpZmZlcmVuY2VzIiwiaXNEYXRlUmVwcmVzZW50YXRpb24iLCJpc1N0cmluZ1JlcHJlc2VudGF0aW9uIiwiZGVlcENvcHkiLCJ2YWxpZGF0ZSIsImJ1aWxkQzJKT3B0aW9ucyIsImJ1aWxkSjJDT3B0aW9ucyIsImRvY19wYXRoXzEiLCJyZXF1aXJlIiwiY29uc3RhbnRzXzEiLCJkYXRlU3RyaW5nUmVnZXgiLCJNQVhfQVJSQVlfTEVOR1RIIiwib3B0cyIsImRlZmF1bHRKc29uMkNzdk9wdGlvbnMiLCJkZWxpbWl0ZXIiLCJmaWVsZCIsIndyYXAiLCJlb2wiLCJmaWVsZFRpdGxlTWFwIiwiY3JlYXRlIiwiZGVmYXVsdENzdjJKc29uT3B0aW9ucyIsImRhdGEiLCJ2YWxpZGF0aW9uRm4iLCJlcnJvck1lc3NhZ2VzIiwiRXJyb3IiLCJjYW5ub3RDYWxsT24iLCJkYXRhQ2hlY2tGYWlsdXJlIiwib2JqIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwiZmllbGRWYWx1ZSIsIm9wdGlvbnMiLCJmaXJzdENoYXIiLCJsYXN0SW5kZXgiLCJsZW5ndGgiLCJsYXN0Q2hhciIsInRlc3QiLCJzY2hlbWFBIiwic2NoZW1hQiIsImNvbmNhdCIsImZpZWxkcyIsImZpbHRlciIsInN0ciIsInN0YXJ0IiwibiIsInN1YnN0cmluZyIsInVud2luZEl0ZW0iLCJhY2N1bXVsYXRvciIsIml0ZW0iLCJmaWVsZFBhdGgiLCJ2YWx1ZVRvVW53aW5kIiwiZXZhbHVhdGVQYXRoIiwiY2xvbmVkIiwiQXJyYXkiLCJpc0FycmF5IiwiZm9yRWFjaCIsInZhbCIsInB1c2giLCJzZXRQYXRoIiwiYXJyYXkiLCJyZXN1bHQiLCJpc05hTiIsIk51bWJlciIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsImEiLCJiIiwieCIsImluY2x1ZGVzIiwiU2V0IiwiZmxhdCIsInNhZmVBcnJheSIsInNsaWNlIiwicmVkdWNlIiwicGFyc2VkSnNvbiIsIkluZmluaXR5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/json-2-csv/lib/utils.js\n");

/***/ })

};
;