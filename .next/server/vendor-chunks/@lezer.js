"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lezer";
exports.ids = ["vendor-chunks/@lezer"];
exports.modules = {

/***/ "(ssr)/./node_modules/@lezer/common/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@lezer/common/dist/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultBufferLength: () => (/* binding */ DefaultBufferLength),\n/* harmony export */   IterMode: () => (/* binding */ IterMode),\n/* harmony export */   MountedTree: () => (/* binding */ MountedTree),\n/* harmony export */   NodeProp: () => (/* binding */ NodeProp),\n/* harmony export */   NodeSet: () => (/* binding */ NodeSet),\n/* harmony export */   NodeType: () => (/* binding */ NodeType),\n/* harmony export */   NodeWeakMap: () => (/* binding */ NodeWeakMap),\n/* harmony export */   Parser: () => (/* binding */ Parser),\n/* harmony export */   Tree: () => (/* binding */ Tree),\n/* harmony export */   TreeBuffer: () => (/* binding */ TreeBuffer),\n/* harmony export */   TreeCursor: () => (/* binding */ TreeCursor),\n/* harmony export */   TreeFragment: () => (/* binding */ TreeFragment),\n/* harmony export */   parseMixed: () => (/* binding */ parseMixed)\n/* harmony export */ });\n/**\nThe default maximum length of a `TreeBuffer` node.\n*/ const DefaultBufferLength = 1024;\nlet nextPropID = 0;\nclass Range {\n    constructor(from, to){\n        this.from = from;\n        this.to = to;\n    }\n}\n/**\nEach [node type](#common.NodeType) or [individual tree](#common.Tree)\ncan have metadata associated with it in props. Instances of this\nclass represent prop names.\n*/ class NodeProp {\n    /**\n    Create a new node prop type.\n    */ constructor(config = {}){\n        this.id = nextPropID++;\n        this.perNode = !!config.perNode;\n        this.deserialize = config.deserialize || (()=>{\n            throw new Error(\"This node type doesn't define a deserialize function\");\n        });\n    }\n    /**\n    This is meant to be used with\n    [`NodeSet.extend`](#common.NodeSet.extend) or\n    [`LRParser.configure`](#lr.ParserConfig.props) to compute\n    prop values for each node type in the set. Takes a [match\n    object](#common.NodeType^match) or function that returns undefined\n    if the node type doesn't get this prop, and the prop's value if\n    it does.\n    */ add(match) {\n        if (this.perNode) throw new RangeError(\"Can't add per-node props to node types\");\n        if (typeof match != \"function\") match = NodeType.match(match);\n        return (type)=>{\n            let result = match(type);\n            return result === undefined ? null : [\n                this,\n                result\n            ];\n        };\n    }\n}\n/**\nProp that is used to describe matching delimiters. For opening\ndelimiters, this holds an array of node names (written as a\nspace-separated string when declaring this prop in a grammar)\nfor the node types of closing delimiters that match it.\n*/ NodeProp.closedBy = new NodeProp({\n    deserialize: (str)=>str.split(\" \")\n});\n/**\nThe inverse of [`closedBy`](#common.NodeProp^closedBy). This is\nattached to closing delimiters, holding an array of node names\nof types of matching opening delimiters.\n*/ NodeProp.openedBy = new NodeProp({\n    deserialize: (str)=>str.split(\" \")\n});\n/**\nUsed to assign node types to groups (for example, all node\ntypes that represent an expression could be tagged with an\n`\"Expression\"` group).\n*/ NodeProp.group = new NodeProp({\n    deserialize: (str)=>str.split(\" \")\n});\n/**\nAttached to nodes to indicate these should be\n[displayed](https://codemirror.net/docs/ref/#language.syntaxTree)\nin a bidirectional text isolate, so that direction-neutral\ncharacters on their sides don't incorrectly get associated with\nsurrounding text. You'll generally want to set this for nodes\nthat contain arbitrary text, like strings and comments, and for\nnodes that appear _inside_ arbitrary text, like HTML tags. When\nnot given a value, in a grammar declaration, defaults to\n`\"auto\"`.\n*/ NodeProp.isolate = new NodeProp({\n    deserialize: (value)=>{\n        if (value && value != \"rtl\" && value != \"ltr\" && value != \"auto\") throw new RangeError(\"Invalid value for isolate: \" + value);\n        return value || \"auto\";\n    }\n});\n/**\nThe hash of the [context](#lr.ContextTracker.constructor)\nthat the node was parsed in, if any. Used to limit reuse of\ncontextual nodes.\n*/ NodeProp.contextHash = new NodeProp({\n    perNode: true\n});\n/**\nThe distance beyond the end of the node that the tokenizer\nlooked ahead for any of the tokens inside the node. (The LR\nparser only stores this when it is larger than 25, for\nefficiency reasons.)\n*/ NodeProp.lookAhead = new NodeProp({\n    perNode: true\n});\n/**\nThis per-node prop is used to replace a given node, or part of a\nnode, with another tree. This is useful to include trees from\ndifferent languages in mixed-language parsers.\n*/ NodeProp.mounted = new NodeProp({\n    perNode: true\n});\n/**\nA mounted tree, which can be [stored](#common.NodeProp^mounted) on\na tree node to indicate that parts of its content are\nrepresented by another tree.\n*/ class MountedTree {\n    constructor(/**\n    The inner tree.\n    */ tree, /**\n    If this is null, this tree replaces the entire node (it will\n    be included in the regular iteration instead of its host\n    node). If not, only the given ranges are considered to be\n    covered by this tree. This is used for trees that are mixed in\n    a way that isn't strictly hierarchical. Such mounted trees are\n    only entered by [`resolveInner`](#common.Tree.resolveInner)\n    and [`enter`](#common.SyntaxNode.enter).\n    */ overlay, /**\n    The parser used to create this subtree.\n    */ parser){\n        this.tree = tree;\n        this.overlay = overlay;\n        this.parser = parser;\n    }\n    /**\n    @internal\n    */ static get(tree) {\n        return tree && tree.props && tree.props[NodeProp.mounted.id];\n    }\n}\nconst noProps = Object.create(null);\n/**\nEach node in a syntax tree has a node type associated with it.\n*/ class NodeType {\n    /**\n    @internal\n    */ constructor(/**\n    The name of the node type. Not necessarily unique, but if the\n    grammar was written properly, different node types with the\n    same name within a node set should play the same semantic\n    role.\n    */ name, /**\n    @internal\n    */ props, /**\n    The id of this node in its set. Corresponds to the term ids\n    used in the parser.\n    */ id, /**\n    @internal\n    */ flags = 0){\n        this.name = name;\n        this.props = props;\n        this.id = id;\n        this.flags = flags;\n    }\n    /**\n    Define a node type.\n    */ static define(spec) {\n        let props = spec.props && spec.props.length ? Object.create(null) : noProps;\n        let flags = (spec.top ? 1 /* NodeFlag.Top */  : 0) | (spec.skipped ? 2 /* NodeFlag.Skipped */  : 0) | (spec.error ? 4 /* NodeFlag.Error */  : 0) | (spec.name == null ? 8 /* NodeFlag.Anonymous */  : 0);\n        let type = new NodeType(spec.name || \"\", props, spec.id, flags);\n        if (spec.props) for (let src of spec.props){\n            if (!Array.isArray(src)) src = src(type);\n            if (src) {\n                if (src[0].perNode) throw new RangeError(\"Can't store a per-node prop on a node type\");\n                props[src[0].id] = src[1];\n            }\n        }\n        return type;\n    }\n    /**\n    Retrieves a node prop for this type. Will return `undefined` if\n    the prop isn't present on this node.\n    */ prop(prop) {\n        return this.props[prop.id];\n    }\n    /**\n    True when this is the top node of a grammar.\n    */ get isTop() {\n        return (this.flags & 1 /* NodeFlag.Top */ ) > 0;\n    }\n    /**\n    True when this node is produced by a skip rule.\n    */ get isSkipped() {\n        return (this.flags & 2 /* NodeFlag.Skipped */ ) > 0;\n    }\n    /**\n    Indicates whether this is an error node.\n    */ get isError() {\n        return (this.flags & 4 /* NodeFlag.Error */ ) > 0;\n    }\n    /**\n    When true, this node type doesn't correspond to a user-declared\n    named node, for example because it is used to cache repetition.\n    */ get isAnonymous() {\n        return (this.flags & 8 /* NodeFlag.Anonymous */ ) > 0;\n    }\n    /**\n    Returns true when this node's name or one of its\n    [groups](#common.NodeProp^group) matches the given string.\n    */ is(name) {\n        if (typeof name == \"string\") {\n            if (this.name == name) return true;\n            let group = this.prop(NodeProp.group);\n            return group ? group.indexOf(name) > -1 : false;\n        }\n        return this.id == name;\n    }\n    /**\n    Create a function from node types to arbitrary values by\n    specifying an object whose property names are node or\n    [group](#common.NodeProp^group) names. Often useful with\n    [`NodeProp.add`](#common.NodeProp.add). You can put multiple\n    names, separated by spaces, in a single property name to map\n    multiple node names to a single value.\n    */ static match(map) {\n        let direct = Object.create(null);\n        for(let prop in map)for (let name of prop.split(\" \"))direct[name] = map[prop];\n        return (node)=>{\n            for(let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++){\n                let found = direct[i < 0 ? node.name : groups[i]];\n                if (found) return found;\n            }\n        };\n    }\n}\n/**\nAn empty dummy node type to use when no actual type is available.\n*/ NodeType.none = new NodeType(\"\", Object.create(null), 0, 8 /* NodeFlag.Anonymous */ );\n/**\nA node set holds a collection of node types. It is used to\ncompactly represent trees by storing their type ids, rather than a\nfull pointer to the type object, in a numeric array. Each parser\n[has](#lr.LRParser.nodeSet) a node set, and [tree\nbuffers](#common.TreeBuffer) can only store collections of nodes\nfrom the same set. A set can have a maximum of 2**16 (65536) node\ntypes in it, so that the ids fit into 16-bit typed array slots.\n*/ class NodeSet {\n    /**\n    Create a set with the given types. The `id` property of each\n    type should correspond to its position within the array.\n    */ constructor(/**\n    The node types in this set, by id.\n    */ types){\n        this.types = types;\n        for(let i = 0; i < types.length; i++)if (types[i].id != i) throw new RangeError(\"Node type ids should correspond to array positions when creating a node set\");\n    }\n    /**\n    Create a copy of this set with some node properties added. The\n    arguments to this method can be created with\n    [`NodeProp.add`](#common.NodeProp.add).\n    */ extend(...props) {\n        let newTypes = [];\n        for (let type of this.types){\n            let newProps = null;\n            for (let source of props){\n                let add = source(type);\n                if (add) {\n                    if (!newProps) newProps = Object.assign({}, type.props);\n                    newProps[add[0].id] = add[1];\n                }\n            }\n            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);\n        }\n        return new NodeSet(newTypes);\n    }\n}\nconst CachedNode = new WeakMap(), CachedInnerNode = new WeakMap();\n/**\nOptions that control iteration. Can be combined with the `|`\noperator to enable multiple ones.\n*/ var IterMode;\n(function(IterMode) {\n    /**\n    When enabled, iteration will only visit [`Tree`](#common.Tree)\n    objects, not nodes packed into\n    [`TreeBuffer`](#common.TreeBuffer)s.\n    */ IterMode[IterMode[\"ExcludeBuffers\"] = 1] = \"ExcludeBuffers\";\n    /**\n    Enable this to make iteration include anonymous nodes (such as\n    the nodes that wrap repeated grammar constructs into a balanced\n    tree).\n    */ IterMode[IterMode[\"IncludeAnonymous\"] = 2] = \"IncludeAnonymous\";\n    /**\n    By default, regular [mounted](#common.NodeProp^mounted) nodes\n    replace their base node in iteration. Enable this to ignore them\n    instead.\n    */ IterMode[IterMode[\"IgnoreMounts\"] = 4] = \"IgnoreMounts\";\n    /**\n    This option only applies in\n    [`enter`](#common.SyntaxNode.enter)-style methods. It tells the\n    library to not enter mounted overlays if one covers the given\n    position.\n    */ IterMode[IterMode[\"IgnoreOverlays\"] = 8] = \"IgnoreOverlays\";\n})(IterMode || (IterMode = {}));\n/**\nA piece of syntax tree. There are two ways to approach these\ntrees: the way they are actually stored in memory, and the\nconvenient way.\n\nSyntax trees are stored as a tree of `Tree` and `TreeBuffer`\nobjects. By packing detail information into `TreeBuffer` leaf\nnodes, the representation is made a lot more memory-efficient.\n\nHowever, when you want to actually work with tree nodes, this\nrepresentation is very awkward, so most client code will want to\nuse the [`TreeCursor`](#common.TreeCursor) or\n[`SyntaxNode`](#common.SyntaxNode) interface instead, which provides\na view on some part of this data structure, and can be used to\nmove around to adjacent nodes.\n*/ class Tree {\n    /**\n    Construct a new tree. See also [`Tree.build`](#common.Tree^build).\n    */ constructor(/**\n    The type of the top node.\n    */ type, /**\n    This node's child nodes.\n    */ children, /**\n    The positions (offsets relative to the start of this tree) of\n    the children.\n    */ positions, /**\n    The total length of this tree\n    */ length, /**\n    Per-node [node props](#common.NodeProp) to associate with this node.\n    */ props){\n        this.type = type;\n        this.children = children;\n        this.positions = positions;\n        this.length = length;\n        /**\n        @internal\n        */ this.props = null;\n        if (props && props.length) {\n            this.props = Object.create(null);\n            for (let [prop, value] of props)this.props[typeof prop == \"number\" ? prop : prop.id] = value;\n        }\n    }\n    /**\n    @internal\n    */ toString() {\n        let mounted = MountedTree.get(this);\n        if (mounted && !mounted.overlay) return mounted.tree.toString();\n        let children = \"\";\n        for (let ch of this.children){\n            let str = ch.toString();\n            if (str) {\n                if (children) children += \",\";\n                children += str;\n            }\n        }\n        return !this.type.name ? children : (/\\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? \"(\" + children + \")\" : \"\");\n    }\n    /**\n    Get a [tree cursor](#common.TreeCursor) positioned at the top of\n    the tree. Mode can be used to [control](#common.IterMode) which\n    nodes the cursor visits.\n    */ cursor(mode = 0) {\n        return new TreeCursor(this.topNode, mode);\n    }\n    /**\n    Get a [tree cursor](#common.TreeCursor) pointing into this tree\n    at the given position and side (see\n    [`moveTo`](#common.TreeCursor.moveTo).\n    */ cursorAt(pos, side = 0, mode = 0) {\n        let scope = CachedNode.get(this) || this.topNode;\n        let cursor = new TreeCursor(scope);\n        cursor.moveTo(pos, side);\n        CachedNode.set(this, cursor._tree);\n        return cursor;\n    }\n    /**\n    Get a [syntax node](#common.SyntaxNode) object for the top of the\n    tree.\n    */ get topNode() {\n        return new TreeNode(this, 0, 0, null);\n    }\n    /**\n    Get the [syntax node](#common.SyntaxNode) at the given position.\n    If `side` is -1, this will move into nodes that end at the\n    position. If 1, it'll move into nodes that start at the\n    position. With 0, it'll only enter nodes that cover the position\n    from both sides.\n    \n    Note that this will not enter\n    [overlays](#common.MountedTree.overlay), and you often want\n    [`resolveInner`](#common.Tree.resolveInner) instead.\n    */ resolve(pos, side = 0) {\n        let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);\n        CachedNode.set(this, node);\n        return node;\n    }\n    /**\n    Like [`resolve`](#common.Tree.resolve), but will enter\n    [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node\n    pointing into the innermost overlaid tree at the given position\n    (with parent links going through all parent structure, including\n    the host trees).\n    */ resolveInner(pos, side = 0) {\n        let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);\n        CachedInnerNode.set(this, node);\n        return node;\n    }\n    /**\n    In some situations, it can be useful to iterate through all\n    nodes around a position, including those in overlays that don't\n    directly cover the position. This method gives you an iterator\n    that will produce all nodes, from small to big, around the given\n    position.\n    */ resolveStack(pos, side = 0) {\n        return stackIterator(this, pos, side);\n    }\n    /**\n    Iterate over the tree and its children, calling `enter` for any\n    node that touches the `from`/`to` region (if given) before\n    running over such a node's children, and `leave` (if given) when\n    leaving the node. When `enter` returns `false`, that node will\n    not have its children iterated over (or `leave` called).\n    */ iterate(spec) {\n        let { enter, leave, from = 0, to = this.length } = spec;\n        let mode = spec.mode || 0, anon = (mode & IterMode.IncludeAnonymous) > 0;\n        for(let c = this.cursor(mode | IterMode.IncludeAnonymous);;){\n            let entered = false;\n            if (c.from <= to && c.to >= from && (!anon && c.type.isAnonymous || enter(c) !== false)) {\n                if (c.firstChild()) continue;\n                entered = true;\n            }\n            for(;;){\n                if (entered && leave && (anon || !c.type.isAnonymous)) leave(c);\n                if (c.nextSibling()) break;\n                if (!c.parent()) return;\n                entered = true;\n            }\n        }\n    }\n    /**\n    Get the value of the given [node prop](#common.NodeProp) for this\n    node. Works with both per-node and per-type props.\n    */ prop(prop) {\n        return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined;\n    }\n    /**\n    Returns the node's [per-node props](#common.NodeProp.perNode) in a\n    format that can be passed to the [`Tree`](#common.Tree)\n    constructor.\n    */ get propValues() {\n        let result = [];\n        if (this.props) for(let id in this.props)result.push([\n            +id,\n            this.props[id]\n        ]);\n        return result;\n    }\n    /**\n    Balance the direct children of this tree, producing a copy of\n    which may have children grouped into subtrees with type\n    [`NodeType.none`](#common.NodeType^none).\n    */ balance(config = {}) {\n        return this.children.length <= 8 /* Balance.BranchFactor */  ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length)=>new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length)=>new Tree(NodeType.none, children, positions, length)));\n    }\n    /**\n    Build a tree from a postfix-ordered buffer of node information,\n    or a cursor over such a buffer.\n    */ static build(data) {\n        return buildTree(data);\n    }\n}\n/**\nThe empty tree\n*/ Tree.empty = new Tree(NodeType.none, [], [], 0);\nclass FlatBufferCursor {\n    constructor(buffer, index){\n        this.buffer = buffer;\n        this.index = index;\n    }\n    get id() {\n        return this.buffer[this.index - 4];\n    }\n    get start() {\n        return this.buffer[this.index - 3];\n    }\n    get end() {\n        return this.buffer[this.index - 2];\n    }\n    get size() {\n        return this.buffer[this.index - 1];\n    }\n    get pos() {\n        return this.index;\n    }\n    next() {\n        this.index -= 4;\n    }\n    fork() {\n        return new FlatBufferCursor(this.buffer, this.index);\n    }\n}\n/**\nTree buffers contain (type, start, end, endIndex) quads for each\nnode. In such a buffer, nodes are stored in prefix order (parents\nbefore children, with the endIndex of the parent indicating which\nchildren belong to it).\n*/ class TreeBuffer {\n    /**\n    Create a tree buffer.\n    */ constructor(/**\n    The buffer's content.\n    */ buffer, /**\n    The total length of the group of nodes in the buffer.\n    */ length, /**\n    The node set used in this buffer.\n    */ set){\n        this.buffer = buffer;\n        this.length = length;\n        this.set = set;\n    }\n    /**\n    @internal\n    */ get type() {\n        return NodeType.none;\n    }\n    /**\n    @internal\n    */ toString() {\n        let result = [];\n        for(let index = 0; index < this.buffer.length;){\n            result.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result.join(\",\");\n    }\n    /**\n    @internal\n    */ childString(index) {\n        let id = this.buffer[index], endIndex = this.buffer[index + 3];\n        let type = this.set.types[id], result = type.name;\n        if (/\\W/.test(result) && !type.isError) result = JSON.stringify(result);\n        index += 4;\n        if (endIndex == index) return result;\n        let children = [];\n        while(index < endIndex){\n            children.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result + \"(\" + children.join(\",\") + \")\";\n    }\n    /**\n    @internal\n    */ findChild(startIndex, endIndex, dir, pos, side) {\n        let { buffer } = this, pick = -1;\n        for(let i = startIndex; i != endIndex; i = buffer[i + 3]){\n            if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {\n                pick = i;\n                if (dir > 0) break;\n            }\n        }\n        return pick;\n    }\n    /**\n    @internal\n    */ slice(startI, endI, from) {\n        let b = this.buffer;\n        let copy = new Uint16Array(endI - startI), len = 0;\n        for(let i = startI, j = 0; i < endI;){\n            copy[j++] = b[i++];\n            copy[j++] = b[i++] - from;\n            let to = copy[j++] = b[i++] - from;\n            copy[j++] = b[i++] - startI;\n            len = Math.max(len, to);\n        }\n        return new TreeBuffer(copy, len, this.set);\n    }\n}\nfunction checkSide(side, pos, from, to) {\n    switch(side){\n        case -2 /* Side.Before */ :\n            return from < pos;\n        case -1 /* Side.AtOrBefore */ :\n            return to >= pos && from < pos;\n        case 0 /* Side.Around */ :\n            return from < pos && to > pos;\n        case 1 /* Side.AtOrAfter */ :\n            return from <= pos && to > pos;\n        case 2 /* Side.After */ :\n            return to > pos;\n        case 4 /* Side.DontCare */ :\n            return true;\n    }\n}\nfunction resolveNode(node, pos, side, overlays) {\n    var _a;\n    // Move up to a node that actually holds the position, if possible\n    while(node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)){\n        let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;\n        if (!parent) return node;\n        node = parent;\n    }\n    let mode = overlays ? 0 : IterMode.IgnoreOverlays;\n    // Must go up out of overlays when those do not overlap with pos\n    if (overlays) for(let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent){\n        if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, mode)) === null || _a === void 0 ? void 0 : _a.from) != scan.from) node = parent;\n    }\n    for(;;){\n        let inner = node.enter(pos, side, mode);\n        if (!inner) return node;\n        node = inner;\n    }\n}\nclass BaseNode {\n    cursor(mode = 0) {\n        return new TreeCursor(this, mode);\n    }\n    getChild(type, before = null, after = null) {\n        let r = getChildren(this, type, before, after);\n        return r.length ? r[0] : null;\n    }\n    getChildren(type, before = null, after = null) {\n        return getChildren(this, type, before, after);\n    }\n    resolve(pos, side = 0) {\n        return resolveNode(this, pos, side, false);\n    }\n    resolveInner(pos, side = 0) {\n        return resolveNode(this, pos, side, true);\n    }\n    matchContext(context) {\n        return matchNodeContext(this.parent, context);\n    }\n    enterUnfinishedNodesBefore(pos) {\n        let scan = this.childBefore(pos), node = this;\n        while(scan){\n            let last = scan.lastChild;\n            if (!last || last.to != scan.to) break;\n            if (last.type.isError && last.from == last.to) {\n                node = scan;\n                scan = last.prevSibling;\n            } else {\n                scan = last;\n            }\n        }\n        return node;\n    }\n    get node() {\n        return this;\n    }\n    get next() {\n        return this.parent;\n    }\n}\nclass TreeNode extends BaseNode {\n    constructor(_tree, from, // Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)\n    index, _parent){\n        super();\n        this._tree = _tree;\n        this.from = from;\n        this.index = index;\n        this._parent = _parent;\n    }\n    get type() {\n        return this._tree.type;\n    }\n    get name() {\n        return this._tree.type.name;\n    }\n    get to() {\n        return this.from + this._tree.length;\n    }\n    nextChild(i, dir, pos, side, mode = 0) {\n        for(let parent = this;;){\n            for(let { children, positions } = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir){\n                let next = children[i], start = positions[i] + parent.from;\n                if (!checkSide(side, pos, start, start + next.length)) continue;\n                if (next instanceof TreeBuffer) {\n                    if (mode & IterMode.ExcludeBuffers) continue;\n                    let index = next.findChild(0, next.buffer.length, dir, pos - start, side);\n                    if (index > -1) return new BufferNode(new BufferContext(parent, next, i, start), null, index);\n                } else if (mode & IterMode.IncludeAnonymous || !next.type.isAnonymous || hasChild(next)) {\n                    let mounted;\n                    if (!(mode & IterMode.IgnoreMounts) && (mounted = MountedTree.get(next)) && !mounted.overlay) return new TreeNode(mounted.tree, start, i, parent);\n                    let inner = new TreeNode(next, start, i, parent);\n                    return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);\n                }\n            }\n            if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous) return null;\n            if (parent.index >= 0) i = parent.index + dir;\n            else i = dir < 0 ? -1 : parent._parent._tree.children.length;\n            parent = parent._parent;\n            if (!parent) return null;\n        }\n    }\n    get firstChild() {\n        return this.nextChild(0, 1, 0, 4 /* Side.DontCare */ );\n    }\n    get lastChild() {\n        return this.nextChild(this._tree.children.length - 1, -1, 0, 4 /* Side.DontCare */ );\n    }\n    childAfter(pos) {\n        return this.nextChild(0, 1, pos, 2 /* Side.After */ );\n    }\n    childBefore(pos) {\n        return this.nextChild(this._tree.children.length - 1, -1, pos, -2 /* Side.Before */ );\n    }\n    enter(pos, side, mode = 0) {\n        let mounted;\n        if (!(mode & IterMode.IgnoreOverlays) && (mounted = MountedTree.get(this._tree)) && mounted.overlay) {\n            let rPos = pos - this.from;\n            for (let { from, to } of mounted.overlay){\n                if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to >= rPos : to > rPos)) return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);\n            }\n        }\n        return this.nextChild(0, 1, pos, side, mode);\n    }\n    nextSignificantParent() {\n        let val = this;\n        while(val.type.isAnonymous && val._parent)val = val._parent;\n        return val;\n    }\n    get parent() {\n        return this._parent ? this._parent.nextSignificantParent() : null;\n    }\n    get nextSibling() {\n        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4 /* Side.DontCare */ ) : null;\n    }\n    get prevSibling() {\n        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4 /* Side.DontCare */ ) : null;\n    }\n    get tree() {\n        return this._tree;\n    }\n    toTree() {\n        return this._tree;\n    }\n    /**\n    @internal\n    */ toString() {\n        return this._tree.toString();\n    }\n}\nfunction getChildren(node, type, before, after) {\n    let cur = node.cursor(), result = [];\n    if (!cur.firstChild()) return result;\n    if (before != null) for(let found = false; !found;){\n        found = cur.type.is(before);\n        if (!cur.nextSibling()) return result;\n    }\n    for(;;){\n        if (after != null && cur.type.is(after)) return result;\n        if (cur.type.is(type)) result.push(cur.node);\n        if (!cur.nextSibling()) return after == null ? result : [];\n    }\n}\nfunction matchNodeContext(node, context, i = context.length - 1) {\n    for(let p = node; i >= 0; p = p.parent){\n        if (!p) return false;\n        if (!p.type.isAnonymous) {\n            if (context[i] && context[i] != p.name) return false;\n            i--;\n        }\n    }\n    return true;\n}\nclass BufferContext {\n    constructor(parent, buffer, index, start){\n        this.parent = parent;\n        this.buffer = buffer;\n        this.index = index;\n        this.start = start;\n    }\n}\nclass BufferNode extends BaseNode {\n    get name() {\n        return this.type.name;\n    }\n    get from() {\n        return this.context.start + this.context.buffer.buffer[this.index + 1];\n    }\n    get to() {\n        return this.context.start + this.context.buffer.buffer[this.index + 2];\n    }\n    constructor(context, _parent, index){\n        super();\n        this.context = context;\n        this._parent = _parent;\n        this.index = index;\n        this.type = context.buffer.set.types[context.buffer.buffer[index]];\n    }\n    child(dir, pos, side) {\n        let { buffer } = this.context;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);\n        return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n    get firstChild() {\n        return this.child(1, 0, 4 /* Side.DontCare */ );\n    }\n    get lastChild() {\n        return this.child(-1, 0, 4 /* Side.DontCare */ );\n    }\n    childAfter(pos) {\n        return this.child(1, pos, 2 /* Side.After */ );\n    }\n    childBefore(pos) {\n        return this.child(-1, pos, -2 /* Side.Before */ );\n    }\n    enter(pos, side, mode = 0) {\n        if (mode & IterMode.ExcludeBuffers) return null;\n        let { buffer } = this.context;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);\n        return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n    get parent() {\n        return this._parent || this.context.parent.nextSignificantParent();\n    }\n    externalSibling(dir) {\n        return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4 /* Side.DontCare */ );\n    }\n    get nextSibling() {\n        let { buffer } = this.context;\n        let after = buffer.buffer[this.index + 3];\n        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length)) return new BufferNode(this.context, this._parent, after);\n        return this.externalSibling(1);\n    }\n    get prevSibling() {\n        let { buffer } = this.context;\n        let parentStart = this._parent ? this._parent.index + 4 : 0;\n        if (this.index == parentStart) return this.externalSibling(-1);\n        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */ ));\n    }\n    get tree() {\n        return null;\n    }\n    toTree() {\n        let children = [], positions = [];\n        let { buffer } = this.context;\n        let startI = this.index + 4, endI = buffer.buffer[this.index + 3];\n        if (endI > startI) {\n            let from = buffer.buffer[this.index + 1];\n            children.push(buffer.slice(startI, endI, from));\n            positions.push(0);\n        }\n        return new Tree(this.type, children, positions, this.to - this.from);\n    }\n    /**\n    @internal\n    */ toString() {\n        return this.context.buffer.childString(this.index);\n    }\n}\nfunction iterStack(heads) {\n    if (!heads.length) return null;\n    let pick = 0, picked = heads[0];\n    for(let i = 1; i < heads.length; i++){\n        let node = heads[i];\n        if (node.from > picked.from || node.to < picked.to) {\n            picked = node;\n            pick = i;\n        }\n    }\n    let next = picked instanceof TreeNode && picked.index < 0 ? null : picked.parent;\n    let newHeads = heads.slice();\n    if (next) newHeads[pick] = next;\n    else newHeads.splice(pick, 1);\n    return new StackIterator(newHeads, picked);\n}\nclass StackIterator {\n    constructor(heads, node){\n        this.heads = heads;\n        this.node = node;\n    }\n    get next() {\n        return iterStack(this.heads);\n    }\n}\nfunction stackIterator(tree, pos, side) {\n    let inner = tree.resolveInner(pos, side), layers = null;\n    for(let scan = inner instanceof TreeNode ? inner : inner.context.parent; scan; scan = scan.parent){\n        if (scan.index < 0) {\n            let parent = scan.parent;\n            (layers || (layers = [\n                inner\n            ])).push(parent.resolve(pos, side));\n            scan = parent;\n        } else {\n            let mount = MountedTree.get(scan.tree);\n            // Relevant overlay branching off\n            if (mount && mount.overlay && mount.overlay[0].from <= pos && mount.overlay[mount.overlay.length - 1].to >= pos) {\n                let root = new TreeNode(mount.tree, mount.overlay[0].from + scan.from, -1, scan);\n                (layers || (layers = [\n                    inner\n                ])).push(resolveNode(root, pos, side, false));\n            }\n        }\n    }\n    return layers ? iterStack(layers) : inner;\n}\n/**\nA tree cursor object focuses on a given node in a syntax tree, and\nallows you to move to adjacent nodes.\n*/ class TreeCursor {\n    /**\n    Shorthand for `.type.name`.\n    */ get name() {\n        return this.type.name;\n    }\n    /**\n    @internal\n    */ constructor(node, /**\n    @internal\n    */ mode = 0){\n        this.mode = mode;\n        /**\n        @internal\n        */ this.buffer = null;\n        this.stack = [];\n        /**\n        @internal\n        */ this.index = 0;\n        this.bufferNode = null;\n        if (node instanceof TreeNode) {\n            this.yieldNode(node);\n        } else {\n            this._tree = node.context.parent;\n            this.buffer = node.context;\n            for(let n = node._parent; n; n = n._parent)this.stack.unshift(n.index);\n            this.bufferNode = node;\n            this.yieldBuf(node.index);\n        }\n    }\n    yieldNode(node) {\n        if (!node) return false;\n        this._tree = node;\n        this.type = node.type;\n        this.from = node.from;\n        this.to = node.to;\n        return true;\n    }\n    yieldBuf(index, type) {\n        this.index = index;\n        let { start, buffer } = this.buffer;\n        this.type = type || buffer.set.types[buffer.buffer[index]];\n        this.from = start + buffer.buffer[index + 1];\n        this.to = start + buffer.buffer[index + 2];\n        return true;\n    }\n    /**\n    @internal\n    */ yield(node) {\n        if (!node) return false;\n        if (node instanceof TreeNode) {\n            this.buffer = null;\n            return this.yieldNode(node);\n        }\n        this.buffer = node.context;\n        return this.yieldBuf(node.index, node.type);\n    }\n    /**\n    @internal\n    */ toString() {\n        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();\n    }\n    /**\n    @internal\n    */ enterChild(dir, pos, side) {\n        if (!this.buffer) return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));\n        let { buffer } = this.buffer;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);\n        if (index < 0) return false;\n        this.stack.push(this.index);\n        return this.yieldBuf(index);\n    }\n    /**\n    Move the cursor to this node's first child. When this returns\n    false, the node has no child, and the cursor has not been moved.\n    */ firstChild() {\n        return this.enterChild(1, 0, 4 /* Side.DontCare */ );\n    }\n    /**\n    Move the cursor to this node's last child.\n    */ lastChild() {\n        return this.enterChild(-1, 0, 4 /* Side.DontCare */ );\n    }\n    /**\n    Move the cursor to the first child that ends after `pos`.\n    */ childAfter(pos) {\n        return this.enterChild(1, pos, 2 /* Side.After */ );\n    }\n    /**\n    Move to the last child that starts before `pos`.\n    */ childBefore(pos) {\n        return this.enterChild(-1, pos, -2 /* Side.Before */ );\n    }\n    /**\n    Move the cursor to the child around `pos`. If side is -1 the\n    child may end at that position, when 1 it may start there. This\n    will also enter [overlaid](#common.MountedTree.overlay)\n    [mounted](#common.NodeProp^mounted) trees unless `overlays` is\n    set to false.\n    */ enter(pos, side, mode = this.mode) {\n        if (!this.buffer) return this.yield(this._tree.enter(pos, side, mode));\n        return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);\n    }\n    /**\n    Move to the node's parent node, if this isn't the top node.\n    */ parent() {\n        if (!this.buffer) return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);\n        if (this.stack.length) return this.yieldBuf(this.stack.pop());\n        let parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();\n        this.buffer = null;\n        return this.yieldNode(parent);\n    }\n    /**\n    @internal\n    */ sibling(dir) {\n        if (!this.buffer) return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4 /* Side.DontCare */ , this.mode));\n        let { buffer } = this.buffer, d = this.stack.length - 1;\n        if (dir < 0) {\n            let parentStart = d < 0 ? 0 : this.stack[d] + 4;\n            if (this.index != parentStart) return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */ ));\n        } else {\n            let after = buffer.buffer[this.index + 3];\n            if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3])) return this.yieldBuf(after);\n        }\n        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4 /* Side.DontCare */ , this.mode)) : false;\n    }\n    /**\n    Move to this node's next sibling, if any.\n    */ nextSibling() {\n        return this.sibling(1);\n    }\n    /**\n    Move to this node's previous sibling, if any.\n    */ prevSibling() {\n        return this.sibling(-1);\n    }\n    atLastNode(dir) {\n        let index, parent, { buffer } = this;\n        if (buffer) {\n            if (dir > 0) {\n                if (this.index < buffer.buffer.buffer.length) return false;\n            } else {\n                for(let i = 0; i < this.index; i++)if (buffer.buffer.buffer[i + 3] < this.index) return false;\n            }\n            ({ index, parent } = buffer);\n        } else {\n            ({ index, _parent: parent } = this._tree);\n        }\n        for(; parent; { index, _parent: parent } = parent){\n            if (index > -1) for(let i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir){\n                let child = parent._tree.children[i];\n                if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child)) return false;\n            }\n        }\n        return true;\n    }\n    move(dir, enter) {\n        if (enter && this.enterChild(dir, 0, 4 /* Side.DontCare */ )) return true;\n        for(;;){\n            if (this.sibling(dir)) return true;\n            if (this.atLastNode(dir) || !this.parent()) return false;\n        }\n    }\n    /**\n    Move to the next node in a\n    [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)\n    traversal, going from a node to its first child or, if the\n    current node is empty or `enter` is false, its next sibling or\n    the next sibling of the first parent node that has one.\n    */ next(enter = true) {\n        return this.move(1, enter);\n    }\n    /**\n    Move to the next node in a last-to-first pre-order traversal. A\n    node is followed by its last child or, if it has none, its\n    previous sibling or the previous sibling of the first parent\n    node that has one.\n    */ prev(enter = true) {\n        return this.move(-1, enter);\n    }\n    /**\n    Move the cursor to the innermost node that covers `pos`. If\n    `side` is -1, it will enter nodes that end at `pos`. If it is 1,\n    it will enter nodes that start at `pos`.\n    */ moveTo(pos, side = 0) {\n        // Move up to a node that actually holds the position, if possible\n        while(this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))if (!this.parent()) break;\n        // Then scan down into child nodes as far as possible\n        while(this.enterChild(1, pos, side)){}\n        return this;\n    }\n    /**\n    Get a [syntax node](#common.SyntaxNode) at the cursor's current\n    position.\n    */ get node() {\n        if (!this.buffer) return this._tree;\n        let cache = this.bufferNode, result = null, depth = 0;\n        if (cache && cache.context == this.buffer) {\n            scan: for(let index = this.index, d = this.stack.length; d >= 0;){\n                for(let c = cache; c; c = c._parent)if (c.index == index) {\n                    if (index == this.index) return c;\n                    result = c;\n                    depth = d + 1;\n                    break scan;\n                }\n                index = this.stack[--d];\n            }\n        }\n        for(let i = depth; i < this.stack.length; i++)result = new BufferNode(this.buffer, result, this.stack[i]);\n        return this.bufferNode = new BufferNode(this.buffer, result, this.index);\n    }\n    /**\n    Get the [tree](#common.Tree) that represents the current node, if\n    any. Will return null when the node is in a [tree\n    buffer](#common.TreeBuffer).\n    */ get tree() {\n        return this.buffer ? null : this._tree._tree;\n    }\n    /**\n    Iterate over the current node and all its descendants, calling\n    `enter` when entering a node and `leave`, if given, when leaving\n    one. When `enter` returns `false`, any children of that node are\n    skipped, and `leave` isn't called for it.\n    */ iterate(enter, leave) {\n        for(let depth = 0;;){\n            let mustLeave = false;\n            if (this.type.isAnonymous || enter(this) !== false) {\n                if (this.firstChild()) {\n                    depth++;\n                    continue;\n                }\n                if (!this.type.isAnonymous) mustLeave = true;\n            }\n            for(;;){\n                if (mustLeave && leave) leave(this);\n                mustLeave = this.type.isAnonymous;\n                if (!depth) return;\n                if (this.nextSibling()) break;\n                this.parent();\n                depth--;\n                mustLeave = true;\n            }\n        }\n    }\n    /**\n    Test whether the current node matches a given contextâ€”a sequence\n    of direct parent node names. Empty strings in the context array\n    are treated as wildcards.\n    */ matchContext(context) {\n        if (!this.buffer) return matchNodeContext(this.node.parent, context);\n        let { buffer } = this.buffer, { types } = buffer.set;\n        for(let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--){\n            if (d < 0) return matchNodeContext(this._tree, context, i);\n            let type = types[buffer.buffer[this.stack[d]]];\n            if (!type.isAnonymous) {\n                if (context[i] && context[i] != type.name) return false;\n                i--;\n            }\n        }\n        return true;\n    }\n}\nfunction hasChild(tree) {\n    return tree.children.some((ch)=>ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));\n}\nfunction buildTree(data) {\n    var _a;\n    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;\n    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;\n    let types = nodeSet.types;\n    let contextHash = 0, lookAhead = 0;\n    function takeNode(parentStart, minPos, children, positions, inRepeat, depth) {\n        let { id, start, end, size } = cursor;\n        let lookAheadAtStart = lookAhead, contextAtStart = contextHash;\n        while(size < 0){\n            cursor.next();\n            if (size == -1 /* SpecialRecord.Reuse */ ) {\n                let node = reused[id];\n                children.push(node);\n                positions.push(start - parentStart);\n                return;\n            } else if (size == -3 /* SpecialRecord.ContextChange */ ) {\n                contextHash = id;\n                return;\n            } else if (size == -4 /* SpecialRecord.LookAhead */ ) {\n                lookAhead = id;\n                return;\n            } else {\n                throw new RangeError(`Unrecognized record size: ${size}`);\n            }\n        }\n        let type = types[id], node, buffer;\n        let startPos = start - parentStart;\n        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {\n            // Small enough for a buffer, and no reused nodes inside\n            let data = new Uint16Array(buffer.size - buffer.skip);\n            let endPos = cursor.pos - buffer.size, index = data.length;\n            while(cursor.pos > endPos)index = copyToBuffer(buffer.start, data, index);\n            node = new TreeBuffer(data, end - buffer.start, nodeSet);\n            startPos = buffer.start - parentStart;\n        } else {\n            let endPos = cursor.pos - size;\n            cursor.next();\n            let localChildren = [], localPositions = [];\n            let localInRepeat = id >= minRepeatType ? id : -1;\n            let lastGroup = 0, lastEnd = end;\n            while(cursor.pos > endPos){\n                if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {\n                    if (cursor.end <= lastEnd - maxBufferLength) {\n                        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);\n                        lastGroup = localChildren.length;\n                        lastEnd = cursor.end;\n                    }\n                    cursor.next();\n                } else if (depth > 2500 /* CutOff.Depth */ ) {\n                    takeFlatNode(start, endPos, localChildren, localPositions);\n                } else {\n                    takeNode(start, endPos, localChildren, localPositions, localInRepeat, depth + 1);\n                }\n            }\n            if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length) makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);\n            localChildren.reverse();\n            localPositions.reverse();\n            if (localInRepeat > -1 && lastGroup > 0) {\n                let make = makeBalanced(type, contextAtStart);\n                node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);\n            } else {\n                node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end, contextAtStart);\n            }\n        }\n        children.push(node);\n        positions.push(startPos);\n    }\n    function takeFlatNode(parentStart, minPos, children, positions) {\n        let nodes = []; // Temporary, inverted array of leaf nodes found, with absolute positions\n        let nodeCount = 0, stopAt = -1;\n        while(cursor.pos > minPos){\n            let { id, start, end, size } = cursor;\n            if (size > 4) {\n                cursor.next();\n            } else if (stopAt > -1 && start < stopAt) {\n                break;\n            } else {\n                if (stopAt < 0) stopAt = end - maxBufferLength;\n                nodes.push(id, start, end);\n                nodeCount++;\n                cursor.next();\n            }\n        }\n        if (nodeCount) {\n            let buffer = new Uint16Array(nodeCount * 4);\n            let start = nodes[nodes.length - 2];\n            for(let i = nodes.length - 3, j = 0; i >= 0; i -= 3){\n                buffer[j++] = nodes[i];\n                buffer[j++] = nodes[i + 1] - start;\n                buffer[j++] = nodes[i + 2] - start;\n                buffer[j++] = j;\n            }\n            children.push(new TreeBuffer(buffer, nodes[2] - start, nodeSet));\n            positions.push(start - parentStart);\n        }\n    }\n    function makeBalanced(type, contextHash) {\n        return (children, positions, length)=>{\n            let lookAhead = 0, lastI = children.length - 1, last, lookAheadProp;\n            if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {\n                if (!lastI && last.type == type && last.length == length) return last;\n                if (lookAheadProp = last.prop(NodeProp.lookAhead)) lookAhead = positions[lastI] + last.length + lookAheadProp;\n            }\n            return makeTree(type, children, positions, length, lookAhead, contextHash);\n        };\n    }\n    function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead, contextHash) {\n        let localChildren = [], localPositions = [];\n        while(children.length > i){\n            localChildren.push(children.pop());\n            localPositions.push(positions.pop() + base - from);\n        }\n        children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to, contextHash));\n        positions.push(from - base);\n    }\n    function makeTree(type, children, positions, length, lookAhead, contextHash, props) {\n        if (contextHash) {\n            let pair = [\n                NodeProp.contextHash,\n                contextHash\n            ];\n            props = props ? [\n                pair\n            ].concat(props) : [\n                pair\n            ];\n        }\n        if (lookAhead > 25) {\n            let pair = [\n                NodeProp.lookAhead,\n                lookAhead\n            ];\n            props = props ? [\n                pair\n            ].concat(props) : [\n                pair\n            ];\n        }\n        return new Tree(type, children, positions, length, props);\n    }\n    function findBufferSize(maxSize, inRepeat) {\n        // Scan through the buffer to find previous siblings that fit\n        // together in a TreeBuffer, and don't contain any reused nodes\n        // (which can't be stored in a buffer).\n        // If `inRepeat` is > -1, ignore node boundaries of that type for\n        // nesting, but make sure the end falls either at the start\n        // (`maxSize`) or before such a node.\n        let fork = cursor.fork();\n        let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;\n        let result = {\n            size: 0,\n            start: 0,\n            skip: 0\n        };\n        scan: for(let minPos = fork.pos - maxSize; fork.pos > minPos;){\n            let nodeSize = fork.size;\n            // Pretend nested repeat nodes of the same type don't exist\n            if (fork.id == inRepeat && nodeSize >= 0) {\n                // Except that we store the current state as a valid return\n                // value.\n                result.size = size;\n                result.start = start;\n                result.skip = skip;\n                skip += 4;\n                size += 4;\n                fork.next();\n                continue;\n            }\n            let startPos = fork.pos - nodeSize;\n            if (nodeSize < 0 || startPos < minPos || fork.start < minStart) break;\n            let localSkipped = fork.id >= minRepeatType ? 4 : 0;\n            let nodeStart = fork.start;\n            fork.next();\n            while(fork.pos > startPos){\n                if (fork.size < 0) {\n                    if (fork.size == -3 /* SpecialRecord.ContextChange */ ) localSkipped += 4;\n                    else break scan;\n                } else if (fork.id >= minRepeatType) {\n                    localSkipped += 4;\n                }\n                fork.next();\n            }\n            start = nodeStart;\n            size += nodeSize;\n            skip += localSkipped;\n        }\n        if (inRepeat < 0 || size == maxSize) {\n            result.size = size;\n            result.start = start;\n            result.skip = skip;\n        }\n        return result.size > 4 ? result : undefined;\n    }\n    function copyToBuffer(bufferStart, buffer, index) {\n        let { id, start, end, size } = cursor;\n        cursor.next();\n        if (size >= 0 && id < minRepeatType) {\n            let startIndex = index;\n            if (size > 4) {\n                let endPos = cursor.pos - (size - 4);\n                while(cursor.pos > endPos)index = copyToBuffer(bufferStart, buffer, index);\n            }\n            buffer[--index] = startIndex;\n            buffer[--index] = end - bufferStart;\n            buffer[--index] = start - bufferStart;\n            buffer[--index] = id;\n        } else if (size == -3 /* SpecialRecord.ContextChange */ ) {\n            contextHash = id;\n        } else if (size == -4 /* SpecialRecord.LookAhead */ ) {\n            lookAhead = id;\n        }\n        return index;\n    }\n    let children = [], positions = [];\n    while(cursor.pos > 0)takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1, 0);\n    let length = (_a = data.length) !== null && _a !== void 0 ? _a : children.length ? positions[0] + children[0].length : 0;\n    return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);\n}\nconst nodeSizeCache = new WeakMap;\nfunction nodeSize(balanceType, node) {\n    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType) return 1;\n    let size = nodeSizeCache.get(node);\n    if (size == null) {\n        size = 1;\n        for (let child of node.children){\n            if (child.type != balanceType || !(child instanceof Tree)) {\n                size = 1;\n                break;\n            }\n            size += nodeSize(balanceType, child);\n        }\n        nodeSizeCache.set(node, size);\n    }\n    return size;\n}\nfunction balanceRange(// The type the balanced tree's inner nodes.\nbalanceType, // The direct children and their positions\nchildren, positions, // The index range in children/positions to use\nfrom, to, // The start position of the nodes, relative to their parent.\nstart, // Length of the outer node\nlength, // Function to build the top node of the balanced tree\nmkTop, // Function to build internal nodes for the balanced tree\nmkTree) {\n    let total = 0;\n    for(let i = from; i < to; i++)total += nodeSize(balanceType, children[i]);\n    let maxChild = Math.ceil(total * 1.5 / 8 /* Balance.BranchFactor */ );\n    let localChildren = [], localPositions = [];\n    function divide(children, positions, from, to, offset) {\n        for(let i = from; i < to;){\n            let groupFrom = i, groupStart = positions[i], groupSize = nodeSize(balanceType, children[i]);\n            i++;\n            for(; i < to; i++){\n                let nextSize = nodeSize(balanceType, children[i]);\n                if (groupSize + nextSize >= maxChild) break;\n                groupSize += nextSize;\n            }\n            if (i == groupFrom + 1) {\n                if (groupSize > maxChild) {\n                    let only = children[groupFrom]; // Only trees can have a size > 1\n                    divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);\n                    continue;\n                }\n                localChildren.push(children[groupFrom]);\n            } else {\n                let length = positions[i - 1] + children[i - 1].length - groupStart;\n                localChildren.push(balanceRange(balanceType, children, positions, groupFrom, i, groupStart, length, null, mkTree));\n            }\n            localPositions.push(groupStart + offset - start);\n        }\n    }\n    divide(children, positions, from, to, 0);\n    return (mkTop || mkTree)(localChildren, localPositions, length);\n}\n/**\nProvides a way to associate values with pieces of trees. As long\nas that part of the tree is reused, the associated values can be\nretrieved from an updated tree.\n*/ class NodeWeakMap {\n    constructor(){\n        this.map = new WeakMap();\n    }\n    setBuffer(buffer, index, value) {\n        let inner = this.map.get(buffer);\n        if (!inner) this.map.set(buffer, inner = new Map);\n        inner.set(index, value);\n    }\n    getBuffer(buffer, index) {\n        let inner = this.map.get(buffer);\n        return inner && inner.get(index);\n    }\n    /**\n    Set the value for this syntax node.\n    */ set(node, value) {\n        if (node instanceof BufferNode) this.setBuffer(node.context.buffer, node.index, value);\n        else if (node instanceof TreeNode) this.map.set(node.tree, value);\n    }\n    /**\n    Retrieve value for this syntax node, if it exists in the map.\n    */ get(node) {\n        return node instanceof BufferNode ? this.getBuffer(node.context.buffer, node.index) : node instanceof TreeNode ? this.map.get(node.tree) : undefined;\n    }\n    /**\n    Set the value for the node that a cursor currently points to.\n    */ cursorSet(cursor, value) {\n        if (cursor.buffer) this.setBuffer(cursor.buffer.buffer, cursor.index, value);\n        else this.map.set(cursor.tree, value);\n    }\n    /**\n    Retrieve the value for the node that a cursor currently points\n    to.\n    */ cursorGet(cursor) {\n        return cursor.buffer ? this.getBuffer(cursor.buffer.buffer, cursor.index) : this.map.get(cursor.tree);\n    }\n}\n/**\nTree fragments are used during [incremental\nparsing](#common.Parser.startParse) to track parts of old trees\nthat can be reused in a new parse. An array of fragments is used\nto track regions of an old tree whose nodes might be reused in new\nparses. Use the static\n[`applyChanges`](#common.TreeFragment^applyChanges) method to\nupdate fragments for document changes.\n*/ class TreeFragment {\n    /**\n    Construct a tree fragment. You'll usually want to use\n    [`addTree`](#common.TreeFragment^addTree) and\n    [`applyChanges`](#common.TreeFragment^applyChanges) instead of\n    calling this directly.\n    */ constructor(/**\n    The start of the unchanged range pointed to by this fragment.\n    This refers to an offset in the _updated_ document (as opposed\n    to the original tree).\n    */ from, /**\n    The end of the unchanged range.\n    */ to, /**\n    The tree that this fragment is based on.\n    */ tree, /**\n    The offset between the fragment's tree and the document that\n    this fragment can be used against. Add this when going from\n    document to tree positions, subtract it to go from tree to\n    document positions.\n    */ offset, openStart = false, openEnd = false){\n        this.from = from;\n        this.to = to;\n        this.tree = tree;\n        this.offset = offset;\n        this.open = (openStart ? 1 /* Open.Start */  : 0) | (openEnd ? 2 /* Open.End */  : 0);\n    }\n    /**\n    Whether the start of the fragment represents the start of a\n    parse, or the end of a change. (In the second case, it may not\n    be safe to reuse some nodes at the start, depending on the\n    parsing algorithm.)\n    */ get openStart() {\n        return (this.open & 1 /* Open.Start */ ) > 0;\n    }\n    /**\n    Whether the end of the fragment represents the end of a\n    full-document parse, or the start of a change.\n    */ get openEnd() {\n        return (this.open & 2 /* Open.End */ ) > 0;\n    }\n    /**\n    Create a set of fragments from a freshly parsed tree, or update\n    an existing set of fragments by replacing the ones that overlap\n    with a tree with content from the new tree. When `partial` is\n    true, the parse is treated as incomplete, and the resulting\n    fragment has [`openEnd`](#common.TreeFragment.openEnd) set to\n    true.\n    */ static addTree(tree, fragments = [], partial = false) {\n        let result = [\n            new TreeFragment(0, tree.length, tree, 0, false, partial)\n        ];\n        for (let f of fragments)if (f.to > tree.length) result.push(f);\n        return result;\n    }\n    /**\n    Apply a set of edits to an array of fragments, removing or\n    splitting fragments as necessary to remove edited ranges, and\n    adjusting offsets for fragments that moved.\n    */ static applyChanges(fragments, changes, minGap = 128) {\n        if (!changes.length) return fragments;\n        let result = [];\n        let fI = 1, nextF = fragments.length ? fragments[0] : null;\n        for(let cI = 0, pos = 0, off = 0;; cI++){\n            let nextC = cI < changes.length ? changes[cI] : null;\n            let nextPos = nextC ? nextC.fromA : 1e9;\n            if (nextPos - pos >= minGap) while(nextF && nextF.from < nextPos){\n                let cut = nextF;\n                if (pos >= cut.from || nextPos <= cut.to || off) {\n                    let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;\n                    cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);\n                }\n                if (cut) result.push(cut);\n                if (nextF.to > nextPos) break;\n                nextF = fI < fragments.length ? fragments[fI++] : null;\n            }\n            if (!nextC) break;\n            pos = nextC.toA;\n            off = nextC.toA - nextC.toB;\n        }\n        return result;\n    }\n}\n/**\nA superclass that parsers should extend.\n*/ class Parser {\n    /**\n    Start a parse, returning a [partial parse](#common.PartialParse)\n    object. [`fragments`](#common.TreeFragment) can be passed in to\n    make the parse incremental.\n    \n    By default, the entire input is parsed. You can pass `ranges`,\n    which should be a sorted array of non-empty, non-overlapping\n    ranges, to parse only those ranges. The tree returned in that\n    case will start at `ranges[0].from`.\n    */ startParse(input, fragments, ranges) {\n        if (typeof input == \"string\") input = new StringInput(input);\n        ranges = !ranges ? [\n            new Range(0, input.length)\n        ] : ranges.length ? ranges.map((r)=>new Range(r.from, r.to)) : [\n            new Range(0, 0)\n        ];\n        return this.createParse(input, fragments || [], ranges);\n    }\n    /**\n    Run a full parse, returning the resulting tree.\n    */ parse(input, fragments, ranges) {\n        let parse = this.startParse(input, fragments, ranges);\n        for(;;){\n            let done = parse.advance();\n            if (done) return done;\n        }\n    }\n}\nclass StringInput {\n    constructor(string){\n        this.string = string;\n    }\n    get length() {\n        return this.string.length;\n    }\n    chunk(from) {\n        return this.string.slice(from);\n    }\n    get lineChunks() {\n        return false;\n    }\n    read(from, to) {\n        return this.string.slice(from, to);\n    }\n}\n/**\nCreate a parse wrapper that, after the inner parse completes,\nscans its tree for mixed language regions with the `nest`\nfunction, runs the resulting [inner parses](#common.NestedParse),\nand then [mounts](#common.NodeProp^mounted) their results onto the\ntree.\n*/ function parseMixed(nest) {\n    return (parse, input, fragments, ranges)=>new MixedParse(parse, nest, input, fragments, ranges);\n}\nclass InnerParse {\n    constructor(parser, parse, overlay, target, from){\n        this.parser = parser;\n        this.parse = parse;\n        this.overlay = overlay;\n        this.target = target;\n        this.from = from;\n    }\n}\nfunction checkRanges(ranges) {\n    if (!ranges.length || ranges.some((r)=>r.from >= r.to)) throw new RangeError(\"Invalid inner parse ranges given: \" + JSON.stringify(ranges));\n}\nclass ActiveOverlay {\n    constructor(parser, predicate, mounts, index, start, target, prev){\n        this.parser = parser;\n        this.predicate = predicate;\n        this.mounts = mounts;\n        this.index = index;\n        this.start = start;\n        this.target = target;\n        this.prev = prev;\n        this.depth = 0;\n        this.ranges = [];\n    }\n}\nconst stoppedInner = new NodeProp({\n    perNode: true\n});\nclass MixedParse {\n    constructor(base, nest, input, fragments, ranges){\n        this.nest = nest;\n        this.input = input;\n        this.fragments = fragments;\n        this.ranges = ranges;\n        this.inner = [];\n        this.innerDone = 0;\n        this.baseTree = null;\n        this.stoppedAt = null;\n        this.baseParse = base;\n    }\n    advance() {\n        if (this.baseParse) {\n            let done = this.baseParse.advance();\n            if (!done) return null;\n            this.baseParse = null;\n            this.baseTree = done;\n            this.startInner();\n            if (this.stoppedAt != null) for (let inner of this.inner)inner.parse.stopAt(this.stoppedAt);\n        }\n        if (this.innerDone == this.inner.length) {\n            let result = this.baseTree;\n            if (this.stoppedAt != null) result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([\n                [\n                    stoppedInner,\n                    this.stoppedAt\n                ]\n            ]));\n            return result;\n        }\n        let inner = this.inner[this.innerDone], done = inner.parse.advance();\n        if (done) {\n            this.innerDone++;\n            // This is a somewhat dodgy but super helpful hack where we\n            // patch up nodes created by the inner parse (and thus\n            // presumably not aliased anywhere else) to hold the information\n            // about the inner parse.\n            let props = Object.assign(Object.create(null), inner.target.props);\n            props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);\n            inner.target.props = props;\n        }\n        return null;\n    }\n    get parsedPos() {\n        if (this.baseParse) return 0;\n        let pos = this.input.length;\n        for(let i = this.innerDone; i < this.inner.length; i++){\n            if (this.inner[i].from < pos) pos = Math.min(pos, this.inner[i].parse.parsedPos);\n        }\n        return pos;\n    }\n    stopAt(pos) {\n        this.stoppedAt = pos;\n        if (this.baseParse) this.baseParse.stopAt(pos);\n        else for(let i = this.innerDone; i < this.inner.length; i++)this.inner[i].parse.stopAt(pos);\n    }\n    startInner() {\n        let fragmentCursor = new FragmentCursor(this.fragments);\n        let overlay = null;\n        let covered = null;\n        let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), IterMode.IncludeAnonymous | IterMode.IgnoreMounts);\n        scan: for(let nest, isCovered;;){\n            let enter = true, range;\n            if (this.stoppedAt != null && cursor.from >= this.stoppedAt) {\n                enter = false;\n            } else if (fragmentCursor.hasNode(cursor)) {\n                if (overlay) {\n                    let match = overlay.mounts.find((m)=>m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay);\n                    if (match) for (let r of match.mount.overlay){\n                        let from = r.from + match.pos, to = r.to + match.pos;\n                        if (from >= cursor.from && to <= cursor.to && !overlay.ranges.some((r)=>r.from < to && r.to > from)) overlay.ranges.push({\n                            from,\n                            to\n                        });\n                    }\n                }\n                enter = false;\n            } else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {\n                enter = isCovered != 2 /* Cover.Full */ ;\n            } else if (!cursor.type.isAnonymous && (nest = this.nest(cursor, this.input)) && (cursor.from < cursor.to || !nest.overlay)) {\n                if (!cursor.tree) materialize(cursor);\n                let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);\n                if (typeof nest.overlay == \"function\") {\n                    overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);\n                } else {\n                    let ranges = punchRanges(this.ranges, nest.overlay || (cursor.from < cursor.to ? [\n                        new Range(cursor.from, cursor.to)\n                    ] : []));\n                    if (ranges.length) checkRanges(ranges);\n                    if (ranges.length || !nest.overlay) this.inner.push(new InnerParse(nest.parser, ranges.length ? nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges) : nest.parser.startParse(\"\"), nest.overlay ? nest.overlay.map((r)=>new Range(r.from - cursor.from, r.to - cursor.from)) : null, cursor.tree, ranges.length ? ranges[0].from : cursor.from));\n                    if (!nest.overlay) enter = false;\n                    else if (ranges.length) covered = {\n                        ranges,\n                        depth: 0,\n                        prev: covered\n                    };\n                }\n            } else if (overlay && (range = overlay.predicate(cursor))) {\n                if (range === true) range = new Range(cursor.from, cursor.to);\n                if (range.from < range.to) {\n                    let last = overlay.ranges.length - 1;\n                    if (last >= 0 && overlay.ranges[last].to == range.from) overlay.ranges[last] = {\n                        from: overlay.ranges[last].from,\n                        to: range.to\n                    };\n                    else overlay.ranges.push(range);\n                }\n            }\n            if (enter && cursor.firstChild()) {\n                if (overlay) overlay.depth++;\n                if (covered) covered.depth++;\n            } else {\n                for(;;){\n                    if (cursor.nextSibling()) break;\n                    if (!cursor.parent()) break scan;\n                    if (overlay && !--overlay.depth) {\n                        let ranges = punchRanges(this.ranges, overlay.ranges);\n                        if (ranges.length) {\n                            checkRanges(ranges);\n                            this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map((r)=>new Range(r.from - overlay.start, r.to - overlay.start)), overlay.target, ranges[0].from));\n                        }\n                        overlay = overlay.prev;\n                    }\n                    if (covered && !--covered.depth) covered = covered.prev;\n                }\n            }\n        }\n    }\n}\nfunction checkCover(covered, from, to) {\n    for (let range of covered){\n        if (range.from >= to) break;\n        if (range.to > from) return range.from <= from && range.to >= to ? 2 /* Cover.Full */  : 1 /* Cover.Partial */ ;\n    }\n    return 0 /* Cover.None */ ;\n}\n// Take a piece of buffer and convert it into a stand-alone\n// TreeBuffer.\nfunction sliceBuf(buf, startI, endI, nodes, positions, off) {\n    if (startI < endI) {\n        let from = buf.buffer[startI + 1];\n        nodes.push(buf.slice(startI, endI, from));\n        positions.push(from - off);\n    }\n}\n// This function takes a node that's in a buffer, and converts it, and\n// its parent buffer nodes, into a Tree. This is again acting on the\n// assumption that the trees and buffers have been constructed by the\n// parse that was ran via the mix parser, and thus aren't shared with\n// any other code, making violations of the immutability safe.\nfunction materialize(cursor) {\n    let { node } = cursor, stack = [];\n    let buffer = node.context.buffer;\n    // Scan up to the nearest tree\n    do {\n        stack.push(cursor.index);\n        cursor.parent();\n    }while (!cursor.tree);\n    // Find the index of the buffer in that tree\n    let base = cursor.tree, i = base.children.indexOf(buffer);\n    let buf = base.children[i], b = buf.buffer, newStack = [\n        i\n    ];\n    // Split a level in the buffer, putting the nodes before and after\n    // the child that contains `node` into new buffers.\n    function split(startI, endI, type, innerOffset, length, stackPos) {\n        let targetI = stack[stackPos];\n        let children = [], positions = [];\n        sliceBuf(buf, startI, targetI, children, positions, innerOffset);\n        let from = b[targetI + 1], to = b[targetI + 2];\n        newStack.push(children.length);\n        let child = stackPos ? split(targetI + 4, b[targetI + 3], buf.set.types[b[targetI]], from, to - from, stackPos - 1) : node.toTree();\n        children.push(child);\n        positions.push(from - innerOffset);\n        sliceBuf(buf, b[targetI + 3], endI, children, positions, innerOffset);\n        return new Tree(type, children, positions, length);\n    }\n    base.children[i] = split(0, b.length, NodeType.none, 0, buf.length, stack.length - 1);\n    // Move the cursor back to the target node\n    for (let index of newStack){\n        let tree = cursor.tree.children[index], pos = cursor.tree.positions[index];\n        cursor.yield(new TreeNode(tree, pos + cursor.from, index, cursor._tree));\n    }\n}\nclass StructureCursor {\n    constructor(root, offset){\n        this.offset = offset;\n        this.done = false;\n        this.cursor = root.cursor(IterMode.IncludeAnonymous | IterMode.IgnoreMounts);\n    }\n    // Move to the first node (in pre-order) that starts at or after `pos`.\n    moveTo(pos) {\n        let { cursor } = this, p = pos - this.offset;\n        while(!this.done && cursor.from < p){\n            if (cursor.to >= pos && cursor.enter(p, 1, IterMode.IgnoreOverlays | IterMode.ExcludeBuffers)) ;\n            else if (!cursor.next(false)) this.done = true;\n        }\n    }\n    hasNode(cursor) {\n        this.moveTo(cursor.from);\n        if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {\n            for(let tree = this.cursor.tree;;){\n                if (tree == cursor.tree) return true;\n                if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree) tree = tree.children[0];\n                else break;\n            }\n        }\n        return false;\n    }\n}\nclass FragmentCursor {\n    constructor(fragments){\n        var _a;\n        this.fragments = fragments;\n        this.curTo = 0;\n        this.fragI = 0;\n        if (fragments.length) {\n            let first = this.curFrag = fragments[0];\n            this.curTo = (_a = first.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : first.to;\n            this.inner = new StructureCursor(first.tree, -first.offset);\n        } else {\n            this.curFrag = this.inner = null;\n        }\n    }\n    hasNode(node) {\n        while(this.curFrag && node.from >= this.curTo)this.nextFrag();\n        return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);\n    }\n    nextFrag() {\n        var _a;\n        this.fragI++;\n        if (this.fragI == this.fragments.length) {\n            this.curFrag = this.inner = null;\n        } else {\n            let frag = this.curFrag = this.fragments[this.fragI];\n            this.curTo = (_a = frag.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : frag.to;\n            this.inner = new StructureCursor(frag.tree, -frag.offset);\n        }\n    }\n    findMounts(pos, parser) {\n        var _a;\n        let result = [];\n        if (this.inner) {\n            this.inner.cursor.moveTo(pos, 1);\n            for(let pos = this.inner.cursor.node; pos; pos = pos.parent){\n                let mount = (_a = pos.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);\n                if (mount && mount.parser == parser) {\n                    for(let i = this.fragI; i < this.fragments.length; i++){\n                        let frag = this.fragments[i];\n                        if (frag.from >= pos.to) break;\n                        if (frag.tree == this.curFrag.tree) result.push({\n                            frag,\n                            pos: pos.from - frag.offset,\n                            mount\n                        });\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}\nfunction punchRanges(outer, ranges) {\n    let copy = null, current = ranges;\n    for(let i = 1, j = 0; i < outer.length; i++){\n        let gapFrom = outer[i - 1].to, gapTo = outer[i].from;\n        for(; j < current.length; j++){\n            let r = current[j];\n            if (r.from >= gapTo) break;\n            if (r.to <= gapFrom) continue;\n            if (!copy) current = copy = ranges.slice();\n            if (r.from < gapFrom) {\n                copy[j] = new Range(r.from, gapFrom);\n                if (r.to > gapTo) copy.splice(j + 1, 0, new Range(gapTo, r.to));\n            } else if (r.to > gapTo) {\n                copy[j--] = new Range(gapTo, r.to);\n            } else {\n                copy.splice(j--, 1);\n            }\n        }\n    }\n    return current;\n}\nfunction findCoverChanges(a, b, from, to) {\n    let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;\n    let result = [];\n    for(;;){\n        let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;\n        let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;\n        if (inA != inB) {\n            let start = Math.max(pos, from), end = Math.min(nextA, nextB, to);\n            if (start < end) result.push(new Range(start, end));\n        }\n        pos = Math.min(nextA, nextB);\n        if (pos == 1e9) break;\n        if (nextA == pos) {\n            if (!inA) inA = true;\n            else {\n                inA = false;\n                iA++;\n            }\n        }\n        if (nextB == pos) {\n            if (!inB) inB = true;\n            else {\n                inB = false;\n                iB++;\n            }\n        }\n    }\n    return result;\n}\n// Given a number of fragments for the outer tree, and a set of ranges\n// to parse, find fragments for inner trees mounted around those\n// ranges, if any.\nfunction enterFragments(mounts, ranges) {\n    let result = [];\n    for (let { pos, mount, frag } of mounts){\n        let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;\n        let from = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);\n        if (mount.overlay) {\n            let overlay = mount.overlay.map((r)=>new Range(r.from + pos, r.to + pos));\n            let changes = findCoverChanges(ranges, overlay, from, to);\n            for(let i = 0, pos = from;; i++){\n                let last = i == changes.length, end = last ? to : changes[i].from;\n                if (end > pos) result.push(new TreeFragment(pos, end, mount.tree, -startPos, frag.from >= pos || frag.openStart, frag.to <= end || frag.openEnd));\n                if (last) break;\n                pos = changes[i].to;\n            }\n        } else {\n            result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos || frag.openStart, frag.to <= endPos || frag.openEnd));\n        }\n    }\n    return result;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxlemVyL2NvbW1vbi9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFFQSxHQUNBLE1BQU1BLHNCQUFzQjtBQUM1QixJQUFJQyxhQUFhO0FBQ2pCLE1BQU1DO0lBQ0ZDLFlBQVlDLElBQUksRUFBRUMsRUFBRSxDQUFFO1FBQ2xCLElBQUksQ0FBQ0QsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0MsRUFBRSxHQUFHQTtJQUNkO0FBQ0o7QUFDQTs7OztBQUlBLEdBQ0EsTUFBTUM7SUFDRjs7SUFFQSxHQUNBSCxZQUFZSSxTQUFTLENBQUMsQ0FBQyxDQUFFO1FBQ3JCLElBQUksQ0FBQ0MsRUFBRSxHQUFHUDtRQUNWLElBQUksQ0FBQ1EsT0FBTyxHQUFHLENBQUMsQ0FBQ0YsT0FBT0UsT0FBTztRQUMvQixJQUFJLENBQUNDLFdBQVcsR0FBR0gsT0FBT0csV0FBVyxJQUFLO1lBQ3RDLE1BQU0sSUFBSUMsTUFBTTtRQUNwQjtJQUNKO0lBQ0E7Ozs7Ozs7O0lBUUEsR0FDQUMsSUFBSUMsS0FBSyxFQUFFO1FBQ1AsSUFBSSxJQUFJLENBQUNKLE9BQU8sRUFDWixNQUFNLElBQUlLLFdBQVc7UUFDekIsSUFBSSxPQUFPRCxTQUFTLFlBQ2hCQSxRQUFRRSxTQUFTRixLQUFLLENBQUNBO1FBQzNCLE9BQU8sQ0FBQ0c7WUFDSixJQUFJQyxTQUFTSixNQUFNRztZQUNuQixPQUFPQyxXQUFXQyxZQUFZLE9BQU87Z0JBQUMsSUFBSTtnQkFBRUQ7YUFBTztRQUN2RDtJQUNKO0FBQ0o7QUFDQTs7Ozs7QUFLQSxHQUNBWCxTQUFTYSxRQUFRLEdBQUcsSUFBSWIsU0FBUztJQUFFSSxhQUFhVSxDQUFBQSxNQUFPQSxJQUFJQyxLQUFLLENBQUM7QUFBSztBQUN0RTs7OztBQUlBLEdBQ0FmLFNBQVNnQixRQUFRLEdBQUcsSUFBSWhCLFNBQVM7SUFBRUksYUFBYVUsQ0FBQUEsTUFBT0EsSUFBSUMsS0FBSyxDQUFD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QUFDWDtBQUVnSyIsInNvdXJjZXMiOlsid2VicGFjazovL2VyYS1wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvQGxlemVyL2NvbW1vbi9kaXN0L2luZGV4LmpzP2MxOTMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG5UaGUgZGVmYXVsdCBtYXhpbXVtIGxlbmd0aCBvZiBhIGBUcmVlQnVmZmVyYCBub2RlLlxuKi9cbmNvbnN0IERlZmF1bHRCdWZmZXJMZW5ndGggPSAxMDI0O1xubGV0IG5leHRQcm9wSUQgPSAwO1xuY2xhc3MgUmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG59XG4vKipcbkVhY2ggW25vZGUgdHlwZV0oI2NvbW1vbi5Ob2RlVHlwZSkgb3IgW2luZGl2aWR1YWwgdHJlZV0oI2NvbW1vbi5UcmVlKVxuY2FuIGhhdmUgbWV0YWRhdGEgYXNzb2NpYXRlZCB3aXRoIGl0IGluIHByb3BzLiBJbnN0YW5jZXMgb2YgdGhpc1xuY2xhc3MgcmVwcmVzZW50IHByb3AgbmFtZXMuXG4qL1xuY2xhc3MgTm9kZVByb3Age1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBub2RlIHByb3AgdHlwZS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHRoaXMuaWQgPSBuZXh0UHJvcElEKys7XG4gICAgICAgIHRoaXMucGVyTm9kZSA9ICEhY29uZmlnLnBlck5vZGU7XG4gICAgICAgIHRoaXMuZGVzZXJpYWxpemUgPSBjb25maWcuZGVzZXJpYWxpemUgfHwgKCgpID0+IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgbm9kZSB0eXBlIGRvZXNuJ3QgZGVmaW5lIGEgZGVzZXJpYWxpemUgZnVuY3Rpb25cIik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGlzIGlzIG1lYW50IHRvIGJlIHVzZWQgd2l0aFxuICAgIFtgTm9kZVNldC5leHRlbmRgXSgjY29tbW9uLk5vZGVTZXQuZXh0ZW5kKSBvclxuICAgIFtgTFJQYXJzZXIuY29uZmlndXJlYF0oI2xyLlBhcnNlckNvbmZpZy5wcm9wcykgdG8gY29tcHV0ZVxuICAgIHByb3AgdmFsdWVzIGZvciBlYWNoIG5vZGUgdHlwZSBpbiB0aGUgc2V0LiBUYWtlcyBhIFttYXRjaFxuICAgIG9iamVjdF0oI2NvbW1vbi5Ob2RlVHlwZV5tYXRjaCkgb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHVuZGVmaW5lZFxuICAgIGlmIHRoZSBub2RlIHR5cGUgZG9lc24ndCBnZXQgdGhpcyBwcm9wLCBhbmQgdGhlIHByb3AncyB2YWx1ZSBpZlxuICAgIGl0IGRvZXMuXG4gICAgKi9cbiAgICBhZGQobWF0Y2gpIHtcbiAgICAgICAgaWYgKHRoaXMucGVyTm9kZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuJ3QgYWRkIHBlci1ub2RlIHByb3BzIHRvIG5vZGUgdHlwZXNcIik7XG4gICAgICAgIGlmICh0eXBlb2YgbWF0Y2ggIT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgbWF0Y2ggPSBOb2RlVHlwZS5tYXRjaChtYXRjaCk7XG4gICAgICAgIHJldHVybiAodHlwZSkgPT4ge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG1hdGNoKHR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IFt0aGlzLCByZXN1bHRdO1xuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuUHJvcCB0aGF0IGlzIHVzZWQgdG8gZGVzY3JpYmUgbWF0Y2hpbmcgZGVsaW1pdGVycy4gRm9yIG9wZW5pbmdcbmRlbGltaXRlcnMsIHRoaXMgaG9sZHMgYW4gYXJyYXkgb2Ygbm9kZSBuYW1lcyAod3JpdHRlbiBhcyBhXG5zcGFjZS1zZXBhcmF0ZWQgc3RyaW5nIHdoZW4gZGVjbGFyaW5nIHRoaXMgcHJvcCBpbiBhIGdyYW1tYXIpXG5mb3IgdGhlIG5vZGUgdHlwZXMgb2YgY2xvc2luZyBkZWxpbWl0ZXJzIHRoYXQgbWF0Y2ggaXQuXG4qL1xuTm9kZVByb3AuY2xvc2VkQnkgPSBuZXcgTm9kZVByb3AoeyBkZXNlcmlhbGl6ZTogc3RyID0+IHN0ci5zcGxpdChcIiBcIikgfSk7XG4vKipcblRoZSBpbnZlcnNlIG9mIFtgY2xvc2VkQnlgXSgjY29tbW9uLk5vZGVQcm9wXmNsb3NlZEJ5KS4gVGhpcyBpc1xuYXR0YWNoZWQgdG8gY2xvc2luZyBkZWxpbWl0ZXJzLCBob2xkaW5nIGFuIGFycmF5IG9mIG5vZGUgbmFtZXNcbm9mIHR5cGVzIG9mIG1hdGNoaW5nIG9wZW5pbmcgZGVsaW1pdGVycy5cbiovXG5Ob2RlUHJvcC5vcGVuZWRCeSA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8qKlxuVXNlZCB0byBhc3NpZ24gbm9kZSB0eXBlcyB0byBncm91cHMgKGZvciBleGFtcGxlLCBhbGwgbm9kZVxudHlwZXMgdGhhdCByZXByZXNlbnQgYW4gZXhwcmVzc2lvbiBjb3VsZCBiZSB0YWdnZWQgd2l0aCBhblxuYFwiRXhwcmVzc2lvblwiYCBncm91cCkuXG4qL1xuTm9kZVByb3AuZ3JvdXAgPSBuZXcgTm9kZVByb3AoeyBkZXNlcmlhbGl6ZTogc3RyID0+IHN0ci5zcGxpdChcIiBcIikgfSk7XG4vKipcbkF0dGFjaGVkIHRvIG5vZGVzIHRvIGluZGljYXRlIHRoZXNlIHNob3VsZCBiZVxuW2Rpc3BsYXllZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9kb2NzL3JlZi8jbGFuZ3VhZ2Uuc3ludGF4VHJlZSlcbmluIGEgYmlkaXJlY3Rpb25hbCB0ZXh0IGlzb2xhdGUsIHNvIHRoYXQgZGlyZWN0aW9uLW5ldXRyYWxcbmNoYXJhY3RlcnMgb24gdGhlaXIgc2lkZXMgZG9uJ3QgaW5jb3JyZWN0bHkgZ2V0IGFzc29jaWF0ZWQgd2l0aFxuc3Vycm91bmRpbmcgdGV4dC4gWW91J2xsIGdlbmVyYWxseSB3YW50IHRvIHNldCB0aGlzIGZvciBub2Rlc1xudGhhdCBjb250YWluIGFyYml0cmFyeSB0ZXh0LCBsaWtlIHN0cmluZ3MgYW5kIGNvbW1lbnRzLCBhbmQgZm9yXG5ub2RlcyB0aGF0IGFwcGVhciBfaW5zaWRlXyBhcmJpdHJhcnkgdGV4dCwgbGlrZSBIVE1MIHRhZ3MuIFdoZW5cbm5vdCBnaXZlbiBhIHZhbHVlLCBpbiBhIGdyYW1tYXIgZGVjbGFyYXRpb24sIGRlZmF1bHRzIHRvXG5gXCJhdXRvXCJgLlxuKi9cbk5vZGVQcm9wLmlzb2xhdGUgPSBuZXcgTm9kZVByb3AoeyBkZXNlcmlhbGl6ZTogdmFsdWUgPT4ge1xuICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUgIT0gXCJydGxcIiAmJiB2YWx1ZSAhPSBcImx0clwiICYmIHZhbHVlICE9IFwiYXV0b1wiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHZhbHVlIGZvciBpc29sYXRlOiBcIiArIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlIHx8IFwiYXV0b1wiO1xuICAgIH0gfSk7XG4vKipcblRoZSBoYXNoIG9mIHRoZSBbY29udGV4dF0oI2xyLkNvbnRleHRUcmFja2VyLmNvbnN0cnVjdG9yKVxudGhhdCB0aGUgbm9kZSB3YXMgcGFyc2VkIGluLCBpZiBhbnkuIFVzZWQgdG8gbGltaXQgcmV1c2Ugb2ZcbmNvbnRleHR1YWwgbm9kZXMuXG4qL1xuTm9kZVByb3AuY29udGV4dEhhc2ggPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuLyoqXG5UaGUgZGlzdGFuY2UgYmV5b25kIHRoZSBlbmQgb2YgdGhlIG5vZGUgdGhhdCB0aGUgdG9rZW5pemVyXG5sb29rZWQgYWhlYWQgZm9yIGFueSBvZiB0aGUgdG9rZW5zIGluc2lkZSB0aGUgbm9kZS4gKFRoZSBMUlxucGFyc2VyIG9ubHkgc3RvcmVzIHRoaXMgd2hlbiBpdCBpcyBsYXJnZXIgdGhhbiAyNSwgZm9yXG5lZmZpY2llbmN5IHJlYXNvbnMuKVxuKi9cbk5vZGVQcm9wLmxvb2tBaGVhZCA9IG5ldyBOb2RlUHJvcCh7IHBlck5vZGU6IHRydWUgfSk7XG4vKipcblRoaXMgcGVyLW5vZGUgcHJvcCBpcyB1c2VkIHRvIHJlcGxhY2UgYSBnaXZlbiBub2RlLCBvciBwYXJ0IG9mIGFcbm5vZGUsIHdpdGggYW5vdGhlciB0cmVlLiBUaGlzIGlzIHVzZWZ1bCB0byBpbmNsdWRlIHRyZWVzIGZyb21cbmRpZmZlcmVudCBsYW5ndWFnZXMgaW4gbWl4ZWQtbGFuZ3VhZ2UgcGFyc2Vycy5cbiovXG5Ob2RlUHJvcC5tb3VudGVkID0gbmV3IE5vZGVQcm9wKHsgcGVyTm9kZTogdHJ1ZSB9KTtcbi8qKlxuQSBtb3VudGVkIHRyZWUsIHdoaWNoIGNhbiBiZSBbc3RvcmVkXSgjY29tbW9uLk5vZGVQcm9wXm1vdW50ZWQpIG9uXG5hIHRyZWUgbm9kZSB0byBpbmRpY2F0ZSB0aGF0IHBhcnRzIG9mIGl0cyBjb250ZW50IGFyZVxucmVwcmVzZW50ZWQgYnkgYW5vdGhlciB0cmVlLlxuKi9cbmNsYXNzIE1vdW50ZWRUcmVlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgaW5uZXIgdHJlZS5cbiAgICAqL1xuICAgIHRyZWUsIFxuICAgIC8qKlxuICAgIElmIHRoaXMgaXMgbnVsbCwgdGhpcyB0cmVlIHJlcGxhY2VzIHRoZSBlbnRpcmUgbm9kZSAoaXQgd2lsbFxuICAgIGJlIGluY2x1ZGVkIGluIHRoZSByZWd1bGFyIGl0ZXJhdGlvbiBpbnN0ZWFkIG9mIGl0cyBob3N0XG4gICAgbm9kZSkuIElmIG5vdCwgb25seSB0aGUgZ2l2ZW4gcmFuZ2VzIGFyZSBjb25zaWRlcmVkIHRvIGJlXG4gICAgY292ZXJlZCBieSB0aGlzIHRyZWUuIFRoaXMgaXMgdXNlZCBmb3IgdHJlZXMgdGhhdCBhcmUgbWl4ZWQgaW5cbiAgICBhIHdheSB0aGF0IGlzbid0IHN0cmljdGx5IGhpZXJhcmNoaWNhbC4gU3VjaCBtb3VudGVkIHRyZWVzIGFyZVxuICAgIG9ubHkgZW50ZXJlZCBieSBbYHJlc29sdmVJbm5lcmBdKCNjb21tb24uVHJlZS5yZXNvbHZlSW5uZXIpXG4gICAgYW5kIFtgZW50ZXJgXSgjY29tbW9uLlN5bnRheE5vZGUuZW50ZXIpLlxuICAgICovXG4gICAgb3ZlcmxheSwgXG4gICAgLyoqXG4gICAgVGhlIHBhcnNlciB1c2VkIHRvIGNyZWF0ZSB0aGlzIHN1YnRyZWUuXG4gICAgKi9cbiAgICBwYXJzZXIpIHtcbiAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgdGhpcy5vdmVybGF5ID0gb3ZlcmxheTtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGdldCh0cmVlKSB7XG4gICAgICAgIHJldHVybiB0cmVlICYmIHRyZWUucHJvcHMgJiYgdHJlZS5wcm9wc1tOb2RlUHJvcC5tb3VudGVkLmlkXTtcbiAgICB9XG59XG5jb25zdCBub1Byb3BzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKlxuRWFjaCBub2RlIGluIGEgc3ludGF4IHRyZWUgaGFzIGEgbm9kZSB0eXBlIGFzc29jaWF0ZWQgd2l0aCBpdC5cbiovXG5jbGFzcyBOb2RlVHlwZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbmFtZSBvZiB0aGUgbm9kZSB0eXBlLiBOb3QgbmVjZXNzYXJpbHkgdW5pcXVlLCBidXQgaWYgdGhlXG4gICAgZ3JhbW1hciB3YXMgd3JpdHRlbiBwcm9wZXJseSwgZGlmZmVyZW50IG5vZGUgdHlwZXMgd2l0aCB0aGVcbiAgICBzYW1lIG5hbWUgd2l0aGluIGEgbm9kZSBzZXQgc2hvdWxkIHBsYXkgdGhlIHNhbWUgc2VtYW50aWNcbiAgICByb2xlLlxuICAgICovXG4gICAgbmFtZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBwcm9wcywgXG4gICAgLyoqXG4gICAgVGhlIGlkIG9mIHRoaXMgbm9kZSBpbiBpdHMgc2V0LiBDb3JyZXNwb25kcyB0byB0aGUgdGVybSBpZHNcbiAgICB1c2VkIGluIHRoZSBwYXJzZXIuXG4gICAgKi9cbiAgICBpZCwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBmbGFncyA9IDApIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgbm9kZSB0eXBlLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShzcGVjKSB7XG4gICAgICAgIGxldCBwcm9wcyA9IHNwZWMucHJvcHMgJiYgc3BlYy5wcm9wcy5sZW5ndGggPyBPYmplY3QuY3JlYXRlKG51bGwpIDogbm9Qcm9wcztcbiAgICAgICAgbGV0IGZsYWdzID0gKHNwZWMudG9wID8gMSAvKiBOb2RlRmxhZy5Ub3AgKi8gOiAwKSB8IChzcGVjLnNraXBwZWQgPyAyIC8qIE5vZGVGbGFnLlNraXBwZWQgKi8gOiAwKSB8XG4gICAgICAgICAgICAoc3BlYy5lcnJvciA/IDQgLyogTm9kZUZsYWcuRXJyb3IgKi8gOiAwKSB8IChzcGVjLm5hbWUgPT0gbnVsbCA/IDggLyogTm9kZUZsYWcuQW5vbnltb3VzICovIDogMCk7XG4gICAgICAgIGxldCB0eXBlID0gbmV3IE5vZGVUeXBlKHNwZWMubmFtZSB8fCBcIlwiLCBwcm9wcywgc3BlYy5pZCwgZmxhZ3MpO1xuICAgICAgICBpZiAoc3BlYy5wcm9wcylcbiAgICAgICAgICAgIGZvciAobGV0IHNyYyBvZiBzcGVjLnByb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNyYykpXG4gICAgICAgICAgICAgICAgICAgIHNyYyA9IHNyYyh0eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcmNbMF0ucGVyTm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuJ3Qgc3RvcmUgYSBwZXItbm9kZSBwcm9wIG9uIGEgbm9kZSB0eXBlXCIpO1xuICAgICAgICAgICAgICAgICAgICBwcm9wc1tzcmNbMF0uaWRdID0gc3JjWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHJpZXZlcyBhIG5vZGUgcHJvcCBmb3IgdGhpcyB0eXBlLiBXaWxsIHJldHVybiBgdW5kZWZpbmVkYCBpZlxuICAgIHRoZSBwcm9wIGlzbid0IHByZXNlbnQgb24gdGhpcyBub2RlLlxuICAgICovXG4gICAgcHJvcChwcm9wKSB7IHJldHVybiB0aGlzLnByb3BzW3Byb3AuaWRdOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgaXMgdGhlIHRvcCBub2RlIG9mIGEgZ3JhbW1hci5cbiAgICAqL1xuICAgIGdldCBpc1RvcCgpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgMSAvKiBOb2RlRmxhZy5Ub3AgKi8pID4gMDsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIG5vZGUgaXMgcHJvZHVjZWQgYnkgYSBza2lwIHJ1bGUuXG4gICAgKi9cbiAgICBnZXQgaXNTa2lwcGVkKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiAyIC8qIE5vZGVGbGFnLlNraXBwZWQgKi8pID4gMDsgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgaXMgYW4gZXJyb3Igbm9kZS5cbiAgICAqL1xuICAgIGdldCBpc0Vycm9yKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiA0IC8qIE5vZGVGbGFnLkVycm9yICovKSA+IDA7IH1cbiAgICAvKipcbiAgICBXaGVuIHRydWUsIHRoaXMgbm9kZSB0eXBlIGRvZXNuJ3QgY29ycmVzcG9uZCB0byBhIHVzZXItZGVjbGFyZWRcbiAgICBuYW1lZCBub2RlLCBmb3IgZXhhbXBsZSBiZWNhdXNlIGl0IGlzIHVzZWQgdG8gY2FjaGUgcmVwZXRpdGlvbi5cbiAgICAqL1xuICAgIGdldCBpc0Fub255bW91cygpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgOCAvKiBOb2RlRmxhZy5Bbm9ueW1vdXMgKi8pID4gMDsgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdHJ1ZSB3aGVuIHRoaXMgbm9kZSdzIG5hbWUgb3Igb25lIG9mIGl0c1xuICAgIFtncm91cHNdKCNjb21tb24uTm9kZVByb3BeZ3JvdXApIG1hdGNoZXMgdGhlIGdpdmVuIHN0cmluZy5cbiAgICAqL1xuICAgIGlzKG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uYW1lID09IG5hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBsZXQgZ3JvdXAgPSB0aGlzLnByb3AoTm9kZVByb3AuZ3JvdXApO1xuICAgICAgICAgICAgcmV0dXJuIGdyb3VwID8gZ3JvdXAuaW5kZXhPZihuYW1lKSA+IC0xIDogZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaWQgPT0gbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgZnVuY3Rpb24gZnJvbSBub2RlIHR5cGVzIHRvIGFyYml0cmFyeSB2YWx1ZXMgYnlcbiAgICBzcGVjaWZ5aW5nIGFuIG9iamVjdCB3aG9zZSBwcm9wZXJ0eSBuYW1lcyBhcmUgbm9kZSBvclxuICAgIFtncm91cF0oI2NvbW1vbi5Ob2RlUHJvcF5ncm91cCkgbmFtZXMuIE9mdGVuIHVzZWZ1bCB3aXRoXG4gICAgW2BOb2RlUHJvcC5hZGRgXSgjY29tbW9uLk5vZGVQcm9wLmFkZCkuIFlvdSBjYW4gcHV0IG11bHRpcGxlXG4gICAgbmFtZXMsIHNlcGFyYXRlZCBieSBzcGFjZXMsIGluIGEgc2luZ2xlIHByb3BlcnR5IG5hbWUgdG8gbWFwXG4gICAgbXVsdGlwbGUgbm9kZSBuYW1lcyB0byBhIHNpbmdsZSB2YWx1ZS5cbiAgICAqL1xuICAgIHN0YXRpYyBtYXRjaChtYXApIHtcbiAgICAgICAgbGV0IGRpcmVjdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gbWFwKVxuICAgICAgICAgICAgZm9yIChsZXQgbmFtZSBvZiBwcm9wLnNwbGl0KFwiIFwiKSlcbiAgICAgICAgICAgICAgICBkaXJlY3RbbmFtZV0gPSBtYXBbcHJvcF07XG4gICAgICAgIHJldHVybiAobm9kZSkgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgZ3JvdXBzID0gbm9kZS5wcm9wKE5vZGVQcm9wLmdyb3VwKSwgaSA9IC0xOyBpIDwgKGdyb3VwcyA/IGdyb3Vwcy5sZW5ndGggOiAwKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gZGlyZWN0W2kgPCAwID8gbm9kZS5uYW1lIDogZ3JvdXBzW2ldXTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG4vKipcbkFuIGVtcHR5IGR1bW15IG5vZGUgdHlwZSB0byB1c2Ugd2hlbiBubyBhY3R1YWwgdHlwZSBpcyBhdmFpbGFibGUuXG4qL1xuTm9kZVR5cGUubm9uZSA9IG5ldyBOb2RlVHlwZShcIlwiLCBPYmplY3QuY3JlYXRlKG51bGwpLCAwLCA4IC8qIE5vZGVGbGFnLkFub255bW91cyAqLyk7XG4vKipcbkEgbm9kZSBzZXQgaG9sZHMgYSBjb2xsZWN0aW9uIG9mIG5vZGUgdHlwZXMuIEl0IGlzIHVzZWQgdG9cbmNvbXBhY3RseSByZXByZXNlbnQgdHJlZXMgYnkgc3RvcmluZyB0aGVpciB0eXBlIGlkcywgcmF0aGVyIHRoYW4gYVxuZnVsbCBwb2ludGVyIHRvIHRoZSB0eXBlIG9iamVjdCwgaW4gYSBudW1lcmljIGFycmF5LiBFYWNoIHBhcnNlclxuW2hhc10oI2xyLkxSUGFyc2VyLm5vZGVTZXQpIGEgbm9kZSBzZXQsIGFuZCBbdHJlZVxuYnVmZmVyc10oI2NvbW1vbi5UcmVlQnVmZmVyKSBjYW4gb25seSBzdG9yZSBjb2xsZWN0aW9ucyBvZiBub2Rlc1xuZnJvbSB0aGUgc2FtZSBzZXQuIEEgc2V0IGNhbiBoYXZlIGEgbWF4aW11bSBvZiAyKioxNiAoNjU1MzYpIG5vZGVcbnR5cGVzIGluIGl0LCBzbyB0aGF0IHRoZSBpZHMgZml0IGludG8gMTYtYml0IHR5cGVkIGFycmF5IHNsb3RzLlxuKi9cbmNsYXNzIE5vZGVTZXQge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNldCB3aXRoIHRoZSBnaXZlbiB0eXBlcy4gVGhlIGBpZGAgcHJvcGVydHkgb2YgZWFjaFxuICAgIHR5cGUgc2hvdWxkIGNvcnJlc3BvbmQgdG8gaXRzIHBvc2l0aW9uIHdpdGhpbiB0aGUgYXJyYXkuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbm9kZSB0eXBlcyBpbiB0aGlzIHNldCwgYnkgaWQuXG4gICAgKi9cbiAgICB0eXBlcykge1xuICAgICAgICB0aGlzLnR5cGVzID0gdHlwZXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAodHlwZXNbaV0uaWQgIT0gaSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vZGUgdHlwZSBpZHMgc2hvdWxkIGNvcnJlc3BvbmQgdG8gYXJyYXkgcG9zaXRpb25zIHdoZW4gY3JlYXRpbmcgYSBub2RlIHNldFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgY29weSBvZiB0aGlzIHNldCB3aXRoIHNvbWUgbm9kZSBwcm9wZXJ0aWVzIGFkZGVkLiBUaGVcbiAgICBhcmd1bWVudHMgdG8gdGhpcyBtZXRob2QgY2FuIGJlIGNyZWF0ZWQgd2l0aFxuICAgIFtgTm9kZVByb3AuYWRkYF0oI2NvbW1vbi5Ob2RlUHJvcC5hZGQpLlxuICAgICovXG4gICAgZXh0ZW5kKC4uLnByb3BzKSB7XG4gICAgICAgIGxldCBuZXdUeXBlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCB0eXBlIG9mIHRoaXMudHlwZXMpIHtcbiAgICAgICAgICAgIGxldCBuZXdQcm9wcyA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGxldCBzb3VyY2Ugb2YgcHJvcHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWRkID0gc291cmNlKHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChhZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdQcm9wcylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgdHlwZS5wcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzW2FkZFswXS5pZF0gPSBhZGRbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3VHlwZXMucHVzaChuZXdQcm9wcyA/IG5ldyBOb2RlVHlwZSh0eXBlLm5hbWUsIG5ld1Byb3BzLCB0eXBlLmlkLCB0eXBlLmZsYWdzKSA6IHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTm9kZVNldChuZXdUeXBlcyk7XG4gICAgfVxufVxuY29uc3QgQ2FjaGVkTm9kZSA9IG5ldyBXZWFrTWFwKCksIENhY2hlZElubmVyTm9kZSA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbk9wdGlvbnMgdGhhdCBjb250cm9sIGl0ZXJhdGlvbi4gQ2FuIGJlIGNvbWJpbmVkIHdpdGggdGhlIGB8YFxub3BlcmF0b3IgdG8gZW5hYmxlIG11bHRpcGxlIG9uZXMuXG4qL1xudmFyIEl0ZXJNb2RlO1xuKGZ1bmN0aW9uIChJdGVyTW9kZSkge1xuICAgIC8qKlxuICAgIFdoZW4gZW5hYmxlZCwgaXRlcmF0aW9uIHdpbGwgb25seSB2aXNpdCBbYFRyZWVgXSgjY29tbW9uLlRyZWUpXG4gICAgb2JqZWN0cywgbm90IG5vZGVzIHBhY2tlZCBpbnRvXG4gICAgW2BUcmVlQnVmZmVyYF0oI2NvbW1vbi5UcmVlQnVmZmVyKXMuXG4gICAgKi9cbiAgICBJdGVyTW9kZVtJdGVyTW9kZVtcIkV4Y2x1ZGVCdWZmZXJzXCJdID0gMV0gPSBcIkV4Y2x1ZGVCdWZmZXJzXCI7XG4gICAgLyoqXG4gICAgRW5hYmxlIHRoaXMgdG8gbWFrZSBpdGVyYXRpb24gaW5jbHVkZSBhbm9ueW1vdXMgbm9kZXMgKHN1Y2ggYXNcbiAgICB0aGUgbm9kZXMgdGhhdCB3cmFwIHJlcGVhdGVkIGdyYW1tYXIgY29uc3RydWN0cyBpbnRvIGEgYmFsYW5jZWRcbiAgICB0cmVlKS5cbiAgICAqL1xuICAgIEl0ZXJNb2RlW0l0ZXJNb2RlW1wiSW5jbHVkZUFub255bW91c1wiXSA9IDJdID0gXCJJbmNsdWRlQW5vbnltb3VzXCI7XG4gICAgLyoqXG4gICAgQnkgZGVmYXVsdCwgcmVndWxhciBbbW91bnRlZF0oI2NvbW1vbi5Ob2RlUHJvcF5tb3VudGVkKSBub2Rlc1xuICAgIHJlcGxhY2UgdGhlaXIgYmFzZSBub2RlIGluIGl0ZXJhdGlvbi4gRW5hYmxlIHRoaXMgdG8gaWdub3JlIHRoZW1cbiAgICBpbnN0ZWFkLlxuICAgICovXG4gICAgSXRlck1vZGVbSXRlck1vZGVbXCJJZ25vcmVNb3VudHNcIl0gPSA0XSA9IFwiSWdub3JlTW91bnRzXCI7XG4gICAgLyoqXG4gICAgVGhpcyBvcHRpb24gb25seSBhcHBsaWVzIGluXG4gICAgW2BlbnRlcmBdKCNjb21tb24uU3ludGF4Tm9kZS5lbnRlciktc3R5bGUgbWV0aG9kcy4gSXQgdGVsbHMgdGhlXG4gICAgbGlicmFyeSB0byBub3QgZW50ZXIgbW91bnRlZCBvdmVybGF5cyBpZiBvbmUgY292ZXJzIHRoZSBnaXZlblxuICAgIHBvc2l0aW9uLlxuICAgICovXG4gICAgSXRlck1vZGVbSXRlck1vZGVbXCJJZ25vcmVPdmVybGF5c1wiXSA9IDhdID0gXCJJZ25vcmVPdmVybGF5c1wiO1xufSkoSXRlck1vZGUgfHwgKEl0ZXJNb2RlID0ge30pKTtcbi8qKlxuQSBwaWVjZSBvZiBzeW50YXggdHJlZS4gVGhlcmUgYXJlIHR3byB3YXlzIHRvIGFwcHJvYWNoIHRoZXNlXG50cmVlczogdGhlIHdheSB0aGV5IGFyZSBhY3R1YWxseSBzdG9yZWQgaW4gbWVtb3J5LCBhbmQgdGhlXG5jb252ZW5pZW50IHdheS5cblxuU3ludGF4IHRyZWVzIGFyZSBzdG9yZWQgYXMgYSB0cmVlIG9mIGBUcmVlYCBhbmQgYFRyZWVCdWZmZXJgXG5vYmplY3RzLiBCeSBwYWNraW5nIGRldGFpbCBpbmZvcm1hdGlvbiBpbnRvIGBUcmVlQnVmZmVyYCBsZWFmXG5ub2RlcywgdGhlIHJlcHJlc2VudGF0aW9uIGlzIG1hZGUgYSBsb3QgbW9yZSBtZW1vcnktZWZmaWNpZW50LlxuXG5Ib3dldmVyLCB3aGVuIHlvdSB3YW50IHRvIGFjdHVhbGx5IHdvcmsgd2l0aCB0cmVlIG5vZGVzLCB0aGlzXG5yZXByZXNlbnRhdGlvbiBpcyB2ZXJ5IGF3a3dhcmQsIHNvIG1vc3QgY2xpZW50IGNvZGUgd2lsbCB3YW50IHRvXG51c2UgdGhlIFtgVHJlZUN1cnNvcmBdKCNjb21tb24uVHJlZUN1cnNvcikgb3JcbltgU3ludGF4Tm9kZWBdKCNjb21tb24uU3ludGF4Tm9kZSkgaW50ZXJmYWNlIGluc3RlYWQsIHdoaWNoIHByb3ZpZGVzXG5hIHZpZXcgb24gc29tZSBwYXJ0IG9mIHRoaXMgZGF0YSBzdHJ1Y3R1cmUsIGFuZCBjYW4gYmUgdXNlZCB0b1xubW92ZSBhcm91bmQgdG8gYWRqYWNlbnQgbm9kZXMuXG4qL1xuY2xhc3MgVHJlZSB7XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGEgbmV3IHRyZWUuIFNlZSBhbHNvIFtgVHJlZS5idWlsZGBdKCNjb21tb24uVHJlZV5idWlsZCkuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgdHlwZSBvZiB0aGUgdG9wIG5vZGUuXG4gICAgKi9cbiAgICB0eXBlLCBcbiAgICAvKipcbiAgICBUaGlzIG5vZGUncyBjaGlsZCBub2Rlcy5cbiAgICAqL1xuICAgIGNoaWxkcmVuLCBcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb25zIChvZmZzZXRzIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGlzIHRyZWUpIG9mXG4gICAgdGhlIGNoaWxkcmVuLlxuICAgICovXG4gICAgcG9zaXRpb25zLCBcbiAgICAvKipcbiAgICBUaGUgdG90YWwgbGVuZ3RoIG9mIHRoaXMgdHJlZVxuICAgICovXG4gICAgbGVuZ3RoLCBcbiAgICAvKipcbiAgICBQZXItbm9kZSBbbm9kZSBwcm9wc10oI2NvbW1vbi5Ob2RlUHJvcCkgdG8gYXNzb2NpYXRlIHdpdGggdGhpcyBub2RlLlxuICAgICovXG4gICAgcHJvcHMpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLnBvc2l0aW9ucyA9IHBvc2l0aW9ucztcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm9wcyA9IG51bGw7XG4gICAgICAgIGlmIChwcm9wcyAmJiBwcm9wcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgZm9yIChsZXQgW3Byb3AsIHZhbHVlXSBvZiBwcm9wcylcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzW3R5cGVvZiBwcm9wID09IFwibnVtYmVyXCIgPyBwcm9wIDogcHJvcC5pZF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgbW91bnRlZCA9IE1vdW50ZWRUcmVlLmdldCh0aGlzKTtcbiAgICAgICAgaWYgKG1vdW50ZWQgJiYgIW1vdW50ZWQub3ZlcmxheSlcbiAgICAgICAgICAgIHJldHVybiBtb3VudGVkLnRyZWUudG9TdHJpbmcoKTtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgY2ggb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgbGV0IHN0ciA9IGNoLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAoc3RyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuKVxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiArPSBcIixcIjtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiArPSBzdHI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICF0aGlzLnR5cGUubmFtZSA/IGNoaWxkcmVuIDpcbiAgICAgICAgICAgICgvXFxXLy50ZXN0KHRoaXMudHlwZS5uYW1lKSAmJiAhdGhpcy50eXBlLmlzRXJyb3IgPyBKU09OLnN0cmluZ2lmeSh0aGlzLnR5cGUubmFtZSkgOiB0aGlzLnR5cGUubmFtZSkgK1xuICAgICAgICAgICAgICAgIChjaGlsZHJlbi5sZW5ndGggPyBcIihcIiArIGNoaWxkcmVuICsgXCIpXCIgOiBcIlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgW3RyZWUgY3Vyc29yXSgjY29tbW9uLlRyZWVDdXJzb3IpIHBvc2l0aW9uZWQgYXQgdGhlIHRvcCBvZlxuICAgIHRoZSB0cmVlLiBNb2RlIGNhbiBiZSB1c2VkIHRvIFtjb250cm9sXSgjY29tbW9uLkl0ZXJNb2RlKSB3aGljaFxuICAgIG5vZGVzIHRoZSBjdXJzb3IgdmlzaXRzLlxuICAgICovXG4gICAgY3Vyc29yKG1vZGUgPSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZUN1cnNvcih0aGlzLnRvcE5vZGUsIG1vZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBbdHJlZSBjdXJzb3JdKCNjb21tb24uVHJlZUN1cnNvcikgcG9pbnRpbmcgaW50byB0aGlzIHRyZWVcbiAgICBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIHNpZGUgKHNlZVxuICAgIFtgbW92ZVRvYF0oI2NvbW1vbi5UcmVlQ3Vyc29yLm1vdmVUbykuXG4gICAgKi9cbiAgICBjdXJzb3JBdChwb3MsIHNpZGUgPSAwLCBtb2RlID0gMCkge1xuICAgICAgICBsZXQgc2NvcGUgPSBDYWNoZWROb2RlLmdldCh0aGlzKSB8fCB0aGlzLnRvcE5vZGU7XG4gICAgICAgIGxldCBjdXJzb3IgPSBuZXcgVHJlZUN1cnNvcihzY29wZSk7XG4gICAgICAgIGN1cnNvci5tb3ZlVG8ocG9zLCBzaWRlKTtcbiAgICAgICAgQ2FjaGVkTm9kZS5zZXQodGhpcywgY3Vyc29yLl90cmVlKTtcbiAgICAgICAgcmV0dXJuIGN1cnNvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgW3N5bnRheCBub2RlXSgjY29tbW9uLlN5bnRheE5vZGUpIG9iamVjdCBmb3IgdGhlIHRvcCBvZiB0aGVcbiAgICB0cmVlLlxuICAgICovXG4gICAgZ2V0IHRvcE5vZGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZU5vZGUodGhpcywgMCwgMCwgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgW3N5bnRheCBub2RlXSgjY29tbW9uLlN5bnRheE5vZGUpIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICBJZiBgc2lkZWAgaXMgLTEsIHRoaXMgd2lsbCBtb3ZlIGludG8gbm9kZXMgdGhhdCBlbmQgYXQgdGhlXG4gICAgcG9zaXRpb24uIElmIDEsIGl0J2xsIG1vdmUgaW50byBub2RlcyB0aGF0IHN0YXJ0IGF0IHRoZVxuICAgIHBvc2l0aW9uLiBXaXRoIDAsIGl0J2xsIG9ubHkgZW50ZXIgbm9kZXMgdGhhdCBjb3ZlciB0aGUgcG9zaXRpb25cbiAgICBmcm9tIGJvdGggc2lkZXMuXG4gICAgXG4gICAgTm90ZSB0aGF0IHRoaXMgd2lsbCBub3QgZW50ZXJcbiAgICBbb3ZlcmxheXNdKCNjb21tb24uTW91bnRlZFRyZWUub3ZlcmxheSksIGFuZCB5b3Ugb2Z0ZW4gd2FudFxuICAgIFtgcmVzb2x2ZUlubmVyYF0oI2NvbW1vbi5UcmVlLnJlc29sdmVJbm5lcikgaW5zdGVhZC5cbiAgICAqL1xuICAgIHJlc29sdmUocG9zLCBzaWRlID0gMCkge1xuICAgICAgICBsZXQgbm9kZSA9IHJlc29sdmVOb2RlKENhY2hlZE5vZGUuZ2V0KHRoaXMpIHx8IHRoaXMudG9wTm9kZSwgcG9zLCBzaWRlLCBmYWxzZSk7XG4gICAgICAgIENhY2hlZE5vZGUuc2V0KHRoaXMsIG5vZGUpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgTGlrZSBbYHJlc29sdmVgXSgjY29tbW9uLlRyZWUucmVzb2x2ZSksIGJ1dCB3aWxsIGVudGVyXG4gICAgW292ZXJsYWlkXSgjY29tbW9uLk1vdW50ZWRUcmVlLm92ZXJsYXkpIG5vZGVzLCBwcm9kdWNpbmcgYSBzeW50YXggbm9kZVxuICAgIHBvaW50aW5nIGludG8gdGhlIGlubmVybW9zdCBvdmVybGFpZCB0cmVlIGF0IHRoZSBnaXZlbiBwb3NpdGlvblxuICAgICh3aXRoIHBhcmVudCBsaW5rcyBnb2luZyB0aHJvdWdoIGFsbCBwYXJlbnQgc3RydWN0dXJlLCBpbmNsdWRpbmdcbiAgICB0aGUgaG9zdCB0cmVlcykuXG4gICAgKi9cbiAgICByZXNvbHZlSW5uZXIocG9zLCBzaWRlID0gMCkge1xuICAgICAgICBsZXQgbm9kZSA9IHJlc29sdmVOb2RlKENhY2hlZElubmVyTm9kZS5nZXQodGhpcykgfHwgdGhpcy50b3BOb2RlLCBwb3MsIHNpZGUsIHRydWUpO1xuICAgICAgICBDYWNoZWRJbm5lck5vZGUuc2V0KHRoaXMsIG5vZGUpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgSW4gc29tZSBzaXR1YXRpb25zLCBpdCBjYW4gYmUgdXNlZnVsIHRvIGl0ZXJhdGUgdGhyb3VnaCBhbGxcbiAgICBub2RlcyBhcm91bmQgYSBwb3NpdGlvbiwgaW5jbHVkaW5nIHRob3NlIGluIG92ZXJsYXlzIHRoYXQgZG9uJ3RcbiAgICBkaXJlY3RseSBjb3ZlciB0aGUgcG9zaXRpb24uIFRoaXMgbWV0aG9kIGdpdmVzIHlvdSBhbiBpdGVyYXRvclxuICAgIHRoYXQgd2lsbCBwcm9kdWNlIGFsbCBub2RlcywgZnJvbSBzbWFsbCB0byBiaWcsIGFyb3VuZCB0aGUgZ2l2ZW5cbiAgICBwb3NpdGlvbi5cbiAgICAqL1xuICAgIHJlc29sdmVTdGFjayhwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIHJldHVybiBzdGFja0l0ZXJhdG9yKHRoaXMsIHBvcywgc2lkZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgdHJlZSBhbmQgaXRzIGNoaWxkcmVuLCBjYWxsaW5nIGBlbnRlcmAgZm9yIGFueVxuICAgIG5vZGUgdGhhdCB0b3VjaGVzIHRoZSBgZnJvbWAvYHRvYCByZWdpb24gKGlmIGdpdmVuKSBiZWZvcmVcbiAgICBydW5uaW5nIG92ZXIgc3VjaCBhIG5vZGUncyBjaGlsZHJlbiwgYW5kIGBsZWF2ZWAgKGlmIGdpdmVuKSB3aGVuXG4gICAgbGVhdmluZyB0aGUgbm9kZS4gV2hlbiBgZW50ZXJgIHJldHVybnMgYGZhbHNlYCwgdGhhdCBub2RlIHdpbGxcbiAgICBub3QgaGF2ZSBpdHMgY2hpbGRyZW4gaXRlcmF0ZWQgb3ZlciAob3IgYGxlYXZlYCBjYWxsZWQpLlxuICAgICovXG4gICAgaXRlcmF0ZShzcGVjKSB7XG4gICAgICAgIGxldCB7IGVudGVyLCBsZWF2ZSwgZnJvbSA9IDAsIHRvID0gdGhpcy5sZW5ndGggfSA9IHNwZWM7XG4gICAgICAgIGxldCBtb2RlID0gc3BlYy5tb2RlIHx8IDAsIGFub24gPSAobW9kZSAmIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpID4gMDtcbiAgICAgICAgZm9yIChsZXQgYyA9IHRoaXMuY3Vyc29yKG1vZGUgfCBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKTs7KSB7XG4gICAgICAgICAgICBsZXQgZW50ZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGMuZnJvbSA8PSB0byAmJiBjLnRvID49IGZyb20gJiYgKCFhbm9uICYmIGMudHlwZS5pc0Fub255bW91cyB8fCBlbnRlcihjKSAhPT0gZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMuZmlyc3RDaGlsZCgpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBlbnRlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBpZiAoZW50ZXJlZCAmJiBsZWF2ZSAmJiAoYW5vbiB8fCAhYy50eXBlLmlzQW5vbnltb3VzKSlcbiAgICAgICAgICAgICAgICAgICAgbGVhdmUoYyk7XG4gICAgICAgICAgICAgICAgaWYgKGMubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKCFjLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgZW50ZXJlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gW25vZGUgcHJvcF0oI2NvbW1vbi5Ob2RlUHJvcCkgZm9yIHRoaXNcbiAgICBub2RlLiBXb3JrcyB3aXRoIGJvdGggcGVyLW5vZGUgYW5kIHBlci10eXBlIHByb3BzLlxuICAgICovXG4gICAgcHJvcChwcm9wKSB7XG4gICAgICAgIHJldHVybiAhcHJvcC5wZXJOb2RlID8gdGhpcy50eXBlLnByb3AocHJvcCkgOiB0aGlzLnByb3BzID8gdGhpcy5wcm9wc1twcm9wLmlkXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0aGUgbm9kZSdzIFtwZXItbm9kZSBwcm9wc10oI2NvbW1vbi5Ob2RlUHJvcC5wZXJOb2RlKSBpbiBhXG4gICAgZm9ybWF0IHRoYXQgY2FuIGJlIHBhc3NlZCB0byB0aGUgW2BUcmVlYF0oI2NvbW1vbi5UcmVlKVxuICAgIGNvbnN0cnVjdG9yLlxuICAgICovXG4gICAgZ2V0IHByb3BWYWx1ZXMoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMpXG4gICAgICAgICAgICBmb3IgKGxldCBpZCBpbiB0aGlzLnByb3BzKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFsraWQsIHRoaXMucHJvcHNbaWRdXSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEJhbGFuY2UgdGhlIGRpcmVjdCBjaGlsZHJlbiBvZiB0aGlzIHRyZWUsIHByb2R1Y2luZyBhIGNvcHkgb2ZcbiAgICB3aGljaCBtYXkgaGF2ZSBjaGlsZHJlbiBncm91cGVkIGludG8gc3VidHJlZXMgd2l0aCB0eXBlXG4gICAgW2BOb2RlVHlwZS5ub25lYF0oI2NvbW1vbi5Ob2RlVHlwZV5ub25lKS5cbiAgICAqL1xuICAgIGJhbGFuY2UoY29uZmlnID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4ubGVuZ3RoIDw9IDggLyogQmFsYW5jZS5CcmFuY2hGYWN0b3IgKi8gPyB0aGlzIDpcbiAgICAgICAgICAgIGJhbGFuY2VSYW5nZShOb2RlVHlwZS5ub25lLCB0aGlzLmNoaWxkcmVuLCB0aGlzLnBvc2l0aW9ucywgMCwgdGhpcy5jaGlsZHJlbi5sZW5ndGgsIDAsIHRoaXMubGVuZ3RoLCAoY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKSA9PiBuZXcgVHJlZSh0aGlzLnR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCwgdGhpcy5wcm9wVmFsdWVzKSwgY29uZmlnLm1ha2VUcmVlIHx8ICgoY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKSA9PiBuZXcgVHJlZShOb2RlVHlwZS5ub25lLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEJ1aWxkIGEgdHJlZSBmcm9tIGEgcG9zdGZpeC1vcmRlcmVkIGJ1ZmZlciBvZiBub2RlIGluZm9ybWF0aW9uLFxuICAgIG9yIGEgY3Vyc29yIG92ZXIgc3VjaCBhIGJ1ZmZlci5cbiAgICAqL1xuICAgIHN0YXRpYyBidWlsZChkYXRhKSB7IHJldHVybiBidWlsZFRyZWUoZGF0YSk7IH1cbn1cbi8qKlxuVGhlIGVtcHR5IHRyZWVcbiovXG5UcmVlLmVtcHR5ID0gbmV3IFRyZWUoTm9kZVR5cGUubm9uZSwgW10sIFtdLCAwKTtcbmNsYXNzIEZsYXRCdWZmZXJDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGJ1ZmZlciwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB9XG4gICAgZ2V0IGlkKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDRdOyB9XG4gICAgZ2V0IHN0YXJ0KCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDNdOyB9XG4gICAgZ2V0IGVuZCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAyXTsgfVxuICAgIGdldCBzaXplKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDFdOyB9XG4gICAgZ2V0IHBvcygpIHsgcmV0dXJuIHRoaXMuaW5kZXg7IH1cbiAgICBuZXh0KCkgeyB0aGlzLmluZGV4IC09IDQ7IH1cbiAgICBmb3JrKCkgeyByZXR1cm4gbmV3IEZsYXRCdWZmZXJDdXJzb3IodGhpcy5idWZmZXIsIHRoaXMuaW5kZXgpOyB9XG59XG4vKipcblRyZWUgYnVmZmVycyBjb250YWluICh0eXBlLCBzdGFydCwgZW5kLCBlbmRJbmRleCkgcXVhZHMgZm9yIGVhY2hcbm5vZGUuIEluIHN1Y2ggYSBidWZmZXIsIG5vZGVzIGFyZSBzdG9yZWQgaW4gcHJlZml4IG9yZGVyIChwYXJlbnRzXG5iZWZvcmUgY2hpbGRyZW4sIHdpdGggdGhlIGVuZEluZGV4IG9mIHRoZSBwYXJlbnQgaW5kaWNhdGluZyB3aGljaFxuY2hpbGRyZW4gYmVsb25nIHRvIGl0KS5cbiovXG5jbGFzcyBUcmVlQnVmZmVyIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSB0cmVlIGJ1ZmZlci5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBidWZmZXIncyBjb250ZW50LlxuICAgICovXG4gICAgYnVmZmVyLCBcbiAgICAvKipcbiAgICBUaGUgdG90YWwgbGVuZ3RoIG9mIHRoZSBncm91cCBvZiBub2RlcyBpbiB0aGUgYnVmZmVyLlxuICAgICovXG4gICAgbGVuZ3RoLCBcbiAgICAvKipcbiAgICBUaGUgbm9kZSBzZXQgdXNlZCBpbiB0aGlzIGJ1ZmZlci5cbiAgICAqL1xuICAgIHNldCkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMuc2V0ID0gc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCB0eXBlKCkgeyByZXR1cm4gTm9kZVR5cGUubm9uZTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuYnVmZmVyLmxlbmd0aDspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuY2hpbGRTdHJpbmcoaW5kZXgpKTtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5idWZmZXJbaW5kZXggKyAzXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCIsXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNoaWxkU3RyaW5nKGluZGV4KSB7XG4gICAgICAgIGxldCBpZCA9IHRoaXMuYnVmZmVyW2luZGV4XSwgZW5kSW5kZXggPSB0aGlzLmJ1ZmZlcltpbmRleCArIDNdO1xuICAgICAgICBsZXQgdHlwZSA9IHRoaXMuc2V0LnR5cGVzW2lkXSwgcmVzdWx0ID0gdHlwZS5uYW1lO1xuICAgICAgICBpZiAoL1xcVy8udGVzdChyZXN1bHQpICYmICF0eXBlLmlzRXJyb3IpXG4gICAgICAgICAgICByZXN1bHQgPSBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgICAgICBpbmRleCArPSA0O1xuICAgICAgICBpZiAoZW5kSW5kZXggPT0gaW5kZXgpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgZW5kSW5kZXgpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy5jaGlsZFN0cmluZyhpbmRleCkpO1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmJ1ZmZlcltpbmRleCArIDNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQgKyBcIihcIiArIGNoaWxkcmVuLmpvaW4oXCIsXCIpICsgXCIpXCI7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZmluZENoaWxkKHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBkaXIsIHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMsIHBpY2sgPSAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgIT0gZW5kSW5kZXg7IGkgPSBidWZmZXJbaSArIDNdKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2tTaWRlKHNpZGUsIHBvcywgYnVmZmVyW2kgKyAxXSwgYnVmZmVyW2kgKyAyXSkpIHtcbiAgICAgICAgICAgICAgICBwaWNrID0gaTtcbiAgICAgICAgICAgICAgICBpZiAoZGlyID4gMClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBpY2s7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2xpY2Uoc3RhcnRJLCBlbmRJLCBmcm9tKSB7XG4gICAgICAgIGxldCBiID0gdGhpcy5idWZmZXI7XG4gICAgICAgIGxldCBjb3B5ID0gbmV3IFVpbnQxNkFycmF5KGVuZEkgLSBzdGFydEkpLCBsZW4gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJLCBqID0gMDsgaSA8IGVuZEk7KSB7XG4gICAgICAgICAgICBjb3B5W2orK10gPSBiW2krK107XG4gICAgICAgICAgICBjb3B5W2orK10gPSBiW2krK10gLSBmcm9tO1xuICAgICAgICAgICAgbGV0IHRvID0gY29weVtqKytdID0gYltpKytdIC0gZnJvbTtcbiAgICAgICAgICAgIGNvcHlbaisrXSA9IGJbaSsrXSAtIHN0YXJ0STtcbiAgICAgICAgICAgIGxlbiA9IE1hdGgubWF4KGxlbiwgdG8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVHJlZUJ1ZmZlcihjb3B5LCBsZW4sIHRoaXMuc2V0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja1NpZGUoc2lkZSwgcG9zLCBmcm9tLCB0bykge1xuICAgIHN3aXRjaCAoc2lkZSkge1xuICAgICAgICBjYXNlIC0yIC8qIFNpZGUuQmVmb3JlICovOiByZXR1cm4gZnJvbSA8IHBvcztcbiAgICAgICAgY2FzZSAtMSAvKiBTaWRlLkF0T3JCZWZvcmUgKi86IHJldHVybiB0byA+PSBwb3MgJiYgZnJvbSA8IHBvcztcbiAgICAgICAgY2FzZSAwIC8qIFNpZGUuQXJvdW5kICovOiByZXR1cm4gZnJvbSA8IHBvcyAmJiB0byA+IHBvcztcbiAgICAgICAgY2FzZSAxIC8qIFNpZGUuQXRPckFmdGVyICovOiByZXR1cm4gZnJvbSA8PSBwb3MgJiYgdG8gPiBwb3M7XG4gICAgICAgIGNhc2UgMiAvKiBTaWRlLkFmdGVyICovOiByZXR1cm4gdG8gPiBwb3M7XG4gICAgICAgIGNhc2UgNCAvKiBTaWRlLkRvbnRDYXJlICovOiByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXNvbHZlTm9kZShub2RlLCBwb3MsIHNpZGUsIG92ZXJsYXlzKSB7XG4gICAgdmFyIF9hO1xuICAgIC8vIE1vdmUgdXAgdG8gYSBub2RlIHRoYXQgYWN0dWFsbHkgaG9sZHMgdGhlIHBvc2l0aW9uLCBpZiBwb3NzaWJsZVxuICAgIHdoaWxlIChub2RlLmZyb20gPT0gbm9kZS50byB8fFxuICAgICAgICAoc2lkZSA8IDEgPyBub2RlLmZyb20gPj0gcG9zIDogbm9kZS5mcm9tID4gcG9zKSB8fFxuICAgICAgICAoc2lkZSA+IC0xID8gbm9kZS50byA8PSBwb3MgOiBub2RlLnRvIDwgcG9zKSkge1xuICAgICAgICBsZXQgcGFyZW50ID0gIW92ZXJsYXlzICYmIG5vZGUgaW5zdGFuY2VvZiBUcmVlTm9kZSAmJiBub2RlLmluZGV4IDwgMCA/IG51bGwgOiBub2RlLnBhcmVudDtcbiAgICAgICAgaWYgKCFwYXJlbnQpXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICB9XG4gICAgbGV0IG1vZGUgPSBvdmVybGF5cyA/IDAgOiBJdGVyTW9kZS5JZ25vcmVPdmVybGF5cztcbiAgICAvLyBNdXN0IGdvIHVwIG91dCBvZiBvdmVybGF5cyB3aGVuIHRob3NlIGRvIG5vdCBvdmVybGFwIHdpdGggcG9zXG4gICAgaWYgKG92ZXJsYXlzKVxuICAgICAgICBmb3IgKGxldCBzY2FuID0gbm9kZSwgcGFyZW50ID0gc2Nhbi5wYXJlbnQ7IHBhcmVudDsgc2NhbiA9IHBhcmVudCwgcGFyZW50ID0gc2Nhbi5wYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChzY2FuIGluc3RhbmNlb2YgVHJlZU5vZGUgJiYgc2Nhbi5pbmRleCA8IDAgJiYgKChfYSA9IHBhcmVudC5lbnRlcihwb3MsIHNpZGUsIG1vZGUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZnJvbSkgIT0gc2Nhbi5mcm9tKVxuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGxldCBpbm5lciA9IG5vZGUuZW50ZXIocG9zLCBzaWRlLCBtb2RlKTtcbiAgICAgICAgaWYgKCFpbm5lcilcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBub2RlID0gaW5uZXI7XG4gICAgfVxufVxuY2xhc3MgQmFzZU5vZGUge1xuICAgIGN1cnNvcihtb2RlID0gMCkgeyByZXR1cm4gbmV3IFRyZWVDdXJzb3IodGhpcywgbW9kZSk7IH1cbiAgICBnZXRDaGlsZCh0eXBlLCBiZWZvcmUgPSBudWxsLCBhZnRlciA9IG51bGwpIHtcbiAgICAgICAgbGV0IHIgPSBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICAgICAgcmV0dXJuIHIubGVuZ3RoID8gclswXSA6IG51bGw7XG4gICAgfVxuICAgIGdldENoaWxkcmVuKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZ2V0Q2hpbGRyZW4odGhpcywgdHlwZSwgYmVmb3JlLCBhZnRlcik7XG4gICAgfVxuICAgIHJlc29sdmUocG9zLCBzaWRlID0gMCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZU5vZGUodGhpcywgcG9zLCBzaWRlLCBmYWxzZSk7XG4gICAgfVxuICAgIHJlc29sdmVJbm5lcihwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlTm9kZSh0aGlzLCBwb3MsIHNpZGUsIHRydWUpO1xuICAgIH1cbiAgICBtYXRjaENvbnRleHQoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbWF0Y2hOb2RlQ29udGV4dCh0aGlzLnBhcmVudCwgY29udGV4dCk7XG4gICAgfVxuICAgIGVudGVyVW5maW5pc2hlZE5vZGVzQmVmb3JlKHBvcykge1xuICAgICAgICBsZXQgc2NhbiA9IHRoaXMuY2hpbGRCZWZvcmUocG9zKSwgbm9kZSA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChzY2FuKSB7XG4gICAgICAgICAgICBsZXQgbGFzdCA9IHNjYW4ubGFzdENoaWxkO1xuICAgICAgICAgICAgaWYgKCFsYXN0IHx8IGxhc3QudG8gIT0gc2Nhbi50bylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChsYXN0LnR5cGUuaXNFcnJvciAmJiBsYXN0LmZyb20gPT0gbGFzdC50bykge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBzY2FuO1xuICAgICAgICAgICAgICAgIHNjYW4gPSBsYXN0LnByZXZTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2NhbiA9IGxhc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGdldCBub2RlKCkgeyByZXR1cm4gdGhpczsgfVxuICAgIGdldCBuZXh0KCkgeyByZXR1cm4gdGhpcy5wYXJlbnQ7IH1cbn1cbmNsYXNzIFRyZWVOb2RlIGV4dGVuZHMgQmFzZU5vZGUge1xuICAgIGNvbnN0cnVjdG9yKF90cmVlLCBmcm9tLCBcbiAgICAvLyBJbmRleCBpbiBwYXJlbnQgbm9kZSwgc2V0IHRvIC0xIGlmIHRoZSBub2RlIGlzIG5vdCBhIGRpcmVjdCBjaGlsZCBvZiBfcGFyZW50Lm5vZGUgKG92ZXJsYXkpXG4gICAgaW5kZXgsIF9wYXJlbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fdHJlZSA9IF90cmVlO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgfVxuICAgIGdldCB0eXBlKCkgeyByZXR1cm4gdGhpcy5fdHJlZS50eXBlOyB9XG4gICAgZ2V0IG5hbWUoKSB7IHJldHVybiB0aGlzLl90cmVlLnR5cGUubmFtZTsgfVxuICAgIGdldCB0bygpIHsgcmV0dXJuIHRoaXMuZnJvbSArIHRoaXMuX3RyZWUubGVuZ3RoOyB9XG4gICAgbmV4dENoaWxkKGksIGRpciwgcG9zLCBzaWRlLCBtb2RlID0gMCkge1xuICAgICAgICBmb3IgKGxldCBwYXJlbnQgPSB0aGlzOzspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHsgY2hpbGRyZW4sIHBvc2l0aW9ucyB9ID0gcGFyZW50Ll90cmVlLCBlID0gZGlyID4gMCA/IGNoaWxkcmVuLmxlbmd0aCA6IC0xOyBpICE9IGU7IGkgKz0gZGlyKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBjaGlsZHJlbltpXSwgc3RhcnQgPSBwb3NpdGlvbnNbaV0gKyBwYXJlbnQuZnJvbTtcbiAgICAgICAgICAgICAgICBpZiAoIWNoZWNrU2lkZShzaWRlLCBwb3MsIHN0YXJ0LCBzdGFydCArIG5leHQubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgaW5zdGFuY2VvZiBUcmVlQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlICYgSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gbmV4dC5maW5kQ2hpbGQoMCwgbmV4dC5idWZmZXIubGVuZ3RoLCBkaXIsIHBvcyAtIHN0YXJ0LCBzaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlck5vZGUobmV3IEJ1ZmZlckNvbnRleHQocGFyZW50LCBuZXh0LCBpLCBzdGFydCksIG51bGwsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKG1vZGUgJiBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKSB8fCAoIW5leHQudHlwZS5pc0Fub255bW91cyB8fCBoYXNDaGlsZChuZXh0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1vdW50ZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG1vZGUgJiBJdGVyTW9kZS5JZ25vcmVNb3VudHMpICYmIChtb3VudGVkID0gTW91bnRlZFRyZWUuZ2V0KG5leHQpKSAmJiAhbW91bnRlZC5vdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUcmVlTm9kZShtb3VudGVkLnRyZWUsIHN0YXJ0LCBpLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5uZXIgPSBuZXcgVHJlZU5vZGUobmV4dCwgc3RhcnQsIGksIHBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAobW9kZSAmIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpIHx8ICFpbm5lci50eXBlLmlzQW5vbnltb3VzID8gaW5uZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogaW5uZXIubmV4dENoaWxkKGRpciA8IDAgPyBuZXh0LmNoaWxkcmVuLmxlbmd0aCAtIDEgOiAwLCBkaXIsIHBvcywgc2lkZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChtb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgfHwgIXBhcmVudC50eXBlLmlzQW5vbnltb3VzKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKHBhcmVudC5pbmRleCA+PSAwKVxuICAgICAgICAgICAgICAgIGkgPSBwYXJlbnQuaW5kZXggKyBkaXI7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgaSA9IGRpciA8IDAgPyAtMSA6IHBhcmVudC5fcGFyZW50Ll90cmVlLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5fcGFyZW50O1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCgwLCAxLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pOyB9XG4gICAgZ2V0IGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMubmV4dENoaWxkKHRoaXMuX3RyZWUuY2hpbGRyZW4ubGVuZ3RoIC0gMSwgLTEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7IH1cbiAgICBjaGlsZEFmdGVyKHBvcykgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQoMCwgMSwgcG9zLCAyIC8qIFNpZGUuQWZ0ZXIgKi8pOyB9XG4gICAgY2hpbGRCZWZvcmUocG9zKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCh0aGlzLl90cmVlLmNoaWxkcmVuLmxlbmd0aCAtIDEsIC0xLCBwb3MsIC0yIC8qIFNpZGUuQmVmb3JlICovKTsgfVxuICAgIGVudGVyKHBvcywgc2lkZSwgbW9kZSA9IDApIHtcbiAgICAgICAgbGV0IG1vdW50ZWQ7XG4gICAgICAgIGlmICghKG1vZGUgJiBJdGVyTW9kZS5JZ25vcmVPdmVybGF5cykgJiYgKG1vdW50ZWQgPSBNb3VudGVkVHJlZS5nZXQodGhpcy5fdHJlZSkpICYmIG1vdW50ZWQub3ZlcmxheSkge1xuICAgICAgICAgICAgbGV0IHJQb3MgPSBwb3MgLSB0aGlzLmZyb207XG4gICAgICAgICAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2YgbW91bnRlZC5vdmVybGF5KSB7XG4gICAgICAgICAgICAgICAgaWYgKChzaWRlID4gMCA/IGZyb20gPD0gclBvcyA6IGZyb20gPCByUG9zKSAmJlxuICAgICAgICAgICAgICAgICAgICAoc2lkZSA8IDAgPyB0byA+PSByUG9zIDogdG8gPiByUG9zKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUcmVlTm9kZShtb3VudGVkLnRyZWUsIG1vdW50ZWQub3ZlcmxheVswXS5mcm9tICsgdGhpcy5mcm9tLCAtMSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dENoaWxkKDAsIDEsIHBvcywgc2lkZSwgbW9kZSk7XG4gICAgfVxuICAgIG5leHRTaWduaWZpY2FudFBhcmVudCgpIHtcbiAgICAgICAgbGV0IHZhbCA9IHRoaXM7XG4gICAgICAgIHdoaWxlICh2YWwudHlwZS5pc0Fub255bW91cyAmJiB2YWwuX3BhcmVudClcbiAgICAgICAgICAgIHZhbCA9IHZhbC5fcGFyZW50O1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICBnZXQgcGFyZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50Lm5leHRTaWduaWZpY2FudFBhcmVudCgpIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IG5leHRTaWJsaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ICYmIHRoaXMuaW5kZXggPj0gMCA/IHRoaXMuX3BhcmVudC5uZXh0Q2hpbGQodGhpcy5pbmRleCArIDEsIDEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLykgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgcHJldlNpYmxpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgJiYgdGhpcy5pbmRleCA+PSAwID8gdGhpcy5fcGFyZW50Lm5leHRDaGlsZCh0aGlzLmluZGV4IC0gMSwgLTEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLykgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgdHJlZSgpIHsgcmV0dXJuIHRoaXMuX3RyZWU7IH1cbiAgICB0b1RyZWUoKSB7IHJldHVybiB0aGlzLl90cmVlOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIHRoaXMuX3RyZWUudG9TdHJpbmcoKTsgfVxufVxuZnVuY3Rpb24gZ2V0Q2hpbGRyZW4obm9kZSwgdHlwZSwgYmVmb3JlLCBhZnRlcikge1xuICAgIGxldCBjdXIgPSBub2RlLmN1cnNvcigpLCByZXN1bHQgPSBbXTtcbiAgICBpZiAoIWN1ci5maXJzdENoaWxkKCkpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKGJlZm9yZSAhPSBudWxsKVxuICAgICAgICBmb3IgKGxldCBmb3VuZCA9IGZhbHNlOyAhZm91bmQ7KSB7XG4gICAgICAgICAgICBmb3VuZCA9IGN1ci50eXBlLmlzKGJlZm9yZSk7XG4gICAgICAgICAgICBpZiAoIWN1ci5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChhZnRlciAhPSBudWxsICYmIGN1ci50eXBlLmlzKGFmdGVyKSlcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGlmIChjdXIudHlwZS5pcyh0eXBlKSlcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1ci5ub2RlKTtcbiAgICAgICAgaWYgKCFjdXIubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgIHJldHVybiBhZnRlciA9PSBudWxsID8gcmVzdWx0IDogW107XG4gICAgfVxufVxuZnVuY3Rpb24gbWF0Y2hOb2RlQ29udGV4dChub2RlLCBjb250ZXh0LCBpID0gY29udGV4dC5sZW5ndGggLSAxKSB7XG4gICAgZm9yIChsZXQgcCA9IG5vZGU7IGkgPj0gMDsgcCA9IHAucGFyZW50KSB7XG4gICAgICAgIGlmICghcClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFwLnR5cGUuaXNBbm9ueW1vdXMpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0W2ldICYmIGNvbnRleHRbaV0gIT0gcC5uYW1lKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNsYXNzIEJ1ZmZlckNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgYnVmZmVyLCBpbmRleCwgc3RhcnQpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICB9XG59XG5jbGFzcyBCdWZmZXJOb2RlIGV4dGVuZHMgQmFzZU5vZGUge1xuICAgIGdldCBuYW1lKCkgeyByZXR1cm4gdGhpcy50eXBlLm5hbWU7IH1cbiAgICBnZXQgZnJvbSgpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5zdGFydCArIHRoaXMuY29udGV4dC5idWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAxXTsgfVxuICAgIGdldCB0bygpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5zdGFydCArIHRoaXMuY29udGV4dC5idWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAyXTsgfVxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIF9wYXJlbnQsIGluZGV4KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy50eXBlID0gY29udGV4dC5idWZmZXIuc2V0LnR5cGVzW2NvbnRleHQuYnVmZmVyLmJ1ZmZlcltpbmRleF1dO1xuICAgIH1cbiAgICBjaGlsZChkaXIsIHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGluZGV4ID0gYnVmZmVyLmZpbmRDaGlsZCh0aGlzLmluZGV4ICsgNCwgYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM10sIGRpciwgcG9zIC0gdGhpcy5jb250ZXh0LnN0YXJ0LCBzaWRlKTtcbiAgICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IG51bGwgOiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMsIGluZGV4KTtcbiAgICB9XG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNoaWxkKDEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7IH1cbiAgICBnZXQgbGFzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5jaGlsZCgtMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKTsgfVxuICAgIGNoaWxkQWZ0ZXIocG9zKSB7IHJldHVybiB0aGlzLmNoaWxkKDEsIHBvcywgMiAvKiBTaWRlLkFmdGVyICovKTsgfVxuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5jaGlsZCgtMSwgcG9zLCAtMiAvKiBTaWRlLkJlZm9yZSAqLyk7IH1cbiAgICBlbnRlcihwb3MsIHNpZGUsIG1vZGUgPSAwKSB7XG4gICAgICAgIGlmIChtb2RlICYgSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBpbmRleCA9IGJ1ZmZlci5maW5kQ2hpbGQodGhpcy5pbmRleCArIDQsIGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdLCBzaWRlID4gMCA/IDEgOiAtMSwgcG9zIC0gdGhpcy5jb250ZXh0LnN0YXJ0LCBzaWRlKTtcbiAgICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IG51bGwgOiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMsIGluZGV4KTtcbiAgICB9XG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCB8fCB0aGlzLmNvbnRleHQucGFyZW50Lm5leHRTaWduaWZpY2FudFBhcmVudCgpO1xuICAgIH1cbiAgICBleHRlcm5hbFNpYmxpbmcoZGlyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPyBudWxsIDogdGhpcy5jb250ZXh0LnBhcmVudC5uZXh0Q2hpbGQodGhpcy5jb250ZXh0LmluZGV4ICsgZGlyLCBkaXIsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7XG4gICAgfVxuICAgIGdldCBuZXh0U2libGluZygpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBhZnRlciA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICBpZiAoYWZ0ZXIgPCAodGhpcy5fcGFyZW50ID8gYnVmZmVyLmJ1ZmZlclt0aGlzLl9wYXJlbnQuaW5kZXggKyAzXSA6IGJ1ZmZlci5idWZmZXIubGVuZ3RoKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMuX3BhcmVudCwgYWZ0ZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5leHRlcm5hbFNpYmxpbmcoMSk7XG4gICAgfVxuICAgIGdldCBwcmV2U2libGluZygpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBwYXJlbnRTdGFydCA9IHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5pbmRleCArIDQgOiAwO1xuICAgICAgICBpZiAodGhpcy5pbmRleCA9PSBwYXJlbnRTdGFydClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4dGVybmFsU2libGluZygtMSk7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMuX3BhcmVudCwgYnVmZmVyLmZpbmRDaGlsZChwYXJlbnRTdGFydCwgdGhpcy5pbmRleCwgLTEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLykpO1xuICAgIH1cbiAgICBnZXQgdHJlZSgpIHsgcmV0dXJuIG51bGw7IH1cbiAgICB0b1RyZWUoKSB7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdLCBwb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBzdGFydEkgPSB0aGlzLmluZGV4ICsgNCwgZW5kSSA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICBpZiAoZW5kSSA+IHN0YXJ0SSkge1xuICAgICAgICAgICAgbGV0IGZyb20gPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAxXTtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goYnVmZmVyLnNsaWNlKHN0YXJ0SSwgZW5kSSwgZnJvbSkpO1xuICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlKHRoaXMudHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgdGhpcy50byAtIHRoaXMuZnJvbSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLmNvbnRleHQuYnVmZmVyLmNoaWxkU3RyaW5nKHRoaXMuaW5kZXgpOyB9XG59XG5mdW5jdGlvbiBpdGVyU3RhY2soaGVhZHMpIHtcbiAgICBpZiAoIWhlYWRzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHBpY2sgPSAwLCBwaWNrZWQgPSBoZWFkc1swXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGhlYWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBub2RlID0gaGVhZHNbaV07XG4gICAgICAgIGlmIChub2RlLmZyb20gPiBwaWNrZWQuZnJvbSB8fCBub2RlLnRvIDwgcGlja2VkLnRvKSB7XG4gICAgICAgICAgICBwaWNrZWQgPSBub2RlO1xuICAgICAgICAgICAgcGljayA9IGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IG5leHQgPSBwaWNrZWQgaW5zdGFuY2VvZiBUcmVlTm9kZSAmJiBwaWNrZWQuaW5kZXggPCAwID8gbnVsbCA6IHBpY2tlZC5wYXJlbnQ7XG4gICAgbGV0IG5ld0hlYWRzID0gaGVhZHMuc2xpY2UoKTtcbiAgICBpZiAobmV4dClcbiAgICAgICAgbmV3SGVhZHNbcGlja10gPSBuZXh0O1xuICAgIGVsc2VcbiAgICAgICAgbmV3SGVhZHMuc3BsaWNlKHBpY2ssIDEpO1xuICAgIHJldHVybiBuZXcgU3RhY2tJdGVyYXRvcihuZXdIZWFkcywgcGlja2VkKTtcbn1cbmNsYXNzIFN0YWNrSXRlcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGhlYWRzLCBub2RlKSB7XG4gICAgICAgIHRoaXMuaGVhZHMgPSBoZWFkcztcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB9XG4gICAgZ2V0IG5leHQoKSB7IHJldHVybiBpdGVyU3RhY2sodGhpcy5oZWFkcyk7IH1cbn1cbmZ1bmN0aW9uIHN0YWNrSXRlcmF0b3IodHJlZSwgcG9zLCBzaWRlKSB7XG4gICAgbGV0IGlubmVyID0gdHJlZS5yZXNvbHZlSW5uZXIocG9zLCBzaWRlKSwgbGF5ZXJzID0gbnVsbDtcbiAgICBmb3IgKGxldCBzY2FuID0gaW5uZXIgaW5zdGFuY2VvZiBUcmVlTm9kZSA/IGlubmVyIDogaW5uZXIuY29udGV4dC5wYXJlbnQ7IHNjYW47IHNjYW4gPSBzY2FuLnBhcmVudCkge1xuICAgICAgICBpZiAoc2Nhbi5pbmRleCA8IDApIHsgLy8gVGhpcyBpcyBhbiBvdmVybGF5IHJvb3RcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSBzY2FuLnBhcmVudDtcbiAgICAgICAgICAgIChsYXllcnMgfHwgKGxheWVycyA9IFtpbm5lcl0pKS5wdXNoKHBhcmVudC5yZXNvbHZlKHBvcywgc2lkZSkpO1xuICAgICAgICAgICAgc2NhbiA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtb3VudCA9IE1vdW50ZWRUcmVlLmdldChzY2FuLnRyZWUpO1xuICAgICAgICAgICAgLy8gUmVsZXZhbnQgb3ZlcmxheSBicmFuY2hpbmcgb2ZmXG4gICAgICAgICAgICBpZiAobW91bnQgJiYgbW91bnQub3ZlcmxheSAmJiBtb3VudC5vdmVybGF5WzBdLmZyb20gPD0gcG9zICYmIG1vdW50Lm92ZXJsYXlbbW91bnQub3ZlcmxheS5sZW5ndGggLSAxXS50byA+PSBwb3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgcm9vdCA9IG5ldyBUcmVlTm9kZShtb3VudC50cmVlLCBtb3VudC5vdmVybGF5WzBdLmZyb20gKyBzY2FuLmZyb20sIC0xLCBzY2FuKTtcbiAgICAgICAgICAgICAgICAobGF5ZXJzIHx8IChsYXllcnMgPSBbaW5uZXJdKSkucHVzaChyZXNvbHZlTm9kZShyb290LCBwb3MsIHNpZGUsIGZhbHNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxheWVycyA/IGl0ZXJTdGFjayhsYXllcnMpIDogaW5uZXI7XG59XG4vKipcbkEgdHJlZSBjdXJzb3Igb2JqZWN0IGZvY3VzZXMgb24gYSBnaXZlbiBub2RlIGluIGEgc3ludGF4IHRyZWUsIGFuZFxuYWxsb3dzIHlvdSB0byBtb3ZlIHRvIGFkamFjZW50IG5vZGVzLlxuKi9cbmNsYXNzIFRyZWVDdXJzb3Ige1xuICAgIC8qKlxuICAgIFNob3J0aGFuZCBmb3IgYC50eXBlLm5hbWVgLlxuICAgICovXG4gICAgZ2V0IG5hbWUoKSB7IHJldHVybiB0aGlzLnR5cGUubmFtZTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3Iobm9kZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtb2RlID0gMCkge1xuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLmJ1ZmZlck5vZGUgPSBudWxsO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLnlpZWxkTm9kZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RyZWUgPSBub2RlLmNvbnRleHQucGFyZW50O1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBub2RlLmNvbnRleHQ7XG4gICAgICAgICAgICBmb3IgKGxldCBuID0gbm9kZS5fcGFyZW50OyBuOyBuID0gbi5fcGFyZW50KVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sudW5zaGlmdChuLmluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICB0aGlzLnlpZWxkQnVmKG5vZGUuaW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHlpZWxkTm9kZShub2RlKSB7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5fdHJlZSA9IG5vZGU7XG4gICAgICAgIHRoaXMudHlwZSA9IG5vZGUudHlwZTtcbiAgICAgICAgdGhpcy5mcm9tID0gbm9kZS5mcm9tO1xuICAgICAgICB0aGlzLnRvID0gbm9kZS50bztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHlpZWxkQnVmKGluZGV4LCB0eXBlKSB7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgbGV0IHsgc3RhcnQsIGJ1ZmZlciB9ID0gdGhpcy5idWZmZXI7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGUgfHwgYnVmZmVyLnNldC50eXBlc1tidWZmZXIuYnVmZmVyW2luZGV4XV07XG4gICAgICAgIHRoaXMuZnJvbSA9IHN0YXJ0ICsgYnVmZmVyLmJ1ZmZlcltpbmRleCArIDFdO1xuICAgICAgICB0aGlzLnRvID0gc3RhcnQgKyBidWZmZXIuYnVmZmVyW2luZGV4ICsgMl07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHlpZWxkKG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZE5vZGUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWZmZXIgPSBub2RlLmNvbnRleHQ7XG4gICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKG5vZGUuaW5kZXgsIG5vZGUudHlwZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlciA/IHRoaXMuYnVmZmVyLmJ1ZmZlci5jaGlsZFN0cmluZyh0aGlzLmluZGV4KSA6IHRoaXMuX3RyZWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBlbnRlckNoaWxkKGRpciwgcG9zLCBzaWRlKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZCh0aGlzLl90cmVlLm5leHRDaGlsZChkaXIgPCAwID8gdGhpcy5fdHJlZS5fdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxIDogMCwgZGlyLCBwb3MsIHNpZGUsIHRoaXMubW9kZSkpO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuYnVmZmVyO1xuICAgICAgICBsZXQgaW5kZXggPSBidWZmZXIuZmluZENoaWxkKHRoaXMuaW5kZXggKyA0LCBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXSwgZGlyLCBwb3MgLSB0aGlzLmJ1ZmZlci5zdGFydCwgc2lkZSk7XG4gICAgICAgIGlmIChpbmRleCA8IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLmluZGV4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYoaW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhpcyBub2RlJ3MgZmlyc3QgY2hpbGQuIFdoZW4gdGhpcyByZXR1cm5zXG4gICAgZmFsc2UsIHRoZSBub2RlIGhhcyBubyBjaGlsZCwgYW5kIHRoZSBjdXJzb3IgaGFzIG5vdCBiZWVuIG1vdmVkLlxuICAgICovXG4gICAgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgxLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0aGUgY3Vyc29yIHRvIHRoaXMgbm9kZSdzIGxhc3QgY2hpbGQuXG4gICAgKi9cbiAgICBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmVudGVyQ2hpbGQoLTEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7IH1cbiAgICAvKipcbiAgICBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGZpcnN0IGNoaWxkIHRoYXQgZW5kcyBhZnRlciBgcG9zYC5cbiAgICAqL1xuICAgIGNoaWxkQWZ0ZXIocG9zKSB7IHJldHVybiB0aGlzLmVudGVyQ2hpbGQoMSwgcG9zLCAyIC8qIFNpZGUuQWZ0ZXIgKi8pOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0byB0aGUgbGFzdCBjaGlsZCB0aGF0IHN0YXJ0cyBiZWZvcmUgYHBvc2AuXG4gICAgKi9cbiAgICBjaGlsZEJlZm9yZShwb3MpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgtMSwgcG9zLCAtMiAvKiBTaWRlLkJlZm9yZSAqLyk7IH1cbiAgICAvKipcbiAgICBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGNoaWxkIGFyb3VuZCBgcG9zYC4gSWYgc2lkZSBpcyAtMSB0aGVcbiAgICBjaGlsZCBtYXkgZW5kIGF0IHRoYXQgcG9zaXRpb24sIHdoZW4gMSBpdCBtYXkgc3RhcnQgdGhlcmUuIFRoaXNcbiAgICB3aWxsIGFsc28gZW50ZXIgW292ZXJsYWlkXSgjY29tbW9uLk1vdW50ZWRUcmVlLm92ZXJsYXkpXG4gICAgW21vdW50ZWRdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgdHJlZXMgdW5sZXNzIGBvdmVybGF5c2AgaXNcbiAgICBzZXQgdG8gZmFsc2UuXG4gICAgKi9cbiAgICBlbnRlcihwb3MsIHNpZGUsIG1vZGUgPSB0aGlzLm1vZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkKHRoaXMuX3RyZWUuZW50ZXIocG9zLCBzaWRlLCBtb2RlKSk7XG4gICAgICAgIHJldHVybiBtb2RlICYgSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMgPyBmYWxzZSA6IHRoaXMuZW50ZXJDaGlsZCgxLCBwb3MsIHNpZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIHRoZSBub2RlJ3MgcGFyZW50IG5vZGUsIGlmIHRoaXMgaXNuJ3QgdGhlIHRvcCBub2RlLlxuICAgICovXG4gICAgcGFyZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGROb2RlKCh0aGlzLm1vZGUgJiBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKSA/IHRoaXMuX3RyZWUuX3BhcmVudCA6IHRoaXMuX3RyZWUucGFyZW50KTtcbiAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYodGhpcy5zdGFjay5wb3AoKSk7XG4gICAgICAgIGxldCBwYXJlbnQgPSAodGhpcy5tb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgPyB0aGlzLmJ1ZmZlci5wYXJlbnQgOiB0aGlzLmJ1ZmZlci5wYXJlbnQubmV4dFNpZ25pZmljYW50UGFyZW50KCk7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGROb2RlKHBhcmVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2libGluZyhkaXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5fdHJlZS5fcGFyZW50ID8gZmFsc2VcbiAgICAgICAgICAgICAgICA6IHRoaXMueWllbGQodGhpcy5fdHJlZS5pbmRleCA8IDAgPyBudWxsXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5fdHJlZS5fcGFyZW50Lm5leHRDaGlsZCh0aGlzLl90cmVlLmluZGV4ICsgZGlyLCBkaXIsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLywgdGhpcy5tb2RlKSk7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5idWZmZXIsIGQgPSB0aGlzLnN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChkaXIgPCAwKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50U3RhcnQgPSBkIDwgMCA/IDAgOiB0aGlzLnN0YWNrW2RdICsgNDtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ICE9IHBhcmVudFN0YXJ0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKGJ1ZmZlci5maW5kQ2hpbGQocGFyZW50U3RhcnQsIHRoaXMuaW5kZXgsIC0xLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBhZnRlciA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICAgICAgaWYgKGFmdGVyIDwgKGQgPCAwID8gYnVmZmVyLmJ1ZmZlci5sZW5ndGggOiBidWZmZXIuYnVmZmVyW3RoaXMuc3RhY2tbZF0gKyAzXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYoYWZ0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkIDwgMCA/IHRoaXMueWllbGQodGhpcy5idWZmZXIucGFyZW50Lm5leHRDaGlsZCh0aGlzLmJ1ZmZlci5pbmRleCArIGRpciwgZGlyLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8sIHRoaXMubW9kZSkpIDogZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhpcyBub2RlJ3MgbmV4dCBzaWJsaW5nLCBpZiBhbnkuXG4gICAgKi9cbiAgICBuZXh0U2libGluZygpIHsgcmV0dXJuIHRoaXMuc2libGluZygxKTsgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhpcyBub2RlJ3MgcHJldmlvdXMgc2libGluZywgaWYgYW55LlxuICAgICovXG4gICAgcHJldlNpYmxpbmcoKSB7IHJldHVybiB0aGlzLnNpYmxpbmcoLTEpOyB9XG4gICAgYXRMYXN0Tm9kZShkaXIpIHtcbiAgICAgICAgbGV0IGluZGV4LCBwYXJlbnQsIHsgYnVmZmVyIH0gPSB0aGlzO1xuICAgICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgICAgICBpZiAoZGlyID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluZGV4IDwgYnVmZmVyLmJ1ZmZlci5idWZmZXIubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW5kZXg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlci5idWZmZXIuYnVmZmVyW2kgKyAzXSA8IHRoaXMuaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoeyBpbmRleCwgcGFyZW50IH0gPSBidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKHsgaW5kZXgsIF9wYXJlbnQ6IHBhcmVudCB9ID0gdGhpcy5fdHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IHBhcmVudDsgeyBpbmRleCwgX3BhcmVudDogcGFyZW50IH0gPSBwYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBpbmRleCArIGRpciwgZSA9IGRpciA8IDAgPyAtMSA6IHBhcmVudC5fdHJlZS5jaGlsZHJlbi5sZW5ndGg7IGkgIT0gZTsgaSArPSBkaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gcGFyZW50Ll90cmVlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHRoaXMubW9kZSAmIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZCBpbnN0YW5jZW9mIFRyZWVCdWZmZXIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICFjaGlsZC50eXBlLmlzQW5vbnltb3VzIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNDaGlsZChjaGlsZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBtb3ZlKGRpciwgZW50ZXIpIHtcbiAgICAgICAgaWYgKGVudGVyICYmIHRoaXMuZW50ZXJDaGlsZChkaXIsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLykpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2libGluZyhkaXIpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXRMYXN0Tm9kZShkaXIpIHx8ICF0aGlzLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIHRoZSBuZXh0IG5vZGUgaW4gYVxuICAgIFtwcmUtb3JkZXJdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RyZWVfdHJhdmVyc2FsI1ByZS1vcmRlcixfTkxSKVxuICAgIHRyYXZlcnNhbCwgZ29pbmcgZnJvbSBhIG5vZGUgdG8gaXRzIGZpcnN0IGNoaWxkIG9yLCBpZiB0aGVcbiAgICBjdXJyZW50IG5vZGUgaXMgZW1wdHkgb3IgYGVudGVyYCBpcyBmYWxzZSwgaXRzIG5leHQgc2libGluZyBvclxuICAgIHRoZSBuZXh0IHNpYmxpbmcgb2YgdGhlIGZpcnN0IHBhcmVudCBub2RlIHRoYXQgaGFzIG9uZS5cbiAgICAqL1xuICAgIG5leHQoZW50ZXIgPSB0cnVlKSB7IHJldHVybiB0aGlzLm1vdmUoMSwgZW50ZXIpOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0byB0aGUgbmV4dCBub2RlIGluIGEgbGFzdC10by1maXJzdCBwcmUtb3JkZXIgdHJhdmVyc2FsLiBBXG4gICAgbm9kZSBpcyBmb2xsb3dlZCBieSBpdHMgbGFzdCBjaGlsZCBvciwgaWYgaXQgaGFzIG5vbmUsIGl0c1xuICAgIHByZXZpb3VzIHNpYmxpbmcgb3IgdGhlIHByZXZpb3VzIHNpYmxpbmcgb2YgdGhlIGZpcnN0IHBhcmVudFxuICAgIG5vZGUgdGhhdCBoYXMgb25lLlxuICAgICovXG4gICAgcHJldihlbnRlciA9IHRydWUpIHsgcmV0dXJuIHRoaXMubW92ZSgtMSwgZW50ZXIpOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0aGUgY3Vyc29yIHRvIHRoZSBpbm5lcm1vc3Qgbm9kZSB0aGF0IGNvdmVycyBgcG9zYC4gSWZcbiAgICBgc2lkZWAgaXMgLTEsIGl0IHdpbGwgZW50ZXIgbm9kZXMgdGhhdCBlbmQgYXQgYHBvc2AuIElmIGl0IGlzIDEsXG4gICAgaXQgd2lsbCBlbnRlciBub2RlcyB0aGF0IHN0YXJ0IGF0IGBwb3NgLlxuICAgICovXG4gICAgbW92ZVRvKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgLy8gTW92ZSB1cCB0byBhIG5vZGUgdGhhdCBhY3R1YWxseSBob2xkcyB0aGUgcG9zaXRpb24sIGlmIHBvc3NpYmxlXG4gICAgICAgIHdoaWxlICh0aGlzLmZyb20gPT0gdGhpcy50byB8fFxuICAgICAgICAgICAgKHNpZGUgPCAxID8gdGhpcy5mcm9tID49IHBvcyA6IHRoaXMuZnJvbSA+IHBvcykgfHxcbiAgICAgICAgICAgIChzaWRlID4gLTEgPyB0aGlzLnRvIDw9IHBvcyA6IHRoaXMudG8gPCBwb3MpKVxuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBUaGVuIHNjYW4gZG93biBpbnRvIGNoaWxkIG5vZGVzIGFzIGZhciBhcyBwb3NzaWJsZVxuICAgICAgICB3aGlsZSAodGhpcy5lbnRlckNoaWxkKDEsIHBvcywgc2lkZSkpIHsgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgW3N5bnRheCBub2RlXSgjY29tbW9uLlN5bnRheE5vZGUpIGF0IHRoZSBjdXJzb3IncyBjdXJyZW50XG4gICAgcG9zaXRpb24uXG4gICAgKi9cbiAgICBnZXQgbm9kZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmVlO1xuICAgICAgICBsZXQgY2FjaGUgPSB0aGlzLmJ1ZmZlck5vZGUsIHJlc3VsdCA9IG51bGwsIGRlcHRoID0gMDtcbiAgICAgICAgaWYgKGNhY2hlICYmIGNhY2hlLmNvbnRleHQgPT0gdGhpcy5idWZmZXIpIHtcbiAgICAgICAgICAgIHNjYW46IGZvciAobGV0IGluZGV4ID0gdGhpcy5pbmRleCwgZCA9IHRoaXMuc3RhY2subGVuZ3RoOyBkID49IDA7KSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYyA9IGNhY2hlOyBjOyBjID0gYy5fcGFyZW50KVxuICAgICAgICAgICAgICAgICAgICBpZiAoYy5pbmRleCA9PSBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09IHRoaXMuaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGggPSBkICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHNjYW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMuc3RhY2tbLS1kXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gZGVwdGg7IGkgPCB0aGlzLnN0YWNrLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEJ1ZmZlck5vZGUodGhpcy5idWZmZXIsIHJlc3VsdCwgdGhpcy5zdGFja1tpXSk7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlck5vZGUgPSBuZXcgQnVmZmVyTm9kZSh0aGlzLmJ1ZmZlciwgcmVzdWx0LCB0aGlzLmluZGV4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBbdHJlZV0oI2NvbW1vbi5UcmVlKSB0aGF0IHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgbm9kZSwgaWZcbiAgICBhbnkuIFdpbGwgcmV0dXJuIG51bGwgd2hlbiB0aGUgbm9kZSBpcyBpbiBhIFt0cmVlXG4gICAgYnVmZmVyXSgjY29tbW9uLlRyZWVCdWZmZXIpLlxuICAgICovXG4gICAgZ2V0IHRyZWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlciA/IG51bGwgOiB0aGlzLl90cmVlLl90cmVlO1xuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIGN1cnJlbnQgbm9kZSBhbmQgYWxsIGl0cyBkZXNjZW5kYW50cywgY2FsbGluZ1xuICAgIGBlbnRlcmAgd2hlbiBlbnRlcmluZyBhIG5vZGUgYW5kIGBsZWF2ZWAsIGlmIGdpdmVuLCB3aGVuIGxlYXZpbmdcbiAgICBvbmUuIFdoZW4gYGVudGVyYCByZXR1cm5zIGBmYWxzZWAsIGFueSBjaGlsZHJlbiBvZiB0aGF0IG5vZGUgYXJlXG4gICAgc2tpcHBlZCwgYW5kIGBsZWF2ZWAgaXNuJ3QgY2FsbGVkIGZvciBpdC5cbiAgICAqL1xuICAgIGl0ZXJhdGUoZW50ZXIsIGxlYXZlKSB7XG4gICAgICAgIGZvciAobGV0IGRlcHRoID0gMDs7KSB7XG4gICAgICAgICAgICBsZXQgbXVzdExlYXZlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlLmlzQW5vbnltb3VzIHx8IGVudGVyKHRoaXMpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpcnN0Q2hpbGQoKSkge1xuICAgICAgICAgICAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnR5cGUuaXNBbm9ueW1vdXMpXG4gICAgICAgICAgICAgICAgICAgIG11c3RMZWF2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgaWYgKG11c3RMZWF2ZSAmJiBsZWF2ZSlcbiAgICAgICAgICAgICAgICAgICAgbGVhdmUodGhpcyk7XG4gICAgICAgICAgICAgICAgbXVzdExlYXZlID0gdGhpcy50eXBlLmlzQW5vbnltb3VzO1xuICAgICAgICAgICAgICAgIGlmICghZGVwdGgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudCgpO1xuICAgICAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgICAgICAgICAgbXVzdExlYXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgdGhlIGN1cnJlbnQgbm9kZSBtYXRjaGVzIGEgZ2l2ZW4gY29udGV4dOKAlGEgc2VxdWVuY2VcbiAgICBvZiBkaXJlY3QgcGFyZW50IG5vZGUgbmFtZXMuIEVtcHR5IHN0cmluZ3MgaW4gdGhlIGNvbnRleHQgYXJyYXlcbiAgICBhcmUgdHJlYXRlZCBhcyB3aWxkY2FyZHMuXG4gICAgKi9cbiAgICBtYXRjaENvbnRleHQoY29udGV4dCkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoTm9kZUNvbnRleHQodGhpcy5ub2RlLnBhcmVudCwgY29udGV4dCk7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5idWZmZXIsIHsgdHlwZXMgfSA9IGJ1ZmZlci5zZXQ7XG4gICAgICAgIGZvciAobGV0IGkgPSBjb250ZXh0Lmxlbmd0aCAtIDEsIGQgPSB0aGlzLnN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgZC0tKSB7XG4gICAgICAgICAgICBpZiAoZCA8IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoTm9kZUNvbnRleHQodGhpcy5fdHJlZSwgY29udGV4dCwgaSk7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IHR5cGVzW2J1ZmZlci5idWZmZXJbdGhpcy5zdGFja1tkXV1dO1xuICAgICAgICAgICAgaWYgKCF0eXBlLmlzQW5vbnltb3VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHRbaV0gJiYgY29udGV4dFtpXSAhPSB0eXBlLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFzQ2hpbGQodHJlZSkge1xuICAgIHJldHVybiB0cmVlLmNoaWxkcmVuLnNvbWUoY2ggPT4gY2ggaW5zdGFuY2VvZiBUcmVlQnVmZmVyIHx8ICFjaC50eXBlLmlzQW5vbnltb3VzIHx8IGhhc0NoaWxkKGNoKSk7XG59XG5mdW5jdGlvbiBidWlsZFRyZWUoZGF0YSkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgeyBidWZmZXIsIG5vZGVTZXQsIG1heEJ1ZmZlckxlbmd0aCA9IERlZmF1bHRCdWZmZXJMZW5ndGgsIHJldXNlZCA9IFtdLCBtaW5SZXBlYXRUeXBlID0gbm9kZVNldC50eXBlcy5sZW5ndGggfSA9IGRhdGE7XG4gICAgbGV0IGN1cnNvciA9IEFycmF5LmlzQXJyYXkoYnVmZmVyKSA/IG5ldyBGbGF0QnVmZmVyQ3Vyc29yKGJ1ZmZlciwgYnVmZmVyLmxlbmd0aCkgOiBidWZmZXI7XG4gICAgbGV0IHR5cGVzID0gbm9kZVNldC50eXBlcztcbiAgICBsZXQgY29udGV4dEhhc2ggPSAwLCBsb29rQWhlYWQgPSAwO1xuICAgIGZ1bmN0aW9uIHRha2VOb2RlKHBhcmVudFN0YXJ0LCBtaW5Qb3MsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGluUmVwZWF0LCBkZXB0aCkge1xuICAgICAgICBsZXQgeyBpZCwgc3RhcnQsIGVuZCwgc2l6ZSB9ID0gY3Vyc29yO1xuICAgICAgICBsZXQgbG9va0FoZWFkQXRTdGFydCA9IGxvb2tBaGVhZCwgY29udGV4dEF0U3RhcnQgPSBjb250ZXh0SGFzaDtcbiAgICAgICAgd2hpbGUgKHNpemUgPCAwKSB7XG4gICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgaWYgKHNpemUgPT0gLTEgLyogU3BlY2lhbFJlY29yZC5SZXVzZSAqLykge1xuICAgICAgICAgICAgICAgIGxldCBub2RlID0gcmV1c2VkW2lkXTtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKHN0YXJ0IC0gcGFyZW50U3RhcnQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNpemUgPT0gLTMgLyogU3BlY2lhbFJlY29yZC5Db250ZXh0Q2hhbmdlICovKSB7IC8vIENvbnRleHQgY2hhbmdlXG4gICAgICAgICAgICAgICAgY29udGV4dEhhc2ggPSBpZDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaXplID09IC00IC8qIFNwZWNpYWxSZWNvcmQuTG9va0FoZWFkICovKSB7XG4gICAgICAgICAgICAgICAgbG9va0FoZWFkID0gaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFVucmVjb2duaXplZCByZWNvcmQgc2l6ZTogJHtzaXplfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCB0eXBlID0gdHlwZXNbaWRdLCBub2RlLCBidWZmZXI7XG4gICAgICAgIGxldCBzdGFydFBvcyA9IHN0YXJ0IC0gcGFyZW50U3RhcnQ7XG4gICAgICAgIGlmIChlbmQgLSBzdGFydCA8PSBtYXhCdWZmZXJMZW5ndGggJiYgKGJ1ZmZlciA9IGZpbmRCdWZmZXJTaXplKGN1cnNvci5wb3MgLSBtaW5Qb3MsIGluUmVwZWF0KSkpIHtcbiAgICAgICAgICAgIC8vIFNtYWxsIGVub3VnaCBmb3IgYSBidWZmZXIsIGFuZCBubyByZXVzZWQgbm9kZXMgaW5zaWRlXG4gICAgICAgICAgICBsZXQgZGF0YSA9IG5ldyBVaW50MTZBcnJheShidWZmZXIuc2l6ZSAtIGJ1ZmZlci5za2lwKTtcbiAgICAgICAgICAgIGxldCBlbmRQb3MgPSBjdXJzb3IucG9zIC0gYnVmZmVyLnNpemUsIGluZGV4ID0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IGVuZFBvcylcbiAgICAgICAgICAgICAgICBpbmRleCA9IGNvcHlUb0J1ZmZlcihidWZmZXIuc3RhcnQsIGRhdGEsIGluZGV4KTtcbiAgICAgICAgICAgIG5vZGUgPSBuZXcgVHJlZUJ1ZmZlcihkYXRhLCBlbmQgLSBidWZmZXIuc3RhcnQsIG5vZGVTZXQpO1xuICAgICAgICAgICAgc3RhcnRQb3MgPSBidWZmZXIuc3RhcnQgLSBwYXJlbnRTdGFydDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gTWFrZSBpdCBhIG5vZGVcbiAgICAgICAgICAgIGxldCBlbmRQb3MgPSBjdXJzb3IucG9zIC0gc2l6ZTtcbiAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICBsZXQgbG9jYWxDaGlsZHJlbiA9IFtdLCBsb2NhbFBvc2l0aW9ucyA9IFtdO1xuICAgICAgICAgICAgbGV0IGxvY2FsSW5SZXBlYXQgPSBpZCA+PSBtaW5SZXBlYXRUeXBlID8gaWQgOiAtMTtcbiAgICAgICAgICAgIGxldCBsYXN0R3JvdXAgPSAwLCBsYXN0RW5kID0gZW5kO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnNvci5wb3MgPiBlbmRQb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxJblJlcGVhdCA+PSAwICYmIGN1cnNvci5pZCA9PSBsb2NhbEluUmVwZWF0ICYmIGN1cnNvci5zaXplID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnNvci5lbmQgPD0gbGFzdEVuZCAtIG1heEJ1ZmZlckxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZVJlcGVhdExlYWYobG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIHN0YXJ0LCBsYXN0R3JvdXAsIGN1cnNvci5lbmQsIGxhc3RFbmQsIGxvY2FsSW5SZXBlYXQsIGxvb2tBaGVhZEF0U3RhcnQsIGNvbnRleHRBdFN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RHcm91cCA9IGxvY2FsQ2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEVuZCA9IGN1cnNvci5lbmQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZGVwdGggPiAyNTAwIC8qIEN1dE9mZi5EZXB0aCAqLykge1xuICAgICAgICAgICAgICAgICAgICB0YWtlRmxhdE5vZGUoc3RhcnQsIGVuZFBvcywgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFrZU5vZGUoc3RhcnQsIGVuZFBvcywgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIGxvY2FsSW5SZXBlYXQsIGRlcHRoICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxvY2FsSW5SZXBlYXQgPj0gMCAmJiBsYXN0R3JvdXAgPiAwICYmIGxhc3RHcm91cCA8IGxvY2FsQ2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIG1ha2VSZXBlYXRMZWFmKGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBzdGFydCwgbGFzdEdyb3VwLCBzdGFydCwgbGFzdEVuZCwgbG9jYWxJblJlcGVhdCwgbG9va0FoZWFkQXRTdGFydCwgY29udGV4dEF0U3RhcnQpO1xuICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5yZXZlcnNlKCk7XG4gICAgICAgICAgICBsb2NhbFBvc2l0aW9ucy5yZXZlcnNlKCk7XG4gICAgICAgICAgICBpZiAobG9jYWxJblJlcGVhdCA+IC0xICYmIGxhc3RHcm91cCA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFrZSA9IG1ha2VCYWxhbmNlZCh0eXBlLCBjb250ZXh0QXRTdGFydCk7XG4gICAgICAgICAgICAgICAgbm9kZSA9IGJhbGFuY2VSYW5nZSh0eXBlLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgMCwgbG9jYWxDaGlsZHJlbi5sZW5ndGgsIDAsIGVuZCAtIHN0YXJ0LCBtYWtlLCBtYWtlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBtYWtlVHJlZSh0eXBlLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgZW5kIC0gc3RhcnQsIGxvb2tBaGVhZEF0U3RhcnQgLSBlbmQsIGNvbnRleHRBdFN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaChzdGFydFBvcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRha2VGbGF0Tm9kZShwYXJlbnRTdGFydCwgbWluUG9zLCBjaGlsZHJlbiwgcG9zaXRpb25zKSB7XG4gICAgICAgIGxldCBub2RlcyA9IFtdOyAvLyBUZW1wb3JhcnksIGludmVydGVkIGFycmF5IG9mIGxlYWYgbm9kZXMgZm91bmQsIHdpdGggYWJzb2x1dGUgcG9zaXRpb25zXG4gICAgICAgIGxldCBub2RlQ291bnQgPSAwLCBzdG9wQXQgPSAtMTtcbiAgICAgICAgd2hpbGUgKGN1cnNvci5wb3MgPiBtaW5Qb3MpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBzdGFydCwgZW5kLCBzaXplIH0gPSBjdXJzb3I7XG4gICAgICAgICAgICBpZiAoc2l6ZSA+IDQpIHsgLy8gTm90IGEgbGVhZlxuICAgICAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdG9wQXQgPiAtMSAmJiBzdGFydCA8IHN0b3BBdCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0b3BBdCA8IDApXG4gICAgICAgICAgICAgICAgICAgIHN0b3BBdCA9IGVuZCAtIG1heEJ1ZmZlckxlbmd0aDtcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGlkLCBzdGFydCwgZW5kKTtcbiAgICAgICAgICAgICAgICBub2RlQ291bnQrKztcbiAgICAgICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlQ291bnQpIHtcbiAgICAgICAgICAgIGxldCBidWZmZXIgPSBuZXcgVWludDE2QXJyYXkobm9kZUNvdW50ICogNCk7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBub2Rlc1tub2Rlcy5sZW5ndGggLSAyXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBub2Rlcy5sZW5ndGggLSAzLCBqID0gMDsgaSA+PSAwOyBpIC09IDMpIHtcbiAgICAgICAgICAgICAgICBidWZmZXJbaisrXSA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltqKytdID0gbm9kZXNbaSArIDFdIC0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgYnVmZmVyW2orK10gPSBub2Rlc1tpICsgMl0gLSBzdGFydDtcbiAgICAgICAgICAgICAgICBidWZmZXJbaisrXSA9IGo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKG5ldyBUcmVlQnVmZmVyKGJ1ZmZlciwgbm9kZXNbMl0gLSBzdGFydCwgbm9kZVNldCkpO1xuICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goc3RhcnQgLSBwYXJlbnRTdGFydCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZUJhbGFuY2VkKHR5cGUsIGNvbnRleHRIYXNoKSB7XG4gICAgICAgIHJldHVybiAoY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKSA9PiB7XG4gICAgICAgICAgICBsZXQgbG9va0FoZWFkID0gMCwgbGFzdEkgPSBjaGlsZHJlbi5sZW5ndGggLSAxLCBsYXN0LCBsb29rQWhlYWRQcm9wO1xuICAgICAgICAgICAgaWYgKGxhc3RJID49IDAgJiYgKGxhc3QgPSBjaGlsZHJlbltsYXN0SV0pIGluc3RhbmNlb2YgVHJlZSkge1xuICAgICAgICAgICAgICAgIGlmICghbGFzdEkgJiYgbGFzdC50eXBlID09IHR5cGUgJiYgbGFzdC5sZW5ndGggPT0gbGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFzdDtcbiAgICAgICAgICAgICAgICBpZiAobG9va0FoZWFkUHJvcCA9IGxhc3QucHJvcChOb2RlUHJvcC5sb29rQWhlYWQpKVxuICAgICAgICAgICAgICAgICAgICBsb29rQWhlYWQgPSBwb3NpdGlvbnNbbGFzdEldICsgbGFzdC5sZW5ndGggKyBsb29rQWhlYWRQcm9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1ha2VUcmVlKHR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCwgbG9va0FoZWFkLCBjb250ZXh0SGFzaCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VSZXBlYXRMZWFmKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGJhc2UsIGksIGZyb20sIHRvLCB0eXBlLCBsb29rQWhlYWQsIGNvbnRleHRIYXNoKSB7XG4gICAgICAgIGxldCBsb2NhbENoaWxkcmVuID0gW10sIGxvY2FsUG9zaXRpb25zID0gW107XG4gICAgICAgIHdoaWxlIChjaGlsZHJlbi5sZW5ndGggPiBpKSB7XG4gICAgICAgICAgICBsb2NhbENoaWxkcmVuLnB1c2goY2hpbGRyZW4ucG9wKCkpO1xuICAgICAgICAgICAgbG9jYWxQb3NpdGlvbnMucHVzaChwb3NpdGlvbnMucG9wKCkgKyBiYXNlIC0gZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4ucHVzaChtYWtlVHJlZShub2RlU2V0LnR5cGVzW3R5cGVdLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgdG8gLSBmcm9tLCBsb29rQWhlYWQgLSB0bywgY29udGV4dEhhc2gpKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goZnJvbSAtIGJhc2UpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlVHJlZSh0eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgsIGxvb2tBaGVhZCwgY29udGV4dEhhc2gsIHByb3BzKSB7XG4gICAgICAgIGlmIChjb250ZXh0SGFzaCkge1xuICAgICAgICAgICAgbGV0IHBhaXIgPSBbTm9kZVByb3AuY29udGV4dEhhc2gsIGNvbnRleHRIYXNoXTtcbiAgICAgICAgICAgIHByb3BzID0gcHJvcHMgPyBbcGFpcl0uY29uY2F0KHByb3BzKSA6IFtwYWlyXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9va0FoZWFkID4gMjUpIHtcbiAgICAgICAgICAgIGxldCBwYWlyID0gW05vZGVQcm9wLmxvb2tBaGVhZCwgbG9va0FoZWFkXTtcbiAgICAgICAgICAgIHByb3BzID0gcHJvcHMgPyBbcGFpcl0uY29uY2F0KHByb3BzKSA6IFtwYWlyXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRyZWUodHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoLCBwcm9wcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRCdWZmZXJTaXplKG1heFNpemUsIGluUmVwZWF0KSB7XG4gICAgICAgIC8vIFNjYW4gdGhyb3VnaCB0aGUgYnVmZmVyIHRvIGZpbmQgcHJldmlvdXMgc2libGluZ3MgdGhhdCBmaXRcbiAgICAgICAgLy8gdG9nZXRoZXIgaW4gYSBUcmVlQnVmZmVyLCBhbmQgZG9uJ3QgY29udGFpbiBhbnkgcmV1c2VkIG5vZGVzXG4gICAgICAgIC8vICh3aGljaCBjYW4ndCBiZSBzdG9yZWQgaW4gYSBidWZmZXIpLlxuICAgICAgICAvLyBJZiBgaW5SZXBlYXRgIGlzID4gLTEsIGlnbm9yZSBub2RlIGJvdW5kYXJpZXMgb2YgdGhhdCB0eXBlIGZvclxuICAgICAgICAvLyBuZXN0aW5nLCBidXQgbWFrZSBzdXJlIHRoZSBlbmQgZmFsbHMgZWl0aGVyIGF0IHRoZSBzdGFydFxuICAgICAgICAvLyAoYG1heFNpemVgKSBvciBiZWZvcmUgc3VjaCBhIG5vZGUuXG4gICAgICAgIGxldCBmb3JrID0gY3Vyc29yLmZvcmsoKTtcbiAgICAgICAgbGV0IHNpemUgPSAwLCBzdGFydCA9IDAsIHNraXAgPSAwLCBtaW5TdGFydCA9IGZvcmsuZW5kIC0gbWF4QnVmZmVyTGVuZ3RoO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyBzaXplOiAwLCBzdGFydDogMCwgc2tpcDogMCB9O1xuICAgICAgICBzY2FuOiBmb3IgKGxldCBtaW5Qb3MgPSBmb3JrLnBvcyAtIG1heFNpemU7IGZvcmsucG9zID4gbWluUG9zOykge1xuICAgICAgICAgICAgbGV0IG5vZGVTaXplID0gZm9yay5zaXplO1xuICAgICAgICAgICAgLy8gUHJldGVuZCBuZXN0ZWQgcmVwZWF0IG5vZGVzIG9mIHRoZSBzYW1lIHR5cGUgZG9uJ3QgZXhpc3RcbiAgICAgICAgICAgIGlmIChmb3JrLmlkID09IGluUmVwZWF0ICYmIG5vZGVTaXplID49IDApIHtcbiAgICAgICAgICAgICAgICAvLyBFeGNlcHQgdGhhdCB3ZSBzdG9yZSB0aGUgY3VycmVudCBzdGF0ZSBhcyBhIHZhbGlkIHJldHVyblxuICAgICAgICAgICAgICAgIC8vIHZhbHVlLlxuICAgICAgICAgICAgICAgIHJlc3VsdC5zaXplID0gc2l6ZTtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgICAgICByZXN1bHQuc2tpcCA9IHNraXA7XG4gICAgICAgICAgICAgICAgc2tpcCArPSA0O1xuICAgICAgICAgICAgICAgIHNpemUgKz0gNDtcbiAgICAgICAgICAgICAgICBmb3JrLm5leHQoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzdGFydFBvcyA9IGZvcmsucG9zIC0gbm9kZVNpemU7XG4gICAgICAgICAgICBpZiAobm9kZVNpemUgPCAwIHx8IHN0YXJ0UG9zIDwgbWluUG9zIHx8IGZvcmsuc3RhcnQgPCBtaW5TdGFydClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCBsb2NhbFNraXBwZWQgPSBmb3JrLmlkID49IG1pblJlcGVhdFR5cGUgPyA0IDogMDtcbiAgICAgICAgICAgIGxldCBub2RlU3RhcnQgPSBmb3JrLnN0YXJ0O1xuICAgICAgICAgICAgZm9yay5uZXh0KCk7XG4gICAgICAgICAgICB3aGlsZSAoZm9yay5wb3MgPiBzdGFydFBvcykge1xuICAgICAgICAgICAgICAgIGlmIChmb3JrLnNpemUgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3JrLnNpemUgPT0gLTMgLyogU3BlY2lhbFJlY29yZC5Db250ZXh0Q2hhbmdlICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTa2lwcGVkICs9IDQ7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHNjYW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcmsuaWQgPj0gbWluUmVwZWF0VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFNraXBwZWQgKz0gNDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yay5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydCA9IG5vZGVTdGFydDtcbiAgICAgICAgICAgIHNpemUgKz0gbm9kZVNpemU7XG4gICAgICAgICAgICBza2lwICs9IGxvY2FsU2tpcHBlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5SZXBlYXQgPCAwIHx8IHNpemUgPT0gbWF4U2l6ZSkge1xuICAgICAgICAgICAgcmVzdWx0LnNpemUgPSBzaXplO1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICByZXN1bHQuc2tpcCA9IHNraXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zaXplID4gNCA/IHJlc3VsdCA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29weVRvQnVmZmVyKGJ1ZmZlclN0YXJ0LCBidWZmZXIsIGluZGV4KSB7XG4gICAgICAgIGxldCB7IGlkLCBzdGFydCwgZW5kLCBzaXplIH0gPSBjdXJzb3I7XG4gICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgIGlmIChzaXplID49IDAgJiYgaWQgPCBtaW5SZXBlYXRUeXBlKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnRJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgaWYgKHNpemUgPiA0KSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZFBvcyA9IGN1cnNvci5wb3MgLSAoc2l6ZSAtIDQpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJzb3IucG9zID4gZW5kUG9zKVxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGNvcHlUb0J1ZmZlcihidWZmZXJTdGFydCwgYnVmZmVyLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBzdGFydEluZGV4O1xuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gZW5kIC0gYnVmZmVyU3RhcnQ7XG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBzdGFydCAtIGJ1ZmZlclN0YXJ0O1xuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2l6ZSA9PSAtMyAvKiBTcGVjaWFsUmVjb3JkLkNvbnRleHRDaGFuZ2UgKi8pIHtcbiAgICAgICAgICAgIGNvbnRleHRIYXNoID0gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2l6ZSA9PSAtNCAvKiBTcGVjaWFsUmVjb3JkLkxvb2tBaGVhZCAqLykge1xuICAgICAgICAgICAgbG9va0FoZWFkID0gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgICBsZXQgY2hpbGRyZW4gPSBbXSwgcG9zaXRpb25zID0gW107XG4gICAgd2hpbGUgKGN1cnNvci5wb3MgPiAwKVxuICAgICAgICB0YWtlTm9kZShkYXRhLnN0YXJ0IHx8IDAsIGRhdGEuYnVmZmVyU3RhcnQgfHwgMCwgY2hpbGRyZW4sIHBvc2l0aW9ucywgLTEsIDApO1xuICAgIGxldCBsZW5ndGggPSAoX2EgPSBkYXRhLmxlbmd0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKGNoaWxkcmVuLmxlbmd0aCA/IHBvc2l0aW9uc1swXSArIGNoaWxkcmVuWzBdLmxlbmd0aCA6IDApO1xuICAgIHJldHVybiBuZXcgVHJlZSh0eXBlc1tkYXRhLnRvcElEXSwgY2hpbGRyZW4ucmV2ZXJzZSgpLCBwb3NpdGlvbnMucmV2ZXJzZSgpLCBsZW5ndGgpO1xufVxuY29uc3Qgbm9kZVNpemVDYWNoZSA9IG5ldyBXZWFrTWFwO1xuZnVuY3Rpb24gbm9kZVNpemUoYmFsYW5jZVR5cGUsIG5vZGUpIHtcbiAgICBpZiAoIWJhbGFuY2VUeXBlLmlzQW5vbnltb3VzIHx8IG5vZGUgaW5zdGFuY2VvZiBUcmVlQnVmZmVyIHx8IG5vZGUudHlwZSAhPSBiYWxhbmNlVHlwZSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgbGV0IHNpemUgPSBub2RlU2l6ZUNhY2hlLmdldChub2RlKTtcbiAgICBpZiAoc2l6ZSA9PSBudWxsKSB7XG4gICAgICAgIHNpemUgPSAxO1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPSBiYWxhbmNlVHlwZSB8fCAhKGNoaWxkIGluc3RhbmNlb2YgVHJlZSkpIHtcbiAgICAgICAgICAgICAgICBzaXplID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNpemUgKz0gbm9kZVNpemUoYmFsYW5jZVR5cGUsIGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlU2l6ZUNhY2hlLnNldChub2RlLCBzaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpemU7XG59XG5mdW5jdGlvbiBiYWxhbmNlUmFuZ2UoXG4vLyBUaGUgdHlwZSB0aGUgYmFsYW5jZWQgdHJlZSdzIGlubmVyIG5vZGVzLlxuYmFsYW5jZVR5cGUsIFxuLy8gVGhlIGRpcmVjdCBjaGlsZHJlbiBhbmQgdGhlaXIgcG9zaXRpb25zXG5jaGlsZHJlbiwgcG9zaXRpb25zLCBcbi8vIFRoZSBpbmRleCByYW5nZSBpbiBjaGlsZHJlbi9wb3NpdGlvbnMgdG8gdXNlXG5mcm9tLCB0bywgXG4vLyBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIG5vZGVzLCByZWxhdGl2ZSB0byB0aGVpciBwYXJlbnQuXG5zdGFydCwgXG4vLyBMZW5ndGggb2YgdGhlIG91dGVyIG5vZGVcbmxlbmd0aCwgXG4vLyBGdW5jdGlvbiB0byBidWlsZCB0aGUgdG9wIG5vZGUgb2YgdGhlIGJhbGFuY2VkIHRyZWVcbm1rVG9wLCBcbi8vIEZ1bmN0aW9uIHRvIGJ1aWxkIGludGVybmFsIG5vZGVzIGZvciB0aGUgYmFsYW5jZWQgdHJlZVxubWtUcmVlKSB7XG4gICAgbGV0IHRvdGFsID0gMDtcbiAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOyBpKyspXG4gICAgICAgIHRvdGFsICs9IG5vZGVTaXplKGJhbGFuY2VUeXBlLCBjaGlsZHJlbltpXSk7XG4gICAgbGV0IG1heENoaWxkID0gTWF0aC5jZWlsKCh0b3RhbCAqIDEuNSkgLyA4IC8qIEJhbGFuY2UuQnJhbmNoRmFjdG9yICovKTtcbiAgICBsZXQgbG9jYWxDaGlsZHJlbiA9IFtdLCBsb2NhbFBvc2l0aW9ucyA9IFtdO1xuICAgIGZ1bmN0aW9uIGRpdmlkZShjaGlsZHJlbiwgcG9zaXRpb25zLCBmcm9tLCB0bywgb2Zmc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87KSB7XG4gICAgICAgICAgICBsZXQgZ3JvdXBGcm9tID0gaSwgZ3JvdXBTdGFydCA9IHBvc2l0aW9uc1tpXSwgZ3JvdXBTaXplID0gbm9kZVNpemUoYmFsYW5jZVR5cGUsIGNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGZvciAoOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0U2l6ZSA9IG5vZGVTaXplKGJhbGFuY2VUeXBlLCBjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwU2l6ZSArIG5leHRTaXplID49IG1heENoaWxkKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBncm91cFNpemUgKz0gbmV4dFNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA9PSBncm91cEZyb20gKyAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwU2l6ZSA+IG1heENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvbmx5ID0gY2hpbGRyZW5bZ3JvdXBGcm9tXTsgLy8gT25seSB0cmVlcyBjYW4gaGF2ZSBhIHNpemUgPiAxXG4gICAgICAgICAgICAgICAgICAgIGRpdmlkZShvbmx5LmNoaWxkcmVuLCBvbmx5LnBvc2l0aW9ucywgMCwgb25seS5jaGlsZHJlbi5sZW5ndGgsIHBvc2l0aW9uc1tncm91cEZyb21dICsgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaChjaGlsZHJlbltncm91cEZyb21dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBsZW5ndGggPSBwb3NpdGlvbnNbaSAtIDFdICsgY2hpbGRyZW5baSAtIDFdLmxlbmd0aCAtIGdyb3VwU3RhcnQ7XG4gICAgICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5wdXNoKGJhbGFuY2VSYW5nZShiYWxhbmNlVHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgZ3JvdXBGcm9tLCBpLCBncm91cFN0YXJ0LCBsZW5ndGgsIG51bGwsIG1rVHJlZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9jYWxQb3NpdGlvbnMucHVzaChncm91cFN0YXJ0ICsgb2Zmc2V0IC0gc3RhcnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpdmlkZShjaGlsZHJlbiwgcG9zaXRpb25zLCBmcm9tLCB0bywgMCk7XG4gICAgcmV0dXJuIChta1RvcCB8fCBta1RyZWUpKGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBsZW5ndGgpO1xufVxuLyoqXG5Qcm92aWRlcyBhIHdheSB0byBhc3NvY2lhdGUgdmFsdWVzIHdpdGggcGllY2VzIG9mIHRyZWVzLiBBcyBsb25nXG5hcyB0aGF0IHBhcnQgb2YgdGhlIHRyZWUgaXMgcmV1c2VkLCB0aGUgYXNzb2NpYXRlZCB2YWx1ZXMgY2FuIGJlXG5yZXRyaWV2ZWQgZnJvbSBhbiB1cGRhdGVkIHRyZWUuXG4qL1xuY2xhc3MgTm9kZVdlYWtNYXAge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgfVxuICAgIHNldEJ1ZmZlcihidWZmZXIsIGluZGV4LCB2YWx1ZSkge1xuICAgICAgICBsZXQgaW5uZXIgPSB0aGlzLm1hcC5nZXQoYnVmZmVyKTtcbiAgICAgICAgaWYgKCFpbm5lcilcbiAgICAgICAgICAgIHRoaXMubWFwLnNldChidWZmZXIsIGlubmVyID0gbmV3IE1hcCk7XG4gICAgICAgIGlubmVyLnNldChpbmRleCwgdmFsdWUpO1xuICAgIH1cbiAgICBnZXRCdWZmZXIoYnVmZmVyLCBpbmRleCkge1xuICAgICAgICBsZXQgaW5uZXIgPSB0aGlzLm1hcC5nZXQoYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIGlubmVyICYmIGlubmVyLmdldChpbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFNldCB0aGUgdmFsdWUgZm9yIHRoaXMgc3ludGF4IG5vZGUuXG4gICAgKi9cbiAgICBzZXQobm9kZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBCdWZmZXJOb2RlKVxuICAgICAgICAgICAgdGhpcy5zZXRCdWZmZXIobm9kZS5jb250ZXh0LmJ1ZmZlciwgbm9kZS5pbmRleCwgdmFsdWUpO1xuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUpXG4gICAgICAgICAgICB0aGlzLm1hcC5zZXQobm9kZS50cmVlLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHJpZXZlIHZhbHVlIGZvciB0aGlzIHN5bnRheCBub2RlLCBpZiBpdCBleGlzdHMgaW4gdGhlIG1hcC5cbiAgICAqL1xuICAgIGdldChub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgQnVmZmVyTm9kZSA/IHRoaXMuZ2V0QnVmZmVyKG5vZGUuY29udGV4dC5idWZmZXIsIG5vZGUuaW5kZXgpXG4gICAgICAgICAgICA6IG5vZGUgaW5zdGFuY2VvZiBUcmVlTm9kZSA/IHRoaXMubWFwLmdldChub2RlLnRyZWUpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXQgdGhlIHZhbHVlIGZvciB0aGUgbm9kZSB0aGF0IGEgY3Vyc29yIGN1cnJlbnRseSBwb2ludHMgdG8uXG4gICAgKi9cbiAgICBjdXJzb3JTZXQoY3Vyc29yLCB2YWx1ZSkge1xuICAgICAgICBpZiAoY3Vyc29yLmJ1ZmZlcilcbiAgICAgICAgICAgIHRoaXMuc2V0QnVmZmVyKGN1cnNvci5idWZmZXIuYnVmZmVyLCBjdXJzb3IuaW5kZXgsIHZhbHVlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5tYXAuc2V0KGN1cnNvci50cmVlLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHJpZXZlIHRoZSB2YWx1ZSBmb3IgdGhlIG5vZGUgdGhhdCBhIGN1cnNvciBjdXJyZW50bHkgcG9pbnRzXG4gICAgdG8uXG4gICAgKi9cbiAgICBjdXJzb3JHZXQoY3Vyc29yKSB7XG4gICAgICAgIHJldHVybiBjdXJzb3IuYnVmZmVyID8gdGhpcy5nZXRCdWZmZXIoY3Vyc29yLmJ1ZmZlci5idWZmZXIsIGN1cnNvci5pbmRleCkgOiB0aGlzLm1hcC5nZXQoY3Vyc29yLnRyZWUpO1xuICAgIH1cbn1cblxuLyoqXG5UcmVlIGZyYWdtZW50cyBhcmUgdXNlZCBkdXJpbmcgW2luY3JlbWVudGFsXG5wYXJzaW5nXSgjY29tbW9uLlBhcnNlci5zdGFydFBhcnNlKSB0byB0cmFjayBwYXJ0cyBvZiBvbGQgdHJlZXNcbnRoYXQgY2FuIGJlIHJldXNlZCBpbiBhIG5ldyBwYXJzZS4gQW4gYXJyYXkgb2YgZnJhZ21lbnRzIGlzIHVzZWRcbnRvIHRyYWNrIHJlZ2lvbnMgb2YgYW4gb2xkIHRyZWUgd2hvc2Ugbm9kZXMgbWlnaHQgYmUgcmV1c2VkIGluIG5ld1xucGFyc2VzLiBVc2UgdGhlIHN0YXRpY1xuW2BhcHBseUNoYW5nZXNgXSgjY29tbW9uLlRyZWVGcmFnbWVudF5hcHBseUNoYW5nZXMpIG1ldGhvZCB0b1xudXBkYXRlIGZyYWdtZW50cyBmb3IgZG9jdW1lbnQgY2hhbmdlcy5cbiovXG5jbGFzcyBUcmVlRnJhZ21lbnQge1xuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhIHRyZWUgZnJhZ21lbnQuIFlvdSdsbCB1c3VhbGx5IHdhbnQgdG8gdXNlXG4gICAgW2BhZGRUcmVlYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnReYWRkVHJlZSkgYW5kXG4gICAgW2BhcHBseUNoYW5nZXNgXSgjY29tbW9uLlRyZWVGcmFnbWVudF5hcHBseUNoYW5nZXMpIGluc3RlYWQgb2ZcbiAgICBjYWxsaW5nIHRoaXMgZGlyZWN0bHkuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc3RhcnQgb2YgdGhlIHVuY2hhbmdlZCByYW5nZSBwb2ludGVkIHRvIGJ5IHRoaXMgZnJhZ21lbnQuXG4gICAgVGhpcyByZWZlcnMgdG8gYW4gb2Zmc2V0IGluIHRoZSBfdXBkYXRlZF8gZG9jdW1lbnQgKGFzIG9wcG9zZWRcbiAgICB0byB0aGUgb3JpZ2luYWwgdHJlZSkuXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgZW5kIG9mIHRoZSB1bmNoYW5nZWQgcmFuZ2UuXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhlIHRyZWUgdGhhdCB0aGlzIGZyYWdtZW50IGlzIGJhc2VkIG9uLlxuICAgICovXG4gICAgdHJlZSwgXG4gICAgLyoqXG4gICAgVGhlIG9mZnNldCBiZXR3ZWVuIHRoZSBmcmFnbWVudCdzIHRyZWUgYW5kIHRoZSBkb2N1bWVudCB0aGF0XG4gICAgdGhpcyBmcmFnbWVudCBjYW4gYmUgdXNlZCBhZ2FpbnN0LiBBZGQgdGhpcyB3aGVuIGdvaW5nIGZyb21cbiAgICBkb2N1bWVudCB0byB0cmVlIHBvc2l0aW9ucywgc3VidHJhY3QgaXQgdG8gZ28gZnJvbSB0cmVlIHRvXG4gICAgZG9jdW1lbnQgcG9zaXRpb25zLlxuICAgICovXG4gICAgb2Zmc2V0LCBvcGVuU3RhcnQgPSBmYWxzZSwgb3BlbkVuZCA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMub3BlbiA9IChvcGVuU3RhcnQgPyAxIC8qIE9wZW4uU3RhcnQgKi8gOiAwKSB8IChvcGVuRW5kID8gMiAvKiBPcGVuLkVuZCAqLyA6IDApO1xuICAgIH1cbiAgICAvKipcbiAgICBXaGV0aGVyIHRoZSBzdGFydCBvZiB0aGUgZnJhZ21lbnQgcmVwcmVzZW50cyB0aGUgc3RhcnQgb2YgYVxuICAgIHBhcnNlLCBvciB0aGUgZW5kIG9mIGEgY2hhbmdlLiAoSW4gdGhlIHNlY29uZCBjYXNlLCBpdCBtYXkgbm90XG4gICAgYmUgc2FmZSB0byByZXVzZSBzb21lIG5vZGVzIGF0IHRoZSBzdGFydCwgZGVwZW5kaW5nIG9uIHRoZVxuICAgIHBhcnNpbmcgYWxnb3JpdGhtLilcbiAgICAqL1xuICAgIGdldCBvcGVuU3RhcnQoKSB7IHJldHVybiAodGhpcy5vcGVuICYgMSAvKiBPcGVuLlN0YXJ0ICovKSA+IDA7IH1cbiAgICAvKipcbiAgICBXaGV0aGVyIHRoZSBlbmQgb2YgdGhlIGZyYWdtZW50IHJlcHJlc2VudHMgdGhlIGVuZCBvZiBhXG4gICAgZnVsbC1kb2N1bWVudCBwYXJzZSwgb3IgdGhlIHN0YXJ0IG9mIGEgY2hhbmdlLlxuICAgICovXG4gICAgZ2V0IG9wZW5FbmQoKSB7IHJldHVybiAodGhpcy5vcGVuICYgMiAvKiBPcGVuLkVuZCAqLykgPiAwOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2V0IG9mIGZyYWdtZW50cyBmcm9tIGEgZnJlc2hseSBwYXJzZWQgdHJlZSwgb3IgdXBkYXRlXG4gICAgYW4gZXhpc3Rpbmcgc2V0IG9mIGZyYWdtZW50cyBieSByZXBsYWNpbmcgdGhlIG9uZXMgdGhhdCBvdmVybGFwXG4gICAgd2l0aCBhIHRyZWUgd2l0aCBjb250ZW50IGZyb20gdGhlIG5ldyB0cmVlLiBXaGVuIGBwYXJ0aWFsYCBpc1xuICAgIHRydWUsIHRoZSBwYXJzZSBpcyB0cmVhdGVkIGFzIGluY29tcGxldGUsIGFuZCB0aGUgcmVzdWx0aW5nXG4gICAgZnJhZ21lbnQgaGFzIFtgb3BlbkVuZGBdKCNjb21tb24uVHJlZUZyYWdtZW50Lm9wZW5FbmQpIHNldCB0b1xuICAgIHRydWUuXG4gICAgKi9cbiAgICBzdGF0aWMgYWRkVHJlZSh0cmVlLCBmcmFnbWVudHMgPSBbXSwgcGFydGlhbCA9IGZhbHNlKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbbmV3IFRyZWVGcmFnbWVudCgwLCB0cmVlLmxlbmd0aCwgdHJlZSwgMCwgZmFsc2UsIHBhcnRpYWwpXTtcbiAgICAgICAgZm9yIChsZXQgZiBvZiBmcmFnbWVudHMpXG4gICAgICAgICAgICBpZiAoZi50byA+IHRyZWUubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGYpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBBcHBseSBhIHNldCBvZiBlZGl0cyB0byBhbiBhcnJheSBvZiBmcmFnbWVudHMsIHJlbW92aW5nIG9yXG4gICAgc3BsaXR0aW5nIGZyYWdtZW50cyBhcyBuZWNlc3NhcnkgdG8gcmVtb3ZlIGVkaXRlZCByYW5nZXMsIGFuZFxuICAgIGFkanVzdGluZyBvZmZzZXRzIGZvciBmcmFnbWVudHMgdGhhdCBtb3ZlZC5cbiAgICAqL1xuICAgIHN0YXRpYyBhcHBseUNoYW5nZXMoZnJhZ21lbnRzLCBjaGFuZ2VzLCBtaW5HYXAgPSAxMjgpIHtcbiAgICAgICAgaWYgKCFjaGFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudHM7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IGZJID0gMSwgbmV4dEYgPSBmcmFnbWVudHMubGVuZ3RoID8gZnJhZ21lbnRzWzBdIDogbnVsbDtcbiAgICAgICAgZm9yIChsZXQgY0kgPSAwLCBwb3MgPSAwLCBvZmYgPSAwOzsgY0krKykge1xuICAgICAgICAgICAgbGV0IG5leHRDID0gY0kgPCBjaGFuZ2VzLmxlbmd0aCA/IGNoYW5nZXNbY0ldIDogbnVsbDtcbiAgICAgICAgICAgIGxldCBuZXh0UG9zID0gbmV4dEMgPyBuZXh0Qy5mcm9tQSA6IDFlOTtcbiAgICAgICAgICAgIGlmIChuZXh0UG9zIC0gcG9zID49IG1pbkdhcClcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV4dEYgJiYgbmV4dEYuZnJvbSA8IG5leHRQb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1dCA9IG5leHRGO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zID49IGN1dC5mcm9tIHx8IG5leHRQb3MgPD0gY3V0LnRvIHx8IG9mZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZGcm9tID0gTWF0aC5tYXgoY3V0LmZyb20sIHBvcykgLSBvZmYsIGZUbyA9IE1hdGgubWluKGN1dC50bywgbmV4dFBvcykgLSBvZmY7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXQgPSBmRnJvbSA+PSBmVG8gPyBudWxsIDogbmV3IFRyZWVGcmFnbWVudChmRnJvbSwgZlRvLCBjdXQudHJlZSwgY3V0Lm9mZnNldCArIG9mZiwgY0kgPiAwLCAhIW5leHRDKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY3V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY3V0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRGLnRvID4gbmV4dFBvcylcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBuZXh0RiA9IGZJIDwgZnJhZ21lbnRzLmxlbmd0aCA/IGZyYWdtZW50c1tmSSsrXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFuZXh0QylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHBvcyA9IG5leHRDLnRvQTtcbiAgICAgICAgICAgIG9mZiA9IG5leHRDLnRvQSAtIG5leHRDLnRvQjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8qKlxuQSBzdXBlcmNsYXNzIHRoYXQgcGFyc2VycyBzaG91bGQgZXh0ZW5kLlxuKi9cbmNsYXNzIFBhcnNlciB7XG4gICAgLyoqXG4gICAgU3RhcnQgYSBwYXJzZSwgcmV0dXJuaW5nIGEgW3BhcnRpYWwgcGFyc2VdKCNjb21tb24uUGFydGlhbFBhcnNlKVxuICAgIG9iamVjdC4gW2BmcmFnbWVudHNgXSgjY29tbW9uLlRyZWVGcmFnbWVudCkgY2FuIGJlIHBhc3NlZCBpbiB0b1xuICAgIG1ha2UgdGhlIHBhcnNlIGluY3JlbWVudGFsLlxuICAgIFxuICAgIEJ5IGRlZmF1bHQsIHRoZSBlbnRpcmUgaW5wdXQgaXMgcGFyc2VkLiBZb3UgY2FuIHBhc3MgYHJhbmdlc2AsXG4gICAgd2hpY2ggc2hvdWxkIGJlIGEgc29ydGVkIGFycmF5IG9mIG5vbi1lbXB0eSwgbm9uLW92ZXJsYXBwaW5nXG4gICAgcmFuZ2VzLCB0byBwYXJzZSBvbmx5IHRob3NlIHJhbmdlcy4gVGhlIHRyZWUgcmV0dXJuZWQgaW4gdGhhdFxuICAgIGNhc2Ugd2lsbCBzdGFydCBhdCBgcmFuZ2VzWzBdLmZyb21gLlxuICAgICovXG4gICAgc3RhcnRQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgaW5wdXQgPSBuZXcgU3RyaW5nSW5wdXQoaW5wdXQpO1xuICAgICAgICByYW5nZXMgPSAhcmFuZ2VzID8gW25ldyBSYW5nZSgwLCBpbnB1dC5sZW5ndGgpXSA6IHJhbmdlcy5sZW5ndGggPyByYW5nZXMubWFwKHIgPT4gbmV3IFJhbmdlKHIuZnJvbSwgci50bykpIDogW25ldyBSYW5nZSgwLCAwKV07XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVBhcnNlKGlucHV0LCBmcmFnbWVudHMgfHwgW10sIHJhbmdlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJ1biBhIGZ1bGwgcGFyc2UsIHJldHVybmluZyB0aGUgcmVzdWx0aW5nIHRyZWUuXG4gICAgKi9cbiAgICBwYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgbGV0IHBhcnNlID0gdGhpcy5zdGFydFBhcnNlKGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcyk7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBkb25lID0gcGFyc2UuYWR2YW5jZSgpO1xuICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbmU7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBTdHJpbmdJbnB1dCB7XG4gICAgY29uc3RydWN0b3Ioc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy5zdHJpbmcubGVuZ3RoOyB9XG4gICAgY2h1bmsoZnJvbSkgeyByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UoZnJvbSk7IH1cbiAgICBnZXQgbGluZUNodW5rcygpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgcmVhZChmcm9tLCB0bykgeyByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UoZnJvbSwgdG8pOyB9XG59XG5cbi8qKlxuQ3JlYXRlIGEgcGFyc2Ugd3JhcHBlciB0aGF0LCBhZnRlciB0aGUgaW5uZXIgcGFyc2UgY29tcGxldGVzLFxuc2NhbnMgaXRzIHRyZWUgZm9yIG1peGVkIGxhbmd1YWdlIHJlZ2lvbnMgd2l0aCB0aGUgYG5lc3RgXG5mdW5jdGlvbiwgcnVucyB0aGUgcmVzdWx0aW5nIFtpbm5lciBwYXJzZXNdKCNjb21tb24uTmVzdGVkUGFyc2UpLFxuYW5kIHRoZW4gW21vdW50c10oI2NvbW1vbi5Ob2RlUHJvcF5tb3VudGVkKSB0aGVpciByZXN1bHRzIG9udG8gdGhlXG50cmVlLlxuKi9cbmZ1bmN0aW9uIHBhcnNlTWl4ZWQobmVzdCkge1xuICAgIHJldHVybiAocGFyc2UsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykgPT4gbmV3IE1peGVkUGFyc2UocGFyc2UsIG5lc3QsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcyk7XG59XG5jbGFzcyBJbm5lclBhcnNlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIHBhcnNlLCBvdmVybGF5LCB0YXJnZXQsIGZyb20pIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMucGFyc2UgPSBwYXJzZTtcbiAgICAgICAgdGhpcy5vdmVybGF5ID0gb3ZlcmxheTtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tSYW5nZXMocmFuZ2VzKSB7XG4gICAgaWYgKCFyYW5nZXMubGVuZ3RoIHx8IHJhbmdlcy5zb21lKHIgPT4gci5mcm9tID49IHIudG8pKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5uZXIgcGFyc2UgcmFuZ2VzIGdpdmVuOiBcIiArIEpTT04uc3RyaW5naWZ5KHJhbmdlcykpO1xufVxuY2xhc3MgQWN0aXZlT3ZlcmxheSB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBwcmVkaWNhdGUsIG1vdW50cywgaW5kZXgsIHN0YXJ0LCB0YXJnZXQsIHByZXYpIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLm1vdW50cyA9IG1vdW50cztcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLnByZXYgPSBwcmV2O1xuICAgICAgICB0aGlzLmRlcHRoID0gMDtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSBbXTtcbiAgICB9XG59XG5jb25zdCBzdG9wcGVkSW5uZXIgPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuY2xhc3MgTWl4ZWRQYXJzZSB7XG4gICAgY29uc3RydWN0b3IoYmFzZSwgbmVzdCwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIHRoaXMubmVzdCA9IG5lc3Q7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHM7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICB0aGlzLmlubmVyID0gW107XG4gICAgICAgIHRoaXMuaW5uZXJEb25lID0gMDtcbiAgICAgICAgdGhpcy5iYXNlVHJlZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RvcHBlZEF0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5iYXNlUGFyc2UgPSBiYXNlO1xuICAgIH1cbiAgICBhZHZhbmNlKCkge1xuICAgICAgICBpZiAodGhpcy5iYXNlUGFyc2UpIHtcbiAgICAgICAgICAgIGxldCBkb25lID0gdGhpcy5iYXNlUGFyc2UuYWR2YW5jZSgpO1xuICAgICAgICAgICAgaWYgKCFkb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdGhpcy5iYXNlUGFyc2UgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5iYXNlVHJlZSA9IGRvbmU7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0SW5uZXIoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGlubmVyIG9mIHRoaXMuaW5uZXIpXG4gICAgICAgICAgICAgICAgICAgIGlubmVyLnBhcnNlLnN0b3BBdCh0aGlzLnN0b3BwZWRBdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5uZXJEb25lID09IHRoaXMuaW5uZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5iYXNlVHJlZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBUcmVlKHJlc3VsdC50eXBlLCByZXN1bHQuY2hpbGRyZW4sIHJlc3VsdC5wb3NpdGlvbnMsIHJlc3VsdC5sZW5ndGgsIHJlc3VsdC5wcm9wVmFsdWVzLmNvbmNhdChbW3N0b3BwZWRJbm5lciwgdGhpcy5zdG9wcGVkQXRdXSkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5uZXIgPSB0aGlzLmlubmVyW3RoaXMuaW5uZXJEb25lXSwgZG9uZSA9IGlubmVyLnBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuaW5uZXJEb25lKys7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgc29tZXdoYXQgZG9kZ3kgYnV0IHN1cGVyIGhlbHBmdWwgaGFjayB3aGVyZSB3ZVxuICAgICAgICAgICAgLy8gcGF0Y2ggdXAgbm9kZXMgY3JlYXRlZCBieSB0aGUgaW5uZXIgcGFyc2UgKGFuZCB0aHVzXG4gICAgICAgICAgICAvLyBwcmVzdW1hYmx5IG5vdCBhbGlhc2VkIGFueXdoZXJlIGVsc2UpIHRvIGhvbGQgdGhlIGluZm9ybWF0aW9uXG4gICAgICAgICAgICAvLyBhYm91dCB0aGUgaW5uZXIgcGFyc2UuXG4gICAgICAgICAgICBsZXQgcHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIGlubmVyLnRhcmdldC5wcm9wcyk7XG4gICAgICAgICAgICBwcm9wc1tOb2RlUHJvcC5tb3VudGVkLmlkXSA9IG5ldyBNb3VudGVkVHJlZShkb25lLCBpbm5lci5vdmVybGF5LCBpbm5lci5wYXJzZXIpO1xuICAgICAgICAgICAgaW5uZXIudGFyZ2V0LnByb3BzID0gcHJvcHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldCBwYXJzZWRQb3MoKSB7XG4gICAgICAgIGlmICh0aGlzLmJhc2VQYXJzZSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5pbnB1dC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmlubmVyRG9uZTsgaSA8IHRoaXMuaW5uZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlubmVyW2ldLmZyb20gPCBwb3MpXG4gICAgICAgICAgICAgICAgcG9zID0gTWF0aC5taW4ocG9zLCB0aGlzLmlubmVyW2ldLnBhcnNlLnBhcnNlZFBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgc3RvcEF0KHBvcykge1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IHBvcztcbiAgICAgICAgaWYgKHRoaXMuYmFzZVBhcnNlKVxuICAgICAgICAgICAgdGhpcy5iYXNlUGFyc2Uuc3RvcEF0KHBvcyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmlubmVyRG9uZTsgaSA8IHRoaXMuaW5uZXIubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgdGhpcy5pbm5lcltpXS5wYXJzZS5zdG9wQXQocG9zKTtcbiAgICB9XG4gICAgc3RhcnRJbm5lcigpIHtcbiAgICAgICAgbGV0IGZyYWdtZW50Q3Vyc29yID0gbmV3IEZyYWdtZW50Q3Vyc29yKHRoaXMuZnJhZ21lbnRzKTtcbiAgICAgICAgbGV0IG92ZXJsYXkgPSBudWxsO1xuICAgICAgICBsZXQgY292ZXJlZCA9IG51bGw7XG4gICAgICAgIGxldCBjdXJzb3IgPSBuZXcgVHJlZUN1cnNvcihuZXcgVHJlZU5vZGUodGhpcy5iYXNlVHJlZSwgdGhpcy5yYW5nZXNbMF0uZnJvbSwgMCwgbnVsbCksIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMgfCBJdGVyTW9kZS5JZ25vcmVNb3VudHMpO1xuICAgICAgICBzY2FuOiBmb3IgKGxldCBuZXN0LCBpc0NvdmVyZWQ7Oykge1xuICAgICAgICAgICAgbGV0IGVudGVyID0gdHJ1ZSwgcmFuZ2U7XG4gICAgICAgICAgICBpZiAodGhpcy5zdG9wcGVkQXQgIT0gbnVsbCAmJiBjdXJzb3IuZnJvbSA+PSB0aGlzLnN0b3BwZWRBdCkge1xuICAgICAgICAgICAgICAgIGVudGVyID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmcmFnbWVudEN1cnNvci5oYXNOb2RlKGN1cnNvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWF0Y2ggPSBvdmVybGF5Lm1vdW50cy5maW5kKG0gPT4gbS5mcmFnLmZyb20gPD0gY3Vyc29yLmZyb20gJiYgbS5mcmFnLnRvID49IGN1cnNvci50byAmJiBtLm1vdW50Lm92ZXJsYXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCByIG9mIG1hdGNoLm1vdW50Lm92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHIuZnJvbSArIG1hdGNoLnBvcywgdG8gPSByLnRvICsgbWF0Y2gucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcm9tID49IGN1cnNvci5mcm9tICYmIHRvIDw9IGN1cnNvci50byAmJiAhb3ZlcmxheS5yYW5nZXMuc29tZShyID0+IHIuZnJvbSA8IHRvICYmIHIudG8gPiBmcm9tKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5yYW5nZXMucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbnRlciA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY292ZXJlZCAmJiAoaXNDb3ZlcmVkID0gY2hlY2tDb3Zlcihjb3ZlcmVkLnJhbmdlcywgY3Vyc29yLmZyb20sIGN1cnNvci50bykpKSB7XG4gICAgICAgICAgICAgICAgZW50ZXIgPSBpc0NvdmVyZWQgIT0gMiAvKiBDb3Zlci5GdWxsICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWN1cnNvci50eXBlLmlzQW5vbnltb3VzICYmIChuZXN0ID0gdGhpcy5uZXN0KGN1cnNvciwgdGhpcy5pbnB1dCkpICYmXG4gICAgICAgICAgICAgICAgKGN1cnNvci5mcm9tIDwgY3Vyc29yLnRvIHx8ICFuZXN0Lm92ZXJsYXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IudHJlZSlcbiAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWxpemUoY3Vyc29yKTtcbiAgICAgICAgICAgICAgICBsZXQgb2xkTW91bnRzID0gZnJhZ21lbnRDdXJzb3IuZmluZE1vdW50cyhjdXJzb3IuZnJvbSwgbmVzdC5wYXJzZXIpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbmVzdC5vdmVybGF5ID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBvdmVybGF5ID0gbmV3IEFjdGl2ZU92ZXJsYXkobmVzdC5wYXJzZXIsIG5lc3Qub3ZlcmxheSwgb2xkTW91bnRzLCB0aGlzLmlubmVyLmxlbmd0aCwgY3Vyc29yLmZyb20sIGN1cnNvci50cmVlLCBvdmVybGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByYW5nZXMgPSBwdW5jaFJhbmdlcyh0aGlzLnJhbmdlcywgbmVzdC5vdmVybGF5IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoY3Vyc29yLmZyb20gPCBjdXJzb3IudG8gPyBbbmV3IFJhbmdlKGN1cnNvci5mcm9tLCBjdXJzb3IudG8pXSA6IFtdKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tSYW5nZXMocmFuZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggfHwgIW5lc3Qub3ZlcmxheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5uZXIucHVzaChuZXcgSW5uZXJQYXJzZShuZXN0LnBhcnNlciwgcmFuZ2VzLmxlbmd0aCA/IG5lc3QucGFyc2VyLnN0YXJ0UGFyc2UodGhpcy5pbnB1dCwgZW50ZXJGcmFnbWVudHMob2xkTW91bnRzLCByYW5nZXMpLCByYW5nZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBuZXN0LnBhcnNlci5zdGFydFBhcnNlKFwiXCIpLCBuZXN0Lm92ZXJsYXkgPyBuZXN0Lm92ZXJsYXkubWFwKHIgPT4gbmV3IFJhbmdlKHIuZnJvbSAtIGN1cnNvci5mcm9tLCByLnRvIC0gY3Vyc29yLmZyb20pKSA6IG51bGwsIGN1cnNvci50cmVlLCByYW5nZXMubGVuZ3RoID8gcmFuZ2VzWzBdLmZyb20gOiBjdXJzb3IuZnJvbSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5lc3Qub3ZlcmxheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3ZlcmVkID0geyByYW5nZXMsIGRlcHRoOiAwLCBwcmV2OiBjb3ZlcmVkIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3ZlcmxheSAmJiAocmFuZ2UgPSBvdmVybGF5LnByZWRpY2F0ZShjdXJzb3IpKSkge1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSBuZXcgUmFuZ2UoY3Vyc29yLmZyb20sIGN1cnNvci50byk7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlLmZyb20gPCByYW5nZS50bykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGFzdCA9IG92ZXJsYXkucmFuZ2VzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0ID49IDAgJiYgb3ZlcmxheS5yYW5nZXNbbGFzdF0udG8gPT0gcmFuZ2UuZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXkucmFuZ2VzW2xhc3RdID0geyBmcm9tOiBvdmVybGF5LnJhbmdlc1tsYXN0XS5mcm9tLCB0bzogcmFuZ2UudG8gfTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5yYW5nZXMucHVzaChyYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVudGVyICYmIGN1cnNvci5maXJzdENoaWxkKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSlcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5kZXB0aCsrO1xuICAgICAgICAgICAgICAgIGlmIChjb3ZlcmVkKVxuICAgICAgICAgICAgICAgICAgICBjb3ZlcmVkLmRlcHRoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJzb3IubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnNvci5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHNjYW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdmVybGF5ICYmICEtLW92ZXJsYXkuZGVwdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByYW5nZXMgPSBwdW5jaFJhbmdlcyh0aGlzLnJhbmdlcywgb3ZlcmxheS5yYW5nZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja1JhbmdlcyhyYW5nZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5uZXIuc3BsaWNlKG92ZXJsYXkuaW5kZXgsIDAsIG5ldyBJbm5lclBhcnNlKG92ZXJsYXkucGFyc2VyLCBvdmVybGF5LnBhcnNlci5zdGFydFBhcnNlKHRoaXMuaW5wdXQsIGVudGVyRnJhZ21lbnRzKG92ZXJsYXkubW91bnRzLCByYW5nZXMpLCByYW5nZXMpLCBvdmVybGF5LnJhbmdlcy5tYXAociA9PiBuZXcgUmFuZ2Uoci5mcm9tIC0gb3ZlcmxheS5zdGFydCwgci50byAtIG92ZXJsYXkuc3RhcnQpKSwgb3ZlcmxheS50YXJnZXQsIHJhbmdlc1swXS5mcm9tKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGF5ID0gb3ZlcmxheS5wcmV2O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3ZlcmVkICYmICEtLWNvdmVyZWQuZGVwdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3ZlcmVkID0gY292ZXJlZC5wcmV2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrQ292ZXIoY292ZXJlZCwgZnJvbSwgdG8pIHtcbiAgICBmb3IgKGxldCByYW5nZSBvZiBjb3ZlcmVkKSB7XG4gICAgICAgIGlmIChyYW5nZS5mcm9tID49IHRvKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChyYW5nZS50byA+IGZyb20pXG4gICAgICAgICAgICByZXR1cm4gcmFuZ2UuZnJvbSA8PSBmcm9tICYmIHJhbmdlLnRvID49IHRvID8gMiAvKiBDb3Zlci5GdWxsICovIDogMSAvKiBDb3Zlci5QYXJ0aWFsICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBDb3Zlci5Ob25lICovO1xufVxuLy8gVGFrZSBhIHBpZWNlIG9mIGJ1ZmZlciBhbmQgY29udmVydCBpdCBpbnRvIGEgc3RhbmQtYWxvbmVcbi8vIFRyZWVCdWZmZXIuXG5mdW5jdGlvbiBzbGljZUJ1ZihidWYsIHN0YXJ0SSwgZW5kSSwgbm9kZXMsIHBvc2l0aW9ucywgb2ZmKSB7XG4gICAgaWYgKHN0YXJ0SSA8IGVuZEkpIHtcbiAgICAgICAgbGV0IGZyb20gPSBidWYuYnVmZmVyW3N0YXJ0SSArIDFdO1xuICAgICAgICBub2Rlcy5wdXNoKGJ1Zi5zbGljZShzdGFydEksIGVuZEksIGZyb20pKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goZnJvbSAtIG9mZik7XG4gICAgfVxufVxuLy8gVGhpcyBmdW5jdGlvbiB0YWtlcyBhIG5vZGUgdGhhdCdzIGluIGEgYnVmZmVyLCBhbmQgY29udmVydHMgaXQsIGFuZFxuLy8gaXRzIHBhcmVudCBidWZmZXIgbm9kZXMsIGludG8gYSBUcmVlLiBUaGlzIGlzIGFnYWluIGFjdGluZyBvbiB0aGVcbi8vIGFzc3VtcHRpb24gdGhhdCB0aGUgdHJlZXMgYW5kIGJ1ZmZlcnMgaGF2ZSBiZWVuIGNvbnN0cnVjdGVkIGJ5IHRoZVxuLy8gcGFyc2UgdGhhdCB3YXMgcmFuIHZpYSB0aGUgbWl4IHBhcnNlciwgYW5kIHRodXMgYXJlbid0IHNoYXJlZCB3aXRoXG4vLyBhbnkgb3RoZXIgY29kZSwgbWFraW5nIHZpb2xhdGlvbnMgb2YgdGhlIGltbXV0YWJpbGl0eSBzYWZlLlxuZnVuY3Rpb24gbWF0ZXJpYWxpemUoY3Vyc29yKSB7XG4gICAgbGV0IHsgbm9kZSB9ID0gY3Vyc29yLCBzdGFjayA9IFtdO1xuICAgIGxldCBidWZmZXIgPSBub2RlLmNvbnRleHQuYnVmZmVyO1xuICAgIC8vIFNjYW4gdXAgdG8gdGhlIG5lYXJlc3QgdHJlZVxuICAgIGRvIHtcbiAgICAgICAgc3RhY2sucHVzaChjdXJzb3IuaW5kZXgpO1xuICAgICAgICBjdXJzb3IucGFyZW50KCk7XG4gICAgfSB3aGlsZSAoIWN1cnNvci50cmVlKTtcbiAgICAvLyBGaW5kIHRoZSBpbmRleCBvZiB0aGUgYnVmZmVyIGluIHRoYXQgdHJlZVxuICAgIGxldCBiYXNlID0gY3Vyc29yLnRyZWUsIGkgPSBiYXNlLmNoaWxkcmVuLmluZGV4T2YoYnVmZmVyKTtcbiAgICBsZXQgYnVmID0gYmFzZS5jaGlsZHJlbltpXSwgYiA9IGJ1Zi5idWZmZXIsIG5ld1N0YWNrID0gW2ldO1xuICAgIC8vIFNwbGl0IGEgbGV2ZWwgaW4gdGhlIGJ1ZmZlciwgcHV0dGluZyB0aGUgbm9kZXMgYmVmb3JlIGFuZCBhZnRlclxuICAgIC8vIHRoZSBjaGlsZCB0aGF0IGNvbnRhaW5zIGBub2RlYCBpbnRvIG5ldyBidWZmZXJzLlxuICAgIGZ1bmN0aW9uIHNwbGl0KHN0YXJ0SSwgZW5kSSwgdHlwZSwgaW5uZXJPZmZzZXQsIGxlbmd0aCwgc3RhY2tQb3MpIHtcbiAgICAgICAgbGV0IHRhcmdldEkgPSBzdGFja1tzdGFja1Bvc107XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdLCBwb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgc2xpY2VCdWYoYnVmLCBzdGFydEksIHRhcmdldEksIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGlubmVyT2Zmc2V0KTtcbiAgICAgICAgbGV0IGZyb20gPSBiW3RhcmdldEkgKyAxXSwgdG8gPSBiW3RhcmdldEkgKyAyXTtcbiAgICAgICAgbmV3U3RhY2sucHVzaChjaGlsZHJlbi5sZW5ndGgpO1xuICAgICAgICBsZXQgY2hpbGQgPSBzdGFja1Bvc1xuICAgICAgICAgICAgPyBzcGxpdCh0YXJnZXRJICsgNCwgYlt0YXJnZXRJICsgM10sIGJ1Zi5zZXQudHlwZXNbYlt0YXJnZXRJXV0sIGZyb20sIHRvIC0gZnJvbSwgc3RhY2tQb3MgLSAxKVxuICAgICAgICAgICAgOiBub2RlLnRvVHJlZSgpO1xuICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goZnJvbSAtIGlubmVyT2Zmc2V0KTtcbiAgICAgICAgc2xpY2VCdWYoYnVmLCBiW3RhcmdldEkgKyAzXSwgZW5kSSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgaW5uZXJPZmZzZXQpO1xuICAgICAgICByZXR1cm4gbmV3IFRyZWUodHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKTtcbiAgICB9XG4gICAgYmFzZS5jaGlsZHJlbltpXSA9IHNwbGl0KDAsIGIubGVuZ3RoLCBOb2RlVHlwZS5ub25lLCAwLCBidWYubGVuZ3RoLCBzdGFjay5sZW5ndGggLSAxKTtcbiAgICAvLyBNb3ZlIHRoZSBjdXJzb3IgYmFjayB0byB0aGUgdGFyZ2V0IG5vZGVcbiAgICBmb3IgKGxldCBpbmRleCBvZiBuZXdTdGFjaykge1xuICAgICAgICBsZXQgdHJlZSA9IGN1cnNvci50cmVlLmNoaWxkcmVuW2luZGV4XSwgcG9zID0gY3Vyc29yLnRyZWUucG9zaXRpb25zW2luZGV4XTtcbiAgICAgICAgY3Vyc29yLnlpZWxkKG5ldyBUcmVlTm9kZSh0cmVlLCBwb3MgKyBjdXJzb3IuZnJvbSwgaW5kZXgsIGN1cnNvci5fdHJlZSkpO1xuICAgIH1cbn1cbmNsYXNzIFN0cnVjdHVyZUN1cnNvciB7XG4gICAgY29uc3RydWN0b3Iocm9vdCwgb2Zmc2V0KSB7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSByb290LmN1cnNvcihJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzIHwgSXRlck1vZGUuSWdub3JlTW91bnRzKTtcbiAgICB9XG4gICAgLy8gTW92ZSB0byB0aGUgZmlyc3Qgbm9kZSAoaW4gcHJlLW9yZGVyKSB0aGF0IHN0YXJ0cyBhdCBvciBhZnRlciBgcG9zYC5cbiAgICBtb3ZlVG8ocG9zKSB7XG4gICAgICAgIGxldCB7IGN1cnNvciB9ID0gdGhpcywgcCA9IHBvcyAtIHRoaXMub2Zmc2V0O1xuICAgICAgICB3aGlsZSAoIXRoaXMuZG9uZSAmJiBjdXJzb3IuZnJvbSA8IHApIHtcbiAgICAgICAgICAgIGlmIChjdXJzb3IudG8gPj0gcG9zICYmIGN1cnNvci5lbnRlcihwLCAxLCBJdGVyTW9kZS5JZ25vcmVPdmVybGF5cyB8IEl0ZXJNb2RlLkV4Y2x1ZGVCdWZmZXJzKSkgO1xuICAgICAgICAgICAgZWxzZSBpZiAoIWN1cnNvci5uZXh0KGZhbHNlKSlcbiAgICAgICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhc05vZGUoY3Vyc29yKSB7XG4gICAgICAgIHRoaXMubW92ZVRvKGN1cnNvci5mcm9tKTtcbiAgICAgICAgaWYgKCF0aGlzLmRvbmUgJiYgdGhpcy5jdXJzb3IuZnJvbSArIHRoaXMub2Zmc2V0ID09IGN1cnNvci5mcm9tICYmIHRoaXMuY3Vyc29yLnRyZWUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHRyZWUgPSB0aGlzLmN1cnNvci50cmVlOzspIHtcbiAgICAgICAgICAgICAgICBpZiAodHJlZSA9PSBjdXJzb3IudHJlZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHRyZWUuY2hpbGRyZW4ubGVuZ3RoICYmIHRyZWUucG9zaXRpb25zWzBdID09IDAgJiYgdHJlZS5jaGlsZHJlblswXSBpbnN0YW5jZW9mIFRyZWUpXG4gICAgICAgICAgICAgICAgICAgIHRyZWUgPSB0cmVlLmNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmNsYXNzIEZyYWdtZW50Q3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcbiAgICAgICAgdGhpcy5jdXJUbyA9IDA7XG4gICAgICAgIHRoaXMuZnJhZ0kgPSAwO1xuICAgICAgICBpZiAoZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gdGhpcy5jdXJGcmFnID0gZnJhZ21lbnRzWzBdO1xuICAgICAgICAgICAgdGhpcy5jdXJUbyA9IChfYSA9IGZpcnN0LnRyZWUucHJvcChzdG9wcGVkSW5uZXIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmaXJzdC50bztcbiAgICAgICAgICAgIHRoaXMuaW5uZXIgPSBuZXcgU3RydWN0dXJlQ3Vyc29yKGZpcnN0LnRyZWUsIC1maXJzdC5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJGcmFnID0gdGhpcy5pbm5lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFzTm9kZShub2RlKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmN1ckZyYWcgJiYgbm9kZS5mcm9tID49IHRoaXMuY3VyVG8pXG4gICAgICAgICAgICB0aGlzLm5leHRGcmFnKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmN1ckZyYWcgJiYgdGhpcy5jdXJGcmFnLmZyb20gPD0gbm9kZS5mcm9tICYmIHRoaXMuY3VyVG8gPj0gbm9kZS50byAmJiB0aGlzLmlubmVyLmhhc05vZGUobm9kZSk7XG4gICAgfVxuICAgIG5leHRGcmFnKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuZnJhZ0krKztcbiAgICAgICAgaWYgKHRoaXMuZnJhZ0kgPT0gdGhpcy5mcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmN1ckZyYWcgPSB0aGlzLmlubmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBmcmFnID0gdGhpcy5jdXJGcmFnID0gdGhpcy5mcmFnbWVudHNbdGhpcy5mcmFnSV07XG4gICAgICAgICAgICB0aGlzLmN1clRvID0gKF9hID0gZnJhZy50cmVlLnByb3Aoc3RvcHBlZElubmVyKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZnJhZy50bztcbiAgICAgICAgICAgIHRoaXMuaW5uZXIgPSBuZXcgU3RydWN0dXJlQ3Vyc29yKGZyYWcudHJlZSwgLWZyYWcub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5kTW91bnRzKHBvcywgcGFyc2VyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAodGhpcy5pbm5lcikge1xuICAgICAgICAgICAgdGhpcy5pbm5lci5jdXJzb3IubW92ZVRvKHBvcywgMSk7XG4gICAgICAgICAgICBmb3IgKGxldCBwb3MgPSB0aGlzLmlubmVyLmN1cnNvci5ub2RlOyBwb3M7IHBvcyA9IHBvcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbW91bnQgPSAoX2EgPSBwb3MudHJlZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByb3AoTm9kZVByb3AubW91bnRlZCk7XG4gICAgICAgICAgICAgICAgaWYgKG1vdW50ICYmIG1vdW50LnBhcnNlciA9PSBwYXJzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuZnJhZ0k7IGkgPCB0aGlzLmZyYWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZyYWcgPSB0aGlzLmZyYWdtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFnLmZyb20gPj0gcG9zLnRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWcudHJlZSA9PSB0aGlzLmN1ckZyYWcudHJlZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvczogcG9zLmZyb20gLSBmcmFnLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW91bnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHB1bmNoUmFuZ2VzKG91dGVyLCByYW5nZXMpIHtcbiAgICBsZXQgY29weSA9IG51bGwsIGN1cnJlbnQgPSByYW5nZXM7XG4gICAgZm9yIChsZXQgaSA9IDEsIGogPSAwOyBpIDwgb3V0ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGdhcEZyb20gPSBvdXRlcltpIC0gMV0udG8sIGdhcFRvID0gb3V0ZXJbaV0uZnJvbTtcbiAgICAgICAgZm9yICg7IGogPCBjdXJyZW50Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBsZXQgciA9IGN1cnJlbnRbal07XG4gICAgICAgICAgICBpZiAoci5mcm9tID49IGdhcFRvKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHIudG8gPD0gZ2FwRnJvbSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICghY29weSlcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY29weSA9IHJhbmdlcy5zbGljZSgpO1xuICAgICAgICAgICAgaWYgKHIuZnJvbSA8IGdhcEZyb20pIHtcbiAgICAgICAgICAgICAgICBjb3B5W2pdID0gbmV3IFJhbmdlKHIuZnJvbSwgZ2FwRnJvbSk7XG4gICAgICAgICAgICAgICAgaWYgKHIudG8gPiBnYXBUbylcbiAgICAgICAgICAgICAgICAgICAgY29weS5zcGxpY2UoaiArIDEsIDAsIG5ldyBSYW5nZShnYXBUbywgci50bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoci50byA+IGdhcFRvKSB7XG4gICAgICAgICAgICAgICAgY29weVtqLS1dID0gbmV3IFJhbmdlKGdhcFRvLCByLnRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvcHkuc3BsaWNlKGotLSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG59XG5mdW5jdGlvbiBmaW5kQ292ZXJDaGFuZ2VzKGEsIGIsIGZyb20sIHRvKSB7XG4gICAgbGV0IGlBID0gMCwgaUIgPSAwLCBpbkEgPSBmYWxzZSwgaW5CID0gZmFsc2UsIHBvcyA9IC0xZTk7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgbGV0IG5leHRBID0gaUEgPT0gYS5sZW5ndGggPyAxZTkgOiBpbkEgPyBhW2lBXS50byA6IGFbaUFdLmZyb207XG4gICAgICAgIGxldCBuZXh0QiA9IGlCID09IGIubGVuZ3RoID8gMWU5IDogaW5CID8gYltpQl0udG8gOiBiW2lCXS5mcm9tO1xuICAgICAgICBpZiAoaW5BICE9IGluQikge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgocG9zLCBmcm9tKSwgZW5kID0gTWF0aC5taW4obmV4dEEsIG5leHRCLCB0byk7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPCBlbmQpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFJhbmdlKHN0YXJ0LCBlbmQpKTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgPSBNYXRoLm1pbihuZXh0QSwgbmV4dEIpO1xuICAgICAgICBpZiAocG9zID09IDFlOSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAobmV4dEEgPT0gcG9zKSB7XG4gICAgICAgICAgICBpZiAoIWluQSlcbiAgICAgICAgICAgICAgICBpbkEgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5BID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaUErKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dEIgPT0gcG9zKSB7XG4gICAgICAgICAgICBpZiAoIWluQilcbiAgICAgICAgICAgICAgICBpbkIgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5CID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaUIrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gR2l2ZW4gYSBudW1iZXIgb2YgZnJhZ21lbnRzIGZvciB0aGUgb3V0ZXIgdHJlZSwgYW5kIGEgc2V0IG9mIHJhbmdlc1xuLy8gdG8gcGFyc2UsIGZpbmQgZnJhZ21lbnRzIGZvciBpbm5lciB0cmVlcyBtb3VudGVkIGFyb3VuZCB0aG9zZVxuLy8gcmFuZ2VzLCBpZiBhbnkuXG5mdW5jdGlvbiBlbnRlckZyYWdtZW50cyhtb3VudHMsIHJhbmdlcykge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCB7IHBvcywgbW91bnQsIGZyYWcgfSBvZiBtb3VudHMpIHtcbiAgICAgICAgbGV0IHN0YXJ0UG9zID0gcG9zICsgKG1vdW50Lm92ZXJsYXkgPyBtb3VudC5vdmVybGF5WzBdLmZyb20gOiAwKSwgZW5kUG9zID0gc3RhcnRQb3MgKyBtb3VudC50cmVlLmxlbmd0aDtcbiAgICAgICAgbGV0IGZyb20gPSBNYXRoLm1heChmcmFnLmZyb20sIHN0YXJ0UG9zKSwgdG8gPSBNYXRoLm1pbihmcmFnLnRvLCBlbmRQb3MpO1xuICAgICAgICBpZiAobW91bnQub3ZlcmxheSkge1xuICAgICAgICAgICAgbGV0IG92ZXJsYXkgPSBtb3VudC5vdmVybGF5Lm1hcChyID0+IG5ldyBSYW5nZShyLmZyb20gKyBwb3MsIHIudG8gKyBwb3MpKTtcbiAgICAgICAgICAgIGxldCBjaGFuZ2VzID0gZmluZENvdmVyQ2hhbmdlcyhyYW5nZXMsIG92ZXJsYXksIGZyb20sIHRvKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSBmcm9tOzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxhc3QgPSBpID09IGNoYW5nZXMubGVuZ3RoLCBlbmQgPSBsYXN0ID8gdG8gOiBjaGFuZ2VzW2ldLmZyb207XG4gICAgICAgICAgICAgICAgaWYgKGVuZCA+IHBvcylcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFRyZWVGcmFnbWVudChwb3MsIGVuZCwgbW91bnQudHJlZSwgLXN0YXJ0UG9zLCBmcmFnLmZyb20gPj0gcG9zIHx8IGZyYWcub3BlblN0YXJ0LCBmcmFnLnRvIDw9IGVuZCB8fCBmcmFnLm9wZW5FbmQpKTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgcG9zID0gY2hhbmdlc1tpXS50bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBUcmVlRnJhZ21lbnQoZnJvbSwgdG8sIG1vdW50LnRyZWUsIC1zdGFydFBvcywgZnJhZy5mcm9tID49IHN0YXJ0UG9zIHx8IGZyYWcub3BlblN0YXJ0LCBmcmFnLnRvIDw9IGVuZFBvcyB8fCBmcmFnLm9wZW5FbmQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgeyBEZWZhdWx0QnVmZmVyTGVuZ3RoLCBJdGVyTW9kZSwgTW91bnRlZFRyZWUsIE5vZGVQcm9wLCBOb2RlU2V0LCBOb2RlVHlwZSwgTm9kZVdlYWtNYXAsIFBhcnNlciwgVHJlZSwgVHJlZUJ1ZmZlciwgVHJlZUN1cnNvciwgVHJlZUZyYWdtZW50LCBwYXJzZU1peGVkIH07XG4iXSwibmFtZXMiOlsiRGVmYXVsdEJ1ZmZlckxlbmd0aCIsIm5leHRQcm9wSUQiLCJSYW5nZSIsImNvbnN0cnVjdG9yIiwiZnJvbSIsInRvIiwiTm9kZVByb3AiLCJjb25maWciLCJpZCIsInBlck5vZGUiLCJkZXNlcmlhbGl6ZSIsIkVycm9yIiwiYWRkIiwibWF0Y2giLCJSYW5nZUVycm9yIiwiTm9kZVR5cGUiLCJ0eXBlIiwicmVzdWx0IiwidW5kZWZpbmVkIiwiY2xvc2VkQnkiLCJzdHIiLCJzcGxpdCIsIm9wZW5lZEJ5IiwiZ3JvdXAiLCJpc29sYXRlIiwidmFsdWUiLCJjb250ZXh0SGFzaCIsImxvb2tBaGVhZCIsIm1vdW50ZWQiLCJNb3VudGVkVHJlZSIsInRyZWUiLCJvdmVybGF5IiwicGFyc2VyIiwiZ2V0IiwicHJvcHMiLCJub1Byb3BzIiwiT2JqZWN0IiwiY3JlYXRlIiwibmFtZSIsImZsYWdzIiwiZGVmaW5lIiwic3BlYyIsImxlbmd0aCIsInRvcCIsInNraXBwZWQiLCJlcnJvciIsInNyYyIsIkFycmF5IiwiaXNBcnJheSIsInByb3AiLCJpc1RvcCIsImlzU2tpcHBlZCIsImlzRXJyb3IiLCJpc0Fub255bW91cyIsImlzIiwiaW5kZXhPZiIsIm1hcCIsImRpcmVjdCIsIm5vZGUiLCJncm91cHMiLCJpIiwiZm91bmQiLCJub25lIiwiTm9kZVNldCIsInR5cGVzIiwiZXh0ZW5kIiwibmV3VHlwZXMiLCJuZXdQcm9wcyIsInNvdXJjZSIsImFzc2lnbiIsInB1c2giLCJDYWNoZWROb2RlIiwiV2Vha01hcCIsIkNhY2hlZElubmVyTm9kZSIsIkl0ZXJNb2RlIiwiVHJlZSIsImNoaWxkcmVuIiwicG9zaXRpb25zIiwidG9TdHJpbmciLCJjaCIsInRlc3QiLCJKU09OIiwic3RyaW5naWZ5IiwiY3Vyc29yIiwibW9kZSIsIlRyZWVDdXJzb3IiLCJ0b3BOb2RlIiwiY3Vyc29yQXQiLCJwb3MiLCJzaWRlIiwic2NvcGUiLCJtb3ZlVG8iLCJzZXQiLCJfdHJlZSIsIlRyZWVOb2RlIiwicmVzb2x2ZSIsInJlc29sdmVOb2RlIiwicmVzb2x2ZUlubmVyIiwicmVzb2x2ZVN0YWNrIiwic3RhY2tJdGVyYXRvciIsIml0ZXJhdGUiLCJlbnRlciIsImxlYXZlIiwiYW5vbiIsIkluY2x1ZGVBbm9ueW1vdXMiLCJjIiwiZW50ZXJlZCIsImZpcnN0Q2hpbGQiLCJuZXh0U2libGluZyIsInBhcmVudCIsInByb3BWYWx1ZXMiLCJiYWxhbmNlIiwiYmFsYW5jZVJhbmdlIiwibWFrZVRyZWUiLCJidWlsZCIsImRhdGEiLCJidWlsZFRyZWUiLCJlbXB0eSIsIkZsYXRCdWZmZXJDdXJzb3IiLCJidWZmZXIiLCJpbmRleCIsInN0YXJ0IiwiZW5kIiwic2l6ZSIsIm5leHQiLCJmb3JrIiwiVHJlZUJ1ZmZlciIsImNoaWxkU3RyaW5nIiwiam9pbiIsImVuZEluZGV4IiwiZmluZENoaWxkIiwic3RhcnRJbmRleCIsImRpciIsInBpY2siLCJjaGVja1NpZGUiLCJzbGljZSIsInN0YXJ0SSIsImVuZEkiLCJiIiwiY29weSIsIlVpbnQxNkFycmF5IiwibGVuIiwiaiIsIk1hdGgiLCJtYXgiLCJvdmVybGF5cyIsIl9hIiwiSWdub3JlT3ZlcmxheXMiLCJzY2FuIiwiaW5uZXIiLCJCYXNlTm9kZSIsImdldENoaWxkIiwiYmVmb3JlIiwiYWZ0ZXIiLCJyIiwiZ2V0Q2hpbGRyZW4iLCJtYXRjaENvbnRleHQiLCJjb250ZXh0IiwibWF0Y2hOb2RlQ29udGV4dCIsImVudGVyVW5maW5pc2hlZE5vZGVzQmVmb3JlIiwiY2hpbGRCZWZvcmUiLCJsYXN0IiwibGFzdENoaWxkIiwicHJldlNpYmxpbmciLCJfcGFyZW50IiwibmV4dENoaWxkIiwiZSIsIkV4Y2x1ZGVCdWZmZXJzIiwiQnVmZmVyTm9kZSIsIkJ1ZmZlckNvbnRleHQiLCJoYXNDaGlsZCIsIklnbm9yZU1vdW50cyIsImNoaWxkQWZ0ZXIiLCJyUG9zIiwibmV4dFNpZ25pZmljYW50UGFyZW50IiwidmFsIiwidG9UcmVlIiwiY3VyIiwicCIsImNoaWxkIiwiZXh0ZXJuYWxTaWJsaW5nIiwicGFyZW50U3RhcnQiLCJpdGVyU3RhY2siLCJoZWFkcyIsInBpY2tlZCIsIm5ld0hlYWRzIiwic3BsaWNlIiwiU3RhY2tJdGVyYXRvciIsImxheWVycyIsIm1vdW50Iiwicm9vdCIsInN0YWNrIiwiYnVmZmVyTm9kZSIsInlpZWxkTm9kZSIsIm4iLCJ1bnNoaWZ0IiwieWllbGRCdWYiLCJ5aWVsZCIsImVudGVyQ2hpbGQiLCJwb3AiLCJzaWJsaW5nIiwiZCIsImF0TGFzdE5vZGUiLCJtb3ZlIiwicHJldiIsImNhY2hlIiwiZGVwdGgiLCJtdXN0TGVhdmUiLCJzb21lIiwibm9kZVNldCIsIm1heEJ1ZmZlckxlbmd0aCIsInJldXNlZCIsIm1pblJlcGVhdFR5cGUiLCJ0YWtlTm9kZSIsIm1pblBvcyIsImluUmVwZWF0IiwibG9va0FoZWFkQXRTdGFydCIsImNvbnRleHRBdFN0YXJ0Iiwic3RhcnRQb3MiLCJmaW5kQnVmZmVyU2l6ZSIsInNraXAiLCJlbmRQb3MiLCJjb3B5VG9CdWZmZXIiLCJsb2NhbENoaWxkcmVuIiwibG9jYWxQb3NpdGlvbnMiLCJsb2NhbEluUmVwZWF0IiwibGFzdEdyb3VwIiwibGFzdEVuZCIsIm1ha2VSZXBlYXRMZWFmIiwidGFrZUZsYXROb2RlIiwicmV2ZXJzZSIsIm1ha2UiLCJtYWtlQmFsYW5jZWQiLCJub2RlcyIsIm5vZGVDb3VudCIsInN0b3BBdCIsImxhc3RJIiwibG9va0FoZWFkUHJvcCIsImJhc2UiLCJwYWlyIiwiY29uY2F0IiwibWF4U2l6ZSIsIm1pblN0YXJ0Iiwibm9kZVNpemUiLCJsb2NhbFNraXBwZWQiLCJub2RlU3RhcnQiLCJidWZmZXJTdGFydCIsInRvcElEIiwibm9kZVNpemVDYWNoZSIsImJhbGFuY2VUeXBlIiwibWtUb3AiLCJta1RyZWUiLCJ0b3RhbCIsIm1heENoaWxkIiwiY2VpbCIsImRpdmlkZSIsIm9mZnNldCIsImdyb3VwRnJvbSIsImdyb3VwU3RhcnQiLCJncm91cFNpemUiLCJuZXh0U2l6ZSIsIm9ubHkiLCJOb2RlV2Vha01hcCIsInNldEJ1ZmZlciIsIk1hcCIsImdldEJ1ZmZlciIsImN1cnNvclNldCIsImN1cnNvckdldCIsIlRyZWVGcmFnbWVudCIsIm9wZW5TdGFydCIsIm9wZW5FbmQiLCJvcGVuIiwiYWRkVHJlZSIsImZyYWdtZW50cyIsInBhcnRpYWwiLCJmIiwiYXBwbHlDaGFuZ2VzIiwiY2hhbmdlcyIsIm1pbkdhcCIsImZJIiwibmV4dEYiLCJjSSIsIm9mZiIsIm5leHRDIiwibmV4dFBvcyIsImZyb21BIiwiY3V0IiwiZkZyb20iLCJmVG8iLCJtaW4iLCJ0b0EiLCJ0b0IiLCJQYXJzZXIiLCJzdGFydFBhcnNlIiwiaW5wdXQiLCJyYW5nZXMiLCJTdHJpbmdJbnB1dCIsImNyZWF0ZVBhcnNlIiwicGFyc2UiLCJkb25lIiwiYWR2YW5jZSIsInN0cmluZyIsImNodW5rIiwibGluZUNodW5rcyIsInJlYWQiLCJwYXJzZU1peGVkIiwibmVzdCIsIk1peGVkUGFyc2UiLCJJbm5lclBhcnNlIiwidGFyZ2V0IiwiY2hlY2tSYW5nZXMiLCJBY3RpdmVPdmVybGF5IiwicHJlZGljYXRlIiwibW91bnRzIiwic3RvcHBlZElubmVyIiwiaW5uZXJEb25lIiwiYmFzZVRyZWUiLCJzdG9wcGVkQXQiLCJiYXNlUGFyc2UiLCJzdGFydElubmVyIiwicGFyc2VkUG9zIiwiZnJhZ21lbnRDdXJzb3IiLCJGcmFnbWVudEN1cnNvciIsImNvdmVyZWQiLCJpc0NvdmVyZWQiLCJyYW5nZSIsImhhc05vZGUiLCJmaW5kIiwibSIsImZyYWciLCJjaGVja0NvdmVyIiwibWF0ZXJpYWxpemUiLCJvbGRNb3VudHMiLCJmaW5kTW91bnRzIiwicHVuY2hSYW5nZXMiLCJlbnRlckZyYWdtZW50cyIsInNsaWNlQnVmIiwiYnVmIiwibmV3U3RhY2siLCJpbm5lck9mZnNldCIsInN0YWNrUG9zIiwidGFyZ2V0SSIsIlN0cnVjdHVyZUN1cnNvciIsImN1clRvIiwiZnJhZ0kiLCJmaXJzdCIsImN1ckZyYWciLCJuZXh0RnJhZyIsIm91dGVyIiwiY3VycmVudCIsImdhcEZyb20iLCJnYXBUbyIsImZpbmRDb3ZlckNoYW5nZXMiLCJhIiwiaUEiLCJpQiIsImluQSIsImluQiIsIm5leHRBIiwibmV4dEIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lezer/common/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lezer/highlight/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@lezer/highlight/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tag: () => (/* binding */ Tag),\n/* harmony export */   classHighlighter: () => (/* binding */ classHighlighter),\n/* harmony export */   getStyleTags: () => (/* binding */ getStyleTags),\n/* harmony export */   highlightCode: () => (/* binding */ highlightCode),\n/* harmony export */   highlightTree: () => (/* binding */ highlightTree),\n/* harmony export */   styleTags: () => (/* binding */ styleTags),\n/* harmony export */   tagHighlighter: () => (/* binding */ tagHighlighter),\n/* harmony export */   tags: () => (/* binding */ tags)\n/* harmony export */ });\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"(ssr)/./node_modules/@lezer/common/dist/index.js\");\n\nlet nextTagID = 0;\n/**\nHighlighting tags are markers that denote a highlighting category.\nThey are [associated](#highlight.styleTags) with parts of a syntax\ntree by a language mode, and then mapped to an actual CSS style by\na [highlighter](#highlight.Highlighter).\n\nBecause syntax tree node types and highlight styles have to be\nable to talk the same language, CodeMirror uses a mostly _closed_\n[vocabulary](#highlight.tags) of syntax tags (as opposed to\ntraditional open string-based systems, which make it hard for\nhighlighting themes to cover all the tokens produced by the\nvarious languages).\n\nIt _is_ possible to [define](#highlight.Tag^define) your own\nhighlighting tags for system-internal use (where you control both\nthe language package and the highlighter), but such tags will not\nbe picked up by regular highlighters (though you can derive them\nfrom standard tags to allow highlighters to fall back to those).\n*/ class Tag {\n    /**\n    @internal\n    */ constructor(/**\n    The optional name of the base tag @internal\n    */ name, /**\n    The set of this tag and all its parent tags, starting with\n    this one itself and sorted in order of decreasing specificity.\n    */ set, /**\n    The base unmodified tag that this one is based on, if it's\n    modified @internal\n    */ base, /**\n    The modifiers applied to this.base @internal\n    */ modified){\n        this.name = name;\n        this.set = set;\n        this.base = base;\n        this.modified = modified;\n        /**\n        @internal\n        */ this.id = nextTagID++;\n    }\n    toString() {\n        let { name } = this;\n        for (let mod of this.modified)if (mod.name) name = `${mod.name}(${name})`;\n        return name;\n    }\n    static define(nameOrParent, parent) {\n        let name = typeof nameOrParent == \"string\" ? nameOrParent : \"?\";\n        if (nameOrParent instanceof Tag) parent = nameOrParent;\n        if (parent === null || parent === void 0 ? void 0 : parent.base) throw new Error(\"Can not derive from a modified tag\");\n        let tag = new Tag(name, [], null, []);\n        tag.set.push(tag);\n        if (parent) for (let t of parent.set)tag.set.push(t);\n        return tag;\n    }\n    /**\n    Define a tag _modifier_, which is a function that, given a tag,\n    will return a tag that is a subtag of the original. Applying the\n    same modifier to a twice tag will return the same value (`m1(t1)\n    == m1(t1)`) and applying multiple modifiers will, regardless or\n    order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).\n    \n    When multiple modifiers are applied to a given base tag, each\n    smaller set of modifiers is registered as a parent, so that for\n    example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,\n    `m1(m3(t1)`, and so on.\n    */ static defineModifier(name) {\n        let mod = new Modifier(name);\n        return (tag)=>{\n            if (tag.modified.indexOf(mod) > -1) return tag;\n            return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b)=>a.id - b.id));\n        };\n    }\n}\nlet nextModifierID = 0;\nclass Modifier {\n    constructor(name){\n        this.name = name;\n        this.instances = [];\n        this.id = nextModifierID++;\n    }\n    static get(base, mods) {\n        if (!mods.length) return base;\n        let exists = mods[0].instances.find((t)=>t.base == base && sameArray(mods, t.modified));\n        if (exists) return exists;\n        let set = [], tag = new Tag(base.name, set, base, mods);\n        for (let m of mods)m.instances.push(tag);\n        let configs = powerSet(mods);\n        for (let parent of base.set)if (!parent.modified.length) for (let config of configs)set.push(Modifier.get(parent, config));\n        return tag;\n    }\n}\nfunction sameArray(a, b) {\n    return a.length == b.length && a.every((x, i)=>x == b[i]);\n}\nfunction powerSet(array) {\n    let sets = [\n        []\n    ];\n    for(let i = 0; i < array.length; i++){\n        for(let j = 0, e = sets.length; j < e; j++){\n            sets.push(sets[j].concat(array[i]));\n        }\n    }\n    return sets.sort((a, b)=>b.length - a.length);\n}\n/**\nThis function is used to add a set of tags to a language syntax\nvia [`NodeSet.extend`](#common.NodeSet.extend) or\n[`LRParser.configure`](#lr.LRParser.configure).\n\nThe argument object maps node selectors to [highlighting\ntags](#highlight.Tag) or arrays of tags.\n\nNode selectors may hold one or more (space-separated) node paths.\nSuch a path can be a [node name](#common.NodeType.name), or\nmultiple node names (or `*` wildcards) separated by slash\ncharacters, as in `\"Block/Declaration/VariableName\"`. Such a path\nmatches the final node but only if its direct parent nodes are the\nother nodes mentioned. A `*` in such a path matches any parent,\nbut only a single levelâ€”wildcards that match multiple parents\naren't supported, both for efficiency reasons and because Lezer\ntrees make it rather hard to reason about what they would match.)\n\nA path can be ended with `/...` to indicate that the tag assigned\nto the node should also apply to all child nodes, even if they\nmatch their own style (by default, only the innermost style is\nused).\n\nWhen a path ends in `!`, as in `Attribute!`, no further matching\nhappens for the node's child nodes, and the entire node gets the\ngiven style.\n\nIn this notation, node names that contain `/`, `!`, `*`, or `...`\nmust be quoted as JSON strings.\n\nFor example:\n\n```javascript\nparser.withProps(\n  styleTags({\n    // Style Number and BigNumber nodes\n    \"Number BigNumber\": tags.number,\n    // Style Escape nodes whose parent is String\n    \"String/Escape\": tags.escape,\n    // Style anything inside Attributes nodes\n    \"Attributes!\": tags.meta,\n    // Add a style to all content inside Italic nodes\n    \"Italic/...\": tags.emphasis,\n    // Style InvalidString nodes as both `string` and `invalid`\n    \"InvalidString\": [tags.string, tags.invalid],\n    // Style the node named \"/\" as punctuation\n    '\"/\"': tags.punctuation\n  })\n)\n```\n*/ function styleTags(spec) {\n    let byName = Object.create(null);\n    for(let prop in spec){\n        let tags = spec[prop];\n        if (!Array.isArray(tags)) tags = [\n            tags\n        ];\n        for (let part of prop.split(\" \"))if (part) {\n            let pieces = [], mode = 2 /* Mode.Normal */ , rest = part;\n            for(let pos = 0;;){\n                if (rest == \"...\" && pos > 0 && pos + 3 == part.length) {\n                    mode = 1 /* Mode.Inherit */ ;\n                    break;\n                }\n                let m = /^\"(?:[^\"\\\\]|\\\\.)*?\"|[^\\/!]+/.exec(rest);\n                if (!m) throw new RangeError(\"Invalid path: \" + part);\n                pieces.push(m[0] == \"*\" ? \"\" : m[0][0] == '\"' ? JSON.parse(m[0]) : m[0]);\n                pos += m[0].length;\n                if (pos == part.length) break;\n                let next = part[pos++];\n                if (pos == part.length && next == \"!\") {\n                    mode = 0 /* Mode.Opaque */ ;\n                    break;\n                }\n                if (next != \"/\") throw new RangeError(\"Invalid path: \" + part);\n                rest = part.slice(pos);\n            }\n            let last = pieces.length - 1, inner = pieces[last];\n            if (!inner) throw new RangeError(\"Invalid path: \" + part);\n            let rule = new Rule(tags, mode, last > 0 ? pieces.slice(0, last) : null);\n            byName[inner] = rule.sort(byName[inner]);\n        }\n    }\n    return ruleNodeProp.add(byName);\n}\nconst ruleNodeProp = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\nclass Rule {\n    constructor(tags, mode, context, next){\n        this.tags = tags;\n        this.mode = mode;\n        this.context = context;\n        this.next = next;\n    }\n    get opaque() {\n        return this.mode == 0 /* Mode.Opaque */ ;\n    }\n    get inherit() {\n        return this.mode == 1 /* Mode.Inherit */ ;\n    }\n    sort(other) {\n        if (!other || other.depth < this.depth) {\n            this.next = other;\n            return this;\n        }\n        other.next = this.sort(other.next);\n        return other;\n    }\n    get depth() {\n        return this.context ? this.context.length : 0;\n    }\n}\nRule.empty = new Rule([], 2 /* Mode.Normal */ , null);\n/**\nDefine a [highlighter](#highlight.Highlighter) from an array of\ntag/class pairs. Classes associated with more specific tags will\ntake precedence.\n*/ function tagHighlighter(tags, options) {\n    let map = Object.create(null);\n    for (let style of tags){\n        if (!Array.isArray(style.tag)) map[style.tag.id] = style.class;\n        else for (let tag of style.tag)map[tag.id] = style.class;\n    }\n    let { scope, all = null } = options || {};\n    return {\n        style: (tags)=>{\n            let cls = all;\n            for (let tag of tags){\n                for (let sub of tag.set){\n                    let tagClass = map[sub.id];\n                    if (tagClass) {\n                        cls = cls ? cls + \" \" + tagClass : tagClass;\n                        break;\n                    }\n                }\n            }\n            return cls;\n        },\n        scope\n    };\n}\nfunction highlightTags(highlighters, tags) {\n    let result = null;\n    for (let highlighter of highlighters){\n        let value = highlighter.style(tags);\n        if (value) result = result ? result + \" \" + value : value;\n    }\n    return result;\n}\n/**\nHighlight the given [tree](#common.Tree) with the given\n[highlighter](#highlight.Highlighter). Often, the higher-level\n[`highlightCode`](#highlight.highlightCode) function is easier to\nuse.\n*/ function highlightTree(tree, highlighter, /**\nAssign styling to a region of the text. Will be called, in order\nof position, for any ranges where more than zero classes apply.\n`classes` is a space separated string of CSS classes.\n*/ putStyle, /**\nThe start of the range to highlight.\n*/ from = 0, /**\nThe end of the range.\n*/ to = tree.length) {\n    let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [\n        highlighter\n    ], putStyle);\n    builder.highlightRange(tree.cursor(), from, to, \"\", builder.highlighters);\n    builder.flush(to);\n}\n/**\nHighlight the given tree with the given highlighter, calling\n`putText` for every piece of text, either with a set of classes or\nwith the empty string when unstyled, and `putBreak` for every line\nbreak.\n*/ function highlightCode(code, tree, highlighter, putText, putBreak, from = 0, to = code.length) {\n    let pos = from;\n    function writeTo(p, classes) {\n        if (p <= pos) return;\n        for(let text = code.slice(pos, p), i = 0;;){\n            let nextBreak = text.indexOf(\"\\n\", i);\n            let upto = nextBreak < 0 ? text.length : nextBreak;\n            if (upto > i) putText(text.slice(i, upto), classes);\n            if (nextBreak < 0) break;\n            putBreak();\n            i = nextBreak + 1;\n        }\n        pos = p;\n    }\n    highlightTree(tree, highlighter, (from, to, classes)=>{\n        writeTo(from, \"\");\n        writeTo(to, classes);\n    }, from, to);\n    writeTo(to, \"\");\n}\nclass HighlightBuilder {\n    constructor(at, highlighters, span){\n        this.at = at;\n        this.highlighters = highlighters;\n        this.span = span;\n        this.class = \"\";\n    }\n    startSpan(at, cls) {\n        if (cls != this.class) {\n            this.flush(at);\n            if (at > this.at) this.at = at;\n            this.class = cls;\n        }\n    }\n    flush(to) {\n        if (to > this.at && this.class) this.span(this.at, to, this.class);\n    }\n    highlightRange(cursor, from, to, inheritedClass, highlighters) {\n        let { type, from: start, to: end } = cursor;\n        if (start >= to || end <= from) return;\n        if (type.isTop) highlighters = this.highlighters.filter((h)=>!h.scope || h.scope(type));\n        let cls = inheritedClass;\n        let rule = getStyleTags(cursor) || Rule.empty;\n        let tagCls = highlightTags(highlighters, rule.tags);\n        if (tagCls) {\n            if (cls) cls += \" \";\n            cls += tagCls;\n            if (rule.mode == 1 /* Mode.Inherit */ ) inheritedClass += (inheritedClass ? \" \" : \"\") + tagCls;\n        }\n        this.startSpan(Math.max(from, start), cls);\n        if (rule.opaque) return;\n        let mounted = cursor.tree && cursor.tree.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.mounted);\n        if (mounted && mounted.overlay) {\n            let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);\n            let innerHighlighters = this.highlighters.filter((h)=>!h.scope || h.scope(mounted.tree.type));\n            let hasChild = cursor.firstChild();\n            for(let i = 0, pos = start;; i++){\n                let next = i < mounted.overlay.length ? mounted.overlay[i] : null;\n                let nextPos = next ? next.from + start : end;\n                let rangeFrom = Math.max(from, pos), rangeTo = Math.min(to, nextPos);\n                if (rangeFrom < rangeTo && hasChild) {\n                    while(cursor.from < rangeTo){\n                        this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);\n                        this.startSpan(Math.min(rangeTo, cursor.to), cls);\n                        if (cursor.to >= nextPos || !cursor.nextSibling()) break;\n                    }\n                }\n                if (!next || nextPos > to) break;\n                pos = next.to + start;\n                if (pos > from) {\n                    this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), \"\", innerHighlighters);\n                    this.startSpan(Math.min(to, pos), cls);\n                }\n            }\n            if (hasChild) cursor.parent();\n        } else if (cursor.firstChild()) {\n            if (mounted) inheritedClass = \"\";\n            do {\n                if (cursor.to <= from) continue;\n                if (cursor.from >= to) break;\n                this.highlightRange(cursor, from, to, inheritedClass, highlighters);\n                this.startSpan(Math.min(to, cursor.to), cls);\n            }while (cursor.nextSibling());\n            cursor.parent();\n        }\n    }\n}\n/**\nMatch a syntax node's [highlight rules](#highlight.styleTags). If\nthere's a match, return its set of tags, and whether it is\nopaque (uses a `!`) or applies to all child nodes (`/...`).\n*/ function getStyleTags(node) {\n    let rule = node.type.prop(ruleNodeProp);\n    while(rule && rule.context && !node.matchContext(rule.context))rule = rule.next;\n    return rule || null;\n}\nconst t = Tag.define;\nconst comment = t(), name = t(), typeName = t(name), propertyName = t(name), literal = t(), string = t(literal), number = t(literal), content = t(), heading = t(content), keyword = t(), operator = t(), punctuation = t(), bracket = t(punctuation), meta = t();\n/**\nThe default set of highlighting [tags](#highlight.Tag).\n\nThis collection is heavily biased towards programming languages,\nand necessarily incomplete. A full ontology of syntactic\nconstructs would fill a stack of books, and be impractical to\nwrite themes for. So try to make do with this set. If all else\nfails, [open an\nissue](https://github.com/codemirror/codemirror.next) to propose a\nnew tag, or [define](#highlight.Tag^define) a local custom tag for\nyour use case.\n\nNote that it is not obligatory to always attach the most specific\ntag possible to an elementâ€”if your grammar can't easily\ndistinguish a certain type of element (such as a local variable),\nit is okay to style it as its more general variant (a variable).\n\nFor tags that extend some parent tag, the documentation links to\nthe parent.\n*/ const tags = {\n    /**\n    A comment.\n    */ comment,\n    /**\n    A line [comment](#highlight.tags.comment).\n    */ lineComment: t(comment),\n    /**\n    A block [comment](#highlight.tags.comment).\n    */ blockComment: t(comment),\n    /**\n    A documentation [comment](#highlight.tags.comment).\n    */ docComment: t(comment),\n    /**\n    Any kind of identifier.\n    */ name,\n    /**\n    The [name](#highlight.tags.name) of a variable.\n    */ variableName: t(name),\n    /**\n    A type [name](#highlight.tags.name).\n    */ typeName: typeName,\n    /**\n    A tag name (subtag of [`typeName`](#highlight.tags.typeName)).\n    */ tagName: t(typeName),\n    /**\n    A property or field [name](#highlight.tags.name).\n    */ propertyName: propertyName,\n    /**\n    An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).\n    */ attributeName: t(propertyName),\n    /**\n    The [name](#highlight.tags.name) of a class.\n    */ className: t(name),\n    /**\n    A label [name](#highlight.tags.name).\n    */ labelName: t(name),\n    /**\n    A namespace [name](#highlight.tags.name).\n    */ namespace: t(name),\n    /**\n    The [name](#highlight.tags.name) of a macro.\n    */ macroName: t(name),\n    /**\n    A literal value.\n    */ literal,\n    /**\n    A string [literal](#highlight.tags.literal).\n    */ string,\n    /**\n    A documentation [string](#highlight.tags.string).\n    */ docString: t(string),\n    /**\n    A character literal (subtag of [string](#highlight.tags.string)).\n    */ character: t(string),\n    /**\n    An attribute value (subtag of [string](#highlight.tags.string)).\n    */ attributeValue: t(string),\n    /**\n    A number [literal](#highlight.tags.literal).\n    */ number,\n    /**\n    An integer [number](#highlight.tags.number) literal.\n    */ integer: t(number),\n    /**\n    A floating-point [number](#highlight.tags.number) literal.\n    */ float: t(number),\n    /**\n    A boolean [literal](#highlight.tags.literal).\n    */ bool: t(literal),\n    /**\n    Regular expression [literal](#highlight.tags.literal).\n    */ regexp: t(literal),\n    /**\n    An escape [literal](#highlight.tags.literal), for example a\n    backslash escape in a string.\n    */ escape: t(literal),\n    /**\n    A color [literal](#highlight.tags.literal).\n    */ color: t(literal),\n    /**\n    A URL [literal](#highlight.tags.literal).\n    */ url: t(literal),\n    /**\n    A language keyword.\n    */ keyword,\n    /**\n    The [keyword](#highlight.tags.keyword) for the self or this\n    object.\n    */ self: t(keyword),\n    /**\n    The [keyword](#highlight.tags.keyword) for null.\n    */ null: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) denoting some atomic value.\n    */ atom: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) that represents a unit.\n    */ unit: t(keyword),\n    /**\n    A modifier [keyword](#highlight.tags.keyword).\n    */ modifier: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) that acts as an operator.\n    */ operatorKeyword: t(keyword),\n    /**\n    A control-flow related [keyword](#highlight.tags.keyword).\n    */ controlKeyword: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) that defines something.\n    */ definitionKeyword: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) related to defining or\n    interfacing with modules.\n    */ moduleKeyword: t(keyword),\n    /**\n    An operator.\n    */ operator,\n    /**\n    An [operator](#highlight.tags.operator) that dereferences something.\n    */ derefOperator: t(operator),\n    /**\n    Arithmetic-related [operator](#highlight.tags.operator).\n    */ arithmeticOperator: t(operator),\n    /**\n    Logical [operator](#highlight.tags.operator).\n    */ logicOperator: t(operator),\n    /**\n    Bit [operator](#highlight.tags.operator).\n    */ bitwiseOperator: t(operator),\n    /**\n    Comparison [operator](#highlight.tags.operator).\n    */ compareOperator: t(operator),\n    /**\n    [Operator](#highlight.tags.operator) that updates its operand.\n    */ updateOperator: t(operator),\n    /**\n    [Operator](#highlight.tags.operator) that defines something.\n    */ definitionOperator: t(operator),\n    /**\n    Type-related [operator](#highlight.tags.operator).\n    */ typeOperator: t(operator),\n    /**\n    Control-flow [operator](#highlight.tags.operator).\n    */ controlOperator: t(operator),\n    /**\n    Program or markup punctuation.\n    */ punctuation,\n    /**\n    [Punctuation](#highlight.tags.punctuation) that separates\n    things.\n    */ separator: t(punctuation),\n    /**\n    Bracket-style [punctuation](#highlight.tags.punctuation).\n    */ bracket,\n    /**\n    Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`\n    tokens).\n    */ angleBracket: t(bracket),\n    /**\n    Square [brackets](#highlight.tags.bracket) (usually `[` and `]`\n    tokens).\n    */ squareBracket: t(bracket),\n    /**\n    Parentheses (usually `(` and `)` tokens). Subtag of\n    [bracket](#highlight.tags.bracket).\n    */ paren: t(bracket),\n    /**\n    Braces (usually `{` and `}` tokens). Subtag of\n    [bracket](#highlight.tags.bracket).\n    */ brace: t(bracket),\n    /**\n    Content, for example plain text in XML or markup documents.\n    */ content,\n    /**\n    [Content](#highlight.tags.content) that represents a heading.\n    */ heading,\n    /**\n    A level 1 [heading](#highlight.tags.heading).\n    */ heading1: t(heading),\n    /**\n    A level 2 [heading](#highlight.tags.heading).\n    */ heading2: t(heading),\n    /**\n    A level 3 [heading](#highlight.tags.heading).\n    */ heading3: t(heading),\n    /**\n    A level 4 [heading](#highlight.tags.heading).\n    */ heading4: t(heading),\n    /**\n    A level 5 [heading](#highlight.tags.heading).\n    */ heading5: t(heading),\n    /**\n    A level 6 [heading](#highlight.tags.heading).\n    */ heading6: t(heading),\n    /**\n    A prose [content](#highlight.tags.content) separator (such as a horizontal rule).\n    */ contentSeparator: t(content),\n    /**\n    [Content](#highlight.tags.content) that represents a list.\n    */ list: t(content),\n    /**\n    [Content](#highlight.tags.content) that represents a quote.\n    */ quote: t(content),\n    /**\n    [Content](#highlight.tags.content) that is emphasized.\n    */ emphasis: t(content),\n    /**\n    [Content](#highlight.tags.content) that is styled strong.\n    */ strong: t(content),\n    /**\n    [Content](#highlight.tags.content) that is part of a link.\n    */ link: t(content),\n    /**\n    [Content](#highlight.tags.content) that is styled as code or\n    monospace.\n    */ monospace: t(content),\n    /**\n    [Content](#highlight.tags.content) that has a strike-through\n    style.\n    */ strikethrough: t(content),\n    /**\n    Inserted text in a change-tracking format.\n    */ inserted: t(),\n    /**\n    Deleted text.\n    */ deleted: t(),\n    /**\n    Changed text.\n    */ changed: t(),\n    /**\n    An invalid or unsyntactic element.\n    */ invalid: t(),\n    /**\n    Metadata or meta-instruction.\n    */ meta,\n    /**\n    [Metadata](#highlight.tags.meta) that applies to the entire\n    document.\n    */ documentMeta: t(meta),\n    /**\n    [Metadata](#highlight.tags.meta) that annotates or adds\n    attributes to a given syntactic element.\n    */ annotation: t(meta),\n    /**\n    Processing instruction or preprocessor directive. Subtag of\n    [meta](#highlight.tags.meta).\n    */ processingInstruction: t(meta),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that indicates that a\n    given element is being defined. Expected to be used with the\n    various [name](#highlight.tags.name) tags.\n    */ definition: Tag.defineModifier(\"definition\"),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that indicates that\n    something is constant. Mostly expected to be used with\n    [variable names](#highlight.tags.variableName).\n    */ constant: Tag.defineModifier(\"constant\"),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) used to indicate that\n    a [variable](#highlight.tags.variableName) or [property\n    name](#highlight.tags.propertyName) is being called or defined\n    as a function.\n    */ function: Tag.defineModifier(\"function\"),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that can be applied to\n    [names](#highlight.tags.name) to indicate that they belong to\n    the language's standard environment.\n    */ standard: Tag.defineModifier(\"standard\"),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that indicates a given\n    [names](#highlight.tags.name) is local to some scope.\n    */ local: Tag.defineModifier(\"local\"),\n    /**\n    A generic variant [modifier](#highlight.Tag^defineModifier) that\n    can be used to tag language-specific alternative variants of\n    some common tag. It is recommended for themes to define special\n    forms of at least the [string](#highlight.tags.string) and\n    [variable name](#highlight.tags.variableName) tags, since those\n    come up a lot.\n    */ special: Tag.defineModifier(\"special\")\n};\nfor(let name in tags){\n    let val = tags[name];\n    if (val instanceof Tag) val.name = name;\n}\n/**\nThis is a highlighter that adds stable, predictable classes to\ntokens, for styling with external CSS.\n\nThe following tags are mapped to their name prefixed with `\"tok-\"`\n(for example `\"tok-comment\"`):\n\n* [`link`](#highlight.tags.link)\n* [`heading`](#highlight.tags.heading)\n* [`emphasis`](#highlight.tags.emphasis)\n* [`strong`](#highlight.tags.strong)\n* [`keyword`](#highlight.tags.keyword)\n* [`atom`](#highlight.tags.atom)\n* [`bool`](#highlight.tags.bool)\n* [`url`](#highlight.tags.url)\n* [`labelName`](#highlight.tags.labelName)\n* [`inserted`](#highlight.tags.inserted)\n* [`deleted`](#highlight.tags.deleted)\n* [`literal`](#highlight.tags.literal)\n* [`string`](#highlight.tags.string)\n* [`number`](#highlight.tags.number)\n* [`variableName`](#highlight.tags.variableName)\n* [`typeName`](#highlight.tags.typeName)\n* [`namespace`](#highlight.tags.namespace)\n* [`className`](#highlight.tags.className)\n* [`macroName`](#highlight.tags.macroName)\n* [`propertyName`](#highlight.tags.propertyName)\n* [`operator`](#highlight.tags.operator)\n* [`comment`](#highlight.tags.comment)\n* [`meta`](#highlight.tags.meta)\n* [`punctuation`](#highlight.tags.punctuation)\n* [`invalid`](#highlight.tags.invalid)\n\nIn addition, these mappings are provided:\n\n* [`regexp`](#highlight.tags.regexp),\n  [`escape`](#highlight.tags.escape), and\n  [`special`](#highlight.tags.special)[`(string)`](#highlight.tags.string)\n  are mapped to `\"tok-string2\"`\n* [`special`](#highlight.tags.special)[`(variableName)`](#highlight.tags.variableName)\n  to `\"tok-variableName2\"`\n* [`local`](#highlight.tags.local)[`(variableName)`](#highlight.tags.variableName)\n  to `\"tok-variableName tok-local\"`\n* [`definition`](#highlight.tags.definition)[`(variableName)`](#highlight.tags.variableName)\n  to `\"tok-variableName tok-definition\"`\n* [`definition`](#highlight.tags.definition)[`(propertyName)`](#highlight.tags.propertyName)\n  to `\"tok-propertyName tok-definition\"`\n*/ const classHighlighter = tagHighlighter([\n    {\n        tag: tags.link,\n        class: \"tok-link\"\n    },\n    {\n        tag: tags.heading,\n        class: \"tok-heading\"\n    },\n    {\n        tag: tags.emphasis,\n        class: \"tok-emphasis\"\n    },\n    {\n        tag: tags.strong,\n        class: \"tok-strong\"\n    },\n    {\n        tag: tags.keyword,\n        class: \"tok-keyword\"\n    },\n    {\n        tag: tags.atom,\n        class: \"tok-atom\"\n    },\n    {\n        tag: tags.bool,\n        class: \"tok-bool\"\n    },\n    {\n        tag: tags.url,\n        class: \"tok-url\"\n    },\n    {\n        tag: tags.labelName,\n        class: \"tok-labelName\"\n    },\n    {\n        tag: tags.inserted,\n        class: \"tok-inserted\"\n    },\n    {\n        tag: tags.deleted,\n        class: \"tok-deleted\"\n    },\n    {\n        tag: tags.literal,\n        class: \"tok-literal\"\n    },\n    {\n        tag: tags.string,\n        class: \"tok-string\"\n    },\n    {\n        tag: tags.number,\n        class: \"tok-number\"\n    },\n    {\n        tag: [\n            tags.regexp,\n            tags.escape,\n            tags.special(tags.string)\n        ],\n        class: \"tok-string2\"\n    },\n    {\n        tag: tags.variableName,\n        class: \"tok-variableName\"\n    },\n    {\n        tag: tags.local(tags.variableName),\n        class: \"tok-variableName tok-local\"\n    },\n    {\n        tag: tags.definition(tags.variableName),\n        class: \"tok-variableName tok-definition\"\n    },\n    {\n        tag: tags.special(tags.variableName),\n        class: \"tok-variableName2\"\n    },\n    {\n        tag: tags.definition(tags.propertyName),\n        class: \"tok-propertyName tok-definition\"\n    },\n    {\n        tag: tags.typeName,\n        class: \"tok-typeName\"\n    },\n    {\n        tag: tags.namespace,\n        class: \"tok-namespace\"\n    },\n    {\n        tag: tags.className,\n        class: \"tok-className\"\n    },\n    {\n        tag: tags.macroName,\n        class: \"tok-macroName\"\n    },\n    {\n        tag: tags.propertyName,\n        class: \"tok-propertyName\"\n    },\n    {\n        tag: tags.operator,\n        class: \"tok-operator\"\n    },\n    {\n        tag: tags.comment,\n        class: \"tok-comment\"\n    },\n    {\n        tag: tags.meta,\n        class: \"tok-meta\"\n    },\n    {\n        tag: tags.invalid,\n        class: \"tok-invalid\"\n    },\n    {\n        tag: tags.punctuation,\n        class: \"tok-punctuation\"\n    }\n]);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxlemVyL2hpZ2hsaWdodC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUF5QztBQUV6QyxJQUFJQyxZQUFZO0FBQ2hCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkEsR0FDQSxNQUFNQztJQUNGOztJQUVBLEdBQ0FDLFlBQ0E7O0lBRUEsR0FDQUMsSUFBSSxFQUNKOzs7SUFHQSxHQUNBQyxHQUFHLEVBQ0g7OztJQUdBLEdBQ0FDLElBQUksRUFDSjs7SUFFQSxHQUNBQyxRQUFRLENBQUU7UUFDTixJQUFJLENBQUNILElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNDLEdBQUcsR0FBR0E7UUFDWCxJQUFJLENBQUNDLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNDLFFBQVEsR0FBR0E7UUFDaEI7O1FBRUEsR0FDQSxJQUFJLENBQUNDLEVBQUUsR0FBR1A7SUFDZDtJQUNBUSxXQUFXO1FBQ1AsSUFBSSxFQUFFTCxJQUFJLEVBQUUsR0FBRyxJQUFJO1FBQ25CLEtBQUssSUFBSU0sT0FBTyxJQUFJLENBQUNILFFBQVEsQ0FDekIsSUFBSUcsSUFBSU4sSUFBSSxFQUNSQSxPQUFPLENBQUMsRUFBRU0sSUFBSU4sSUFBSSxDQUFDLENBQUMsRUFBRUEsS0FBSyxDQUFDLENBQUM7UUFDckMsT0FBT0E7SUFDWDtJQUNBLE9BQU9PLE9BQU9DLFlBQVksRUFBRUMsTUFBTSxFQUFFO1FBQ2hDLElBQUlULE9BQU8sT0FBT1EsZ0JBQWdCLFdBQVdBLGVBQWU7UUFDNUQsSUFBSUEsd0JBQXdCVixLQUN4QlcsU0FBU0Q7UUFDYixJQUFJQyxXQUFXLFFBQVFBLFdBQVcsS0FBSyxJQUFJLEtBQUssSUFBSUEsT0FBT1AsSUFBSSxFQUMzRCxNQUFNLElBQUlRLE1BQU07UUFDcEIsSUFBSUMsTUFBTSxJQUFJYixJQUFJRSxNQUFNLEVBQUUsRUFBRSxNQUFNLEVBQUU7UUFDcENXLElBQUlWLEdBQUcsQ0FBQ1csSUFBSSxDQUFDRDtRQUNi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QUUzRCxPQUFPO0lBQWU7SUFDNUM7UUFBRWxFLEtBQUttQyxLQUFLOEcsU0FBUztRQUFFL0UsT0FBTztJQUFnQjtJQUM5QztRQUFFbEUsS0FBS21DLEtBQUs0RyxTQUFTO1FBQUU3RSxPQUFPO0lBQWdCO0lBQzlDO1FBQUVsRSxLQUFLbUMsS0FBSytHLFNBQVM7UUFBRWhGLE9BQU87SUFBZ0I7SUFDOUM7UUFBRWxFLEtBQUttQyxLQUFLMkYsWUFBWTtRQUFFNUQsT0FBTztJQUFtQjtJQUNwRDtRQUFFbEUsS0FBS21DLEtBQUtrRyxRQUFRO1FBQUVuRSxPQUFPO0lBQWU7SUFDNUM7UUFBRWxFLEtBQUttQyxLQUFLeUYsT0FBTztRQUFFMUQsT0FBTztJQUFjO0lBQzFDO1FBQUVsRSxLQUFLbUMsS0FBS3FHLElBQUk7UUFBRXRFLE9BQU87SUFBVztJQUNwQztRQUFFbEUsS0FBS21DLEtBQUtrSyxPQUFPO1FBQUVuSSxPQUFPO0lBQWM7SUFDMUM7UUFBRWxFLEtBQUttQyxLQUFLbUcsV0FBVztRQUFFcEUsT0FBTztJQUFrQjtDQUNyRDtBQUU2RyIsInNvdXJjZXMiOlsid2VicGFjazovL2VyYS1wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvQGxlemVyL2hpZ2hsaWdodC9kaXN0L2luZGV4LmpzP2YyOWEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTm9kZVByb3AgfSBmcm9tICdAbGV6ZXIvY29tbW9uJztcblxubGV0IG5leHRUYWdJRCA9IDA7XG4vKipcbkhpZ2hsaWdodGluZyB0YWdzIGFyZSBtYXJrZXJzIHRoYXQgZGVub3RlIGEgaGlnaGxpZ2h0aW5nIGNhdGVnb3J5LlxuVGhleSBhcmUgW2Fzc29jaWF0ZWRdKCNoaWdobGlnaHQuc3R5bGVUYWdzKSB3aXRoIHBhcnRzIG9mIGEgc3ludGF4XG50cmVlIGJ5IGEgbGFuZ3VhZ2UgbW9kZSwgYW5kIHRoZW4gbWFwcGVkIHRvIGFuIGFjdHVhbCBDU1Mgc3R5bGUgYnlcbmEgW2hpZ2hsaWdodGVyXSgjaGlnaGxpZ2h0LkhpZ2hsaWdodGVyKS5cblxuQmVjYXVzZSBzeW50YXggdHJlZSBub2RlIHR5cGVzIGFuZCBoaWdobGlnaHQgc3R5bGVzIGhhdmUgdG8gYmVcbmFibGUgdG8gdGFsayB0aGUgc2FtZSBsYW5ndWFnZSwgQ29kZU1pcnJvciB1c2VzIGEgbW9zdGx5IF9jbG9zZWRfXG5bdm9jYWJ1bGFyeV0oI2hpZ2hsaWdodC50YWdzKSBvZiBzeW50YXggdGFncyAoYXMgb3Bwb3NlZCB0b1xudHJhZGl0aW9uYWwgb3BlbiBzdHJpbmctYmFzZWQgc3lzdGVtcywgd2hpY2ggbWFrZSBpdCBoYXJkIGZvclxuaGlnaGxpZ2h0aW5nIHRoZW1lcyB0byBjb3ZlciBhbGwgdGhlIHRva2VucyBwcm9kdWNlZCBieSB0aGVcbnZhcmlvdXMgbGFuZ3VhZ2VzKS5cblxuSXQgX2lzXyBwb3NzaWJsZSB0byBbZGVmaW5lXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmUpIHlvdXIgb3duXG5oaWdobGlnaHRpbmcgdGFncyBmb3Igc3lzdGVtLWludGVybmFsIHVzZSAod2hlcmUgeW91IGNvbnRyb2wgYm90aFxudGhlIGxhbmd1YWdlIHBhY2thZ2UgYW5kIHRoZSBoaWdobGlnaHRlciksIGJ1dCBzdWNoIHRhZ3Mgd2lsbCBub3RcbmJlIHBpY2tlZCB1cCBieSByZWd1bGFyIGhpZ2hsaWdodGVycyAodGhvdWdoIHlvdSBjYW4gZGVyaXZlIHRoZW1cbmZyb20gc3RhbmRhcmQgdGFncyB0byBhbGxvdyBoaWdobGlnaHRlcnMgdG8gZmFsbCBiYWNrIHRvIHRob3NlKS5cbiovXG5jbGFzcyBUYWcge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIG9wdGlvbmFsIG5hbWUgb2YgdGhlIGJhc2UgdGFnIEBpbnRlcm5hbFxuICAgICovXG4gICAgbmFtZSwgXG4gICAgLyoqXG4gICAgVGhlIHNldCBvZiB0aGlzIHRhZyBhbmQgYWxsIGl0cyBwYXJlbnQgdGFncywgc3RhcnRpbmcgd2l0aFxuICAgIHRoaXMgb25lIGl0c2VsZiBhbmQgc29ydGVkIGluIG9yZGVyIG9mIGRlY3JlYXNpbmcgc3BlY2lmaWNpdHkuXG4gICAgKi9cbiAgICBzZXQsIFxuICAgIC8qKlxuICAgIFRoZSBiYXNlIHVubW9kaWZpZWQgdGFnIHRoYXQgdGhpcyBvbmUgaXMgYmFzZWQgb24sIGlmIGl0J3NcbiAgICBtb2RpZmllZCBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGJhc2UsIFxuICAgIC8qKlxuICAgIFRoZSBtb2RpZmllcnMgYXBwbGllZCB0byB0aGlzLmJhc2UgQGludGVybmFsXG4gICAgKi9cbiAgICBtb2RpZmllZCkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnNldCA9IHNldDtcbiAgICAgICAgdGhpcy5iYXNlID0gYmFzZTtcbiAgICAgICAgdGhpcy5tb2RpZmllZCA9IG1vZGlmaWVkO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuaWQgPSBuZXh0VGFnSUQrKztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCB7IG5hbWUgfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IG1vZCBvZiB0aGlzLm1vZGlmaWVkKVxuICAgICAgICAgICAgaWYgKG1vZC5uYW1lKVxuICAgICAgICAgICAgICAgIG5hbWUgPSBgJHttb2QubmFtZX0oJHtuYW1lfSlgO1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgc3RhdGljIGRlZmluZShuYW1lT3JQYXJlbnQsIHBhcmVudCkge1xuICAgICAgICBsZXQgbmFtZSA9IHR5cGVvZiBuYW1lT3JQYXJlbnQgPT0gXCJzdHJpbmdcIiA/IG5hbWVPclBhcmVudCA6IFwiP1wiO1xuICAgICAgICBpZiAobmFtZU9yUGFyZW50IGluc3RhbmNlb2YgVGFnKVxuICAgICAgICAgICAgcGFyZW50ID0gbmFtZU9yUGFyZW50O1xuICAgICAgICBpZiAocGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50LmJhc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGRlcml2ZSBmcm9tIGEgbW9kaWZpZWQgdGFnXCIpO1xuICAgICAgICBsZXQgdGFnID0gbmV3IFRhZyhuYW1lLCBbXSwgbnVsbCwgW10pO1xuICAgICAgICB0YWcuc2V0LnB1c2godGFnKTtcbiAgICAgICAgaWYgKHBhcmVudClcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgcGFyZW50LnNldClcbiAgICAgICAgICAgICAgICB0YWcuc2V0LnB1c2godCk7XG4gICAgICAgIHJldHVybiB0YWc7XG4gICAgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIHRhZyBfbW9kaWZpZXJfLCB3aGljaCBpcyBhIGZ1bmN0aW9uIHRoYXQsIGdpdmVuIGEgdGFnLFxuICAgIHdpbGwgcmV0dXJuIGEgdGFnIHRoYXQgaXMgYSBzdWJ0YWcgb2YgdGhlIG9yaWdpbmFsLiBBcHBseWluZyB0aGVcbiAgICBzYW1lIG1vZGlmaWVyIHRvIGEgdHdpY2UgdGFnIHdpbGwgcmV0dXJuIHRoZSBzYW1lIHZhbHVlIChgbTEodDEpXG4gICAgPT0gbTEodDEpYCkgYW5kIGFwcGx5aW5nIG11bHRpcGxlIG1vZGlmaWVycyB3aWxsLCByZWdhcmRsZXNzIG9yXG4gICAgb3JkZXIsIHByb2R1Y2UgdGhlIHNhbWUgdGFnIChgbTEobTIodDEpKSA9PSBtMihtMSh0MSkpYCkuXG4gICAgXG4gICAgV2hlbiBtdWx0aXBsZSBtb2RpZmllcnMgYXJlIGFwcGxpZWQgdG8gYSBnaXZlbiBiYXNlIHRhZywgZWFjaFxuICAgIHNtYWxsZXIgc2V0IG9mIG1vZGlmaWVycyBpcyByZWdpc3RlcmVkIGFzIGEgcGFyZW50LCBzbyB0aGF0IGZvclxuICAgIGV4YW1wbGUgYG0xKG0yKG0zKHQxKSkpYCBpcyBhIHN1YnR5cGUgb2YgYG0xKG0yKHQxKSlgLFxuICAgIGBtMShtMyh0MSlgLCBhbmQgc28gb24uXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lTW9kaWZpZXIobmFtZSkge1xuICAgICAgICBsZXQgbW9kID0gbmV3IE1vZGlmaWVyKG5hbWUpO1xuICAgICAgICByZXR1cm4gKHRhZykgPT4ge1xuICAgICAgICAgICAgaWYgKHRhZy5tb2RpZmllZC5pbmRleE9mKG1vZCkgPiAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFnO1xuICAgICAgICAgICAgcmV0dXJuIE1vZGlmaWVyLmdldCh0YWcuYmFzZSB8fCB0YWcsIHRhZy5tb2RpZmllZC5jb25jYXQobW9kKS5zb3J0KChhLCBiKSA9PiBhLmlkIC0gYi5pZCkpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmxldCBuZXh0TW9kaWZpZXJJRCA9IDA7XG5jbGFzcyBNb2RpZmllciB7XG4gICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmluc3RhbmNlcyA9IFtdO1xuICAgICAgICB0aGlzLmlkID0gbmV4dE1vZGlmaWVySUQrKztcbiAgICB9XG4gICAgc3RhdGljIGdldChiYXNlLCBtb2RzKSB7XG4gICAgICAgIGlmICghbW9kcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgICAgbGV0IGV4aXN0cyA9IG1vZHNbMF0uaW5zdGFuY2VzLmZpbmQodCA9PiB0LmJhc2UgPT0gYmFzZSAmJiBzYW1lQXJyYXkobW9kcywgdC5tb2RpZmllZCkpO1xuICAgICAgICBpZiAoZXhpc3RzKVxuICAgICAgICAgICAgcmV0dXJuIGV4aXN0cztcbiAgICAgICAgbGV0IHNldCA9IFtdLCB0YWcgPSBuZXcgVGFnKGJhc2UubmFtZSwgc2V0LCBiYXNlLCBtb2RzKTtcbiAgICAgICAgZm9yIChsZXQgbSBvZiBtb2RzKVxuICAgICAgICAgICAgbS5pbnN0YW5jZXMucHVzaCh0YWcpO1xuICAgICAgICBsZXQgY29uZmlncyA9IHBvd2VyU2V0KG1vZHMpO1xuICAgICAgICBmb3IgKGxldCBwYXJlbnQgb2YgYmFzZS5zZXQpXG4gICAgICAgICAgICBpZiAoIXBhcmVudC5tb2RpZmllZC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY29uZmlnIG9mIGNvbmZpZ3MpXG4gICAgICAgICAgICAgICAgICAgIHNldC5wdXNoKE1vZGlmaWVyLmdldChwYXJlbnQsIGNvbmZpZykpO1xuICAgICAgICByZXR1cm4gdGFnO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNhbWVBcnJheShhLCBiKSB7XG4gICAgcmV0dXJuIGEubGVuZ3RoID09IGIubGVuZ3RoICYmIGEuZXZlcnkoKHgsIGkpID0+IHggPT0gYltpXSk7XG59XG5mdW5jdGlvbiBwb3dlclNldChhcnJheSkge1xuICAgIGxldCBzZXRzID0gW1tdXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwLCBlID0gc2V0cy5sZW5ndGg7IGogPCBlOyBqKyspIHtcbiAgICAgICAgICAgIHNldHMucHVzaChzZXRzW2pdLmNvbmNhdChhcnJheVtpXSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXRzLnNvcnQoKGEsIGIpID0+IGIubGVuZ3RoIC0gYS5sZW5ndGgpO1xufVxuLyoqXG5UaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gYWRkIGEgc2V0IG9mIHRhZ3MgdG8gYSBsYW5ndWFnZSBzeW50YXhcbnZpYSBbYE5vZGVTZXQuZXh0ZW5kYF0oI2NvbW1vbi5Ob2RlU2V0LmV4dGVuZCkgb3JcbltgTFJQYXJzZXIuY29uZmlndXJlYF0oI2xyLkxSUGFyc2VyLmNvbmZpZ3VyZSkuXG5cblRoZSBhcmd1bWVudCBvYmplY3QgbWFwcyBub2RlIHNlbGVjdG9ycyB0byBbaGlnaGxpZ2h0aW5nXG50YWdzXSgjaGlnaGxpZ2h0LlRhZykgb3IgYXJyYXlzIG9mIHRhZ3MuXG5cbk5vZGUgc2VsZWN0b3JzIG1heSBob2xkIG9uZSBvciBtb3JlIChzcGFjZS1zZXBhcmF0ZWQpIG5vZGUgcGF0aHMuXG5TdWNoIGEgcGF0aCBjYW4gYmUgYSBbbm9kZSBuYW1lXSgjY29tbW9uLk5vZGVUeXBlLm5hbWUpLCBvclxubXVsdGlwbGUgbm9kZSBuYW1lcyAob3IgYCpgIHdpbGRjYXJkcykgc2VwYXJhdGVkIGJ5IHNsYXNoXG5jaGFyYWN0ZXJzLCBhcyBpbiBgXCJCbG9jay9EZWNsYXJhdGlvbi9WYXJpYWJsZU5hbWVcImAuIFN1Y2ggYSBwYXRoXG5tYXRjaGVzIHRoZSBmaW5hbCBub2RlIGJ1dCBvbmx5IGlmIGl0cyBkaXJlY3QgcGFyZW50IG5vZGVzIGFyZSB0aGVcbm90aGVyIG5vZGVzIG1lbnRpb25lZC4gQSBgKmAgaW4gc3VjaCBhIHBhdGggbWF0Y2hlcyBhbnkgcGFyZW50LFxuYnV0IG9ubHkgYSBzaW5nbGUgbGV2ZWzigJR3aWxkY2FyZHMgdGhhdCBtYXRjaCBtdWx0aXBsZSBwYXJlbnRzXG5hcmVuJ3Qgc3VwcG9ydGVkLCBib3RoIGZvciBlZmZpY2llbmN5IHJlYXNvbnMgYW5kIGJlY2F1c2UgTGV6ZXJcbnRyZWVzIG1ha2UgaXQgcmF0aGVyIGhhcmQgdG8gcmVhc29uIGFib3V0IHdoYXQgdGhleSB3b3VsZCBtYXRjaC4pXG5cbkEgcGF0aCBjYW4gYmUgZW5kZWQgd2l0aCBgLy4uLmAgdG8gaW5kaWNhdGUgdGhhdCB0aGUgdGFnIGFzc2lnbmVkXG50byB0aGUgbm9kZSBzaG91bGQgYWxzbyBhcHBseSB0byBhbGwgY2hpbGQgbm9kZXMsIGV2ZW4gaWYgdGhleVxubWF0Y2ggdGhlaXIgb3duIHN0eWxlIChieSBkZWZhdWx0LCBvbmx5IHRoZSBpbm5lcm1vc3Qgc3R5bGUgaXNcbnVzZWQpLlxuXG5XaGVuIGEgcGF0aCBlbmRzIGluIGAhYCwgYXMgaW4gYEF0dHJpYnV0ZSFgLCBubyBmdXJ0aGVyIG1hdGNoaW5nXG5oYXBwZW5zIGZvciB0aGUgbm9kZSdzIGNoaWxkIG5vZGVzLCBhbmQgdGhlIGVudGlyZSBub2RlIGdldHMgdGhlXG5naXZlbiBzdHlsZS5cblxuSW4gdGhpcyBub3RhdGlvbiwgbm9kZSBuYW1lcyB0aGF0IGNvbnRhaW4gYC9gLCBgIWAsIGAqYCwgb3IgYC4uLmBcbm11c3QgYmUgcXVvdGVkIGFzIEpTT04gc3RyaW5ncy5cblxuRm9yIGV4YW1wbGU6XG5cbmBgYGphdmFzY3JpcHRcbnBhcnNlci53aXRoUHJvcHMoXG4gIHN0eWxlVGFncyh7XG4gICAgLy8gU3R5bGUgTnVtYmVyIGFuZCBCaWdOdW1iZXIgbm9kZXNcbiAgICBcIk51bWJlciBCaWdOdW1iZXJcIjogdGFncy5udW1iZXIsXG4gICAgLy8gU3R5bGUgRXNjYXBlIG5vZGVzIHdob3NlIHBhcmVudCBpcyBTdHJpbmdcbiAgICBcIlN0cmluZy9Fc2NhcGVcIjogdGFncy5lc2NhcGUsXG4gICAgLy8gU3R5bGUgYW55dGhpbmcgaW5zaWRlIEF0dHJpYnV0ZXMgbm9kZXNcbiAgICBcIkF0dHJpYnV0ZXMhXCI6IHRhZ3MubWV0YSxcbiAgICAvLyBBZGQgYSBzdHlsZSB0byBhbGwgY29udGVudCBpbnNpZGUgSXRhbGljIG5vZGVzXG4gICAgXCJJdGFsaWMvLi4uXCI6IHRhZ3MuZW1waGFzaXMsXG4gICAgLy8gU3R5bGUgSW52YWxpZFN0cmluZyBub2RlcyBhcyBib3RoIGBzdHJpbmdgIGFuZCBgaW52YWxpZGBcbiAgICBcIkludmFsaWRTdHJpbmdcIjogW3RhZ3Muc3RyaW5nLCB0YWdzLmludmFsaWRdLFxuICAgIC8vIFN0eWxlIHRoZSBub2RlIG5hbWVkIFwiL1wiIGFzIHB1bmN0dWF0aW9uXG4gICAgJ1wiL1wiJzogdGFncy5wdW5jdHVhdGlvblxuICB9KVxuKVxuYGBgXG4qL1xuZnVuY3Rpb24gc3R5bGVUYWdzKHNwZWMpIHtcbiAgICBsZXQgYnlOYW1lID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCBwcm9wIGluIHNwZWMpIHtcbiAgICAgICAgbGV0IHRhZ3MgPSBzcGVjW3Byb3BdO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGFncykpXG4gICAgICAgICAgICB0YWdzID0gW3RhZ3NdO1xuICAgICAgICBmb3IgKGxldCBwYXJ0IG9mIHByb3Auc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgaWYgKHBhcnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGllY2VzID0gW10sIG1vZGUgPSAyIC8qIE1vZGUuTm9ybWFsICovLCByZXN0ID0gcGFydDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwb3MgPSAwOzspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3QgPT0gXCIuLi5cIiAmJiBwb3MgPiAwICYmIHBvcyArIDMgPT0gcGFydC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPSAxIC8qIE1vZGUuSW5oZXJpdCAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBtID0gL15cIig/OlteXCJcXFxcXXxcXFxcLikqP1wifFteXFwvIV0rLy5leGVjKHJlc3QpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW0pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgcGF0aDogXCIgKyBwYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgcGllY2VzLnB1c2gobVswXSA9PSBcIipcIiA/IFwiXCIgOiBtWzBdWzBdID09ICdcIicgPyBKU09OLnBhcnNlKG1bMF0pIDogbVswXSk7XG4gICAgICAgICAgICAgICAgICAgIHBvcyArPSBtWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA9PSBwYXJ0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHBhcnRbcG9zKytdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zID09IHBhcnQubGVuZ3RoICYmIG5leHQgPT0gXCIhXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPSAwIC8qIE1vZGUuT3BhcXVlICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgIT0gXCIvXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgcGF0aDogXCIgKyBwYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdCA9IHBhcnQuc2xpY2UocG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGxhc3QgPSBwaWVjZXMubGVuZ3RoIC0gMSwgaW5uZXIgPSBwaWVjZXNbbGFzdF07XG4gICAgICAgICAgICAgICAgaWYgKCFpbm5lcilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHBhdGg6IFwiICsgcGFydCk7XG4gICAgICAgICAgICAgICAgbGV0IHJ1bGUgPSBuZXcgUnVsZSh0YWdzLCBtb2RlLCBsYXN0ID4gMCA/IHBpZWNlcy5zbGljZSgwLCBsYXN0KSA6IG51bGwpO1xuICAgICAgICAgICAgICAgIGJ5TmFtZVtpbm5lcl0gPSBydWxlLnNvcnQoYnlOYW1lW2lubmVyXSk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBydWxlTm9kZVByb3AuYWRkKGJ5TmFtZSk7XG59XG5jb25zdCBydWxlTm9kZVByb3AgPSBuZXcgTm9kZVByb3AoKTtcbmNsYXNzIFJ1bGUge1xuICAgIGNvbnN0cnVjdG9yKHRhZ3MsIG1vZGUsIGNvbnRleHQsIG5leHQpIHtcbiAgICAgICAgdGhpcy50YWdzID0gdGFncztcbiAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5uZXh0ID0gbmV4dDtcbiAgICB9XG4gICAgZ2V0IG9wYXF1ZSgpIHsgcmV0dXJuIHRoaXMubW9kZSA9PSAwIC8qIE1vZGUuT3BhcXVlICovOyB9XG4gICAgZ2V0IGluaGVyaXQoKSB7IHJldHVybiB0aGlzLm1vZGUgPT0gMSAvKiBNb2RlLkluaGVyaXQgKi87IH1cbiAgICBzb3J0KG90aGVyKSB7XG4gICAgICAgIGlmICghb3RoZXIgfHwgb3RoZXIuZGVwdGggPCB0aGlzLmRlcHRoKSB7XG4gICAgICAgICAgICB0aGlzLm5leHQgPSBvdGhlcjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIG90aGVyLm5leHQgPSB0aGlzLnNvcnQob3RoZXIubmV4dCk7XG4gICAgICAgIHJldHVybiBvdGhlcjtcbiAgICB9XG4gICAgZ2V0IGRlcHRoKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0ID8gdGhpcy5jb250ZXh0Lmxlbmd0aCA6IDA7IH1cbn1cblJ1bGUuZW1wdHkgPSBuZXcgUnVsZShbXSwgMiAvKiBNb2RlLk5vcm1hbCAqLywgbnVsbCk7XG4vKipcbkRlZmluZSBhIFtoaWdobGlnaHRlcl0oI2hpZ2hsaWdodC5IaWdobGlnaHRlcikgZnJvbSBhbiBhcnJheSBvZlxudGFnL2NsYXNzIHBhaXJzLiBDbGFzc2VzIGFzc29jaWF0ZWQgd2l0aCBtb3JlIHNwZWNpZmljIHRhZ3Mgd2lsbFxudGFrZSBwcmVjZWRlbmNlLlxuKi9cbmZ1bmN0aW9uIHRhZ0hpZ2hsaWdodGVyKHRhZ3MsIG9wdGlvbnMpIHtcbiAgICBsZXQgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCBzdHlsZSBvZiB0YWdzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzdHlsZS50YWcpKVxuICAgICAgICAgICAgbWFwW3N0eWxlLnRhZy5pZF0gPSBzdHlsZS5jbGFzcztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZm9yIChsZXQgdGFnIG9mIHN0eWxlLnRhZylcbiAgICAgICAgICAgICAgICBtYXBbdGFnLmlkXSA9IHN0eWxlLmNsYXNzO1xuICAgIH1cbiAgICBsZXQgeyBzY29wZSwgYWxsID0gbnVsbCB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdHlsZTogKHRhZ3MpID0+IHtcbiAgICAgICAgICAgIGxldCBjbHMgPSBhbGw7XG4gICAgICAgICAgICBmb3IgKGxldCB0YWcgb2YgdGFncykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHN1YiBvZiB0YWcuc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0YWdDbGFzcyA9IG1hcFtzdWIuaWRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFnQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNscyA9IGNscyA/IGNscyArIFwiIFwiICsgdGFnQ2xhc3MgOiB0YWdDbGFzcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNscztcbiAgICAgICAgfSxcbiAgICAgICAgc2NvcGVcbiAgICB9O1xufVxuZnVuY3Rpb24gaGlnaGxpZ2h0VGFncyhoaWdobGlnaHRlcnMsIHRhZ3MpIHtcbiAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICBmb3IgKGxldCBoaWdobGlnaHRlciBvZiBoaWdobGlnaHRlcnMpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gaGlnaGxpZ2h0ZXIuc3R5bGUodGFncyk7XG4gICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCA/IHJlc3VsdCArIFwiIFwiICsgdmFsdWUgOiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuSGlnaGxpZ2h0IHRoZSBnaXZlbiBbdHJlZV0oI2NvbW1vbi5UcmVlKSB3aXRoIHRoZSBnaXZlblxuW2hpZ2hsaWdodGVyXSgjaGlnaGxpZ2h0LkhpZ2hsaWdodGVyKS4gT2Z0ZW4sIHRoZSBoaWdoZXItbGV2ZWxcbltgaGlnaGxpZ2h0Q29kZWBdKCNoaWdobGlnaHQuaGlnaGxpZ2h0Q29kZSkgZnVuY3Rpb24gaXMgZWFzaWVyIHRvXG51c2UuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0VHJlZSh0cmVlLCBoaWdobGlnaHRlciwgXG4vKipcbkFzc2lnbiBzdHlsaW5nIHRvIGEgcmVnaW9uIG9mIHRoZSB0ZXh0LiBXaWxsIGJlIGNhbGxlZCwgaW4gb3JkZXJcbm9mIHBvc2l0aW9uLCBmb3IgYW55IHJhbmdlcyB3aGVyZSBtb3JlIHRoYW4gemVybyBjbGFzc2VzIGFwcGx5LlxuYGNsYXNzZXNgIGlzIGEgc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBDU1MgY2xhc3Nlcy5cbiovXG5wdXRTdHlsZSwgXG4vKipcblRoZSBzdGFydCBvZiB0aGUgcmFuZ2UgdG8gaGlnaGxpZ2h0LlxuKi9cbmZyb20gPSAwLCBcbi8qKlxuVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4qL1xudG8gPSB0cmVlLmxlbmd0aCkge1xuICAgIGxldCBidWlsZGVyID0gbmV3IEhpZ2hsaWdodEJ1aWxkZXIoZnJvbSwgQXJyYXkuaXNBcnJheShoaWdobGlnaHRlcikgPyBoaWdobGlnaHRlciA6IFtoaWdobGlnaHRlcl0sIHB1dFN0eWxlKTtcbiAgICBidWlsZGVyLmhpZ2hsaWdodFJhbmdlKHRyZWUuY3Vyc29yKCksIGZyb20sIHRvLCBcIlwiLCBidWlsZGVyLmhpZ2hsaWdodGVycyk7XG4gICAgYnVpbGRlci5mbHVzaCh0byk7XG59XG4vKipcbkhpZ2hsaWdodCB0aGUgZ2l2ZW4gdHJlZSB3aXRoIHRoZSBnaXZlbiBoaWdobGlnaHRlciwgY2FsbGluZ1xuYHB1dFRleHRgIGZvciBldmVyeSBwaWVjZSBvZiB0ZXh0LCBlaXRoZXIgd2l0aCBhIHNldCBvZiBjbGFzc2VzIG9yXG53aXRoIHRoZSBlbXB0eSBzdHJpbmcgd2hlbiB1bnN0eWxlZCwgYW5kIGBwdXRCcmVha2AgZm9yIGV2ZXJ5IGxpbmVcbmJyZWFrLlxuKi9cbmZ1bmN0aW9uIGhpZ2hsaWdodENvZGUoY29kZSwgdHJlZSwgaGlnaGxpZ2h0ZXIsIHB1dFRleHQsIHB1dEJyZWFrLCBmcm9tID0gMCwgdG8gPSBjb2RlLmxlbmd0aCkge1xuICAgIGxldCBwb3MgPSBmcm9tO1xuICAgIGZ1bmN0aW9uIHdyaXRlVG8ocCwgY2xhc3Nlcykge1xuICAgICAgICBpZiAocCA8PSBwb3MpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAobGV0IHRleHQgPSBjb2RlLnNsaWNlKHBvcywgcCksIGkgPSAwOzspIHtcbiAgICAgICAgICAgIGxldCBuZXh0QnJlYWsgPSB0ZXh0LmluZGV4T2YoXCJcXG5cIiwgaSk7XG4gICAgICAgICAgICBsZXQgdXB0byA9IG5leHRCcmVhayA8IDAgPyB0ZXh0Lmxlbmd0aCA6IG5leHRCcmVhaztcbiAgICAgICAgICAgIGlmICh1cHRvID4gaSlcbiAgICAgICAgICAgICAgICBwdXRUZXh0KHRleHQuc2xpY2UoaSwgdXB0byksIGNsYXNzZXMpO1xuICAgICAgICAgICAgaWYgKG5leHRCcmVhayA8IDApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBwdXRCcmVhaygpO1xuICAgICAgICAgICAgaSA9IG5leHRCcmVhayArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gcDtcbiAgICB9XG4gICAgaGlnaGxpZ2h0VHJlZSh0cmVlLCBoaWdobGlnaHRlciwgKGZyb20sIHRvLCBjbGFzc2VzKSA9PiB7XG4gICAgICAgIHdyaXRlVG8oZnJvbSwgXCJcIik7XG4gICAgICAgIHdyaXRlVG8odG8sIGNsYXNzZXMpO1xuICAgIH0sIGZyb20sIHRvKTtcbiAgICB3cml0ZVRvKHRvLCBcIlwiKTtcbn1cbmNsYXNzIEhpZ2hsaWdodEJ1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKGF0LCBoaWdobGlnaHRlcnMsIHNwYW4pIHtcbiAgICAgICAgdGhpcy5hdCA9IGF0O1xuICAgICAgICB0aGlzLmhpZ2hsaWdodGVycyA9IGhpZ2hsaWdodGVycztcbiAgICAgICAgdGhpcy5zcGFuID0gc3BhbjtcbiAgICAgICAgdGhpcy5jbGFzcyA9IFwiXCI7XG4gICAgfVxuICAgIHN0YXJ0U3BhbihhdCwgY2xzKSB7XG4gICAgICAgIGlmIChjbHMgIT0gdGhpcy5jbGFzcykge1xuICAgICAgICAgICAgdGhpcy5mbHVzaChhdCk7XG4gICAgICAgICAgICBpZiAoYXQgPiB0aGlzLmF0KVxuICAgICAgICAgICAgICAgIHRoaXMuYXQgPSBhdDtcbiAgICAgICAgICAgIHRoaXMuY2xhc3MgPSBjbHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmx1c2godG8pIHtcbiAgICAgICAgaWYgKHRvID4gdGhpcy5hdCAmJiB0aGlzLmNsYXNzKVxuICAgICAgICAgICAgdGhpcy5zcGFuKHRoaXMuYXQsIHRvLCB0aGlzLmNsYXNzKTtcbiAgICB9XG4gICAgaGlnaGxpZ2h0UmFuZ2UoY3Vyc29yLCBmcm9tLCB0bywgaW5oZXJpdGVkQ2xhc3MsIGhpZ2hsaWdodGVycykge1xuICAgICAgICBsZXQgeyB0eXBlLCBmcm9tOiBzdGFydCwgdG86IGVuZCB9ID0gY3Vyc29yO1xuICAgICAgICBpZiAoc3RhcnQgPj0gdG8gfHwgZW5kIDw9IGZyb20pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0eXBlLmlzVG9wKVxuICAgICAgICAgICAgaGlnaGxpZ2h0ZXJzID0gdGhpcy5oaWdobGlnaHRlcnMuZmlsdGVyKGggPT4gIWguc2NvcGUgfHwgaC5zY29wZSh0eXBlKSk7XG4gICAgICAgIGxldCBjbHMgPSBpbmhlcml0ZWRDbGFzcztcbiAgICAgICAgbGV0IHJ1bGUgPSBnZXRTdHlsZVRhZ3MoY3Vyc29yKSB8fCBSdWxlLmVtcHR5O1xuICAgICAgICBsZXQgdGFnQ2xzID0gaGlnaGxpZ2h0VGFncyhoaWdobGlnaHRlcnMsIHJ1bGUudGFncyk7XG4gICAgICAgIGlmICh0YWdDbHMpIHtcbiAgICAgICAgICAgIGlmIChjbHMpXG4gICAgICAgICAgICAgICAgY2xzICs9IFwiIFwiO1xuICAgICAgICAgICAgY2xzICs9IHRhZ0NscztcbiAgICAgICAgICAgIGlmIChydWxlLm1vZGUgPT0gMSAvKiBNb2RlLkluaGVyaXQgKi8pXG4gICAgICAgICAgICAgICAgaW5oZXJpdGVkQ2xhc3MgKz0gKGluaGVyaXRlZENsYXNzID8gXCIgXCIgOiBcIlwiKSArIHRhZ0NscztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXJ0U3BhbihNYXRoLm1heChmcm9tLCBzdGFydCksIGNscyk7XG4gICAgICAgIGlmIChydWxlLm9wYXF1ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IG1vdW50ZWQgPSBjdXJzb3IudHJlZSAmJiBjdXJzb3IudHJlZS5wcm9wKE5vZGVQcm9wLm1vdW50ZWQpO1xuICAgICAgICBpZiAobW91bnRlZCAmJiBtb3VudGVkLm92ZXJsYXkpIHtcbiAgICAgICAgICAgIGxldCBpbm5lciA9IGN1cnNvci5ub2RlLmVudGVyKG1vdW50ZWQub3ZlcmxheVswXS5mcm9tICsgc3RhcnQsIDEpO1xuICAgICAgICAgICAgbGV0IGlubmVySGlnaGxpZ2h0ZXJzID0gdGhpcy5oaWdobGlnaHRlcnMuZmlsdGVyKGggPT4gIWguc2NvcGUgfHwgaC5zY29wZShtb3VudGVkLnRyZWUudHlwZSkpO1xuICAgICAgICAgICAgbGV0IGhhc0NoaWxkID0gY3Vyc29yLmZpcnN0Q2hpbGQoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSBzdGFydDs7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gaSA8IG1vdW50ZWQub3ZlcmxheS5sZW5ndGggPyBtb3VudGVkLm92ZXJsYXlbaV0gOiBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBuZXh0UG9zID0gbmV4dCA/IG5leHQuZnJvbSArIHN0YXJ0IDogZW5kO1xuICAgICAgICAgICAgICAgIGxldCByYW5nZUZyb20gPSBNYXRoLm1heChmcm9tLCBwb3MpLCByYW5nZVRvID0gTWF0aC5taW4odG8sIG5leHRQb3MpO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZUZyb20gPCByYW5nZVRvICYmIGhhc0NoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjdXJzb3IuZnJvbSA8IHJhbmdlVG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0UmFuZ2UoY3Vyc29yLCByYW5nZUZyb20sIHJhbmdlVG8sIGluaGVyaXRlZENsYXNzLCBoaWdobGlnaHRlcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydFNwYW4oTWF0aC5taW4ocmFuZ2VUbywgY3Vyc29yLnRvKSwgY2xzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJzb3IudG8gPj0gbmV4dFBvcyB8fCAhY3Vyc29yLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0IHx8IG5leHRQb3MgPiB0bylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgcG9zID0gbmV4dC50byArIHN0YXJ0O1xuICAgICAgICAgICAgICAgIGlmIChwb3MgPiBmcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0UmFuZ2UoaW5uZXIuY3Vyc29yKCksIE1hdGgubWF4KGZyb20sIG5leHQuZnJvbSArIHN0YXJ0KSwgTWF0aC5taW4odG8sIHBvcyksIFwiXCIsIGlubmVySGlnaGxpZ2h0ZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydFNwYW4oTWF0aC5taW4odG8sIHBvcyksIGNscyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc0NoaWxkKVxuICAgICAgICAgICAgICAgIGN1cnNvci5wYXJlbnQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJzb3IuZmlyc3RDaGlsZCgpKSB7XG4gICAgICAgICAgICBpZiAobW91bnRlZClcbiAgICAgICAgICAgICAgICBpbmhlcml0ZWRDbGFzcyA9IFwiXCI7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvci50byA8PSBmcm9tKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAoY3Vyc29yLmZyb20gPj0gdG8pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0UmFuZ2UoY3Vyc29yLCBmcm9tLCB0bywgaW5oZXJpdGVkQ2xhc3MsIGhpZ2hsaWdodGVycyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFNwYW4oTWF0aC5taW4odG8sIGN1cnNvci50byksIGNscyk7XG4gICAgICAgICAgICB9IHdoaWxlIChjdXJzb3IubmV4dFNpYmxpbmcoKSk7XG4gICAgICAgICAgICBjdXJzb3IucGFyZW50KCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbk1hdGNoIGEgc3ludGF4IG5vZGUncyBbaGlnaGxpZ2h0IHJ1bGVzXSgjaGlnaGxpZ2h0LnN0eWxlVGFncykuIElmXG50aGVyZSdzIGEgbWF0Y2gsIHJldHVybiBpdHMgc2V0IG9mIHRhZ3MsIGFuZCB3aGV0aGVyIGl0IGlzXG5vcGFxdWUgKHVzZXMgYSBgIWApIG9yIGFwcGxpZXMgdG8gYWxsIGNoaWxkIG5vZGVzIChgLy4uLmApLlxuKi9cbmZ1bmN0aW9uIGdldFN0eWxlVGFncyhub2RlKSB7XG4gICAgbGV0IHJ1bGUgPSBub2RlLnR5cGUucHJvcChydWxlTm9kZVByb3ApO1xuICAgIHdoaWxlIChydWxlICYmIHJ1bGUuY29udGV4dCAmJiAhbm9kZS5tYXRjaENvbnRleHQocnVsZS5jb250ZXh0KSlcbiAgICAgICAgcnVsZSA9IHJ1bGUubmV4dDtcbiAgICByZXR1cm4gcnVsZSB8fCBudWxsO1xufVxuY29uc3QgdCA9IFRhZy5kZWZpbmU7XG5jb25zdCBjb21tZW50ID0gdCgpLCBuYW1lID0gdCgpLCB0eXBlTmFtZSA9IHQobmFtZSksIHByb3BlcnR5TmFtZSA9IHQobmFtZSksIGxpdGVyYWwgPSB0KCksIHN0cmluZyA9IHQobGl0ZXJhbCksIG51bWJlciA9IHQobGl0ZXJhbCksIGNvbnRlbnQgPSB0KCksIGhlYWRpbmcgPSB0KGNvbnRlbnQpLCBrZXl3b3JkID0gdCgpLCBvcGVyYXRvciA9IHQoKSwgcHVuY3R1YXRpb24gPSB0KCksIGJyYWNrZXQgPSB0KHB1bmN0dWF0aW9uKSwgbWV0YSA9IHQoKTtcbi8qKlxuVGhlIGRlZmF1bHQgc2V0IG9mIGhpZ2hsaWdodGluZyBbdGFnc10oI2hpZ2hsaWdodC5UYWcpLlxuXG5UaGlzIGNvbGxlY3Rpb24gaXMgaGVhdmlseSBiaWFzZWQgdG93YXJkcyBwcm9ncmFtbWluZyBsYW5ndWFnZXMsXG5hbmQgbmVjZXNzYXJpbHkgaW5jb21wbGV0ZS4gQSBmdWxsIG9udG9sb2d5IG9mIHN5bnRhY3RpY1xuY29uc3RydWN0cyB3b3VsZCBmaWxsIGEgc3RhY2sgb2YgYm9va3MsIGFuZCBiZSBpbXByYWN0aWNhbCB0b1xud3JpdGUgdGhlbWVzIGZvci4gU28gdHJ5IHRvIG1ha2UgZG8gd2l0aCB0aGlzIHNldC4gSWYgYWxsIGVsc2VcbmZhaWxzLCBbb3BlbiBhblxuaXNzdWVdKGh0dHBzOi8vZ2l0aHViLmNvbS9jb2RlbWlycm9yL2NvZGVtaXJyb3IubmV4dCkgdG8gcHJvcG9zZSBhXG5uZXcgdGFnLCBvciBbZGVmaW5lXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmUpIGEgbG9jYWwgY3VzdG9tIHRhZyBmb3JcbnlvdXIgdXNlIGNhc2UuXG5cbk5vdGUgdGhhdCBpdCBpcyBub3Qgb2JsaWdhdG9yeSB0byBhbHdheXMgYXR0YWNoIHRoZSBtb3N0IHNwZWNpZmljXG50YWcgcG9zc2libGUgdG8gYW4gZWxlbWVudOKAlGlmIHlvdXIgZ3JhbW1hciBjYW4ndCBlYXNpbHlcbmRpc3Rpbmd1aXNoIGEgY2VydGFpbiB0eXBlIG9mIGVsZW1lbnQgKHN1Y2ggYXMgYSBsb2NhbCB2YXJpYWJsZSksXG5pdCBpcyBva2F5IHRvIHN0eWxlIGl0IGFzIGl0cyBtb3JlIGdlbmVyYWwgdmFyaWFudCAoYSB2YXJpYWJsZSkuXG5cbkZvciB0YWdzIHRoYXQgZXh0ZW5kIHNvbWUgcGFyZW50IHRhZywgdGhlIGRvY3VtZW50YXRpb24gbGlua3MgdG9cbnRoZSBwYXJlbnQuXG4qL1xuY29uc3QgdGFncyA9IHtcbiAgICAvKipcbiAgICBBIGNvbW1lbnQuXG4gICAgKi9cbiAgICBjb21tZW50LFxuICAgIC8qKlxuICAgIEEgbGluZSBbY29tbWVudF0oI2hpZ2hsaWdodC50YWdzLmNvbW1lbnQpLlxuICAgICovXG4gICAgbGluZUNvbW1lbnQ6IHQoY29tbWVudCksXG4gICAgLyoqXG4gICAgQSBibG9jayBbY29tbWVudF0oI2hpZ2hsaWdodC50YWdzLmNvbW1lbnQpLlxuICAgICovXG4gICAgYmxvY2tDb21tZW50OiB0KGNvbW1lbnQpLFxuICAgIC8qKlxuICAgIEEgZG9jdW1lbnRhdGlvbiBbY29tbWVudF0oI2hpZ2hsaWdodC50YWdzLmNvbW1lbnQpLlxuICAgICovXG4gICAgZG9jQ29tbWVudDogdChjb21tZW50KSxcbiAgICAvKipcbiAgICBBbnkga2luZCBvZiBpZGVudGlmaWVyLlxuICAgICovXG4gICAgbmFtZSxcbiAgICAvKipcbiAgICBUaGUgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKSBvZiBhIHZhcmlhYmxlLlxuICAgICovXG4gICAgdmFyaWFibGVOYW1lOiB0KG5hbWUpLFxuICAgIC8qKlxuICAgIEEgdHlwZSBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpLlxuICAgICovXG4gICAgdHlwZU5hbWU6IHR5cGVOYW1lLFxuICAgIC8qKlxuICAgIEEgdGFnIG5hbWUgKHN1YnRhZyBvZiBbYHR5cGVOYW1lYF0oI2hpZ2hsaWdodC50YWdzLnR5cGVOYW1lKSkuXG4gICAgKi9cbiAgICB0YWdOYW1lOiB0KHR5cGVOYW1lKSxcbiAgICAvKipcbiAgICBBIHByb3BlcnR5IG9yIGZpZWxkIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkuXG4gICAgKi9cbiAgICBwcm9wZXJ0eU5hbWU6IHByb3BlcnR5TmFtZSxcbiAgICAvKipcbiAgICBBbiBhdHRyaWJ1dGUgbmFtZSAoc3VidGFnIG9mIFtgcHJvcGVydHlOYW1lYF0oI2hpZ2hsaWdodC50YWdzLnByb3BlcnR5TmFtZSkpLlxuICAgICovXG4gICAgYXR0cmlidXRlTmFtZTogdChwcm9wZXJ0eU5hbWUpLFxuICAgIC8qKlxuICAgIFRoZSBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpIG9mIGEgY2xhc3MuXG4gICAgKi9cbiAgICBjbGFzc05hbWU6IHQobmFtZSksXG4gICAgLyoqXG4gICAgQSBsYWJlbCBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpLlxuICAgICovXG4gICAgbGFiZWxOYW1lOiB0KG5hbWUpLFxuICAgIC8qKlxuICAgIEEgbmFtZXNwYWNlIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkuXG4gICAgKi9cbiAgICBuYW1lc3BhY2U6IHQobmFtZSksXG4gICAgLyoqXG4gICAgVGhlIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkgb2YgYSBtYWNyby5cbiAgICAqL1xuICAgIG1hY3JvTmFtZTogdChuYW1lKSxcbiAgICAvKipcbiAgICBBIGxpdGVyYWwgdmFsdWUuXG4gICAgKi9cbiAgICBsaXRlcmFsLFxuICAgIC8qKlxuICAgIEEgc3RyaW5nIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXG4gICAgKi9cbiAgICBzdHJpbmcsXG4gICAgLyoqXG4gICAgQSBkb2N1bWVudGF0aW9uIFtzdHJpbmddKCNoaWdobGlnaHQudGFncy5zdHJpbmcpLlxuICAgICovXG4gICAgZG9jU3RyaW5nOiB0KHN0cmluZyksXG4gICAgLyoqXG4gICAgQSBjaGFyYWN0ZXIgbGl0ZXJhbCAoc3VidGFnIG9mIFtzdHJpbmddKCNoaWdobGlnaHQudGFncy5zdHJpbmcpKS5cbiAgICAqL1xuICAgIGNoYXJhY3RlcjogdChzdHJpbmcpLFxuICAgIC8qKlxuICAgIEFuIGF0dHJpYnV0ZSB2YWx1ZSAoc3VidGFnIG9mIFtzdHJpbmddKCNoaWdobGlnaHQudGFncy5zdHJpbmcpKS5cbiAgICAqL1xuICAgIGF0dHJpYnV0ZVZhbHVlOiB0KHN0cmluZyksXG4gICAgLyoqXG4gICAgQSBudW1iZXIgW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICAqL1xuICAgIG51bWJlcixcbiAgICAvKipcbiAgICBBbiBpbnRlZ2VyIFtudW1iZXJdKCNoaWdobGlnaHQudGFncy5udW1iZXIpIGxpdGVyYWwuXG4gICAgKi9cbiAgICBpbnRlZ2VyOiB0KG51bWJlciksXG4gICAgLyoqXG4gICAgQSBmbG9hdGluZy1wb2ludCBbbnVtYmVyXSgjaGlnaGxpZ2h0LnRhZ3MubnVtYmVyKSBsaXRlcmFsLlxuICAgICovXG4gICAgZmxvYXQ6IHQobnVtYmVyKSxcbiAgICAvKipcbiAgICBBIGJvb2xlYW4gW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICAqL1xuICAgIGJvb2w6IHQobGl0ZXJhbCksXG4gICAgLyoqXG4gICAgUmVndWxhciBleHByZXNzaW9uIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXG4gICAgKi9cbiAgICByZWdleHA6IHQobGl0ZXJhbCksXG4gICAgLyoqXG4gICAgQW4gZXNjYXBlIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCksIGZvciBleGFtcGxlIGFcbiAgICBiYWNrc2xhc2ggZXNjYXBlIGluIGEgc3RyaW5nLlxuICAgICovXG4gICAgZXNjYXBlOiB0KGxpdGVyYWwpLFxuICAgIC8qKlxuICAgIEEgY29sb3IgW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICAqL1xuICAgIGNvbG9yOiB0KGxpdGVyYWwpLFxuICAgIC8qKlxuICAgIEEgVVJMIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXG4gICAgKi9cbiAgICB1cmw6IHQobGl0ZXJhbCksXG4gICAgLyoqXG4gICAgQSBsYW5ndWFnZSBrZXl3b3JkLlxuICAgICovXG4gICAga2V5d29yZCxcbiAgICAvKipcbiAgICBUaGUgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSBmb3IgdGhlIHNlbGYgb3IgdGhpc1xuICAgIG9iamVjdC5cbiAgICAqL1xuICAgIHNlbGY6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgVGhlIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgZm9yIG51bGwuXG4gICAgKi9cbiAgICBudWxsOiB0KGtleXdvcmQpLFxuICAgIC8qKlxuICAgIEEgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSBkZW5vdGluZyBzb21lIGF0b21pYyB2YWx1ZS5cbiAgICAqL1xuICAgIGF0b206IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIHRoYXQgcmVwcmVzZW50cyBhIHVuaXQuXG4gICAgKi9cbiAgICB1bml0OiB0KGtleXdvcmQpLFxuICAgIC8qKlxuICAgIEEgbW9kaWZpZXIgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKS5cbiAgICAqL1xuICAgIG1vZGlmaWVyOiB0KGtleXdvcmQpLFxuICAgIC8qKlxuICAgIEEgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSB0aGF0IGFjdHMgYXMgYW4gb3BlcmF0b3IuXG4gICAgKi9cbiAgICBvcGVyYXRvcktleXdvcmQ6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQSBjb250cm9sLWZsb3cgcmVsYXRlZCBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpLlxuICAgICovXG4gICAgY29udHJvbEtleXdvcmQ6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIHRoYXQgZGVmaW5lcyBzb21ldGhpbmcuXG4gICAgKi9cbiAgICBkZWZpbml0aW9uS2V5d29yZDogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgcmVsYXRlZCB0byBkZWZpbmluZyBvclxuICAgIGludGVyZmFjaW5nIHdpdGggbW9kdWxlcy5cbiAgICAqL1xuICAgIG1vZHVsZUtleXdvcmQ6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQW4gb3BlcmF0b3IuXG4gICAgKi9cbiAgICBvcGVyYXRvcixcbiAgICAvKipcbiAgICBBbiBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikgdGhhdCBkZXJlZmVyZW5jZXMgc29tZXRoaW5nLlxuICAgICovXG4gICAgZGVyZWZPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgQXJpdGhtZXRpYy1yZWxhdGVkIFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICAqL1xuICAgIGFyaXRobWV0aWNPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgTG9naWNhbCBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgKi9cbiAgICBsb2dpY09wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBCaXQgW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpLlxuICAgICovXG4gICAgYml0d2lzZU9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBDb21wYXJpc29uIFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICAqL1xuICAgIGNvbXBhcmVPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgW09wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpIHRoYXQgdXBkYXRlcyBpdHMgb3BlcmFuZC5cbiAgICAqL1xuICAgIHVwZGF0ZU9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBbT3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikgdGhhdCBkZWZpbmVzIHNvbWV0aGluZy5cbiAgICAqL1xuICAgIGRlZmluaXRpb25PcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgVHlwZS1yZWxhdGVkIFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICAqL1xuICAgIHR5cGVPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgQ29udHJvbC1mbG93IFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICAqL1xuICAgIGNvbnRyb2xPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgUHJvZ3JhbSBvciBtYXJrdXAgcHVuY3R1YXRpb24uXG4gICAgKi9cbiAgICBwdW5jdHVhdGlvbixcbiAgICAvKipcbiAgICBbUHVuY3R1YXRpb25dKCNoaWdobGlnaHQudGFncy5wdW5jdHVhdGlvbikgdGhhdCBzZXBhcmF0ZXNcbiAgICB0aGluZ3MuXG4gICAgKi9cbiAgICBzZXBhcmF0b3I6IHQocHVuY3R1YXRpb24pLFxuICAgIC8qKlxuICAgIEJyYWNrZXQtc3R5bGUgW3B1bmN0dWF0aW9uXSgjaGlnaGxpZ2h0LnRhZ3MucHVuY3R1YXRpb24pLlxuICAgICovXG4gICAgYnJhY2tldCxcbiAgICAvKipcbiAgICBBbmdsZSBbYnJhY2tldHNdKCNoaWdobGlnaHQudGFncy5icmFja2V0KSAodXN1YWxseSBgPGAgYW5kIGA+YFxuICAgIHRva2VucykuXG4gICAgKi9cbiAgICBhbmdsZUJyYWNrZXQ6IHQoYnJhY2tldCksXG4gICAgLyoqXG4gICAgU3F1YXJlIFticmFja2V0c10oI2hpZ2hsaWdodC50YWdzLmJyYWNrZXQpICh1c3VhbGx5IGBbYCBhbmQgYF1gXG4gICAgdG9rZW5zKS5cbiAgICAqL1xuICAgIHNxdWFyZUJyYWNrZXQ6IHQoYnJhY2tldCksXG4gICAgLyoqXG4gICAgUGFyZW50aGVzZXMgKHVzdWFsbHkgYChgIGFuZCBgKWAgdG9rZW5zKS4gU3VidGFnIG9mXG4gICAgW2JyYWNrZXRdKCNoaWdobGlnaHQudGFncy5icmFja2V0KS5cbiAgICAqL1xuICAgIHBhcmVuOiB0KGJyYWNrZXQpLFxuICAgIC8qKlxuICAgIEJyYWNlcyAodXN1YWxseSBge2AgYW5kIGB9YCB0b2tlbnMpLiBTdWJ0YWcgb2ZcbiAgICBbYnJhY2tldF0oI2hpZ2hsaWdodC50YWdzLmJyYWNrZXQpLlxuICAgICovXG4gICAgYnJhY2U6IHQoYnJhY2tldCksXG4gICAgLyoqXG4gICAgQ29udGVudCwgZm9yIGV4YW1wbGUgcGxhaW4gdGV4dCBpbiBYTUwgb3IgbWFya3VwIGRvY3VtZW50cy5cbiAgICAqL1xuICAgIGNvbnRlbnQsXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IHJlcHJlc2VudHMgYSBoZWFkaW5nLlxuICAgICovXG4gICAgaGVhZGluZyxcbiAgICAvKipcbiAgICBBIGxldmVsIDEgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICAqL1xuICAgIGhlYWRpbmcxOiB0KGhlYWRpbmcpLFxuICAgIC8qKlxuICAgIEEgbGV2ZWwgMiBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgICovXG4gICAgaGVhZGluZzI6IHQoaGVhZGluZyksXG4gICAgLyoqXG4gICAgQSBsZXZlbCAzIFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgKi9cbiAgICBoZWFkaW5nMzogdChoZWFkaW5nKSxcbiAgICAvKipcbiAgICBBIGxldmVsIDQgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICAqL1xuICAgIGhlYWRpbmc0OiB0KGhlYWRpbmcpLFxuICAgIC8qKlxuICAgIEEgbGV2ZWwgNSBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgICovXG4gICAgaGVhZGluZzU6IHQoaGVhZGluZyksXG4gICAgLyoqXG4gICAgQSBsZXZlbCA2IFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgKi9cbiAgICBoZWFkaW5nNjogdChoZWFkaW5nKSxcbiAgICAvKipcbiAgICBBIHByb3NlIFtjb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgc2VwYXJhdG9yIChzdWNoIGFzIGEgaG9yaXpvbnRhbCBydWxlKS5cbiAgICAqL1xuICAgIGNvbnRlbnRTZXBhcmF0b3I6IHQoY29udGVudCksXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IHJlcHJlc2VudHMgYSBsaXN0LlxuICAgICovXG4gICAgbGlzdDogdChjb250ZW50KSxcbiAgICAvKipcbiAgICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgcmVwcmVzZW50cyBhIHF1b3RlLlxuICAgICovXG4gICAgcXVvdGU6IHQoY29udGVudCksXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IGlzIGVtcGhhc2l6ZWQuXG4gICAgKi9cbiAgICBlbXBoYXNpczogdChjb250ZW50KSxcbiAgICAvKipcbiAgICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaXMgc3R5bGVkIHN0cm9uZy5cbiAgICAqL1xuICAgIHN0cm9uZzogdChjb250ZW50KSxcbiAgICAvKipcbiAgICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaXMgcGFydCBvZiBhIGxpbmsuXG4gICAgKi9cbiAgICBsaW5rOiB0KGNvbnRlbnQpLFxuICAgIC8qKlxuICAgIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCBpcyBzdHlsZWQgYXMgY29kZSBvclxuICAgIG1vbm9zcGFjZS5cbiAgICAqL1xuICAgIG1vbm9zcGFjZTogdChjb250ZW50KSxcbiAgICAvKipcbiAgICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaGFzIGEgc3RyaWtlLXRocm91Z2hcbiAgICBzdHlsZS5cbiAgICAqL1xuICAgIHN0cmlrZXRocm91Z2g6IHQoY29udGVudCksXG4gICAgLyoqXG4gICAgSW5zZXJ0ZWQgdGV4dCBpbiBhIGNoYW5nZS10cmFja2luZyBmb3JtYXQuXG4gICAgKi9cbiAgICBpbnNlcnRlZDogdCgpLFxuICAgIC8qKlxuICAgIERlbGV0ZWQgdGV4dC5cbiAgICAqL1xuICAgIGRlbGV0ZWQ6IHQoKSxcbiAgICAvKipcbiAgICBDaGFuZ2VkIHRleHQuXG4gICAgKi9cbiAgICBjaGFuZ2VkOiB0KCksXG4gICAgLyoqXG4gICAgQW4gaW52YWxpZCBvciB1bnN5bnRhY3RpYyBlbGVtZW50LlxuICAgICovXG4gICAgaW52YWxpZDogdCgpLFxuICAgIC8qKlxuICAgIE1ldGFkYXRhIG9yIG1ldGEtaW5zdHJ1Y3Rpb24uXG4gICAgKi9cbiAgICBtZXRhLFxuICAgIC8qKlxuICAgIFtNZXRhZGF0YV0oI2hpZ2hsaWdodC50YWdzLm1ldGEpIHRoYXQgYXBwbGllcyB0byB0aGUgZW50aXJlXG4gICAgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBkb2N1bWVudE1ldGE6IHQobWV0YSksXG4gICAgLyoqXG4gICAgW01ldGFkYXRhXSgjaGlnaGxpZ2h0LnRhZ3MubWV0YSkgdGhhdCBhbm5vdGF0ZXMgb3IgYWRkc1xuICAgIGF0dHJpYnV0ZXMgdG8gYSBnaXZlbiBzeW50YWN0aWMgZWxlbWVudC5cbiAgICAqL1xuICAgIGFubm90YXRpb246IHQobWV0YSksXG4gICAgLyoqXG4gICAgUHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBvciBwcmVwcm9jZXNzb3IgZGlyZWN0aXZlLiBTdWJ0YWcgb2ZcbiAgICBbbWV0YV0oI2hpZ2hsaWdodC50YWdzLm1ldGEpLlxuICAgICovXG4gICAgcHJvY2Vzc2luZ0luc3RydWN0aW9uOiB0KG1ldGEpLFxuICAgIC8qKlxuICAgIFtNb2RpZmllcl0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHRoYXQgaW5kaWNhdGVzIHRoYXQgYVxuICAgIGdpdmVuIGVsZW1lbnQgaXMgYmVpbmcgZGVmaW5lZC4gRXhwZWN0ZWQgdG8gYmUgdXNlZCB3aXRoIHRoZVxuICAgIHZhcmlvdXMgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKSB0YWdzLlxuICAgICovXG4gICAgZGVmaW5pdGlvbjogVGFnLmRlZmluZU1vZGlmaWVyKFwiZGVmaW5pdGlvblwiKSxcbiAgICAvKipcbiAgICBbTW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB0aGF0IGluZGljYXRlcyB0aGF0XG4gICAgc29tZXRoaW5nIGlzIGNvbnN0YW50LiBNb3N0bHkgZXhwZWN0ZWQgdG8gYmUgdXNlZCB3aXRoXG4gICAgW3ZhcmlhYmxlIG5hbWVzXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKS5cbiAgICAqL1xuICAgIGNvbnN0YW50OiBUYWcuZGVmaW5lTW9kaWZpZXIoXCJjb25zdGFudFwiKSxcbiAgICAvKipcbiAgICBbTW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB1c2VkIHRvIGluZGljYXRlIHRoYXRcbiAgICBhIFt2YXJpYWJsZV0oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSkgb3IgW3Byb3BlcnR5XG4gICAgbmFtZV0oI2hpZ2hsaWdodC50YWdzLnByb3BlcnR5TmFtZSkgaXMgYmVpbmcgY2FsbGVkIG9yIGRlZmluZWRcbiAgICBhcyBhIGZ1bmN0aW9uLlxuICAgICovXG4gICAgZnVuY3Rpb246IFRhZy5kZWZpbmVNb2RpZmllcihcImZ1bmN0aW9uXCIpLFxuICAgIC8qKlxuICAgIFtNb2RpZmllcl0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHRoYXQgY2FuIGJlIGFwcGxpZWQgdG9cbiAgICBbbmFtZXNdKCNoaWdobGlnaHQudGFncy5uYW1lKSB0byBpbmRpY2F0ZSB0aGF0IHRoZXkgYmVsb25nIHRvXG4gICAgdGhlIGxhbmd1YWdlJ3Mgc3RhbmRhcmQgZW52aXJvbm1lbnQuXG4gICAgKi9cbiAgICBzdGFuZGFyZDogVGFnLmRlZmluZU1vZGlmaWVyKFwic3RhbmRhcmRcIiksXG4gICAgLyoqXG4gICAgW01vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdCBpbmRpY2F0ZXMgYSBnaXZlblxuICAgIFtuYW1lc10oI2hpZ2hsaWdodC50YWdzLm5hbWUpIGlzIGxvY2FsIHRvIHNvbWUgc2NvcGUuXG4gICAgKi9cbiAgICBsb2NhbDogVGFnLmRlZmluZU1vZGlmaWVyKFwibG9jYWxcIiksXG4gICAgLyoqXG4gICAgQSBnZW5lcmljIHZhcmlhbnQgW21vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdFxuICAgIGNhbiBiZSB1c2VkIHRvIHRhZyBsYW5ndWFnZS1zcGVjaWZpYyBhbHRlcm5hdGl2ZSB2YXJpYW50cyBvZlxuICAgIHNvbWUgY29tbW9uIHRhZy4gSXQgaXMgcmVjb21tZW5kZWQgZm9yIHRoZW1lcyB0byBkZWZpbmUgc3BlY2lhbFxuICAgIGZvcm1zIG9mIGF0IGxlYXN0IHRoZSBbc3RyaW5nXSgjaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKSBhbmRcbiAgICBbdmFyaWFibGUgbmFtZV0oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSkgdGFncywgc2luY2UgdGhvc2VcbiAgICBjb21lIHVwIGEgbG90LlxuICAgICovXG4gICAgc3BlY2lhbDogVGFnLmRlZmluZU1vZGlmaWVyKFwic3BlY2lhbFwiKVxufTtcbmZvciAobGV0IG5hbWUgaW4gdGFncykge1xuICAgIGxldCB2YWwgPSB0YWdzW25hbWVdO1xuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBUYWcpXG4gICAgICAgIHZhbC5uYW1lID0gbmFtZTtcbn1cbi8qKlxuVGhpcyBpcyBhIGhpZ2hsaWdodGVyIHRoYXQgYWRkcyBzdGFibGUsIHByZWRpY3RhYmxlIGNsYXNzZXMgdG9cbnRva2VucywgZm9yIHN0eWxpbmcgd2l0aCBleHRlcm5hbCBDU1MuXG5cblRoZSBmb2xsb3dpbmcgdGFncyBhcmUgbWFwcGVkIHRvIHRoZWlyIG5hbWUgcHJlZml4ZWQgd2l0aCBgXCJ0b2stXCJgXG4oZm9yIGV4YW1wbGUgYFwidG9rLWNvbW1lbnRcImApOlxuXG4qIFtgbGlua2BdKCNoaWdobGlnaHQudGFncy5saW5rKVxuKiBbYGhlYWRpbmdgXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZylcbiogW2BlbXBoYXNpc2BdKCNoaWdobGlnaHQudGFncy5lbXBoYXNpcylcbiogW2BzdHJvbmdgXSgjaGlnaGxpZ2h0LnRhZ3Muc3Ryb25nKVxuKiBbYGtleXdvcmRgXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZClcbiogW2BhdG9tYF0oI2hpZ2hsaWdodC50YWdzLmF0b20pXG4qIFtgYm9vbGBdKCNoaWdobGlnaHQudGFncy5ib29sKVxuKiBbYHVybGBdKCNoaWdobGlnaHQudGFncy51cmwpXG4qIFtgbGFiZWxOYW1lYF0oI2hpZ2hsaWdodC50YWdzLmxhYmVsTmFtZSlcbiogW2BpbnNlcnRlZGBdKCNoaWdobGlnaHQudGFncy5pbnNlcnRlZClcbiogW2BkZWxldGVkYF0oI2hpZ2hsaWdodC50YWdzLmRlbGV0ZWQpXG4qIFtgbGl0ZXJhbGBdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKVxuKiBbYHN0cmluZ2BdKCNoaWdobGlnaHQudGFncy5zdHJpbmcpXG4qIFtgbnVtYmVyYF0oI2hpZ2hsaWdodC50YWdzLm51bWJlcilcbiogW2B2YXJpYWJsZU5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKVxuKiBbYHR5cGVOYW1lYF0oI2hpZ2hsaWdodC50YWdzLnR5cGVOYW1lKVxuKiBbYG5hbWVzcGFjZWBdKCNoaWdobGlnaHQudGFncy5uYW1lc3BhY2UpXG4qIFtgY2xhc3NOYW1lYF0oI2hpZ2hsaWdodC50YWdzLmNsYXNzTmFtZSlcbiogW2BtYWNyb05hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MubWFjcm9OYW1lKVxuKiBbYHByb3BlcnR5TmFtZWBdKCNoaWdobGlnaHQudGFncy5wcm9wZXJ0eU5hbWUpXG4qIFtgb3BlcmF0b3JgXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpXG4qIFtgY29tbWVudGBdKCNoaWdobGlnaHQudGFncy5jb21tZW50KVxuKiBbYG1ldGFgXSgjaGlnaGxpZ2h0LnRhZ3MubWV0YSlcbiogW2BwdW5jdHVhdGlvbmBdKCNoaWdobGlnaHQudGFncy5wdW5jdHVhdGlvbilcbiogW2BpbnZhbGlkYF0oI2hpZ2hsaWdodC50YWdzLmludmFsaWQpXG5cbkluIGFkZGl0aW9uLCB0aGVzZSBtYXBwaW5ncyBhcmUgcHJvdmlkZWQ6XG5cbiogW2ByZWdleHBgXSgjaGlnaGxpZ2h0LnRhZ3MucmVnZXhwKSxcbiAgW2Blc2NhcGVgXSgjaGlnaGxpZ2h0LnRhZ3MuZXNjYXBlKSwgYW5kXG4gIFtgc3BlY2lhbGBdKCNoaWdobGlnaHQudGFncy5zcGVjaWFsKVtgKHN0cmluZylgXSgjaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKVxuICBhcmUgbWFwcGVkIHRvIGBcInRvay1zdHJpbmcyXCJgXG4qIFtgc3BlY2lhbGBdKCNoaWdobGlnaHQudGFncy5zcGVjaWFsKVtgKHZhcmlhYmxlTmFtZSlgXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKVxuICB0byBgXCJ0b2stdmFyaWFibGVOYW1lMlwiYFxuKiBbYGxvY2FsYF0oI2hpZ2hsaWdodC50YWdzLmxvY2FsKVtgKHZhcmlhYmxlTmFtZSlgXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKVxuICB0byBgXCJ0b2stdmFyaWFibGVOYW1lIHRvay1sb2NhbFwiYFxuKiBbYGRlZmluaXRpb25gXSgjaGlnaGxpZ2h0LnRhZ3MuZGVmaW5pdGlvbilbYCh2YXJpYWJsZU5hbWUpYF0oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSlcbiAgdG8gYFwidG9rLXZhcmlhYmxlTmFtZSB0b2stZGVmaW5pdGlvblwiYFxuKiBbYGRlZmluaXRpb25gXSgjaGlnaGxpZ2h0LnRhZ3MuZGVmaW5pdGlvbilbYChwcm9wZXJ0eU5hbWUpYF0oI2hpZ2hsaWdodC50YWdzLnByb3BlcnR5TmFtZSlcbiAgdG8gYFwidG9rLXByb3BlcnR5TmFtZSB0b2stZGVmaW5pdGlvblwiYFxuKi9cbmNvbnN0IGNsYXNzSGlnaGxpZ2h0ZXIgPSB0YWdIaWdobGlnaHRlcihbXG4gICAgeyB0YWc6IHRhZ3MubGluaywgY2xhc3M6IFwidG9rLWxpbmtcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmhlYWRpbmcsIGNsYXNzOiBcInRvay1oZWFkaW5nXCIgfSxcbiAgICB7IHRhZzogdGFncy5lbXBoYXNpcywgY2xhc3M6IFwidG9rLWVtcGhhc2lzXCIgfSxcbiAgICB7IHRhZzogdGFncy5zdHJvbmcsIGNsYXNzOiBcInRvay1zdHJvbmdcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmtleXdvcmQsIGNsYXNzOiBcInRvay1rZXl3b3JkXCIgfSxcbiAgICB7IHRhZzogdGFncy5hdG9tLCBjbGFzczogXCJ0b2stYXRvbVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuYm9vbCwgY2xhc3M6IFwidG9rLWJvb2xcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnVybCwgY2xhc3M6IFwidG9rLXVybFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubGFiZWxOYW1lLCBjbGFzczogXCJ0b2stbGFiZWxOYW1lXCIgfSxcbiAgICB7IHRhZzogdGFncy5pbnNlcnRlZCwgY2xhc3M6IFwidG9rLWluc2VydGVkXCIgfSxcbiAgICB7IHRhZzogdGFncy5kZWxldGVkLCBjbGFzczogXCJ0b2stZGVsZXRlZFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubGl0ZXJhbCwgY2xhc3M6IFwidG9rLWxpdGVyYWxcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnN0cmluZywgY2xhc3M6IFwidG9rLXN0cmluZ1wiIH0sXG4gICAgeyB0YWc6IHRhZ3MubnVtYmVyLCBjbGFzczogXCJ0b2stbnVtYmVyXCIgfSxcbiAgICB7IHRhZzogW3RhZ3MucmVnZXhwLCB0YWdzLmVzY2FwZSwgdGFncy5zcGVjaWFsKHRhZ3Muc3RyaW5nKV0sIGNsYXNzOiBcInRvay1zdHJpbmcyXCIgfSxcbiAgICB7IHRhZzogdGFncy52YXJpYWJsZU5hbWUsIGNsYXNzOiBcInRvay12YXJpYWJsZU5hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmxvY2FsKHRhZ3MudmFyaWFibGVOYW1lKSwgY2xhc3M6IFwidG9rLXZhcmlhYmxlTmFtZSB0b2stbG9jYWxcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmRlZmluaXRpb24odGFncy52YXJpYWJsZU5hbWUpLCBjbGFzczogXCJ0b2stdmFyaWFibGVOYW1lIHRvay1kZWZpbml0aW9uXCIgfSxcbiAgICB7IHRhZzogdGFncy5zcGVjaWFsKHRhZ3MudmFyaWFibGVOYW1lKSwgY2xhc3M6IFwidG9rLXZhcmlhYmxlTmFtZTJcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmRlZmluaXRpb24odGFncy5wcm9wZXJ0eU5hbWUpLCBjbGFzczogXCJ0b2stcHJvcGVydHlOYW1lIHRvay1kZWZpbml0aW9uXCIgfSxcbiAgICB7IHRhZzogdGFncy50eXBlTmFtZSwgY2xhc3M6IFwidG9rLXR5cGVOYW1lXCIgfSxcbiAgICB7IHRhZzogdGFncy5uYW1lc3BhY2UsIGNsYXNzOiBcInRvay1uYW1lc3BhY2VcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmNsYXNzTmFtZSwgY2xhc3M6IFwidG9rLWNsYXNzTmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubWFjcm9OYW1lLCBjbGFzczogXCJ0b2stbWFjcm9OYW1lXCIgfSxcbiAgICB7IHRhZzogdGFncy5wcm9wZXJ0eU5hbWUsIGNsYXNzOiBcInRvay1wcm9wZXJ0eU5hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLm9wZXJhdG9yLCBjbGFzczogXCJ0b2stb3BlcmF0b3JcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmNvbW1lbnQsIGNsYXNzOiBcInRvay1jb21tZW50XCIgfSxcbiAgICB7IHRhZzogdGFncy5tZXRhLCBjbGFzczogXCJ0b2stbWV0YVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuaW52YWxpZCwgY2xhc3M6IFwidG9rLWludmFsaWRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnB1bmN0dWF0aW9uLCBjbGFzczogXCJ0b2stcHVuY3R1YXRpb25cIiB9XG5dKTtcblxuZXhwb3J0IHsgVGFnLCBjbGFzc0hpZ2hsaWdodGVyLCBnZXRTdHlsZVRhZ3MsIGhpZ2hsaWdodENvZGUsIGhpZ2hsaWdodFRyZWUsIHN0eWxlVGFncywgdGFnSGlnaGxpZ2h0ZXIsIHRhZ3MgfTtcbiJdLCJuYW1lcyI6WyJOb2RlUHJvcCIsIm5leHRUYWdJRCIsIlRhZyIsImNvbnN0cnVjdG9yIiwibmFtZSIsInNldCIsImJhc2UiLCJtb2RpZmllZCIsImlkIiwidG9TdHJpbmciLCJtb2QiLCJkZWZpbmUiLCJuYW1lT3JQYXJlbnQiLCJwYXJlbnQiLCJFcnJvciIsInRhZyIsInB1c2giLCJ0IiwiZGVmaW5lTW9kaWZpZXIiLCJNb2RpZmllciIsImluZGV4T2YiLCJnZXQiLCJjb25jYXQiLCJzb3J0IiwiYSIsImIiLCJuZXh0TW9kaWZpZXJJRCIsImluc3RhbmNlcyIsIm1vZHMiLCJsZW5ndGgiLCJleGlzdHMiLCJmaW5kIiwic2FtZUFycmF5IiwibSIsImNvbmZpZ3MiLCJwb3dlclNldCIsImNvbmZpZyIsImV2ZXJ5IiwieCIsImkiLCJhcnJheSIsInNldHMiLCJqIiwiZSIsInN0eWxlVGFncyIsInNwZWMiLCJieU5hbWUiLCJPYmplY3QiLCJjcmVhdGUiLCJwcm9wIiwidGFncyIsIkFycmF5IiwiaXNBcnJheSIsInBhcnQiLCJzcGxpdCIsInBpZWNlcyIsIm1vZGUiLCJyZXN0IiwicG9zIiwiZXhlYyIsIlJhbmdlRXJyb3IiLCJKU09OIiwicGFyc2UiLCJuZXh0Iiwic2xpY2UiLCJsYXN0IiwiaW5uZXIiLCJydWxlIiwiUnVsZSIsInJ1bGVOb2RlUHJvcCIsImFkZCIsImNvbnRleHQiLCJvcGFxdWUiLCJpbmhlcml0Iiwib3RoZXIiLCJkZXB0aCIsImVtcHR5IiwidGFnSGlnaGxpZ2h0ZXIiLCJvcHRpb25zIiwibWFwIiwic3R5bGUiLCJjbGFzcyIsInNjb3BlIiwiYWxsIiwiY2xzIiwic3ViIiwidGFnQ2xhc3MiLCJoaWdobGlnaHRUYWdzIiwiaGlnaGxpZ2h0ZXJzIiwicmVzdWx0IiwiaGlnaGxpZ2h0ZXIiLCJ2YWx1ZSIsImhpZ2hsaWdodFRyZWUiLCJ0cmVlIiwicHV0U3R5bGUiLCJmcm9tIiwidG8iLCJidWlsZGVyIiwiSGlnaGxpZ2h0QnVpbGRlciIsImhpZ2hsaWdodFJhbmdlIiwiY3Vyc29yIiwiZmx1c2giLCJoaWdobGlnaHRDb2RlIiwiY29kZSIsInB1dFRleHQiLCJwdXRCcmVhayIsIndyaXRlVG8iLCJwIiwiY2xhc3NlcyIsInRleHQiLCJuZXh0QnJlYWsiLCJ1cHRvIiwiYXQiLCJzcGFuIiwic3RhcnRTcGFuIiwiaW5oZXJpdGVkQ2xhc3MiLCJ0eXBlIiwic3RhcnQiLCJlbmQiLCJpc1RvcCIsImZpbHRlciIsImgiLCJnZXRTdHlsZVRhZ3MiLCJ0YWdDbHMiLCJNYXRoIiwibWF4IiwibW91bnRlZCIsIm92ZXJsYXkiLCJub2RlIiwiZW50ZXIiLCJpbm5lckhpZ2hsaWdodGVycyIsImhhc0NoaWxkIiwiZmlyc3RDaGlsZCIsIm5leHRQb3MiLCJyYW5nZUZyb20iLCJyYW5nZVRvIiwibWluIiwibmV4dFNpYmxpbmciLCJtYXRjaENvbnRleHQiLCJjb21tZW50IiwidHlwZU5hbWUiLCJwcm9wZXJ0eU5hbWUiLCJsaXRlcmFsIiwic3RyaW5nIiwibnVtYmVyIiwiY29udGVudCIsImhlYWRpbmciLCJrZXl3b3JkIiwib3BlcmF0b3IiLCJwdW5jdHVhdGlvbiIsImJyYWNrZXQiLCJtZXRhIiwibGluZUNvbW1lbnQiLCJibG9ja0NvbW1lbnQiLCJkb2NDb21tZW50IiwidmFyaWFibGVOYW1lIiwidGFnTmFtZSIsImF0dHJpYnV0ZU5hbWUiLCJjbGFzc05hbWUiLCJsYWJlbE5hbWUiLCJuYW1lc3BhY2UiLCJtYWNyb05hbWUiLCJkb2NTdHJpbmciLCJjaGFyYWN0ZXIiLCJhdHRyaWJ1dGVWYWx1ZSIsImludGVnZXIiLCJmbG9hdCIsImJvb2wiLCJyZWdleHAiLCJlc2NhcGUiLCJjb2xvciIsInVybCIsInNlbGYiLCJudWxsIiwiYXRvbSIsInVuaXQiLCJtb2RpZmllciIsIm9wZXJhdG9yS2V5d29yZCIsImNvbnRyb2xLZXl3b3JkIiwiZGVmaW5pdGlvbktleXdvcmQiLCJtb2R1bGVLZXl3b3JkIiwiZGVyZWZPcGVyYXRvciIsImFyaXRobWV0aWNPcGVyYXRvciIsImxvZ2ljT3BlcmF0b3IiLCJiaXR3aXNlT3BlcmF0b3IiLCJjb21wYXJlT3BlcmF0b3IiLCJ1cGRhdGVPcGVyYXRvciIsImRlZmluaXRpb25PcGVyYXRvciIsInR5cGVPcGVyYXRvciIsImNvbnRyb2xPcGVyYXRvciIsInNlcGFyYXRvciIsImFuZ2xlQnJhY2tldCIsInNxdWFyZUJyYWNrZXQiLCJwYXJlbiIsImJyYWNlIiwiaGVhZGluZzEiLCJoZWFkaW5nMiIsImhlYWRpbmczIiwiaGVhZGluZzQiLCJoZWFkaW5nNSIsImhlYWRpbmc2IiwiY29udGVudFNlcGFyYXRvciIsImxpc3QiLCJxdW90ZSIsImVtcGhhc2lzIiwic3Ryb25nIiwibGluayIsIm1vbm9zcGFjZSIsInN0cmlrZXRocm91Z2giLCJpbnNlcnRlZCIsImRlbGV0ZWQiLCJjaGFuZ2VkIiwiaW52YWxpZCIsImRvY3VtZW50TWV0YSIsImFubm90YXRpb24iLCJwcm9jZXNzaW5nSW5zdHJ1Y3Rpb24iLCJkZWZpbml0aW9uIiwiY29uc3RhbnQiLCJmdW5jdGlvbiIsInN0YW5kYXJkIiwibG9jYWwiLCJzcGVjaWFsIiwidmFsIiwiY2xhc3NIaWdobGlnaHRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lezer/highlight/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lezer/javascript/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@lezer/javascript/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parser: () => (/* binding */ parser)\n/* harmony export */ });\n/* harmony import */ var _lezer_lr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/lr */ \"(ssr)/./node_modules/@lezer/lr/dist/index.js\");\n/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lezer/highlight */ \"(ssr)/./node_modules/@lezer/highlight/dist/index.js\");\n\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst noSemi = 315, noSemiType = 316, incdec = 1, incdecPrefix = 2, questionDot = 3, JSXStartTag = 4, insertSemi = 317, spaces = 319, newline = 320, LineComment = 5, BlockComment = 6, Dialect_jsx = 0;\n/* Hand-written tokenizers for JavaScript tokens that can't be\n   expressed by lezer's built-in tokenizer. */ const space = [\n    9,\n    10,\n    11,\n    12,\n    13,\n    32,\n    133,\n    160,\n    5760,\n    8192,\n    8193,\n    8194,\n    8195,\n    8196,\n    8197,\n    8198,\n    8199,\n    8200,\n    8201,\n    8202,\n    8232,\n    8233,\n    8239,\n    8287,\n    12288\n];\nconst braceR = 125, semicolon = 59, slash = 47, star = 42, plus = 43, minus = 45, lt = 60, comma = 44, question = 63, dot = 46, bracketL = 91;\nconst trackNewline = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ContextTracker({\n    start: false,\n    shift (context, term) {\n        return term == LineComment || term == BlockComment || term == spaces ? context : term == newline;\n    },\n    strict: false\n});\nconst insertSemicolon = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, stack)=>{\n    let { next } = input;\n    if (next == braceR || next == -1 || stack.context) input.acceptToken(insertSemi);\n}, {\n    contextual: true,\n    fallback: true\n});\nconst noSemicolon = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, stack)=>{\n    let { next } = input, after;\n    if (space.indexOf(next) > -1) return;\n    if (next == slash && ((after = input.peek(1)) == slash || after == star)) return;\n    if (next != braceR && next != semicolon && next != -1 && !stack.context) input.acceptToken(noSemi);\n}, {\n    contextual: true\n});\nconst noSemicolonType = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, stack)=>{\n    if (input.next == bracketL && !stack.context) input.acceptToken(noSemiType);\n}, {\n    contextual: true\n});\nconst operatorToken = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, stack)=>{\n    let { next } = input;\n    if (next == plus || next == minus) {\n        input.advance();\n        if (next == input.next) {\n            input.advance();\n            let mayPostfix = !stack.context && stack.canShift(incdec);\n            input.acceptToken(mayPostfix ? incdec : incdecPrefix);\n        }\n    } else if (next == question && input.peek(1) == dot) {\n        input.advance();\n        input.advance();\n        if (input.next < 48 || input.next > 57) input.acceptToken(questionDot);\n    }\n}, {\n    contextual: true\n});\nfunction identifierChar(ch, start) {\n    return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch == 95 || ch >= 192 || !start && ch >= 48 && ch <= 57;\n}\nconst jsx = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, stack)=>{\n    if (input.next != lt || !stack.dialectEnabled(Dialect_jsx)) return;\n    input.advance();\n    if (input.next == slash) return;\n    // Scan for an identifier followed by a comma or 'extends', don't\n    // treat this as a start tag if present.\n    let back = 0;\n    while(space.indexOf(input.next) > -1){\n        input.advance();\n        back++;\n    }\n    if (identifierChar(input.next, true)) {\n        input.advance();\n        back++;\n        while(identifierChar(input.next, false)){\n            input.advance();\n            back++;\n        }\n        while(space.indexOf(input.next) > -1){\n            input.advance();\n            back++;\n        }\n        if (input.next == comma) return;\n        for(let i = 0;; i++){\n            if (i == 7) {\n                if (!identifierChar(input.next, true)) return;\n                break;\n            }\n            if (input.next != \"extends\".charCodeAt(i)) break;\n            input.advance();\n            back++;\n        }\n    }\n    input.acceptToken(JSXStartTag, -back);\n});\nconst jsHighlight = (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.styleTags)({\n    \"get set async static\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.modifier,\n    \"for while do if else switch try catch finally return throw break continue default case\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.controlKeyword,\n    \"in of await yield void typeof delete instanceof as satisfies\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.operatorKeyword,\n    \"let var const using function class extends\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definitionKeyword,\n    \"import export from\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.moduleKeyword,\n    \"with debugger new\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.keyword,\n    TemplateString: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string),\n    super: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.atom,\n    BooleanLiteral: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.bool,\n    this: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.self,\n    null: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.null,\n    Star: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.modifier,\n    VariableName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName,\n    \"CallExpression/VariableName TaggedTemplateExpression/VariableName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.function(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\n    VariableDefinition: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\n    Label: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.labelName,\n    PropertyName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName,\n    PrivatePropertyName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName),\n    \"CallExpression/MemberExpression/PropertyName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.function(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName),\n    \"FunctionDeclaration/VariableDefinition\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.function(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName)),\n    \"ClassDeclaration/VariableDefinition\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.className),\n    \"NewExpression/VariableName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.className,\n    PropertyDefinition: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName),\n    PrivatePropertyDefinition: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName)),\n    UpdateOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.updateOperator,\n    \"LineComment Hashbang\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.lineComment,\n    BlockComment: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.blockComment,\n    Number: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.number,\n    String: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string,\n    Escape: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.escape,\n    ArithOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.arithmeticOperator,\n    LogicOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.logicOperator,\n    BitOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.bitwiseOperator,\n    CompareOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.compareOperator,\n    RegExp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.regexp,\n    Equals: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definitionOperator,\n    Arrow: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.function(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.punctuation),\n    \": Spread\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.punctuation,\n    \"( )\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.paren,\n    \"[ ]\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.squareBracket,\n    \"{ }\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.brace,\n    \"InterpolationStart InterpolationEnd\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.brace),\n    \".\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.derefOperator,\n    \", ;\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.separator,\n    \"@\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.meta,\n    TypeName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.typeName,\n    TypeDefinition: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.typeName),\n    \"type enum interface implements namespace module declare\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definitionKeyword,\n    \"abstract global Privacy readonly override\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.modifier,\n    \"is keyof unique infer asserts\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.operatorKeyword,\n    JSXAttributeValue: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.attributeValue,\n    JSXText: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.content,\n    \"JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.angleBracket,\n    \"JSXIdentifier JSXNameSpacedName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.tagName,\n    \"JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.attributeName,\n    \"JSXBuiltin/JSXIdentifier\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.standard(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.tagName)\n});\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst spec_identifier = {\n    __proto__: null,\n    export: 20,\n    as: 25,\n    from: 33,\n    default: 36,\n    async: 41,\n    function: 42,\n    in: 52,\n    out: 55,\n    const: 56,\n    extends: 60,\n    this: 64,\n    true: 72,\n    false: 72,\n    null: 84,\n    void: 88,\n    typeof: 92,\n    super: 108,\n    new: 142,\n    delete: 154,\n    yield: 163,\n    await: 167,\n    class: 172,\n    public: 235,\n    private: 235,\n    protected: 235,\n    readonly: 237,\n    instanceof: 256,\n    satisfies: 259,\n    import: 292,\n    keyof: 349,\n    unique: 353,\n    infer: 359,\n    asserts: 395,\n    is: 397,\n    abstract: 417,\n    implements: 419,\n    type: 421,\n    let: 424,\n    var: 426,\n    using: 429,\n    interface: 435,\n    enum: 439,\n    namespace: 445,\n    module: 447,\n    declare: 451,\n    global: 455,\n    for: 474,\n    of: 483,\n    while: 486,\n    with: 490,\n    do: 494,\n    if: 498,\n    else: 500,\n    switch: 504,\n    case: 510,\n    try: 516,\n    catch: 520,\n    finally: 524,\n    return: 528,\n    throw: 532,\n    break: 536,\n    continue: 540,\n    debugger: 544\n};\nconst spec_word = {\n    __proto__: null,\n    async: 129,\n    get: 131,\n    set: 133,\n    declare: 195,\n    public: 197,\n    private: 197,\n    protected: 197,\n    static: 199,\n    abstract: 201,\n    override: 203,\n    readonly: 209,\n    accessor: 211,\n    new: 401\n};\nconst spec_LessThan = {\n    __proto__: null,\n    \"<\": 193\n};\nconst parser = _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.LRParser.deserialize({\n    version: 14,\n    states: \"$EOQ%TQlOOO%[QlOOO'_QpOOP(lO`OOO*zQ!0MxO'#CiO+RO#tO'#CjO+aO&jO'#CjO+oO#@ItO'#DaO.QQlO'#DgO.bQlO'#DrO%[QlO'#DzO0fQlO'#ESOOQ!0Lf'#E['#E[O1PQ`O'#EXOOQO'#Ep'#EpOOQO'#Ik'#IkO1XQ`O'#GsO1dQ`O'#EoO1iQ`O'#EoO3hQ!0MxO'#JqO6[Q!0MxO'#JrO6uQ`O'#F]O6zQ,UO'#FtOOQ!0Lf'#Ff'#FfO7VO7dO'#FfO7eQMhO'#F|O9[Q`O'#F{OOQ!0Lf'#Jr'#JrOOQ!0Lb'#Jq'#JqO9aQ`O'#GwOOQ['#K^'#K^O9lQ`O'#IXO9qQ!0LrO'#IYOOQ['#J_'#J_OOQ['#I^'#I^Q`QlOOQ`QlOOO9yQ!L^O'#DvO:QQlO'#EOO:XQlO'#EQO9gQ`O'#GsO:`QMhO'#CoO:nQ`O'#EnO:yQ`O'#EyO;OQMhO'#FeO;mQ`O'#GsOOQO'#K_'#K_O;rQ`O'#K_O<QQ`O'#G{O<QQ`O'#G|O<QQ`O'#HOO9gQ`O'#HRO<wQ`O'#HUO>`Q`O'#CeO>pQ`O'#HbO>xQ`O'#HhO>xQ`O'#HjO`QlO'#HlO>xQ`O'#HnO>xQ`O'#HqO>}Q`O'#HwO?SQ!0LsO'#H}O%[QlO'#IPO?_Q!0LsO'#IRO?jQ!0LsO'#ITO9qQ!0LrO'#IVO?uQ!0MxO'#CiO@wQpO'#DlQOQ`OOO%[QlO'#EQOA_Q`O'#ETO:`QMhO'#EnOAjQ`O'#EnOAuQ!bO'#FeOOQ['#Cg'#CgOOQ!0Lb'#Dq'#DqOOQ!0Lb'#Ju'#JuO%[QlO'#JuOOQO'#Jx'#JxOOQO'#Ig'#IgOBuQpO'#EgOOQ!0Lb'#Ef'#EfOOQ!0Lb'#J|'#J|OCqQ!0MSO'#EgOC{QpO'#EWOOQO'#Jw'#JwODaQpO'#JxOEnQpO'#EWOC{QpO'#EgPE{O&2DjO'#CbPOOO)CD|)CD|OOOO'#I_'#I_OFWO#tO,59UOOQ!0Lh,59U,59UOOOO'#I`'#I`OFfO&jO,59UOFtQ!L^O'#DcOOOO'#Ib'#IbOF{O#@ItO,59{OOQ!0Lf,59{,59{OGZQlO'#IcOGnQ`O'#JsOImQ!fO'#JsO+}QlO'#JsOItQ`O,5:ROJ[Q`O'#EpOJiQ`O'#KSOJtQ`O'#KROJtQ`O'#KROJ|Q`O,5;^OKRQ`O'#KQOOQ!0Ln,5:^,5:^OKYQlO,5:^OMWQ!0MxO,5:fOMwQ`O,5:nONbQ!0LrO'#KPONiQ`O'#KOO9aQ`O'#KOON}Q`O'#KOO! VQ`O,5;]O! [Q`O'#KOO!#aQ!fO'#JrOOQ!0Lh'#Ci'#CiO%[QlO'#ESO!$PQ!fO,5:sOOQS'#Jy'#JyOOQO-E<i-E<iO9gQ`O,5=_O!$gQ`O,5=_O!$lQlO,5;ZO!&oQMhO'#EkO!(YQ`O,5;ZO!(_QlO'#DyO!(iQpO,5;dO!(qQpO,5;dO%[QlO,5;dOOQ['#FT'#FTOOQ['#FV'#FVO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eOOQ['#FZ'#FZO!)PQlO,5;tOOQ!0Lf,5;y,5;yOOQ!0Lf,5;z,5;zOOQ!0Lf,5;|,5;|O%[QlO'#IoO!+SQ!0LrO,5<iO%[QlO,5;eO!&oQMhO,5;eO!+qQMhO,5;eO!-cQMhO'#E^O%[QlO,5;wOOQ!0Lf,5;{,5;{O!-jQ,UO'#FjO!.gQ,UO'#KWO!.RQ,UO'#KWO!.nQ,UO'#KWOOQO'#KW'#KWO!/SQ,UO,5<SOOOW,5<`,5<`O!/eQlO'#FvOOOW'#In'#InO7VO7dO,5<QO!/lQ,UO'#FxOOQ!0Lf,5<Q,5<QO!0]Q$IUO'#CyOOQ!0Lh'#C}'#C}O!0pO#@ItO'#DRO!1^QMjO,5<eO!1eQ`O,5<hO!3QQ(CWO'#GXO!3_Q`O'#GYO!3dQ`O'#GYO!5SQ(CWO'#G^O!6XQpO'#GbOOQO'#Gn'#GnO!+xQMhO'#GmOOQO'#Gp'#GpO!+xQMhO'#GoO!6zQ$IUO'#JkOOQ!0Lh'#Jk'#JkO!7UQ`O'#JjO!7dQ`O'#JiO!7lQ`O'#CuOOQ!0Lh'#C{'#C{O!7}Q`O'#C}OOQ!0Lh'#DV'#DVOOQ!0Lh'#DX'#DXO1SQ`O'#DZO!+xQMhO'#GPO!+xQMhO'#GRO!8SQ`O'#GTO!8XQ`O'#GUO!3dQ`O'#G[O!+xQMhO'#GaO<QQ`O'#JjO!8^Q`O'#EqO!8{Q`O,5<gOOQ!0Lb'#Cr'#CrO!9TQ`O'#ErO!9}QpO'#EsOOQ!0Lb'#KQ'#KQO!:UQ!0LrO'#K`O9qQ!0LrO,5=cO`QlO,5>sOOQ['#Jg'#JgOOQ[,5>t,5>tOOQ[-E<[-E<[O!<TQ!0MxO,5:bO!9xQpO,5:`O!>nQ!0MxO,5:jO%[QlO,5:jO!AUQ!0MxO,5:lOOQO,5@y,5@yO!AuQMhO,5=_O!BTQ!0LrO'#JhO9[Q`O'#JhO!BfQ!0LrO,59ZO!BqQpO,59ZO!ByQMhO,59ZO:`QMhO,59ZO!CUQ`O,5;ZO!C^Q`O'#HaO!CrQ`O'#KcO%[QlO,5;}O!9xQpO,5<PO!CzQ`O,5=zO!DPQ`O,5=zO!DUQ`O,5=zO9qQ!0LrO,5=zO<QQ`O,5=jOOQO'#Cy'#CyO!DdQpO,5=gO!DlQMhO,5=hO!DwQ`O,5=jO!D|Q!bO,5=mO!EUQ`O'#K_O>}Q`O'#HWO9gQ`O'#HYO!EZQ`O'#HYO:`QMhO'#H[O!E`Q`O'#H[OOQ[,5=p,5=pO!EeQ`O'#H]O!EvQ`O'#CoO!E{Q`O,59PO!FVQ`O,59PO!H[QlO,59POOQ[,59P,59PO!HlQ!0LrO,59PO%[QlO,59PO!JwQlO'#HdOOQ['#He'#HeOOQ['#Hf'#HfO`QlO,5=|O!K_Q`O,5=|O`QlO,5>SO`QlO,5>UO!KdQ`O,5>WO`QlO,5>YO!KiQ`O,5>]O!KnQlO,5>cOOQ[,5>i,5>iO%[QlO,5>iO9qQ!0LrO,5>kOOQ[,5>m,5>mO# xQ`O,5>mOOQ[,5>o,5>oO# xQ`O,5>oOOQ[,5>q,5>qO#!fQpO'#D_O%[QlO'#JuO##XQpO'#JuO##cQpO'#DmO##tQpO'#DmO#&VQlO'#DmO#&^Q`O'#JtO#&fQ`O,5:WO#&kQ`O'#EtO#&yQ`O'#KTO#'RQ`O,5;_O#'WQpO'#DmO#'eQpO'#EVOOQ!0Lf,5:o,5:oO%[QlO,5:oO#'lQ`O,5:oO>}Q`O,5;YO!BqQpO,5;YO!ByQMhO,5;YO:`QMhO,5;YO#'tQ`O,5@aO#'yQ07dO,5:sOOQO-E<e-E<eO#)PQ!0MSO,5;ROC{QpO,5:rO#)ZQpO,5:rOC{QpO,5;RO!BfQ!0LrO,5:rOOQ!0Lb'#Ej'#EjOOQO,5;R,5;RO%[QlO,5;RO#)hQ!0LrO,5;RO#)sQ!0LrO,5;RO!BqQpO,5:rOOQO,5;X,5;XO#*RQ!0LrO,5;RPOOO'#I]'#I]P#*gO&2DjO,58|POOO,58|,58|OOOO-E<]-E<]OOQ!0Lh1G.p1G.pOOOO-E<^-E<^OOOO,59},59}O#*rQ!bO,59}OOOO-E<`-E<`OOQ!0Lf1G/g1G/gO#*wQ!fO,5>}O+}QlO,5>}OOQO,5?T,5?TO#+RQlO'#IcOOQO-E<a-E<aO#+`Q`O,5@_O#+hQ!fO,5@_O#+oQ`O,5@mOOQ!0Lf1G/m1G/mO%[QlO,5@nO#+wQ`O'#IiOOQO-E<g-E<gO#+oQ`O,5@mOOQ!0Lb1G0x1G0xOOQ!0Ln1G/x1G/xOOQ!0Ln1G0Y1G0YO%[QlO,5@kO#,]Q!0LrO,5@kO#,nQ!0LrO,5@kO#,uQ`O,5@jO9aQ`O,5@jO#,}Q`O,5@jO#-]Q`O'#IlO#,uQ`O,5@jOOQ!0Lb1G0w1G0wO!(iQpO,5:uO!(tQpO,5:uOOQS,5:w,5:wO#-}QdO,5:wO#.VQMhO1G2yO9gQ`O1G2yOOQ!0Lf1G0u1G0uO#.eQ!0MxO1G0uO#/jQ!0MvO,5;VOOQ!0Lh'#GW'#GWO#0WQ!0MzO'#JkO!$lQlO1G0uO#2cQ!fO'#JvO%[QlO'#JvO#2mQ`O,5:eOOQ!0Lh'#D_'#D_OOQ!0Lf1G1O1G1OO%[QlO1G1OOOQ!0Lf1G1f1G1fO#2rQ`O1G1OO#5WQ!0MxO1G1PO#5_Q!0MxO1G1PO#7uQ!0MxO1G1PO#7|Q!0MxO1G1PO#:dQ!0MxO1G1PO#<zQ!0MxO1G1PO#=RQ!0MxO1G1PO#=YQ!0MxO1G1PO#?pQ!0MxO1G1PO#?wQ!0MxO1G1PO#BUQ?MtO'#CiO#DPQ?MtO1G1`O#DWQ?MtO'#JrO#DkQ!0MxO,5?ZOOQ!0Lb-E<m-E<mO#FxQ!0MxO1G1PO#GuQ!0MzO1G1POOQ!0Lf1G1P1G1PO#HxQMjO'#J{O#ISQ`O,5:xO#IXQ!0MxO1G1cO#I{Q,UO,5<WO#JTQ,UO,5<XO#J]Q,UO'#FoO#JtQ`O'#FnOOQO'#KX'#KXOOQO'#Im'#ImO#JyQ,UO1G1nOOQ!0Lf1G1n1G1nOOOW1G1y1G1yO#K[Q?MtO'#JqO#KfQ`O,5<bO!)PQlO,5<bOOOW-E<l-E<lOOQ!0Lf1G1l1G1lO#KkQpO'#KWOOQ!0Lf,5<d,5<dO#KsQpO,5<dO#KxQMhO'#DTOOOO'#Ia'#IaO#LPO#@ItO,59mOOQ!0Lh,59m,59mO%[QlO1G2PO!8XQ`O'#IqO#L[Q`O,5<zOOQ!0Lh,5<w,5<wO!+xQMhO'#ItO#LxQMjO,5=XO!+xQMhO'#IvO#MkQMjO,5=ZO!&oQMhO,5=]OOQO1G2S1G2SO#MuQ!dO'#CrO#NYQ(CWO'#ErO$ _QpO'#GbO$ uQ!dO,5<sO$ |Q`O'#KZO9aQ`O'#KZO$![Q`O,5<uO!+xQMhO,5<tO$!aQ`O'#GZO$!rQ`O,5<tO$!wQ!dO'#GWO$#UQ!dO'#K[O$#`Q`O'#K[O!&oQMhO'#K[O$#eQ`O,5<xO$#jQlO'#JuO$#tQpO'#GcO##tQpO'#GcO$$VQ`O'#GgO!3dQ`O'#GkO$$[Q!0LrO'#IsO$$gQpO,5<|OOQ!0Lp,5<|,5<|O$$nQpO'#GcO$${QpO'#GdO$%^QpO'#GdO$%cQMjO,5=XO$%sQMjO,5=ZOOQ!0Lh,5=^,5=^O!+xQMhO,5@UO!+xQMhO,5@UO$&TQ`O'#IxO$&iQ`O,5@TO$&qQ`O,59aOOQ!0Lh,59i,59iO$'hQ$IYO,59uOOQ!0Lh'#Jo'#JoO$(ZQMjO,5<kO$(|QMjO,5<mO@oQ`O,5<oOOQ!0Lh,5<p,5<pO$)WQ`O,5<vO$)]QMjO,5<{O$)mQ`O,5@UO$){Q`O'#KOO!$lQlO1G2RO$*QQ`O1G2RO9aQ`O'#KRO9aQ`O'#EtO%[QlO'#EtO9aQ`O'#IzO$*VQ!0LrO,5@zOOQ[1G2}1G2}OOQ[1G4_1G4_OOQ!0Lf1G/|1G/|OOQ!0Lf1G/z1G/zO$,XQ!0MxO1G0UOOQ[1G2y1G2yO!&oQMhO1G2yO%[QlO1G2yO#.YQ`O1G2yO$.]QMhO'#EkOOQ!0Lb,5@S,5@SO$.jQ!0LrO,5@SOOQ[1G.u1G.uO!BfQ!0LrO1G.uO!BqQpO1G.uO!ByQMhO1G.uO$.{Q`O1G0uO$/QQ`O'#CiO$/]Q`O'#KdO$/eQ`O,5={O$/jQ`O'#KdO$/oQ`O'#KdO$/}Q`O'#JQO$0]Q`O,5@}O$0eQ!fO1G1iOOQ!0Lf1G1k1G1kO9gQ`O1G3fO@oQ`O1G3fO$0lQ`O1G3fO$0qQ`O1G3fOOQ[1G3f1G3fO!DwQ`O1G3UO!&oQMhO1G3RO$0vQ`O1G3ROOQ[1G3S1G3SO!&oQMhO1G3SO$0{Q`O1G3SO$1TQpO'#HQOOQ[1G3U1G3UO!6SQpO'#I|O!D|Q!bO1G3XOOQ[1G3X1G3XOOQ[,5=r,5=rO$1]QMhO,5=tO9gQ`O,5=tO$$VQ`O,5=vO9[Q`O,5=vO!BqQpO,5=vO!ByQMhO,5=vO:`QMhO,5=vO$1kQ`O'#KbO$1vQ`O,5=wOOQ[1G.k1G.kO$1{Q!0LrO1G.kO@oQ`O1G.kO$2WQ`O1G.kO9qQ!0LrO1G.kO$4`Q!fO,5APO$4mQ`O,5APO9aQ`O,5APO$4xQlO,5>OO$5PQ`O,5>OOOQ[1G3h1G3hO`QlO1G3hOOQ[1G3n1G3nOOQ[1G3p1G3pO>xQ`O1G3rO$5UQlO1G3tO$9YQlO'#HsOOQ[1G3w1G3wO$9gQ`O'#HyO>}Q`O'#H{OOQ[1G3}1G3}O$9oQlO1G3}O9qQ!0LrO1G4TOOQ[1G4V1G4VOOQ!0Lb'#G_'#G_O9qQ!0LrO1G4XO9qQ!0LrO1G4ZO$=vQ`O,5@aO!)PQlO,5;`O9aQ`O,5;`O>}Q`O,5:XO!)PQlO,5:XO!BqQpO,5:XO$={Q?MtO,5:XOOQO,5;`,5;`O$>VQpO'#IdO$>mQ`O,5@`OOQ!0Lf1G/r1G/rO$>uQpO'#IjO$?PQ`O,5@oOOQ!0Lb1G0y1G0yO##tQpO,5:XOOQO'#If'#IfO$?XQpO,5:qOOQ!0Ln,5:q,5:qO#'oQ`O1G0ZOOQ!0Lf1G0Z1G0ZO%[QlO1G0ZOOQ!0Lf1G0t1G0tO>}Q`O1G0tO!BqQpO1G0tO!ByQMhO1G0tOOQ!0Lb1G5{1G5{O!BfQ!0LrO1G0^OOQO1G0m1G0mO%[QlO1G0mO$?`Q!0LrO1G0mO$?kQ!0LrO1G0mO!BqQpO1G0^OC{QpO1G0^O$?yQ!0LrO1G0mOOQO1G0^1G0^O$@_Q!0MxO1G0mPOOO-E<Z-E<ZPOOO1G.h1G.hOOOO1G/i1G/iO$@iQ!bO,5<iO$@qQ!fO1G4iOOQO1G4o1G4oO%[QlO,5>}O$@{Q`O1G5yO$ATQ`O1G6XO$A]Q!fO1G6YO9aQ`O,5?TO$AgQ!0MxO1G6VO%[QlO1G6VO$AwQ!0LrO1G6VO$BYQ`O1G6UO$BYQ`O1G6UO9aQ`O1G6UO$BbQ`O,5?WO9aQ`O,5?WOOQO,5?W,5?WO$BvQ`O,5?WO$){Q`O,5?WOOQO-E<j-E<jOOQS1G0a1G0aOOQS1G0c1G0cO#.QQ`O1G0cOOQ[7+(e7+(eO!&oQMhO7+(eO%[QlO7+(eO$CUQ`O7+(eO$CaQMhO7+(eO$CoQ!0MzO,5=XO$EzQ!0MzO,5=ZO$HVQ!0MzO,5=XO$JhQ!0MzO,5=ZO$LyQ!0MzO,59uO% OQ!0MzO,5<kO%#ZQ!0MzO,5<mO%%fQ!0MzO,5<{OOQ!0Lf7+&a7+&aO%'wQ!0MxO7+&aO%(kQlO'#IeO%(xQ`O,5@bO%)QQ!fO,5@bOOQ!0Lf1G0P1G0PO%)[Q`O7+&jOOQ!0Lf7+&j7+&jO%)aQ?MtO,5:fO%[QlO7+&zO%)kQ?MtO,5:bO%)xQ?MtO,5:jO%*SQ?MtO,5:lO%*^QMhO'#IhO%*hQ`O,5@gOOQ!0Lh1G0d1G0dOOQO1G1r1G1rOOQO1G1s1G1sO%*pQ!jO,5<ZO!)PQlO,5<YOOQO-E<k-E<kOOQ!0Lf7+'Y7+'YOOOW7+'e7+'eOOOW1G1|1G1|O%*{Q`O1G1|OOQ!0Lf1G2O1G2OOOOO,59o,59oO%+QQ!dO,59oOOOO-E<_-E<_OOQ!0Lh1G/X1G/XO%+XQ!0MxO7+'kOOQ!0Lh,5?],5?]O%+{QMhO1G2fP%,SQ`O'#IqPOQ!0Lh-E<o-E<oO%,pQMjO,5?`OOQ!0Lh-E<r-E<rO%-cQMjO,5?bOOQ!0Lh-E<t-E<tO%-mQ!dO1G2wO%-tQ!dO'#CrO%.[QMhO'#KRO$#jQlO'#JuOOQ!0Lh1G2_1G2_O%.cQ`O'#IpO%.wQ`O,5@uO%.wQ`O,5@uO%/PQ`O,5@uO%/[Q`O,5@uOOQO1G2a1G2aO%/jQMjO1G2`O!+xQMhO1G2`O%/zQ(CWO'#IrO%0XQ`O,5@vO!&oQMhO,5@vO%0aQ!dO,5@vOOQ!0Lh1G2d1G2dO%2qQ!fO'#CiO%2{Q`O,5=POOQ!0Lb,5<},5<}O%3TQpO,5<}OOQ!0Lb,5=O,5=OOClQ`O,5<}O%3`QpO,5<}OOQ!0Lb,5=R,5=RO$){Q`O,5=VOOQO,5?_,5?_OOQO-E<q-E<qOOQ!0Lp1G2h1G2hO##tQpO,5<}O$#jQlO,5=PO%3nQ`O,5=OO%3yQpO,5=OO!+xQMhO'#ItO%4sQMjO1G2sO!+xQMhO'#IvO%5fQMjO1G2uO%5pQMjO1G5pO%5zQMjO1G5pOOQO,5?d,5?dOOQO-E<v-E<vOOQO1G.{1G.{O!9xQpO,59wO%[QlO,59wOOQ!0Lh,5<j,5<jO%6XQ`O1G2ZO!+xQMhO1G2bO!+xQMhO1G5pO!+xQMhO1G5pO%6^Q!0MxO7+'mOOQ!0Lf7+'m7+'mO!$lQlO7+'mO%7QQ`O,5;`OOQ!0Lb,5?f,5?fOOQ!0Lb-E<x-E<xO%7VQ!dO'#K]O#'oQ`O7+(eO4UQ!fO7+(eO$CXQ`O7+(eO%7aQ!0MvO'#CiO%7tQ!0MvO,5=SO%8fQ`O,5=SO%8nQ`O,5=SOOQ!0Lb1G5n1G5nOOQ[7+$a7+$aO!BfQ!0LrO7+$aO!BqQpO7+$aO!$lQlO7+&aO%8sQ`O'#JPO%9[Q`O,5AOOOQO1G3g1G3gO9gQ`O,5AOO%9[Q`O,5AOO%9dQ`O,5AOOOQO,5?l,5?lOOQO-E=O-E=OOOQ!0Lf7+'T7+'TO%9iQ`O7+)QO9qQ!0LrO7+)QO9gQ`O7+)QO@oQ`O7+)QOOQ[7+(p7+(pO%9nQ!0MvO7+(mO!&oQMhO7+(mO!DrQ`O7+(nOOQ[7+(n7+(nO!&oQMhO7+(nO%9xQ`O'#KaO%:TQ`O,5=lOOQO,5?h,5?hOOQO-E<z-E<zOOQ[7+(s7+(sO%;gQpO'#HZOOQ[1G3`1G3`O!&oQMhO1G3`O%[QlO1G3`O%;nQ`O1G3`O%;yQMhO1G3`O9qQ!0LrO1G3bO$$VQ`O1G3bO9[Q`O1G3bO!BqQpO1G3bO!ByQMhO1G3bO%<XQ`O'#JOO%<mQ`O,5@|O%<uQpO,5@|OOQ!0Lb1G3c1G3cOOQ[7+$V7+$VO@oQ`O7+$VO9qQ!0LrO7+$VO%=QQ`O7+$VO%[QlO1G6kO%[QlO1G6lO%=VQ!0LrO1G6kO%=aQlO1G3jO%=hQ`O1G3jO%=mQlO1G3jOOQ[7+)S7+)SO9qQ!0LrO7+)^O`QlO7+)`OOQ['#Kg'#KgOOQ['#JR'#JRO%=tQlO,5>_OOQ[,5>_,5>_O%[QlO'#HtO%>RQ`O'#HvOOQ[,5>e,5>eO9aQ`O,5>eOOQ[,5>g,5>gOOQ[7+)i7+)iOOQ[7+)o7+)oOOQ[7+)s7+)sOOQ[7+)u7+)uO%>WQpO1G5{O%>rQ?MtO1G0zO%>|Q`O1G0zOOQO1G/s1G/sO%?XQ?MtO1G/sO>}Q`O1G/sO!)PQlO'#DmOOQO,5?O,5?OOOQO-E<b-E<bOOQO,5?U,5?UOOQO-E<h-E<hO!BqQpO1G/sOOQO-E<d-E<dOOQ!0Ln1G0]1G0]OOQ!0Lf7+%u7+%uO#'oQ`O7+%uOOQ!0Lf7+&`7+&`O>}Q`O7+&`O!BqQpO7+&`OOQO7+%x7+%xO$@_Q!0MxO7+&XOOQO7+&X7+&XO%[QlO7+&XO%?cQ!0LrO7+&XO!BfQ!0LrO7+%xO!BqQpO7+%xO%?nQ!0LrO7+&XO%?|Q!0MxO7++qO%[QlO7++qO%@^Q`O7++pO%@^Q`O7++pOOQO1G4r1G4rO9aQ`O1G4rO%@fQ`O1G4rOOQS7+%}7+%}O#'oQ`O<<LPO4UQ!fO<<LPO%@tQ`O<<LPOOQ[<<LP<<LPO!&oQMhO<<LPO%[QlO<<LPO%@|Q`O<<LPO%AXQ!0MzO,5?`O%CdQ!0MzO,5?bO%EoQ!0MzO1G2`O%HQQ!0MzO1G2sO%J]Q!0MzO1G2uO%LhQ!fO,5?PO%[QlO,5?POOQO-E<c-E<cO%LrQ`O1G5|OOQ!0Lf<<JU<<JUO%LzQ?MtO1G0uO& RQ?MtO1G1PO& YQ?MtO1G1PO&#ZQ?MtO1G1PO&#bQ?MtO1G1PO&%cQ?MtO1G1PO&'dQ?MtO1G1PO&'kQ?MtO1G1PO&'rQ?MtO1G1PO&)sQ?MtO1G1PO&)zQ?MtO1G1PO&*RQ!0MxO<<JfO&+yQ?MtO1G1PO&,vQ?MvO1G1PO&-yQ?MvO'#JkO&0PQ?MtO1G1cO&0^Q?MtO1G0UO&0hQMjO,5?SOOQO-E<f-E<fO!)PQlO'#FqOOQO'#KY'#KYOOQO1G1u1G1uO&0rQ`O1G1tO&0wQ?MtO,5?ZOOOW7+'h7+'hOOOO1G/Z1G/ZO&1RQ!dO1G4wOOQ!0Lh7+(Q7+(QP!&oQMhO,5?]O!+xQMhO7+(cO&1YQ`O,5?[O9aQ`O,5?[OOQO-E<n-E<nO&1hQ`O1G6aO&1hQ`O1G6aO&1pQ`O1G6aO&1{QMjO7+'zO&2]Q!dO,5?^O&2gQ`O,5?^O!&oQMhO,5?^OOQO-E<p-E<pO&2lQ!dO1G6bO&2vQ`O1G6bO&3OQ`O1G2kO!&oQMhO1G2kOOQ!0Lb1G2i1G2iOOQ!0Lb1G2j1G2jO%3TQpO1G2iO!BqQpO1G2iOClQ`O1G2iOOQ!0Lb1G2q1G2qO&3TQpO1G2iO&3cQ`O1G2kO$){Q`O1G2jOClQ`O1G2jO$#jQlO1G2kO&3kQ`O1G2jO&4_QMjO,5?`OOQ!0Lh-E<s-E<sO&5QQMjO,5?bOOQ!0Lh-E<u-E<uO!+xQMhO7++[OOQ!0Lh1G/c1G/cO&5[Q`O1G/cOOQ!0Lh7+'u7+'uO&5aQMjO7+'|O&5qQMjO7++[O&5{QMjO7++[O&6YQ!0MxO<<KXOOQ!0Lf<<KX<<KXO&6|Q`O1G0zO!&oQMhO'#IyO&7RQ`O,5@wO&9TQ!fO<<LPO!&oQMhO1G2nO&9[Q!0LrO1G2nOOQ[<<G{<<G{O!BfQ!0LrO<<G{O&9mQ!0MxO<<I{OOQ!0Lf<<I{<<I{OOQO,5?k,5?kO&:aQ`O,5?kO&:fQ`O,5?kOOQO-E<}-E<}O&:tQ`O1G6jO&:tQ`O1G6jO9gQ`O1G6jO@oQ`O<<LlOOQ[<<Ll<<LlO&:|Q`O<<LlO9qQ!0LrO<<LlOOQ[<<LX<<LXO%9nQ!0MvO<<LXOOQ[<<LY<<LYO!DrQ`O<<LYO&;RQpO'#I{O&;^Q`O,5@{O!)PQlO,5@{OOQ[1G3W1G3WOOQO'#I}'#I}O9qQ!0LrO'#I}O&;fQpO,5=uOOQ[,5=u,5=uO&;mQpO'#EgO&;tQpO'#GeO&;yQ`O7+(zO&<OQ`O7+(zOOQ[7+(z7+(zO!&oQMhO7+(zO%[QlO7+(zO&<WQ`O7+(zOOQ[7+(|7+(|O9qQ!0LrO7+(|O$$VQ`O7+(|O9[Q`O7+(|O!BqQpO7+(|O&<cQ`O,5?jOOQO-E<|-E<|OOQO'#H^'#H^O&<nQ`O1G6hO9qQ!0LrO<<GqOOQ[<<Gq<<GqO@oQ`O<<GqO&<vQ`O7+,VO&<{Q`O7+,WO%[QlO7+,VO%[QlO7+,WOOQ[7+)U7+)UO&=QQ`O7+)UO&=VQlO7+)UO&=^Q`O7+)UOOQ[<<Lx<<LxOOQ[<<Lz<<LzOOQ[-E=P-E=POOQ[1G3y1G3yO&=cQ`O,5>`OOQ[,5>b,5>bO&=hQ`O1G4PO9aQ`O7+&fO!)PQlO7+&fOOQO7+%_7+%_O&=mQ?MtO1G6YO>}Q`O7+%_OOQ!0Lf<<Ia<<IaOOQ!0Lf<<Iz<<IzO>}Q`O<<IzOOQO<<Is<<IsO$@_Q!0MxO<<IsO%[QlO<<IsOOQO<<Id<<IdO!BfQ!0LrO<<IdO&=wQ!0LrO<<IsO&>SQ!0MxO<= ]O&>dQ`O<= [OOQO7+*^7+*^O9aQ`O7+*^OOQ[ANAkANAkO&>lQ!fOANAkO!&oQMhOANAkO#'oQ`OANAkO4UQ!fOANAkO&>sQ`OANAkO%[QlOANAkO&>{Q!0MzO7+'zO&A^Q!0MzO,5?`O&CiQ!0MzO,5?bO&EtQ!0MzO7+'|O&HVQ!fO1G4kO&HaQ?MtO7+&aO&JeQ?MvO,5=XO&LlQ?MvO,5=ZO&L|Q?MvO,5=XO&M^Q?MvO,5=ZO&MnQ?MvO,59uO' tQ?MvO,5<kO'#wQ?MvO,5<mO'&]Q?MvO,5<{O'(RQ?MtO7+'kO'(`Q?MtO7+'mO'(mQ`O,5<]OOQO7+'`7+'`OOQ!0Lh7+*c7+*cO'(rQMjO<<K}OOQO1G4v1G4vO'(yQ`O1G4vO')UQ`O1G4vO')dQ`O7++{O')dQ`O7++{O!&oQMhO1G4xO')lQ!dO1G4xO')vQ`O7++|O'*OQ`O7+(VO'*ZQ!dO7+(VOOQ!0Lb7+(T7+(TOOQ!0Lb7+(U7+(UO!BqQpO7+(TOClQ`O7+(TO'*eQ`O7+(VO!&oQMhO7+(VO$){Q`O7+(UO'*jQ`O7+(VOClQ`O7+(UO'*rQMjO<<NvOOQ!0Lh7+$}7+$}O!+xQMhO<<NvO'*|Q!dO,5?eOOQO-E<w-E<wO'+WQ!0MvO7+(YO!&oQMhO7+(YOOQ[AN=gAN=gO9gQ`O1G5VOOQO1G5V1G5VO'+hQ`O1G5VO'+mQ`O7+,UO'+mQ`O7+,UO9qQ!0LrOANBWO@oQ`OANBWOOQ[ANBWANBWOOQ[ANAsANAsOOQ[ANAtANAtO'+uQ`O,5?gOOQO-E<y-E<yO',QQ?MtO1G6gOOQO,5?i,5?iOOQO-E<{-E<{OOQ[1G3a1G3aO',[Q`O,5=POOQ[<<Lf<<LfO!&oQMhO<<LfO&;yQ`O<<LfO',aQ`O<<LfO%[QlO<<LfOOQ[<<Lh<<LhO9qQ!0LrO<<LhO$$VQ`O<<LhO9[Q`O<<LhO',iQpO1G5UO',tQ`O7+,SOOQ[AN=]AN=]O9qQ!0LrOAN=]OOQ[<= q<= qOOQ[<= r<= rO',|Q`O<= qO'-RQ`O<= rOOQ[<<Lp<<LpO'-WQ`O<<LpO'-]QlO<<LpOOQ[1G3z1G3zO>}Q`O7+)kO'-dQ`O<<JQO'-oQ?MtO<<JQOOQO<<Hy<<HyOOQ!0LfAN?fAN?fOOQOAN?_AN?_O$@_Q!0MxOAN?_OOQOAN?OAN?OO%[QlOAN?_OOQO<<Mx<<MxOOQ[G27VG27VO!&oQMhOG27VO#'oQ`OG27VO'-yQ!fOG27VO4UQ!fOG27VO'.QQ`OG27VO'.YQ?MtO<<JfO'.gQ?MvO1G2`O'0]Q?MvO,5?`O'2`Q?MvO,5?bO'4cQ?MvO1G2sO'6fQ?MvO1G2uO'8iQ?MtO<<KXO'8vQ?MtO<<I{OOQO1G1w1G1wO!+xQMhOANAiOOQO7+*b7+*bO'9TQ`O7+*bO'9`Q`O<= gO'9hQ!dO7+*dOOQ!0Lb<<Kq<<KqO$){Q`O<<KqOClQ`O<<KqO'9rQ`O<<KqO!&oQMhO<<KqOOQ!0Lb<<Ko<<KoO!BqQpO<<KoO'9}Q!dO<<KqOOQ!0Lb<<Kp<<KpO':XQ`O<<KqO!&oQMhO<<KqO$){Q`O<<KpO':^QMjOANDbO':hQ!0MvO<<KtOOQO7+*q7+*qO9gQ`O7+*qO':xQ`O<= pOOQ[G27rG27rO9qQ!0LrOG27rO!)PQlO1G5RO';QQ`O7+,RO';YQ`O1G2kO&;yQ`OANBQOOQ[ANBQANBQO!&oQMhOANBQO';_Q`OANBQOOQ[ANBSANBSO9qQ!0LrOANBSO$$VQ`OANBSOOQO'#H_'#H_OOQO7+*p7+*pOOQ[G22wG22wOOQ[ANE]ANE]OOQ[ANE^ANE^OOQ[ANB[ANB[O';gQ`OANB[OOQ[<<MV<<MVO!)PQlOAN?lOOQOG24yG24yO$@_Q!0MxOG24yO#'oQ`OLD,qOOQ[LD,qLD,qO!&oQMhOLD,qO';lQ!fOLD,qO';sQ?MvO7+'zO'=iQ?MvO,5?`O'?lQ?MvO,5?bO'AoQ?MvO7+'|O'CeQMjOG27TOOQO<<M|<<M|OOQ!0LbANA]ANA]O$){Q`OANA]OClQ`OANA]O'CuQ!dOANA]OOQ!0LbANAZANAZO'C|Q`OANA]O!&oQMhOANA]O'DXQ!dOANA]OOQ!0LbANA[ANA[OOQO<<N]<<N]OOQ[LD-^LD-^O'DcQ?MtO7+*mOOQO'#Gf'#GfOOQ[G27lG27lO&;yQ`OG27lO!&oQMhOG27lOOQ[G27nG27nO9qQ!0LrOG27nOOQ[G27vG27vO'DmQ?MtOG25WOOQOLD*eLD*eOOQ[!$(!]!$(!]O#'oQ`O!$(!]O!&oQMhO!$(!]O'DwQ!0MzOG27TOOQ!0LbG26wG26wO$){Q`OG26wO'GYQ`OG26wOClQ`OG26wO'GeQ!dOG26wO!&oQMhOG26wOOQ[LD-WLD-WO&;yQ`OLD-WOOQ[LD-YLD-YOOQ[!)9Ew!)9EwO#'oQ`O!)9EwOOQ!0LbLD,cLD,cO$){Q`OLD,cOClQ`OLD,cO'GlQ`OLD,cO'GwQ!dOLD,cOOQ[!$(!r!$(!rOOQ[!.K;c!.K;cO'HOQ?MvOG27TOOQ!0Lb!$( }!$( }O$){Q`O!$( }OClQ`O!$( }O'ItQ`O!$( }OOQ!0Lb!)9Ei!)9EiO$){Q`O!)9EiOClQ`O!)9EiOOQ!0Lb!.K;T!.K;TO$){Q`O!.K;TOOQ!0Lb!4/0o!4/0oO!)PQlO'#DzO1PQ`O'#EXO'JPQ!fO'#JqO'JWQ!L^O'#DvO'J_QlO'#EOO'JfQ!fO'#CiO'L|Q!fO'#CiO!)PQlO'#EQO'M^QlO,5;ZO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO'#IoO( aQ`O,5<iO!)PQlO,5;eO( iQMhO,5;eO(#SQMhO,5;eO!)PQlO,5;wO!&oQMhO'#GmO( iQMhO'#GmO!&oQMhO'#GoO( iQMhO'#GoO1SQ`O'#DZO1SQ`O'#DZO!&oQMhO'#GPO( iQMhO'#GPO!&oQMhO'#GRO( iQMhO'#GRO!&oQMhO'#GaO( iQMhO'#GaO!)PQlO,5:jO(#ZQpO'#D_O(#eQpO'#JuO!)PQlO,5@nO'M^QlO1G0uO(#oQ?MtO'#CiO!)PQlO1G2PO!&oQMhO'#ItO( iQMhO'#ItO!&oQMhO'#IvO( iQMhO'#IvO(#yQ!dO'#CrO!&oQMhO,5<tO( iQMhO,5<tO'M^QlO1G2RO!)PQlO7+&zO!&oQMhO1G2`O( iQMhO1G2`O!&oQMhO'#ItO( iQMhO'#ItO!&oQMhO'#IvO( iQMhO'#IvO!&oQMhO1G2bO( iQMhO1G2bO'M^QlO7+'mO'M^QlO7+&aO!&oQMhOANAiO( iQMhOANAiO($^Q`O'#EoO($cQ`O'#EoO($kQ`O'#F]O($pQ`O'#EyO($uQ`O'#KSO(%QQ`O'#KQO(%]Q`O,5;ZO(%bQMjO,5<eO(%iQ`O'#GYO(%nQ`O'#GYO(%sQ`O,5<gO(%{Q`O,5;ZO(&TQ?MtO1G1`O(&[Q`O,5<tO(&aQ`O,5<tO(&fQ`O,5<vO(&kQ`O,5<vO(&pQ`O1G2RO(&uQ`O1G0uO(&zQMjO<<K}O('RQMjO<<K}O7eQMhO'#F|O9[Q`O'#F{OAjQ`O'#EnO!)PQlO,5;tO!3dQ`O'#GYO!3dQ`O'#GYO!3dQ`O'#G[O!3dQ`O'#G[O!+xQMhO7+(cO!+xQMhO7+(cO%-mQ!dO1G2wO%-mQ!dO1G2wO!&oQMhO,5=]O!&oQMhO,5=]\",\n    stateData: \"((X~O'{OS'|OSTOS'}RQ~OPYOQYOSfOY!VOaqOdzOeyOl!POpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_XO!iuO!lZO!oYO!pYO!qYO!svO!uwO!xxO!|]O$W|O$niO%h}O%j!QO%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO%y!UO&V!WO&]!XO&_!YO&a!ZO&c![O&f!]O&l!^O&r!_O&t!`O&v!aO&x!bO&z!cO(SSO(UTO(XUO(`VO(n[O~OWtO~P`OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(S!dO(UTO(XUO(`VO(n[O~Oa!wOs!nO!S!oO!b!yO!c!vO!d!vO!|;wO#T!pO#U!pO#V!xO#W!pO#X!pO#[!zO#]!zO(T!lO(UTO(XUO(d!mO(n!sO~O'}!{O~OP]XR]X[]Xa]Xj]Xr]X!Q]X!S]X!]]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X'y]X(`]X(q]X(x]X(y]X~O!g%RX~P(qO_!}O(U#PO(V!}O(W#PO~O_#QO(W#PO(X#PO(Y#QO~Ox#SO!U#TO(a#TO(b#VO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(S;{O(UTO(XUO(`VO(n[O~O![#ZO!]#WO!Y(gP!Y(uP~P+}O!^#cO~P`OPYOQYOSfOd!jOe!iOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(UTO(XUO(`VO(n[O~Op#mO![#iO!|]O#i#lO#j#iO(S;|O!k(rP~P.iO!l#oO(S#nO~O!x#sO!|]O%h#tO~O#k#uO~O!g#vO#k#uO~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!]$_O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(`VO(q$YO(x#|O(y#}O~Oa(eX'y(eX'v(eX!k(eX!Y(eX!_(eX%i(eX!g(eX~P1qO#S$dO#`$eO$Q$eOP(fXR(fX[(fXj(fXr(fX!Q(fX!S(fX!](fX!l(fX!p(fX#R(fX#n(fX#o(fX#p(fX#q(fX#r(fX#s(fX#t(fX#u(fX#v(fX#x(fX#z(fX#{(fX(`(fX(q(fX(x(fX(y(fX!_(fX%i(fX~Oa(fX'y(fX'v(fX!Y(fX!k(fXv(fX!g(fX~P4UO#`$eO~O$]$hO$_$gO$f$mO~OSfO!_$nO$i$oO$k$qO~Oh%VOj%cOk%cOl%cOp%WOr%XOs$tOt$tOz%YO|%ZO!O%[O!S${O!_$|O!i%aO!l$xO#j%bO$W%_O$t%]O$v%^O$y%`O(S$sO(UTO(XUO(`$uO(x$}O(y%POg(]P~O!l%dO~O!S%gO!_%hO(S%fO~O!g%lO~Oa%mO'y%mO~O!Q%qO~P%[O(T!lO~P%[O%n%uO~P%[Oh%VO!l%dO(S%fO(T!lO~Oe%|O!l%dO(S%fO~Oj$RO~O!Q&RO!_&OO!l&QO%j&UO(S%fO(T!lO(UTO(XUO`)VP~O!x#sO~O%s&WO!S)RX!_)RX(S)RX~O(S&XO~Ol!PO!u&^O%j!QO%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO~Od&cOe&bO!x&`O%h&aO%{&_O~P<VOd&fOeyOl!PO!_&eO!u&^O!xxO!|]O%h}O%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO%y!UO~Ob&iO#`&lO%j&gO(T!lO~P=[O!l&mO!u&qO~O!l#oO~O!_XO~Oa%mO'w&yO'y%mO~Oa%mO'w&|O'y%mO~Oa%mO'w'OO'y%mO~O'v]X!Y]Xv]X!k]X&Z]X!_]X%i]X!g]X~P(qO!b']O!c'UO!d'UO(T!lO(UTO(XUO~Os'SO!S'RO!['VO(d'QO!^(hP!^(wP~P@cOn'`O!_'^O(S%fO~Oe'eO!l%dO(S%fO~O!Q&RO!l&QO~Os!nO!S!oO!|;wO#T!pO#U!pO#W!pO#X!pO(T!lO(UTO(XUO(d!mO(n!sO~O!b'kO!c'jO!d'jO#V!pO#['lO#]'lO~PA}Oa%mOh%VO!g#vO!l%dO'y%mO(q'nO~O!p'rO#`'pO~PC]Os!nO!S!oO(UTO(XUO(d!mO(n!sO~O!_XOs(lX!S(lX!b(lX!c(lX!d(lX!|(lX#T(lX#U(lX#V(lX#W(lX#X(lX#[(lX#](lX(T(lX(U(lX(X(lX(d(lX(n(lX~O!c'jO!d'jO(T!lO~PC{O(O'vO(P'vO(Q'xO~O_!}O(U'zO(V!}O(W'zO~O_#QO(W'zO(X'zO(Y#QO~Ov'|O~P%[Ox#SO!U#TO(a#TO(b(PO~O![(RO!Y'VX!Y']X!]'VX!]']X~P+}O!](TO!Y(gX~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!](TO!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(`VO(q$YO(x#|O(y#}O~O!Y(gX~PGvO!Y(YO~O!Y(tX!](tX!g(tX!k(tX(q(tX~O#`(tX#k#dX!^(tX~PIyO#`(ZO!Y(vX!](vX~O!]([O!Y(uX~O!Y(_O~O#`$eO~PIyO!^(`O~P`OR#zO!Q#yO!S#{O!l#xO(`VOP!na[!naj!nar!na!]!na!p!na#R!na#n!na#o!na#p!na#q!na#r!na#s!na#t!na#u!na#v!na#x!na#z!na#{!na(q!na(x!na(y!na~Oa!na'y!na'v!na!Y!na!k!nav!na!_!na%i!na!g!na~PKaO!k(aO~O!g#vO#`(bO(q'nO!](sXa(sX'y(sX~O!k(sX~PM|O!S%gO!_%hO!|]O#i(gO#j(fO(S%fO~O!](hO!k(rX~O!k(jO~O!S%gO!_%hO#j(fO(S%fO~OP(fXR(fX[(fXj(fXr(fX!Q(fX!S(fX!](fX!l(fX!p(fX#R(fX#n(fX#o(fX#p(fX#q(fX#r(fX#s(fX#t(fX#u(fX#v(fX#x(fX#z(fX#{(fX(`(fX(q(fX(x(fX(y(fX~O!g#vO!k(fX~P! jOR(lO!Q(kO!l#xO#S$dO!|!{a!S!{a~O!x!{a%h!{a!_!{a#i!{a#j!{a(S!{a~P!#kO!x(pO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_XO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(S!dO(UTO(XUO(`VO(n[O~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<eO!S${O!_$|O!i=vO!l$xO#j<kO$W%_O$t<gO$v<iO$y%`O(S(tO(UTO(XUO(`$uO(x$}O(y%PO~O#k(vO~O![(xO!k(jP~P%[O(d(zO(n[O~O!S(|O!l#xO(d(zO(n[O~OP;vOQ;vOSfOd=rOe!iOpkOr;vOskOtkOzkO|;vO!O;vO!SWO!WkO!XkO!_!eO!i;yO!lZO!o;vO!p;vO!q;vO!s;zO!u;}O!x!hO$W!kO$n=pO(S)ZO(UTO(XUO(`VO(n[O~O!]$_Oa$qa'y$qa'v$qa!k$qa!Y$qa!_$qa%i$qa!g$qa~Ol)bO~P!&oOh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O%[O!S${O!_$|O!i%aO!l$xO#j%bO$W%_O$t%]O$v%^O$y%`O(S(tO(UTO(XUO(`$uO(x$}O(y%PO~Og(oP~P!+xO!Q)gO!g)fO!_$^X$Z$^X$]$^X$_$^X$f$^X~O!g)fO!_(zX$Z(zX$](zX$_(zX$f(zX~O!Q)gO~P!.RO!Q)gO!_(zX$Z(zX$](zX$_(zX$f(zX~O!_)iO$Z)mO$])hO$_)hO$f)nO~O![)qO~P!)PO$]$hO$_$gO$f)uO~On$zX!Q$zX#S$zX'x$zX(x$zX(y$zX~OgmXg$zXnmX!]mX#`mX~P!/wOx)wO(a)xO(b)zO~On*TO!Q)|O'x)}O(x$}O(y%PO~Og){O~P!0{Og*UO~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<eO!S*WO!_*XO!i=vO!l$xO#j<kO$W%_O$t<gO$v<iO$y%`O(UTO(XUO(`$uO(x$}O(y%PO~O![*[O(S*VO!k(}P~P!1jO#k*^O~O!l*_O~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<eO!S${O!_$|O!i=vO!l$xO#j<kO$W%_O$t<gO$v<iO$y%`O(S*aO(UTO(XUO(`$uO(x$}O(y%PO~O![*dO!Y)OP~P!3iOr*pOs!nO!S*fO!b*nO!c*hO!d*hO!l*_O#[*oO%`*jO(T!lO(UTO(XUO(d!mO~O!^*mO~P!5^O#S$dOn(_X!Q(_X'x(_X(x(_X(y(_X!](_X#`(_X~Og(_X$O(_X~P!6`On*uO#`*tOg(^X!](^X~O!]*vOg(]X~Oj%cOk%cOl%cO(S&XOg(]P~Os*yO~O!l+OO~O(S(tO~Op+TO!S%gO![#iO!_%hO!|]O#i#lO#j#iO(S%fO!k(rP~O!g#vO#k+UO~O!S%gO![+WO!]([O!_%hO(S%fO!Y(uP~Os'YO!S+YO![+XO(UTO(XUO(d(zO~O!^(wP~P!9iO!]+ZOa)SX'y)SX~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(`VO(q$YO(x#|O(y#}O~Oa!ja!]!ja'y!ja'v!ja!Y!ja!k!jav!ja!_!ja%i!ja!g!ja~P!:aOR#zO!Q#yO!S#{O!l#xO(`VOP!ra[!raj!rar!ra!]!ra!p!ra#R!ra#n!ra#o!ra#p!ra#q!ra#r!ra#s!ra#t!ra#u!ra#v!ra#x!ra#z!ra#{!ra(q!ra(x!ra(y!ra~Oa!ra'y!ra'v!ra!Y!ra!k!rav!ra!_!ra%i!ra!g!ra~P!<wOR#zO!Q#yO!S#{O!l#xO(`VOP!ta[!taj!tar!ta!]!ta!p!ta#R!ta#n!ta#o!ta#p!ta#q!ta#r!ta#s!ta#t!ta#u!ta#v!ta#x!ta#z!ta#{!ta(q!ta(x!ta(y!ta~Oa!ta'y!ta'v!ta!Y!ta!k!tav!ta!_!ta%i!ta!g!ta~P!?_Oh%VOn+dO!_'^O%i+cO~O!g+fOa([X!_([X'y([X!]([X~Oa%mO!_XO'y%mO~Oh%VO!l%dO~Oh%VO!l%dO(S%fO~O!g#vO#k(vO~Ob+qO%j+rO(S+nO(UTO(XUO!^)WP~O!]+sO`)VX~O[+wO~O`+xO~O!_&OO(S%fO(T!lO`)VP~Oh%VO#`+}O~Oh%VOn,QO!_$|O~O!_,SO~O!Q,UO!_XO~O%n%uO~O!x,ZO~Oe,`O~Ob,aO(S#nO(UTO(XUO!^)UP~Oe%|O~O%j!QO(S&XO~P=[O[,fO`,eO~OPYOQYOSfOdzOeyOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!iuO!lZO!oYO!pYO!qYO!svO!xxO!|]O$niO%h}O(UTO(XUO(`VO(n[O~O!_!eO!u!gO$W!kO(S!dO~P!F_O`,eOa%mO'y%mO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!x!hO$W!kO$niO(S!dO(UTO(XUO(`VO(n[O~Oa,kOl!OO!uwO%l!OO%m!OO%n!OO~P!HwO!l&mO~O&],qO~O!_,sO~O&n,uO&p,vOP&kaQ&kaS&kaY&kaa&kad&kae&kal&kap&kar&kas&kat&kaz&ka|&ka!O&ka!S&ka!W&ka!X&ka!_&ka!i&ka!l&ka!o&ka!p&ka!q&ka!s&ka!u&ka!x&ka!|&ka$W&ka$n&ka%h&ka%j&ka%l&ka%m&ka%n&ka%q&ka%s&ka%v&ka%w&ka%y&ka&V&ka&]&ka&_&ka&a&ka&c&ka&f&ka&l&ka&r&ka&t&ka&v&ka&x&ka&z&ka'v&ka(S&ka(U&ka(X&ka(`&ka(n&ka!^&ka&d&kab&ka&i&ka~O(S,{O~Oh!eX!]!RX!^!RX!g!RX!g!eX!l!eX#`!RX~O!]!eX!^!eX~P# }O!g-QO#`-POh(iX!]#hX!^#hX!g(iX!l(iX~O!](iX!^(iX~P#!pOh%VO!g-SO!l%dO!]!aX!^!aX~Os!nO!S!oO(UTO(XUO(d!mO~OP;vOQ;vOSfOd=rOe!iOpkOr;vOskOtkOzkO|;vO!O;vO!SWO!WkO!XkO!_!eO!i;yO!lZO!o;vO!p;vO!q;vO!s;zO!u;}O!x!hO$W!kO$n=pO(UTO(XUO(`VO(n[O~O(S<rO~P#$VO!]-WO!^(hX~O!^-YO~O!g-QO#`-PO!]#hX!^#hX~O!]-ZO!^(wX~O!^-]O~O!c-^O!d-^O(T!lO~P##tO!^-aO~P'_On-dO!_'^O~O!Y-iO~Os!{a!b!{a!c!{a!d!{a#T!{a#U!{a#V!{a#W!{a#X!{a#[!{a#]!{a(T!{a(U!{a(X!{a(d!{a(n!{a~P!#kO!p-nO#`-lO~PC]O!c-pO!d-pO(T!lO~PC{Oa%mO#`-lO'y%mO~Oa%mO!g#vO#`-lO'y%mO~Oa%mO!g#vO!p-nO#`-lO'y%mO(q'nO~O(O'vO(P'vO(Q-uO~Ov-vO~O!Y'Va!]'Va~P!:aO![-zO!Y'VX!]'VX~P%[O!](TO!Y(ga~O!Y(ga~PGvO!]([O!Y(ua~O!S%gO![.OO!_%hO(S%fO!Y']X!]']X~O#`.QO!](sa!k(saa(sa'y(sa~O!g#vO~P#,]O!](hO!k(ra~O!S%gO!_%hO#j.UO(S%fO~Op.ZO!S%gO![.WO!_%hO!|]O#i.YO#j.WO(S%fO!]'`X!k'`X~OR._O!l#xO~Oh%VOn.bO!_'^O%i.aO~Oa#ci!]#ci'y#ci'v#ci!Y#ci!k#civ#ci!_#ci%i#ci!g#ci~P!:aOn=|O!Q)|O'x)}O(x$}O(y%PO~O#k#_aa#_a#`#_a'y#_a!]#_a!k#_a!_#_a!Y#_a~P#/XO#k(_XP(_XR(_X[(_Xa(_Xj(_Xr(_X!S(_X!l(_X!p(_X#R(_X#n(_X#o(_X#p(_X#q(_X#r(_X#s(_X#t(_X#u(_X#v(_X#x(_X#z(_X#{(_X'y(_X(`(_X(q(_X!k(_X!Y(_X'v(_Xv(_X!_(_X%i(_X!g(_X~P!6`O!].oO!k(jX~P!:aO!k.rO~O!Y.tO~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O(`VO[#mia#mij#mir#mi!]#mi#R#mi#o#mi#p#mi#q#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'y#mi(q#mi(x#mi(y#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#n#mi~P#2wO#n$OO~P#2wOP$[OR#zOr$aO!Q#yO!S#{O!l#xO!p$[O#n$OO#o$PO#p$PO#q$PO(`VO[#mia#mij#mi!]#mi#R#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'y#mi(q#mi(x#mi(y#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#r#mi~P#5fO#r$QO~P#5fOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO(`VOa#mi!]#mi#x#mi#z#mi#{#mi'y#mi(q#mi(x#mi(y#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#v#mi~P#8TOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO(`VO(y#}Oa#mi!]#mi#z#mi#{#mi'y#mi(q#mi(x#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#x$UO~P#:kO#x#mi~P#:kO#v$SO~P#8TOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO(`VO(x#|O(y#}Oa#mi!]#mi#{#mi'y#mi(q#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#z#mi~P#=aO#z$WO~P#=aOP]XR]X[]Xj]Xr]X!Q]X!S]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(`]X(q]X(x]X(y]X!]]X!^]X~O$O]X~P#@OOP$[OR#zO[<_Oj<SOr<]O!Q#yO!S#{O!l#xO!p$[O#R<SO#n<PO#o<QO#p<QO#q<QO#r<RO#s<SO#t<SO#u<^O#v<TO#x<VO#z<XO#{<YO(`VO(q$YO(x#|O(y#}O~O$O.vO~P#B]O#S$dO#`<`O$Q<`O$O(fX!^(fX~P! jOa'ca!]'ca'y'ca'v'ca!k'ca!Y'cav'ca!_'ca%i'ca!g'ca~P!:aO[#mia#mij#mir#mi!]#mi#R#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'y#mi(q#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O#n$OO#o$PO#p$PO#q$PO(`VO(x#mi(y#mi~P#E_On=|O!Q)|O'x)}O(x$}O(y%POP#miR#mi!S#mi!l#mi!p#mi#n#mi#o#mi#p#mi#q#mi(`#mi~P#E_O!].zOg(oX~P!0{Og.|O~Oa$Pi!]$Pi'y$Pi'v$Pi!Y$Pi!k$Piv$Pi!_$Pi%i$Pi!g$Pi~P!:aO$].}O$_.}O~O$]/OO$_/OO~O!g)fO#`/PO!_$cX$Z$cX$]$cX$_$cX$f$cX~O![/QO~O!_)iO$Z/SO$])hO$_)hO$f/TO~O!]<ZO!^(eX~P#B]O!^/UO~O!g)fO$f(zX~O$f/WO~Ov/XO~P!&oOx)wO(a)xO(b/[O~O!S/_O~O(x$}On%aa!Q%aa'x%aa(y%aa!]%aa#`%aa~Og%aa$O%aa~P#LaO(y%POn%ca!Q%ca'x%ca(x%ca!]%ca#`%ca~Og%ca$O%ca~P#MSO!]fX!gfX!kfX!k$zX(qfX~P!/wO![/hO!]([O(S/gO!Y(uP!Y)OP~P!1jOr*pO!b*nO!c*hO!d*hO!l*_O#[*oO%`*jO(T!lO(UTO(XUO~Os<oO!S/iO![+XO!^*mO(d<nO!^(wP~P#NmO!k/jO~P#/XO!]/kO!g#vO(q'nO!k(}X~O!k/pO~O!S%gO![*[O!_%hO(S%fO!k(}P~O#k/rO~O!Y$zX!]$zX!g%RX~P!/wO!]/sO!Y)OX~P#/XO!g/uO~O!Y/wO~OpkO(S/xO~P.iOh%VOr/}O!g#vO!l%dO(q'nO~O!g+fO~Oa%mO!]0RO'y%mO~O!^0TO~P!5^O!c0UO!d0UO(T!lO~P##tOs!nO!S0VO(UTO(XUO(d!mO~O#[0XO~Og%aa!]%aa#`%aa$O%aa~P!0{Og%ca!]%ca#`%ca$O%ca~P!0{Oj%cOk%cOl%cO(S&XOg'lX!]'lX~O!]*vOg(]a~Og0bO~OR0cO!Q0cO!S0dO#S$dOn}a'x}a(x}a(y}a!]}a#`}a~Og}a$O}a~P$&vO!Q)|O'x)}On$sa(x$sa(y$sa!]$sa#`$sa~Og$sa$O$sa~P$'rO!Q)|O'x)}On$ua(x$ua(y$ua!]$ua#`$ua~Og$ua$O$ua~P$(eO#k0gO~Og%Ta!]%Ta#`%Ta$O%Ta~P!0{On0iO#`0hOg(^a!](^a~O!g#vO~O#k0lO~O!]+ZOa)Sa'y)Sa~OR#zO!Q#yO!S#{O!l#xO(`VOP!ri[!rij!rir!ri!]!ri!p!ri#R!ri#n!ri#o!ri#p!ri#q!ri#r!ri#s!ri#t!ri#u!ri#v!ri#x!ri#z!ri#{!ri(q!ri(x!ri(y!ri~Oa!ri'y!ri'v!ri!Y!ri!k!riv!ri!_!ri%i!ri!g!ri~P$*bOh%VOr%XOs$tOt$tOz%YO|%ZO!O<eO!S${O!_$|O!i=vO!l$xO#j<kO$W%_O$t<gO$v<iO$y%`O(UTO(XUO(`$uO(x$}O(y%PO~Op0uO%]0vO(S0tO~P$,xO!g+fOa([a!_([a'y([a!]([a~O#k0|O~O[]X!]fX!^fX~O!]0}O!^)WX~O!^1PO~O[1QO~Ob1SO(S+nO(UTO(XUO~O!_&OO(S%fO`'tX!]'tX~O!]+sO`)Va~O!k1VO~P!:aO[1YO~O`1ZO~O#`1^O~On1aO!_$|O~O(d(zO!^)TP~Oh%VOn1jO!_1gO%i1iO~O[1tO!]1rO!^)UX~O!^1uO~O`1wOa%mO'y%mO~O(S#nO(UTO(XUO~O#S$dO#`$eO$Q$eOP(fXR(fX[(fXr(fX!Q(fX!S(fX!](fX!l(fX!p(fX#R(fX#n(fX#o(fX#p(fX#q(fX#r(fX#s(fX#t(fX#u(fX#v(fX#x(fX#z(fX#{(fX(`(fX(q(fX(x(fX(y(fX~Oj1zO&Z1{Oa(fX~P$2cOj1zO#`$eO&Z1{O~Oa1}O~P%[Oa2PO~O&d2SOP&biQ&biS&biY&bia&bid&bie&bil&bip&bir&bis&bit&biz&bi|&bi!O&bi!S&bi!W&bi!X&bi!_&bi!i&bi!l&bi!o&bi!p&bi!q&bi!s&bi!u&bi!x&bi!|&bi$W&bi$n&bi%h&bi%j&bi%l&bi%m&bi%n&bi%q&bi%s&bi%v&bi%w&bi%y&bi&V&bi&]&bi&_&bi&a&bi&c&bi&f&bi&l&bi&r&bi&t&bi&v&bi&x&bi&z&bi'v&bi(S&bi(U&bi(X&bi(`&bi(n&bi!^&bib&bi&i&bi~Ob2YO!^2WO&i2XO~P`O!_XO!l2[O~O&p,vOP&kiQ&kiS&kiY&kia&kid&kie&kil&kip&kir&kis&kit&kiz&ki|&ki!O&ki!S&ki!W&ki!X&ki!_&ki!i&ki!l&ki!o&ki!p&ki!q&ki!s&ki!u&ki!x&ki!|&ki$W&ki$n&ki%h&ki%j&ki%l&ki%m&ki%n&ki%q&ki%s&ki%v&ki%w&ki%y&ki&V&ki&]&ki&_&ki&a&ki&c&ki&f&ki&l&ki&r&ki&t&ki&v&ki&x&ki&z&ki'v&ki(S&ki(U&ki(X&ki(`&ki(n&ki!^&ki&d&kib&ki&i&ki~O!Y2bO~O!]!aa!^!aa~P#B]Os!nO!S!oO![2hO(d!mO!]'WX!^'WX~P@cO!]-WO!^(ha~O!]'^X!^'^X~P!9iO!]-ZO!^(wa~O!^2oO~P'_Oa%mO#`2xO'y%mO~Oa%mO!g#vO#`2xO'y%mO~Oa%mO!g#vO!p2|O#`2xO'y%mO(q'nO~Oa%mO'y%mO~P!:aO!]$_Ov$qa~O!Y'Vi!]'Vi~P!:aO!](TO!Y(gi~O!]([O!Y(ui~O!Y(vi!](vi~P!:aO!](si!k(sia(si'y(si~P!:aO#`3OO!](si!k(sia(si'y(si~O!](hO!k(ri~O!S%gO!_%hO!|]O#i3TO#j3SO(S%fO~O!S%gO!_%hO#j3SO(S%fO~On3[O!_'^O%i3ZO~Oh%VOn3[O!_'^O%i3ZO~O#k%aaP%aaR%aa[%aaa%aaj%aar%aa!S%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa'y%aa(`%aa(q%aa!k%aa!Y%aa'v%aav%aa!_%aa%i%aa!g%aa~P#LaO#k%caP%caR%ca[%caa%caj%car%ca!S%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca'y%ca(`%ca(q%ca!k%ca!Y%ca'v%cav%ca!_%ca%i%ca!g%ca~P#MSO#k%aaP%aaR%aa[%aaa%aaj%aar%aa!S%aa!]%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa'y%aa(`%aa(q%aa!k%aa!Y%aa'v%aa#`%aav%aa!_%aa%i%aa!g%aa~P#/XO#k%caP%caR%ca[%caa%caj%car%ca!S%ca!]%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca'y%ca(`%ca(q%ca!k%ca!Y%ca'v%ca#`%cav%ca!_%ca%i%ca!g%ca~P#/XO#k}aP}a[}aa}aj}ar}a!l}a!p}a#R}a#n}a#o}a#p}a#q}a#r}a#s}a#t}a#u}a#v}a#x}a#z}a#{}a'y}a(`}a(q}a!k}a!Y}a'v}av}a!_}a%i}a!g}a~P$&vO#k$saP$saR$sa[$saa$saj$sar$sa!S$sa!l$sa!p$sa#R$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#t$sa#u$sa#v$sa#x$sa#z$sa#{$sa'y$sa(`$sa(q$sa!k$sa!Y$sa'v$sav$sa!_$sa%i$sa!g$sa~P$'rO#k$uaP$uaR$ua[$uaa$uaj$uar$ua!S$ua!l$ua!p$ua#R$ua#n$ua#o$ua#p$ua#q$ua#r$ua#s$ua#t$ua#u$ua#v$ua#x$ua#z$ua#{$ua'y$ua(`$ua(q$ua!k$ua!Y$ua'v$uav$ua!_$ua%i$ua!g$ua~P$(eO#k%TaP%TaR%Ta[%Taa%Taj%Tar%Ta!S%Ta!]%Ta!l%Ta!p%Ta#R%Ta#n%Ta#o%Ta#p%Ta#q%Ta#r%Ta#s%Ta#t%Ta#u%Ta#v%Ta#x%Ta#z%Ta#{%Ta'y%Ta(`%Ta(q%Ta!k%Ta!Y%Ta'v%Ta#`%Tav%Ta!_%Ta%i%Ta!g%Ta~P#/XOa#cq!]#cq'y#cq'v#cq!Y#cq!k#cqv#cq!_#cq%i#cq!g#cq~P!:aO![3dO!]'XX!k'XX~P%[O!].oO!k(ja~O!].oO!k(ja~P!:aO!Y3gO~O$O!na!^!na~PKaO$O!ja!]!ja!^!ja~P#B]O$O!ra!^!ra~P!<wO$O!ta!^!ta~P!?_Og'[X!]'[X~P!+xO!].zOg(oa~OSfO!_3{O$d3|O~O!^4QO~Ov4RO~P#/XOa$mq!]$mq'y$mq'v$mq!Y$mq!k$mqv$mq!_$mq%i$mq!g$mq~P!:aO!Y4TO~P!&oO!S4UO~O!Q)|O'x)}O(y%POn'ha(x'ha!]'ha#`'ha~Og'ha$O'ha~P%,XO!Q)|O'x)}On'ja(x'ja(y'ja!]'ja#`'ja~Og'ja$O'ja~P%,zO(q$YO~P#/XO!YfX!Y$zX!]fX!]$zX!g%RX#`fX~P!/wO(S<xO~P!1jO!S%gO![4XO!_%hO(S%fO!]'dX!k'dX~O!]/kO!k(}a~O!]/kO!g#vO!k(}a~O!]/kO!g#vO(q'nO!k(}a~Og$|i!]$|i#`$|i$O$|i~P!0{O![4aO!Y'fX!]'fX~P!3iO!]/sO!Y)Oa~O!]/sO!Y)Oa~P#/XOP]XR]X[]Xj]Xr]X!Q]X!S]X!Y]X!]]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(`]X(q]X(x]X(y]X~Oj%YX!g%YX~P%0kOj4fO!g#vO~Oh%VO!g#vO!l%dO~Oh%VOr4kO!l%dO(q'nO~Or4pO!g#vO(q'nO~Os!nO!S4qO(UTO(XUO(d!mO~O(x$}On%ai!Q%ai'x%ai(y%ai!]%ai#`%ai~Og%ai$O%ai~P%4[O(y%POn%ci!Q%ci'x%ci(x%ci!]%ci#`%ci~Og%ci$O%ci~P%4}Og(^i!](^i~P!0{O#`4wOg(^i!](^i~P!0{O!k4zO~Oa$oq!]$oq'y$oq'v$oq!Y$oq!k$oqv$oq!_$oq%i$oq!g$oq~P!:aO!Y5QO~O!]5RO!_)PX~P#/XOa$zX!_$zX%^]X'y$zX!]$zX~P!/wO%^5UOaoXnoX!QoX!_oX'xoX'yoX(xoX(yoX!]oX~Op5VO(S#nO~O%^5UO~Ob5]O%j5^O(S+nO(UTO(XUO!]'sX!^'sX~O!]0}O!^)Wa~O[5bO~O`5cO~Oa%mO'y%mO~P#/XO!]5kO#`5mO!^)TX~O!^5nO~Or5tOs!nO!S*fO!b!yO!c!vO!d!vO!|;wO#T!pO#U!pO#V!pO#W!pO#X!pO#[5sO#]!zO(T!lO(UTO(XUO(d!mO(n!sO~O!^5rO~P%:YOn5yO!_1gO%i5xO~Oh%VOn5yO!_1gO%i5xO~Ob6QO(S#nO(UTO(XUO!]'rX!^'rX~O!]1rO!^)Ua~O(UTO(XUO(d6SO~O`6WO~Oj6ZO&Z6[O~PM|O!k6]O~P%[Oa6_O~Oa6_O~P%[Ob2YO!^6dO&i2XO~P`O!g6fO~O!g6hOh(ii!](ii!^(ii!g(ii!l(iir(ii(q(ii~O!]#hi!^#hi~P#B]O#`6iO!]#hi!^#hi~O!]!ai!^!ai~P#B]Oa%mO#`6rO'y%mO~Oa%mO!g#vO#`6rO'y%mO~O!](sq!k(sqa(sq'y(sq~P!:aO!](hO!k(rq~O!S%gO!_%hO#j6yO(S%fO~O!_'^O%i6|O~On7QO!_'^O%i6|O~O#k'haP'haR'ha['haa'haj'har'ha!S'ha!l'ha!p'ha#R'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#t'ha#u'ha#v'ha#x'ha#z'ha#{'ha'y'ha(`'ha(q'ha!k'ha!Y'ha'v'hav'ha!_'ha%i'ha!g'ha~P%,XO#k'jaP'jaR'ja['jaa'jaj'jar'ja!S'ja!l'ja!p'ja#R'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#v'ja#x'ja#z'ja#{'ja'y'ja(`'ja(q'ja!k'ja!Y'ja'v'jav'ja!_'ja%i'ja!g'ja~P%,zO#k$|iP$|iR$|i[$|ia$|ij$|ir$|i!S$|i!]$|i!l$|i!p$|i#R$|i#n$|i#o$|i#p$|i#q$|i#r$|i#s$|i#t$|i#u$|i#v$|i#x$|i#z$|i#{$|i'y$|i(`$|i(q$|i!k$|i!Y$|i'v$|i#`$|iv$|i!_$|i%i$|i!g$|i~P#/XO#k%aiP%aiR%ai[%aia%aij%air%ai!S%ai!l%ai!p%ai#R%ai#n%ai#o%ai#p%ai#q%ai#r%ai#s%ai#t%ai#u%ai#v%ai#x%ai#z%ai#{%ai'y%ai(`%ai(q%ai!k%ai!Y%ai'v%aiv%ai!_%ai%i%ai!g%ai~P%4[O#k%ciP%ciR%ci[%cia%cij%cir%ci!S%ci!l%ci!p%ci#R%ci#n%ci#o%ci#p%ci#q%ci#r%ci#s%ci#t%ci#u%ci#v%ci#x%ci#z%ci#{%ci'y%ci(`%ci(q%ci!k%ci!Y%ci'v%civ%ci!_%ci%i%ci!g%ci~P%4}O!]'Xa!k'Xa~P!:aO!].oO!k(ji~O$O#ci!]#ci!^#ci~P#B]OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O(`VO[#mij#mir#mi#R#mi#o#mi#p#mi#q#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(q#mi(x#mi(y#mi!]#mi!^#mi~O#n#mi~P%MXO#n<PO~P%MXOP$[OR#zOr<]O!Q#yO!S#{O!l#xO!p$[O#n<PO#o<QO#p<QO#q<QO(`VO[#mij#mi#R#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(q#mi(x#mi(y#mi!]#mi!^#mi~O#r#mi~P& aO#r<RO~P& aOP$[OR#zO[<_Oj<SOr<]O!Q#yO!S#{O!l#xO!p$[O#R<SO#n<PO#o<QO#p<QO#q<QO#r<RO#s<SO#t<SO#u<^O(`VO#x#mi#z#mi#{#mi$O#mi(q#mi(x#mi(y#mi!]#mi!^#mi~O#v#mi~P&#iOP$[OR#zO[<_Oj<SOr<]O!Q#yO!S#{O!l#xO!p$[O#R<SO#n<PO#o<QO#p<QO#q<QO#r<RO#s<SO#t<SO#u<^O#v<TO(`VO(y#}O#z#mi#{#mi$O#mi(q#mi(x#mi!]#mi!^#mi~O#x<VO~P&%jO#x#mi~P&%jO#v<TO~P&#iOP$[OR#zO[<_Oj<SOr<]O!Q#yO!S#{O!l#xO!p$[O#R<SO#n<PO#o<QO#p<QO#q<QO#r<RO#s<SO#t<SO#u<^O#v<TO#x<VO(`VO(x#|O(y#}O#{#mi$O#mi(q#mi!]#mi!^#mi~O#z#mi~P&'yO#z<XO~P&'yOa#|y!]#|y'y#|y'v#|y!Y#|y!k#|yv#|y!_#|y%i#|y!g#|y~P!:aO[#mij#mir#mi#R#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(q#mi!]#mi!^#mi~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O#n<PO#o<QO#p<QO#q<QO(`VO(x#mi(y#mi~P&*uOn=}O!Q)|O'x)}O(x$}O(y%POP#miR#mi!S#mi!l#mi!p#mi#n#mi#o#mi#p#mi#q#mi(`#mi~P&*uO#S$dOP(_XR(_X[(_Xj(_Xn(_Xr(_X!Q(_X!S(_X!l(_X!p(_X#R(_X#n(_X#o(_X#p(_X#q(_X#r(_X#s(_X#t(_X#u(_X#v(_X#x(_X#z(_X#{(_X$O(_X'x(_X(`(_X(q(_X(x(_X(y(_X!](_X!^(_X~O$O$Pi!]$Pi!^$Pi~P#B]O$O!ri!^!ri~P$*bOg'[a!]'[a~P!0{O!^7dO~O!]'ca!^'ca~P#B]O!Y7eO~P#/XO!g#vO(q'nO!]'da!k'da~O!]/kO!k(}i~O!]/kO!g#vO!k(}i~Og$|q!]$|q#`$|q$O$|q~P!0{O!Y'fa!]'fa~P#/XO!g7lO~O!]/sO!Y)Oi~P#/XO!]/sO!Y)Oi~O!Y7oO~Oh%VOr7tO!l%dO(q'nO~Oj7vO!g#vO~Or7yO!g#vO(q'nO~O!Q)|O'x)}O(y%POn'ia(x'ia!]'ia#`'ia~Og'ia$O'ia~P&3vO!Q)|O'x)}On'ka(x'ka(y'ka!]'ka#`'ka~Og'ka$O'ka~P&4iO!Y7{O~Og%Oq!]%Oq#`%Oq$O%Oq~P!0{Og(^q!](^q~P!0{O#`7|Og(^q!](^q~P!0{Oa$oy!]$oy'y$oy'v$oy!Y$oy!k$oyv$oy!_$oy%i$oy!g$oy~P!:aO!g6hO~O!]5RO!_)Pa~O!_'^OP$TaR$Ta[$Taj$Tar$Ta!Q$Ta!S$Ta!]$Ta!l$Ta!p$Ta#R$Ta#n$Ta#o$Ta#p$Ta#q$Ta#r$Ta#s$Ta#t$Ta#u$Ta#v$Ta#x$Ta#z$Ta#{$Ta(`$Ta(q$Ta(x$Ta(y$Ta~O%i6|O~P&7ZO%^8QOa%[i!_%[i'y%[i!]%[i~Oa#cy!]#cy'y#cy'v#cy!Y#cy!k#cyv#cy!_#cy%i#cy!g#cy~P!:aO[8SO~Ob8UO(S+nO(UTO(XUO~O!]0}O!^)Wi~O`8YO~O(d(zO!]'oX!^'oX~O!]5kO!^)Ta~O!^8cO~P%:YO(n!sO~P$${O#[8dO~O!_1gO~O!_1gO%i8fO~On8iO!_1gO%i8fO~O[8nO!]'ra!^'ra~O!]1rO!^)Ui~O!k8rO~O!k8sO~O!k8vO~O!k8vO~P%[Oa8xO~O!g8yO~O!k8zO~O!](vi!^(vi~P#B]Oa%mO#`9SO'y%mO~O!](sy!k(sya(sy'y(sy~P!:aO!](hO!k(ry~O%i9VO~P&7ZO!_'^O%i9VO~O#k$|qP$|qR$|q[$|qa$|qj$|qr$|q!S$|q!]$|q!l$|q!p$|q#R$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#t$|q#u$|q#v$|q#x$|q#z$|q#{$|q'y$|q(`$|q(q$|q!k$|q!Y$|q'v$|q#`$|qv$|q!_$|q%i$|q!g$|q~P#/XO#k'iaP'iaR'ia['iaa'iaj'iar'ia!S'ia!l'ia!p'ia#R'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#v'ia#x'ia#z'ia#{'ia'y'ia(`'ia(q'ia!k'ia!Y'ia'v'iav'ia!_'ia%i'ia!g'ia~P&3vO#k'kaP'kaR'ka['kaa'kaj'kar'ka!S'ka!l'ka!p'ka#R'ka#n'ka#o'ka#p'ka#q'ka#r'ka#s'ka#t'ka#u'ka#v'ka#x'ka#z'ka#{'ka'y'ka(`'ka(q'ka!k'ka!Y'ka'v'kav'ka!_'ka%i'ka!g'ka~P&4iO#k%OqP%OqR%Oq[%Oqa%Oqj%Oqr%Oq!S%Oq!]%Oq!l%Oq!p%Oq#R%Oq#n%Oq#o%Oq#p%Oq#q%Oq#r%Oq#s%Oq#t%Oq#u%Oq#v%Oq#x%Oq#z%Oq#{%Oq'y%Oq(`%Oq(q%Oq!k%Oq!Y%Oq'v%Oq#`%Oqv%Oq!_%Oq%i%Oq!g%Oq~P#/XO!]'Xi!k'Xi~P!:aO$O#cq!]#cq!^#cq~P#B]O(x$}OP%aaR%aa[%aaj%aar%aa!S%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa$O%aa(`%aa(q%aa!]%aa!^%aa~On%aa!Q%aa'x%aa(y%aa~P&HnO(y%POP%caR%ca[%caj%car%ca!S%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca$O%ca(`%ca(q%ca!]%ca!^%ca~On%ca!Q%ca'x%ca(x%ca~P&JuOn=}O!Q)|O'x)}O(y%PO~P&HnOn=}O!Q)|O'x)}O(x$}O~P&JuOR0cO!Q0cO!S0dO#S$dOP}a[}aj}an}ar}a!l}a!p}a#R}a#n}a#o}a#p}a#q}a#r}a#s}a#t}a#u}a#v}a#x}a#z}a#{}a$O}a'x}a(`}a(q}a(x}a(y}a!]}a!^}a~O!Q)|O'x)}OP$saR$sa[$saj$san$sar$sa!S$sa!l$sa!p$sa#R$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#t$sa#u$sa#v$sa#x$sa#z$sa#{$sa$O$sa(`$sa(q$sa(x$sa(y$sa!]$sa!^$sa~O!Q)|O'x)}OP$uaR$ua[$uaj$uan$uar$ua!S$ua!l$ua!p$ua#R$ua#n$ua#o$ua#p$ua#q$ua#r$ua#s$ua#t$ua#u$ua#v$ua#x$ua#z$ua#{$ua$O$ua(`$ua(q$ua(x$ua(y$ua!]$ua!^$ua~On=}O!Q)|O'x)}O(x$}O(y%PO~OP%TaR%Ta[%Taj%Tar%Ta!S%Ta!l%Ta!p%Ta#R%Ta#n%Ta#o%Ta#p%Ta#q%Ta#r%Ta#s%Ta#t%Ta#u%Ta#v%Ta#x%Ta#z%Ta#{%Ta$O%Ta(`%Ta(q%Ta!]%Ta!^%Ta~P'%zO$O$mq!]$mq!^$mq~P#B]O$O$oq!]$oq!^$oq~P#B]O!^9dO~O$O9eO~P!0{O!g#vO!]'di!k'di~O!g#vO(q'nO!]'di!k'di~O!]/kO!k(}q~O!Y'fi!]'fi~P#/XO!]/sO!Y)Oq~Or9lO!g#vO(q'nO~O[9nO!Y9mO~P#/XO!Y9mO~Oj9tO!g#vO~Og(^y!](^y~P!0{O!]'ma!_'ma~P#/XOa%[q!_%[q'y%[q!]%[q~P#/XO[9yO~O!]0}O!^)Wq~O#`9}O!]'oa!^'oa~O!]5kO!^)Ti~P#B]O!S:PO~O!_1gO%i:SO~O(UTO(XUO(d:XO~O!]1rO!^)Uq~O!k:[O~O!k:]O~O!k:^O~O!k:^O~P%[O#`:aO!]#hy!^#hy~O!]#hy!^#hy~P#B]O%i:fO~P&7ZO!_'^O%i:fO~O$O#|y!]#|y!^#|y~P#B]OP$|iR$|i[$|ij$|ir$|i!S$|i!l$|i!p$|i#R$|i#n$|i#o$|i#p$|i#q$|i#r$|i#s$|i#t$|i#u$|i#v$|i#x$|i#z$|i#{$|i$O$|i(`$|i(q$|i!]$|i!^$|i~P'%zO!Q)|O'x)}O(y%POP'haR'ha['haj'han'har'ha!S'ha!l'ha!p'ha#R'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#t'ha#u'ha#v'ha#x'ha#z'ha#{'ha$O'ha(`'ha(q'ha(x'ha!]'ha!^'ha~O!Q)|O'x)}OP'jaR'ja['jaj'jan'jar'ja!S'ja!l'ja!p'ja#R'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#v'ja#x'ja#z'ja#{'ja$O'ja(`'ja(q'ja(x'ja(y'ja!]'ja!^'ja~O(x$}OP%aiR%ai[%aij%ain%air%ai!Q%ai!S%ai!l%ai!p%ai#R%ai#n%ai#o%ai#p%ai#q%ai#r%ai#s%ai#t%ai#u%ai#v%ai#x%ai#z%ai#{%ai$O%ai'x%ai(`%ai(q%ai(y%ai!]%ai!^%ai~O(y%POP%ciR%ci[%cij%cin%cir%ci!Q%ci!S%ci!l%ci!p%ci#R%ci#n%ci#o%ci#p%ci#q%ci#r%ci#s%ci#t%ci#u%ci#v%ci#x%ci#z%ci#{%ci$O%ci'x%ci(`%ci(q%ci(x%ci!]%ci!^%ci~O$O$oy!]$oy!^$oy~P#B]O$O#cy!]#cy!^#cy~P#B]O!g#vO!]'dq!k'dq~O!]/kO!k(}y~O!Y'fq!]'fq~P#/XOr:pO!g#vO(q'nO~O[:tO!Y:sO~P#/XO!Y:sO~Og(^!R!](^!R~P!0{Oa%[y!_%[y'y%[y!]%[y~P#/XO!]0}O!^)Wy~O!]5kO!^)Tq~O(S:zO~O!_1gO%i:}O~O!k;QO~O%i;VO~P&7ZOP$|qR$|q[$|qj$|qr$|q!S$|q!l$|q!p$|q#R$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#t$|q#u$|q#v$|q#x$|q#z$|q#{$|q$O$|q(`$|q(q$|q!]$|q!^$|q~P'%zO!Q)|O'x)}O(y%POP'iaR'ia['iaj'ian'iar'ia!S'ia!l'ia!p'ia#R'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#v'ia#x'ia#z'ia#{'ia$O'ia(`'ia(q'ia(x'ia!]'ia!^'ia~O!Q)|O'x)}OP'kaR'ka['kaj'kan'kar'ka!S'ka!l'ka!p'ka#R'ka#n'ka#o'ka#p'ka#q'ka#r'ka#s'ka#t'ka#u'ka#v'ka#x'ka#z'ka#{'ka$O'ka(`'ka(q'ka(x'ka(y'ka!]'ka!^'ka~OP%OqR%Oq[%Oqj%Oqr%Oq!S%Oq!l%Oq!p%Oq#R%Oq#n%Oq#o%Oq#p%Oq#q%Oq#r%Oq#s%Oq#t%Oq#u%Oq#v%Oq#x%Oq#z%Oq#{%Oq$O%Oq(`%Oq(q%Oq!]%Oq!^%Oq~P'%zOg%e!Z!]%e!Z#`%e!Z$O%e!Z~P!0{O!Y;ZO~P#/XOr;[O!g#vO(q'nO~O[;^O!Y;ZO~P#/XO!]'oq!^'oq~P#B]O!]#h!Z!^#h!Z~P#B]O#k%e!ZP%e!ZR%e!Z[%e!Za%e!Zj%e!Zr%e!Z!S%e!Z!]%e!Z!l%e!Z!p%e!Z#R%e!Z#n%e!Z#o%e!Z#p%e!Z#q%e!Z#r%e!Z#s%e!Z#t%e!Z#u%e!Z#v%e!Z#x%e!Z#z%e!Z#{%e!Z'y%e!Z(`%e!Z(q%e!Z!k%e!Z!Y%e!Z'v%e!Z#`%e!Zv%e!Z!_%e!Z%i%e!Z!g%e!Z~P#/XOr;fO!g#vO(q'nO~O!Y;gO~P#/XOr;nO!g#vO(q'nO~O!Y;oO~P#/XOP%e!ZR%e!Z[%e!Zj%e!Zr%e!Z!S%e!Z!l%e!Z!p%e!Z#R%e!Z#n%e!Z#o%e!Z#p%e!Z#q%e!Z#r%e!Z#s%e!Z#t%e!Z#u%e!Z#v%e!Z#x%e!Z#z%e!Z#{%e!Z$O%e!Z(`%e!Z(q%e!Z!]%e!Z!^%e!Z~P'%zOr;rO!g#vO(q'nO~Ov(eX~P1qO!Q%qO~P!)PO(T!lO~P!)PO!YfX!]fX#`fX~P%0kOP]XR]X[]Xj]Xr]X!Q]X!S]X!]]X!]fX!l]X!p]X#R]X#S]X#`]X#`fX#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(`]X(q]X(x]X(y]X~O!gfX!k]X!kfX(qfX~P'JsOP;vOQ;vOSfOd=rOe!iOpkOr;vOskOtkOzkO|;vO!O;vO!SWO!WkO!XkO!_XO!i;yO!lZO!o;vO!p;vO!q;vO!s;zO!u;}O!x!hO$W!kO$n=pO(S)ZO(UTO(XUO(`VO(n[O~O!]<ZO!^$qa~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<fO!S${O!_$|O!i=wO!l$xO#j<lO$W%_O$t<hO$v<jO$y%`O(S(tO(UTO(XUO(`$uO(x$}O(y%PO~Ol)bO~P( iOr!eX(q!eX~P# }Or(iX(q(iX~P#!pO!^]X!^fX~P'JsO!YfX!Y$zX!]fX!]$zX#`fX~P!/wO#k<OO~O!g#vO#k<OO~O#`<`O~Oj<SO~O#`<pO!](vX!^(vX~O#`<`O!](tX!^(tX~O#k<qO~Og<sO~P!0{O#k<yO~O#k<zO~O!g#vO#k<{O~O!g#vO#k<qO~O$O<|O~P#B]O#k<}O~O#k=OO~O#k=TO~O#k=UO~O#k=VO~O#k=WO~O$O=XO~P!0{O$O=YO~P!0{Ok#S#T#U#W#X#[#i#j#u$n$t$v$y%]%^%h%i%j%q%s%v%w%y%{~'}T#o!X'{(T#ps#n#qr!Q'|$]'|(S$_(d~\",\n    goto: \"$8g)[PPPPPP)]PP)`P)qP+R/WPPPP6bPP6xPP<pPPP@dP@zP@zPPP@zPCSP@zP@zP@zPCWPC]PCzPHtPPPHxPPPPHxK{PPPLRLsPHxPHxPP! RHxPPPHxPHxP!#YHxP!&p!'u!(OP!(r!(v!(r!,TPPPPPPP!,t!'uPP!-U!.vP!2SHxHx!2X!5e!:R!:R!>QPPP!>YHxPPPPPPPPP!AiP!BvPPHx!DXPHxPHxHxHxHxHxPHx!EkP!HuP!K{P!LP!LZ!L_!L_P!HrP!Lc!LcP# iP# mHxPHx# s#$xCW@zP@zP@z@zP#&V@z@z#(i@z#+a@z#-m@z@z#.]#0q#0q#0v#1P#0q#1[PP#0qP@z#1t@z#5s@z@z6bPPP#9xPPP#:c#:cP#:cP#:y#:cPP#;PP#:vP#:v#;d#:v#<O#<U#<X)`#<[)`P#<c#<c#<cP)`P)`P)`P)`PP)`P#<i#<lP#<l)`P#<pP#<sP)`P)`P)`P)`P)`P)`)`PP#<y#=P#=[#=b#=h#=n#=t#>S#>Y#>d#>j#>t#>z#?[#?b#@S#@f#@l#@r#AQ#Ag#C[#Cj#Cq#E]#Ek#G]#Gk#Gq#Gw#G}#HX#H_#He#Ho#IR#IXPPPPPPPPPPP#I_PPPPPPP#JS#MZ#Ns#Nz$ SPPP$&nP$&w$)p$0Z$0^$0a$1`$1c$1j$1rP$1x$1{P$2i$2m$3e$4s$4x$5`PP$5e$5k$5o$5r$5v$5z$6v$7_$7v$7z$7}$8Q$8W$8Z$8_$8cR!|RoqOXst!Z#d%l&p&r&s&u,n,s2S2VY!vQ'^-`1g5qQ%svQ%{yQ&S|Q&h!VS'U!e-WQ'd!iS'j!r!yU*h$|*X*lQ+l%|Q+y&UQ,_&bQ-^']Q-h'eQ-p'kQ0U*nQ1q,`R<m;z%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y,k,n,s-d-l-z.Q.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3d4q5y6Z6[6_6r8i8x9SS#q];w!r)]$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sU*{%[<e<fQ+q&OQ,a&eQ,h&mQ0r+dQ0w+fQ1S+rQ1y,fQ3W.bQ5V0vQ5]0}Q6Q1rQ7O3[Q8U5^R9Y7Q'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=s!S!nQ!r!v!y!z$|'U']'^'j'k'l*h*l*n*o-W-^-`-p0U0X1g5q5s%[$ti#v$b$c$d$x${%O%Q%]%^%b)w*P*R*T*W*^*d*t*u+c+f+},Q.a.z/_/h/r/s/u0Y0[0g0h0i1^1a1i3Z4U4V4a4f4w5R5U5x6|7l7v7|8Q8f9V9e9n9t:S:f:t:};V;^<^<_<a<b<c<d<g<h<i<j<k<l<t<u<v<w<y<z<}=O=P=Q=R=S=T=U=X=Y=p=x=y=|=}Q&V|Q'S!eS'Y%h-ZQ+q&OQ,a&eQ0f+OQ1S+rQ1X+xQ1x,eQ1y,fQ5]0}Q5f1ZQ6Q1rQ6T1tQ6U1wQ8U5^Q8X5cQ8q6WQ9|8YQ:Y8nR<o*XrnOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VR,c&i&z^OPXYstuvwz!Z!`!g!j!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=r=s[#]WZ#W#Z'V(R!b%im#h#i#l$x%d%g([(f(g(h*W*[*_+W+X+Z,j-Q.O.U.V.W.Y/h/k2[3S3T4X6h6yQ%vxQ%zyS&P|&UQ&]!TQ'a!hQ'c!iQ(o#sS+k%{%|Q+o&OQ,Y&`Q,^&bS-g'd'eQ.d(pQ0{+lQ1R+rQ1T+sQ1W+wQ1l,ZS1p,_,`Q2t-hQ5[0}Q5`1QQ5e1YQ6P1qQ8T5^Q8W5bQ9x8SR:w9y!U$zi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y!^%xy!i!u%z%{%|'T'c'd'e'i's*g+k+l-T-g-h-o/{0O0{2m2t2{4i4j4m7s9pQ+e%vQ,O&YQ,R&ZQ,]&bQ.c(oQ1k,YU1o,^,_,`Q3].dQ5z1lS6O1p1qQ8m6P#f=t#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}o=u<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=YW%Ti%V*v=pS&Y!Q&gQ&Z!RQ&[!SQ+S%cR+|&W%]%Si#v$b$c$d$x${%O%Q%]%^%b)w*P*R*T*W*^*d*t*u+c+f+},Q.a.z/_/h/r/s/u0Y0[0g0h0i1^1a1i3Z4U4V4a4f4w5R5U5x6|7l7v7|8Q8f9V9e9n9t:S:f:t:};V;^<^<_<a<b<c<d<g<h<i<j<k<l<t<u<v<w<y<z<}=O=P=Q=R=S=T=U=X=Y=p=x=y=|=}T)x$u)yV*{%[<e<fW'Y!e%h*X-ZS({#y#zQ+`%qQ+v&RS.](k(lQ1b,SQ4x0cR8^5k'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=s$i$^c#Y#e%p%r%t(Q(W(r(w)P)Q)R)S)T)U)V)W)X)Y)[)^)`)e)o+a+u-U-s-x-}.P.n.q.u.w.x.y/]0j2c2f2v2}3c3h3i3j3k3l3m3n3o3p3q3r3s3t3w3x4P5O5Y6k6q6v7V7W7a7b8`8|9Q9[9b9c:c:y;R;x=gT#TV#U'RkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sQ'W!eR2i-W!W!nQ!e!r!v!y!z$|'U']'^'j'k'l*X*h*l*n*o-W-^-`-p0U0X1g5q5sR1d,UnqOXst!Z#d%l&p&r&s&u,n,s2S2VQ&w!^Q't!xS(q#u<OQ+i%yQ,W&]Q,X&_Q-e'bQ-r'mS.m(v<qS0k+U<{Q0y+jQ1f,VQ2Z,uQ2],vQ2e-RQ2r-fQ2u-jS5P0l=VQ5W0zS5Z0|=WQ6j2gQ6n2sQ6s2zQ8R5XQ8}6lQ9O6oQ9R6tR:`8z$d$]c#Y#e%r%t(Q(W(r(w)P)Q)R)S)T)U)V)W)X)Y)[)^)`)e)o+a+u-U-s-x-}.P.n.q.u.x.y/]0j2c2f2v2}3c3h3i3j3k3l3m3n3o3p3q3r3s3t3w3x4P5O5Y6k6q6v7V7W7a7b8`8|9Q9[9b9c:c:y;R;x=gS(m#p'gQ(}#zS+_%p.wS.^(l(nR3U._'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sS#q];wQ&r!XQ&s!YQ&u![Q&v!]R2R,qQ'_!hQ+b%vQ-c'aS.`(o+eQ2p-bW3Y.c.d0q0sQ6m2qW6z3V3X3]5TU9U6{6}7PU:e9W9X9ZS;T:d:gQ;b;UR;j;cU!wQ'^-`T5o1g5q!Q_OXZ`st!V!Z#d#h%d%l&g&i&p&r&s&u(h,n,s.V2S2V]!pQ!r'^-`1g5qT#q];w%^{OPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SS({#y#zS.](k(l!s=^$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sU$fd)],hS(n#p'gU*s%R(u3vU0e*z.i7]Q5T0rQ6{3WQ9X7OR:g9Ym!tQ!r!v!y!z'^'j'k'l-`-p1g5q5sQ'r!uS(d#g1|S-n'i'uQ/n*ZQ/{*gQ2|-qQ4]/oQ4i/}Q4j0OQ4o0WQ7h4WS7s4k4mS7w4p4rQ9g7iQ9k7oQ9p7tQ9u7yS:o9l9mS;Y:p:sS;e;Z;[S;m;f;gS;q;n;oR;t;rQ#wbQ'q!uS(c#g1|S(e#m+TQ+V%eQ+g%wQ+m%}U-m'i'r'uQ.R(dQ/m*ZQ/|*gQ0P*iQ0x+hQ1m,[S2y-n-qQ3R.ZS4[/n/oQ4e/yS4h/{0WQ4l0QQ5|1nQ6u2|Q7g4WQ7k4]U7r4i4o4rQ7u4nQ8k5}S9f7h7iQ9j7oQ9r7wQ9s7xQ:V8lQ:m9gS:n9k9mQ:v9uQ;P:WS;X:o:sS;d;Y;ZS;l;e;gS;p;m;oQ;s;qQ;u;tQ=a=[Q=l=eR=m=fV!wQ'^-`%^aOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SS#wz!j!r=Z$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sR=a=r%^bOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SQ%ej!^%wy!i!u%z%{%|'T'c'd'e'i's*g+k+l-T-g-h-o/{0O0{2m2t2{4i4j4m7s9pS%}z!jQ+h%xQ,[&bW1n,],^,_,`U5}1o1p1qS8l6O6PQ:W8m!r=[$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sQ=e=qR=f=r%QeOPXYstuvw!Z!`!g!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&p&r&s&u&y'R'`'p(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SY#bWZ#W#Z(R!b%im#h#i#l$x%d%g([(f(g(h*W*[*_+W+X+Z,j-Q.O.U.V.W.Y/h/k2[3S3T4X6h6yQ,i&m!p=]$Z$n)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sR=`'VU'Z!e%h*XR2k-Z%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y,k,n,s-d-l-z.Q.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3d4q5y6Z6[6_6r8i8x9S!r)]$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sQ,h&mQ0r+dQ3W.bQ7O3[R9Y7Q!b$Tc#Y%p(Q(W(r(w)X)Y)^)e+u-s-x-}.P.n.q/]0j2v2}3c3s5O5Y6q6v7V9Q:c;x!P<U)[)o-U.w2c2f3h3q3r3w4P6k7W7a7b8`8|9[9b9c:y;R=g!f$Vc#Y%p(Q(W(r(w)U)V)X)Y)^)e+u-s-x-}.P.n.q/]0j2v2}3c3s5O5Y6q6v7V9Q:c;x!T<W)[)o-U.w2c2f3h3n3o3q3r3w4P6k7W7a7b8`8|9[9b9c:y;R=g!^$Zc#Y%p(Q(W(r(w)^)e+u-s-x-}.P.n.q/]0j2v2}3c3s5O5Y6q6v7V9Q:c;xQ4V/fz=s)[)o-U.w2c2f3h3w4P6k7W7a7b8`8|9[9b9c:y;R=gQ=x=zR=y={'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sS$oh$pR3|/P'XgOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/P/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sT$kf$qQ$ifS)h$l)lR)t$qT$jf$qT)j$l)l'XhOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/P/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sT$oh$pQ$rhR)s$p%^jOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9S!s=q$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=s#glOPXZst!Z!`!o#S#d#o#{$n%l&i&l&m&p&r&s&u&y'R'`(|)q*f+Y+d,k,n,s-d.b/Q/i0V0d1j1z1{1}2P2S2V2X3[3{4q5y6Z6[6_7Q8i8x!U%Ri$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y#f(u#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}Q+P%`Q/^)|o3v<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=Y!U$yi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=yQ*`$zU*i$|*X*lQ+Q%aQ0Q*j#f=c#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}n=d<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=YQ=h=tQ=i=uQ=j=vR=k=w!U%Ri$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y#f(u#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}o3v<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=YnoOXst!Z#d%l&p&r&s&u,n,s2S2VS*c${*WQ,|&|Q,}'OR4`/s%[%Si#v$b$c$d$x${%O%Q%]%^%b)w*P*R*T*W*^*d*t*u+c+f+},Q.a.z/_/h/r/s/u0Y0[0g0h0i1^1a1i3Z4U4V4a4f4w5R5U5x6|7l7v7|8Q8f9V9e9n9t:S:f:t:};V;^<^<_<a<b<c<d<g<h<i<j<k<l<t<u<v<w<y<z<}=O=P=Q=R=S=T=U=X=Y=p=x=y=|=}Q,P&ZQ1`,RQ5i1_R8]5jV*k$|*X*lU*k$|*X*lT5p1g5qS/y*f/iQ4n0VT7x4q:PQ+g%wQ0P*iQ0x+hQ1m,[Q5|1nQ8k5}Q:V8lR;P:W!U%Oi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=yx*P$v)c*Q*r+R/q0^0_3y4^4{4|4}7f7z9v:l=b=n=oS0Y*q0Z#f<a#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}n<b<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=Y!d<t(s)a*Y*b.e.h.l/Y/f/v0p1]3`4S4_4c5h7R7U7m7p7}8P9i9q9w:q:u;W;];h=z={`<u3u7X7[7`9]:h:k;kS=P.g3aT=Q7Z9`!U%Qi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y|*R$v)c*S*q+R/b/q0^0_3y4^4s4{4|4}7f7z9v:l=b=n=oS0[*r0]#f<c#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}n<d<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=Y!h<v(s)a*Y*b.f.g.l/Y/f/v0p1]3^3`4S4_4c5h7R7S7U7m7p7}8P9i9q9w:q:u;W;];h=z={d<w3u7Y7Z7`9]9^:h:i:k;kS=R.h3bT=S7[9arnOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VQ&d!UR,k&mrnOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VR&d!UQ,T&[R1[+|snOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VQ1h,YS5w1k1lU8e5u5v5zS:R8g8hS:{:Q:TQ;_:|R;i;`Q&k!VR,d&gR6T1tR:Y8nS&P|&UR1T+sQ&p!WR,n&qR,t&vT2T,s2VR,x&wQ,w&wR2^,xQ'w!{R-t'wSsOtQ#dXT%os#dQ#OTR'y#OQ#RUR'{#RQ)y$uR/Z)yQ#UVR(O#UQ#XWU(U#X(V-{Q(V#YR-{(WQ-X'WR2j-XQ.p(wS3e.p3fR3f.qQ-`'^R2n-`Y!rQ'^-`1g5qR'h!rQ.{)cR3z.{U#_W%g*WU(]#_(^-|Q(^#`R-|(XQ-['ZR2l-[t`OXst!V!Z#d%l&g&i&p&r&s&u,n,s2S2VS#hZ%dU#r`#h.VR.V(hQ(i#jQ.S(eW.[(i.S3P6wQ3P.TR6w3QQ)l$lR/R)lQ$phR)r$pQ$`cU)_$`-w<[Q-w;xR<[)oQ/l*ZW4Y/l4Z7j9hU4Z/m/n/oS7j4[4]R9h7k$e*O$v(s)a)c*Y*b*q*r*|*}+R.g.h.j.k.l/Y/b/d/f/q/v0^0_0p1]3^3_3`3u3y4S4^4_4c4s4u4{4|4}5h7R7S7T7U7Z7[7^7_7`7f7m7p7z7}8P9]9^9_9i9q9v9w:h:i:j:k:l:q:u;W;];h;k=b=n=o=z={Q/t*bU4b/t4d7nQ4d/vR7n4cS*l$|*XR0S*lx*Q$v)c*q*r+R/q0^0_3y4^4{4|4}7f7z9v:l=b=n=o!d.e(s)a*Y*b.g.h.l/Y/f/v0p1]3`4S4_4c5h7R7U7m7p7}8P9i9q9w:q:u;W;];h=z={U/c*Q.e7Xa7X3u7Z7[7`9]:h:k;kQ0Z*qQ3a.gU4t0Z3a9`R9`7Z|*S$v)c*q*r+R/b/q0^0_3y4^4s4{4|4}7f7z9v:l=b=n=o!h.f(s)a*Y*b.g.h.l/Y/f/v0p1]3^3`4S4_4c5h7R7S7U7m7p7}8P9i9q9w:q:u;W;];h=z={U/e*S.f7Ye7Y3u7Z7[7`9]9^:h:i:k;kQ0]*rQ3b.hU4v0]3b9aR9a7[Q*w%UR0a*wQ5S0pR8O5SQ+[%jR0o+[Q5l1bS8_5l:OR:O8`Q,V&]R1e,VQ5q1gR8b5qQ1s,aS6R1s8oR8o6TQ1O+oW5_1O5a8V9zQ5a1RQ8V5`R9z8WQ+t&PR1U+tQ2V,sR6c2VYrOXst#dQ&t!ZQ+^%lQ,m&pQ,o&rQ,p&sQ,r&uQ2Q,nS2T,s2VR6b2SQ%npQ&x!_Q&{!aQ&}!bQ'P!cQ'o!uQ+]%kQ+i%yQ+{&VQ,c&kQ,z&zW-k'i'q'r'uQ-r'mQ0R*kQ0y+jS1v,d,gQ2_,yQ2`,|Q2a,}Q2u-jW2w-m-n-q-sQ5W0zQ5d1XQ5g1]Q5{1mQ6V1xQ6a2RU6p2v2y2|Q6s2zQ8R5XQ8Z5fQ8[5hQ8a5pQ8j5|Q8p6US9P6q6uQ9R6tQ9{8XQ:U8kQ:Z8qQ:b9QQ:x9|Q;O:VQ;S:cR;a;PQ%yyQ'b!iQ'm!uU+j%z%{%|Q-R'TU-f'c'd'eS-j'i'sQ/z*gS0z+k+lQ2g-TS2s-g-hQ2z-oS4g/{0OQ5X0{Q6l2mQ6o2tQ6t2{U7q4i4j4mQ9o7sR:r9pS$wi=pR*x%VU%Ui%V=pR0`*vQ$viS(s#v+fS)a$b$cQ)c$dQ*Y$xS*b${*WQ*q%OQ*r%QQ*|%]Q*}%^Q+R%bQ.g<aQ.h<cQ.j<gQ.k<iQ.l<kQ/Y)wQ/b*PQ/d*RQ/f*TQ/q*^S/v*d/hQ0^*tQ0_*ul0p+c,Q.a1a1i3Z5x6|8f9V:S:f:};VQ1]+}Q3^<tQ3_<vQ3`<yS3u<^<_Q3y.zS4S/_4UQ4^/rQ4_/sQ4c/uQ4s0YQ4u0[Q4{0gQ4|0hQ4}0iQ5h1^Q7R<}Q7S=PQ7T=RQ7U=TQ7Z<bQ7[<dQ7^<hQ7_<jQ7`<lQ7f4VQ7m4aQ7p4fQ7z4wQ7}5RQ8P5UQ9]<zQ9^<uQ9_<wQ9i7lQ9q7vQ9v7|Q9w8QQ:h=OQ:i=QQ:j=SQ:k=UQ:l9eQ:q9nQ:u9tQ;W=XQ;]:tQ;h;^Q;k=YQ=b=pQ=n=xQ=o=yQ=z=|R={=}Q*z%[Q.i<eR7]<fnpOXst!Z#d%l&p&r&s&u,n,s2S2VQ!fPS#fZ#oQ&z!`W'f!o*f0V4qQ'}#SQ)O#{Q)p$nS,g&i&lQ,l&mQ,y&yS-O'R/iQ-b'`Q.s(|Q/V)qQ0m+YQ0s+dQ2O,kQ2q-dQ3X.bQ4O/QQ4y0dQ5v1jQ6X1zQ6Y1{Q6^1}Q6`2PQ6e2XQ7P3[Q7c3{Q8h5yQ8t6ZQ8u6[Q8w6_Q9Z7QQ:T8iR:_8x#[cOPXZst!Z!`!o#d#o#{%l&i&l&m&p&r&s&u&y'R'`(|*f+Y+d,k,n,s-d.b/i0V0d1j1z1{1}2P2S2V2X3[4q5y6Z6[6_7Q8i8xQ#YWQ#eYQ%puQ%rvS%tw!gS(Q#W(TQ(W#ZQ(r#uQ(w#xQ)P$OQ)Q$PQ)R$QQ)S$RQ)T$SQ)U$TQ)V$UQ)W$VQ)X$WQ)Y$XQ)[$ZQ)^$_Q)`$aQ)e$eW)o$n)q/Q3{Q+a%sQ+u&QS-U'V2hQ-s'pS-x(R-zQ-}(ZQ.P(bQ.n(vQ.q(xQ.u;vQ.w;yQ.x;zQ.y;}Q/]){Q0j+UQ2c-PQ2f-SQ2v-lQ2}.QQ3c.oQ3h<OQ3i<PQ3j<QQ3k<RQ3l<SQ3m<TQ3n<UQ3o<VQ3p<WQ3q<XQ3r<YQ3s.vQ3t<]Q3w<`Q3x<mQ4P<ZQ5O0lQ5Y0|Q6k<pQ6q2xQ6v3OQ7V3dQ7W<qQ7a<sQ7b<{Q8`5mQ8|6iQ9Q6rQ9[<|Q9b=VQ9c=WQ:c9SQ:y9}Q;R:aQ;x#SR=g=sR#[WR'X!el!tQ!r!v!y!z'^'j'k'l-`-p1g5q5sS'T!e-WU*g$|*X*lS-T'U']S0O*h*nQ0W*oQ2m-^Q4m0UR4r0XR(y#xQ!fQT-_'^-`]!qQ!r'^-`1g5qQ#p]R'g;wR)d$dY!uQ'^-`1g5qQ'i!rS's!v!yS'u!z5sS-o'j'kQ-q'lR2{-pT#kZ%dS#jZ%dS%jm,jU(e#h#i#lS.T(f(gQ.X(hQ0n+ZQ3Q.UU3R.V.W.YS6x3S3TR9T6yd#^W#W#Z%g(R([*W+W.O/hr#gZm#h#i#l%d(f(g(h+Z.U.V.W.Y3S3T6yS*Z$x*_Q/o*[Q1|,jQ2d-QQ4W/kQ6g2[Q7i4XQ8{6hT=_'V+XV#aW%g*WU#`W%g*WS(S#W([U(X#Z+W/hS-V'V+XT-y(R.OV'[!e%h*XQ$lfR)v$qT)k$l)lR3}/PT*]$x*_T*e${*WQ0q+cQ1_,QQ3V.aQ5j1aQ5u1iQ6}3ZQ8g5xQ9W6|Q:Q8fQ:d9VQ:|:SQ;U:fQ;`:}R;c;VnqOXst!Z#d%l&p&r&s&u,n,s2S2VQ&j!VR,c&gtmOXst!U!V!Z#d%l&g&p&r&s&u,n,s2S2VR,j&mT%km,jR1c,SR,b&eQ&T|R+z&UR+p&OT&n!W&qT&o!W&qT2U,s2V\",\n    nodeNames: \"âš  ArithOp ArithOp ?. JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList in out const TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewTarget new NewExpression ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression TypeArgList CompareOp < declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression InstantiationExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast < ArrowFunction TypeParamList SequenceExpression InstantiationExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate asserts is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem\",\n    maxTerm: 379,\n    context: trackNewline,\n    nodeProps: [\n        [\n            \"isolate\",\n            -8,\n            5,\n            6,\n            14,\n            37,\n            39,\n            51,\n            53,\n            55,\n            \"\"\n        ],\n        [\n            \"group\",\n            -26,\n            9,\n            17,\n            19,\n            68,\n            207,\n            211,\n            215,\n            216,\n            218,\n            221,\n            224,\n            234,\n            236,\n            242,\n            244,\n            246,\n            248,\n            251,\n            257,\n            263,\n            265,\n            267,\n            269,\n            271,\n            273,\n            274,\n            \"Statement\",\n            -34,\n            13,\n            14,\n            32,\n            35,\n            36,\n            42,\n            51,\n            54,\n            55,\n            57,\n            62,\n            70,\n            72,\n            76,\n            80,\n            82,\n            84,\n            85,\n            110,\n            111,\n            120,\n            121,\n            136,\n            139,\n            141,\n            142,\n            143,\n            144,\n            145,\n            147,\n            148,\n            167,\n            169,\n            171,\n            \"Expression\",\n            -23,\n            31,\n            33,\n            37,\n            41,\n            43,\n            45,\n            173,\n            175,\n            177,\n            178,\n            180,\n            181,\n            182,\n            184,\n            185,\n            186,\n            188,\n            189,\n            190,\n            201,\n            203,\n            205,\n            206,\n            \"Type\",\n            -3,\n            88,\n            103,\n            109,\n            \"ClassItem\"\n        ],\n        [\n            \"openedBy\",\n            23,\n            \"<\",\n            38,\n            \"InterpolationStart\",\n            56,\n            \"[\",\n            60,\n            \"{\",\n            73,\n            \"(\",\n            160,\n            \"JSXStartCloseTag\"\n        ],\n        [\n            \"closedBy\",\n            -2,\n            24,\n            168,\n            \">\",\n            40,\n            \"InterpolationEnd\",\n            50,\n            \"]\",\n            61,\n            \"}\",\n            74,\n            \")\",\n            165,\n            \"JSXEndTag\"\n        ]\n    ],\n    propSources: [\n        jsHighlight\n    ],\n    skippedNodes: [\n        0,\n        5,\n        6,\n        277\n    ],\n    repeatNodeCount: 37,\n    tokenData: \"$Fq07[R!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#:O!R![#<_![!]#I_!]!^#Jk!^!_#Ku!_!`$![!`!a$$v!a!b$*T!b!c$,r!c!}Er!}#O$-|#O#P$/W#P#Q$4o#Q#R$5y#R#SEr#S#T$7W#T#o$8b#o#p$<r#p#q$=h#q#r$>x#r#s$@U#s$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$I|Er$I|$I}$Dk$I}$JO$Dk$JO$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr(n%d_$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$i&j(Y!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(Y!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$i&j(VpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(VpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Vp(Y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z07[+rq$i&j(Vp(Y!b'{0/lOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z07[.ST(W#S$i&j'|0/lO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c07[.n_$i&j(Vp(Y!b'|0/lOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)3p/x`$i&j!p),Q(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW1V`#v(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW2d_#v(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At3l_(U':f$i&j(Y!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$i&j(Y!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$i&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$d`$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$d``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$d`$i&j(Y!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(Y!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$d`(Y!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k%9[:hh$i&j(Vp(Y!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__WS$i&j(Vp(Y!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]WS$i&j(Y!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXWS$i&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSWSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWWS(Y!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]WS$i&j(VpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWWS(VpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYWS(Vp(Y!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S%9[C}i$i&j(n%1l(Vp(Y!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr%9[EoP;=`<%lCr07[FRk$i&j(Vp(Y!b$]#t(S,2j(d$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$i&j(Vp(Y!b$]#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv07[JPP;=`<%lEr(KWJ_`$i&j(Vp(Y!b#p(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWKl_$i&j$Q(Ch(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,#xLva(y+JY$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWNW`$i&j#z(Ch(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At! c_(X';W$i&j(VpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$i&j(VpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$i&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$d`$i&j(VpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(VpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$d`(VpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b/5|!'t_!l/.^$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&U!)O_!k!Lf$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z-!n!*[b$i&j(Vp(Y!b(T%&f#q(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW!+o`$i&j(Vp(Y!b#n(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;x!,|`$i&j(Vp(Y!br+4YOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,$U!.Z_!]+Jf$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!/ec$i&j(Vp(Y!b!Q.2^OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!0ya$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!2Z_![!L^$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!3eg$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!5Vg$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!6wc$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!8_c$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!9uf$i&j(Vp(Y!b#o(ChOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcxz!;Zz{#-}{!P!;Z!P!Q#/d!Q!^!;Z!^!_#(i!_!`#7S!`!a#8i!a!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z?O!;fb$i&j(Vp(Y!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z>^!<w`$i&j(Y!b!X7`OY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eq!Q!^!<n!^!_!Gr!_!}!<n!}#O!KS#O#P!Dy#P#o!<n#o#p!Gr#p;'S!<n;'S;=`!L]<%lO!<n<z!>Q^$i&j!X7`OY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@c!_!}!=y!}#O!CW#O#P!Dy#P#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!?Td$i&j!X7`O!^&c!_#W&c#W#X!>|#X#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#k!>|#k#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&c7`!@hX!X7`OY!@cZ!P!@c!P!Q!AT!Q!}!@c!}#O!Ar#O#P!Bq#P;'S!@c;'S;=`!CQ<%lO!@c7`!AYW!X7`#W#X!AT#Z#[!AT#]#^!AT#a#b!AT#g#h!AT#i#j!AT#j#k!AT#m#n!AT7`!AuVOY!ArZ#O!Ar#O#P!B[#P#Q!@c#Q;'S!Ar;'S;=`!Bk<%lO!Ar7`!B_SOY!ArZ;'S!Ar;'S;=`!Bk<%lO!Ar7`!BnP;=`<%l!Ar7`!BtSOY!@cZ;'S!@c;'S;=`!CQ<%lO!@c7`!CTP;=`<%l!@c<z!C][$i&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#O!CW#O#P!DR#P#Q!=y#Q#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DWX$i&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DvP;=`<%l!CW<z!EOX$i&jOY!=yYZ&cZ!^!=y!^!_!@c!_#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!EnP;=`<%l!=y>^!Ezl$i&j(Y!b!X7`OY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#W&}#W#X!Eq#X#Z&}#Z#[!Eq#[#]&}#]#^!Eq#^#a&}#a#b!Eq#b#g&}#g#h!Eq#h#i&}#i#j!Eq#j#k!Eq#k#m&}#m#n!Eq#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}8r!GyZ(Y!b!X7`OY!GrZw!Grwx!@cx!P!Gr!P!Q!Hl!Q!}!Gr!}#O!JU#O#P!Bq#P;'S!Gr;'S;=`!J|<%lO!Gr8r!Hse(Y!b!X7`OY'}Zw'}x#O'}#P#W'}#W#X!Hl#X#Z'}#Z#[!Hl#[#]'}#]#^!Hl#^#a'}#a#b!Hl#b#g'}#g#h!Hl#h#i'}#i#j!Hl#j#k!Hl#k#m'}#m#n!Hl#n;'S'};'S;=`(f<%lO'}8r!JZX(Y!bOY!JUZw!JUwx!Arx#O!JU#O#P!B[#P#Q!Gr#Q;'S!JU;'S;=`!Jv<%lO!JU8r!JyP;=`<%l!JU8r!KPP;=`<%l!Gr>^!KZ^$i&j(Y!bOY!KSYZ&cZw!KSwx!CWx!^!KS!^!_!JU!_#O!KS#O#P!DR#P#Q!<n#Q#o!KS#o#p!JU#p;'S!KS;'S;=`!LV<%lO!KS>^!LYP;=`<%l!KS>^!L`P;=`<%l!<n=l!Ll`$i&j(Vp!X7`OY!LcYZ&cZr!Lcrs!=ys!P!Lc!P!Q!Mn!Q!^!Lc!^!_# o!_!}!Lc!}#O#%P#O#P!Dy#P#o!Lc#o#p# o#p;'S!Lc;'S;=`#&Y<%lO!Lc=l!Mwl$i&j(Vp!X7`OY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#W(r#W#X!Mn#X#Z(r#Z#[!Mn#[#](r#]#^!Mn#^#a(r#a#b!Mn#b#g(r#g#h!Mn#h#i(r#i#j!Mn#j#k!Mn#k#m(r#m#n!Mn#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r8Q# vZ(Vp!X7`OY# oZr# ors!@cs!P# o!P!Q#!i!Q!}# o!}#O#$R#O#P!Bq#P;'S# o;'S;=`#$y<%lO# o8Q#!pe(Vp!X7`OY)rZr)rs#O)r#P#W)r#W#X#!i#X#Z)r#Z#[#!i#[#])r#]#^#!i#^#a)r#a#b#!i#b#g)r#g#h#!i#h#i)r#i#j#!i#j#k#!i#k#m)r#m#n#!i#n;'S)r;'S;=`*Z<%lO)r8Q#$WX(VpOY#$RZr#$Rrs!Ars#O#$R#O#P!B[#P#Q# o#Q;'S#$R;'S;=`#$s<%lO#$R8Q#$vP;=`<%l#$R8Q#$|P;=`<%l# o=l#%W^$i&j(VpOY#%PYZ&cZr#%Prs!CWs!^#%P!^!_#$R!_#O#%P#O#P!DR#P#Q!Lc#Q#o#%P#o#p#$R#p;'S#%P;'S;=`#&S<%lO#%P=l#&VP;=`<%l#%P=l#&]P;=`<%l!Lc?O#&kn$i&j(Vp(Y!b!X7`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#W%Z#W#X#&`#X#Z%Z#Z#[#&`#[#]%Z#]#^#&`#^#a%Z#a#b#&`#b#g%Z#g#h#&`#h#i%Z#i#j#&`#j#k#&`#k#m%Z#m#n#&`#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z9d#(r](Vp(Y!b!X7`OY#(iZr#(irs!Grsw#(iwx# ox!P#(i!P!Q#)k!Q!}#(i!}#O#+`#O#P!Bq#P;'S#(i;'S;=`#,`<%lO#(i9d#)th(Vp(Y!b!X7`OY*gZr*grs'}sw*gwx)rx#O*g#P#W*g#W#X#)k#X#Z*g#Z#[#)k#[#]*g#]#^#)k#^#a*g#a#b#)k#b#g*g#g#h#)k#h#i*g#i#j#)k#j#k#)k#k#m*g#m#n#)k#n;'S*g;'S;=`+Z<%lO*g9d#+gZ(Vp(Y!bOY#+`Zr#+`rs!JUsw#+`wx#$Rx#O#+`#O#P!B[#P#Q#(i#Q;'S#+`;'S;=`#,Y<%lO#+`9d#,]P;=`<%l#+`9d#,cP;=`<%l#(i?O#,o`$i&j(Vp(Y!bOY#,fYZ&cZr#,frs!KSsw#,fwx#%Px!^#,f!^!_#+`!_#O#,f#O#P!DR#P#Q!;Z#Q#o#,f#o#p#+`#p;'S#,f;'S;=`#-q<%lO#,f?O#-tP;=`<%l#,f?O#-zP;=`<%l!;Z07[#.[b$i&j(Vp(Y!b'}0/l!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z07[#/o_$i&j(Vp(Y!bT0/lOY#/dYZ&cZr#/drs#0nsw#/dwx#4Ox!^#/d!^!_#5}!_#O#/d#O#P#1p#P#o#/d#o#p#5}#p;'S#/d;'S;=`#6|<%lO#/d06j#0w]$i&j(Y!bT0/lOY#0nYZ&cZw#0nwx#1px!^#0n!^!_#3R!_#O#0n#O#P#1p#P#o#0n#o#p#3R#p;'S#0n;'S;=`#3x<%lO#0n05W#1wX$i&jT0/lOY#1pYZ&cZ!^#1p!^!_#2d!_#o#1p#o#p#2d#p;'S#1p;'S;=`#2{<%lO#1p0/l#2iST0/lOY#2dZ;'S#2d;'S;=`#2u<%lO#2d0/l#2xP;=`<%l#2d05W#3OP;=`<%l#1p01O#3YW(Y!bT0/lOY#3RZw#3Rwx#2dx#O#3R#O#P#2d#P;'S#3R;'S;=`#3r<%lO#3R01O#3uP;=`<%l#3R06j#3{P;=`<%l#0n05x#4X]$i&j(VpT0/lOY#4OYZ&cZr#4Ors#1ps!^#4O!^!_#5Q!_#O#4O#O#P#1p#P#o#4O#o#p#5Q#p;'S#4O;'S;=`#5w<%lO#4O00^#5XW(VpT0/lOY#5QZr#5Qrs#2ds#O#5Q#O#P#2d#P;'S#5Q;'S;=`#5q<%lO#5Q00^#5tP;=`<%l#5Q05x#5zP;=`<%l#4O01p#6WY(Vp(Y!bT0/lOY#5}Zr#5}rs#3Rsw#5}wx#5Qx#O#5}#O#P#2d#P;'S#5};'S;=`#6v<%lO#5}01p#6yP;=`<%l#5}07[#7PP;=`<%l#/d)3h#7ab$i&j$Q(Ch(Vp(Y!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;ZAt#8vb$Z#t$i&j(Vp(Y!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z'Ad#:Zp$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#U%Z#U#V#?i#V#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#d#Bq#d#l%Z#l#m#Es#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#<jk$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#>j_$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#?rd$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#A]f$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Bzc$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Dbe$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#E|g$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Gpi$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x#Il_!g$b$i&j$O)Lv(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Jv_al$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f#LS^h#)`#R-<U(Vp(Y!b$n7`OY*gZr*grs'}sw*gwx)rx!P*g!P!Q#MO!Q!^*g!^!_#Mt!_!`$ f!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#MXX$k&j(Vp(Y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El#M}Z#r(Ch(Vp(Y!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Np!`#O*g#P;'S*g;'S;=`+Z<%lO*g(El#NyX$Q(Ch(Vp(Y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El$ oX#s(Ch(Vp(Y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g*)x$!ga#`*!Y$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$#l!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(K[$#w_#k(Cl$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x$%Vag!*r#s(Ch$f#|$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$&[!`!a$'f!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$&g_#s(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$'qa#r(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$(v!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$)R`#r(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(Kd$*`a(q(Ct$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!a%Z!a!b$+e!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$+p`$i&j#{(Ch(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`$,}_!|$Ip$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f$.X_!S0,v$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/]Z$i&jO!^$0O!^!_$0f!_#i$0O#i#j$0k#j#l$0O#l#m$2^#m#o$0O#o#p$0f#p;'S$0O;'S;=`$4i<%lO$0O(n$0VT_#S$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0kO_#S(n$0p[$i&jO!Q&c!Q![$1f![!^&c!_!c&c!c!i$1f!i#T&c#T#Z$1f#Z#o&c#o#p$3|#p;'S&c;'S;=`&w<%lO&c(n$1kZ$i&jO!Q&c!Q![$2^![!^&c!_!c&c!c!i$2^!i#T&c#T#Z$2^#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2cZ$i&jO!Q&c!Q![$3U![!^&c!_!c&c!c!i$3U!i#T&c#T#Z$3U#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3ZZ$i&jO!Q&c!Q![$0O![!^&c!_!c&c!c!i$0O!i#T&c#T#Z$0O#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$4PR!Q![$4Y!c!i$4Y#T#Z$4Y#S$4]S!Q![$4Y!c!i$4Y#T#Z$4Y#q#r$0f(n$4lP;=`<%l$0O#1[$4z_!Y#)l$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$6U`#x(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;p$7c_$i&j(Vp(Y!b(`+4QOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$8qk$i&j(Vp(Y!b(S,2j$_#t(d$I[OY%ZYZ&cZr%Zrs&}st%Ztu$8buw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$8b![!^%Z!^!_*g!_!c%Z!c!}$8b!}#O%Z#O#P&c#P#R%Z#R#S$8b#S#T%Z#T#o$8b#o#p*g#p$g%Z$g;'S$8b;'S;=`$<l<%lO$8b+d$:qk$i&j(Vp(Y!b$_#tOY%ZYZ&cZr%Zrs&}st%Ztu$:fuw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$:f![!^%Z!^!_*g!_!c%Z!c!}$:f!}#O%Z#O#P&c#P#R%Z#R#S$:f#S#T%Z#T#o$:f#o#p*g#p$g%Z$g;'S$:f;'S;=`$<f<%lO$:f+d$<iP;=`<%l$:f07[$<oP;=`<%l$8b#Jf$<{X!_#Hb(Vp(Y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g,#x$=sa(x+JY$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+e#q;'S%Z;'S;=`+a<%lO%Z)>v$?V_!^(CdvBr$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z?O$@a_!q7`$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$Aq|$i&j(Vp(Y!b'{0/l$]#t(S,2j(d$I[OX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr07[$D|k$i&j(Vp(Y!b'|0/l$]#t(S,2j(d$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr\",\n    tokenizers: [\n        noSemicolon,\n        noSemicolonType,\n        operatorToken,\n        jsx,\n        2,\n        3,\n        4,\n        5,\n        6,\n        7,\n        8,\n        9,\n        10,\n        11,\n        12,\n        13,\n        14,\n        insertSemicolon,\n        new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.LocalTokenGroup(\"$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOx~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!U~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(b~~\", 141, 339),\n        new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.LocalTokenGroup(\"j~RQYZXz{^~^O(P~~aP!P!Qd~iO(Q~~\", 25, 322)\n    ],\n    topRules: {\n        \"Script\": [\n            0,\n            7\n        ],\n        \"SingleExpression\": [\n            1,\n            275\n        ],\n        \"SingleClassItem\": [\n            2,\n            276\n        ]\n    },\n    dialects: {\n        jsx: 0,\n        ts: 15098\n    },\n    dynamicPrecedences: {\n        \"80\": 1,\n        \"82\": 1,\n        \"94\": 1,\n        \"169\": 1,\n        \"199\": 1\n    },\n    specialized: [\n        {\n            term: 326,\n            get: (value)=>spec_identifier[value] || -1\n        },\n        {\n            term: 342,\n            get: (value)=>spec_word[value] || -1\n        },\n        {\n            term: 95,\n            get: (value)=>spec_LessThan[value] || -1\n        }\n    ],\n    tokenPrec: 15124\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxlemVyL2phdmFzY3JpcHQvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBeUY7QUFDdEM7QUFFbkQsOEVBQThFO0FBQzlFLE1BQU1NLFNBQVMsS0FDYkMsYUFBYSxLQUNiQyxTQUFTLEdBQ1RDLGVBQWUsR0FDZkMsY0FBYyxHQUNkQyxjQUFjLEdBQ2RDLGFBQWEsS0FDYkMsU0FBUyxLQUNUQyxVQUFVLEtBQ1ZDLGNBQWMsR0FDZEMsZUFBZSxHQUNmQyxjQUFjO0FBRWhCOzRDQUM0QyxHQUU1QyxNQUFNQyxRQUFRO0lBQUM7SUFBRztJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSztJQUFLO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQ3ZGO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0NBQU07QUFFekQsTUFBTUMsU0FBUyxLQUFLQyxZQUFZLElBQUlDLFFBQVEsSUFBSUMsT0FBTyxJQUFJQyxPQUFPLElBQUlDLFFBQVEsSUFBSUMsS0FBSyxJQUFJQyxRQUFRLElBQzdGQyxXQUFXLElBQUlDLE1BQU0sSUFBSUMsV0FBVztBQUUxQyxNQUFNQyxlQUFlLElBQUk5QixxREFBY0EsQ0FBQztJQUN0QytCLE9BQU87SUFDUEMsT0FBTUMsT0FBTyxFQUFFQyxJQUFJO1FBQ2pCLE9BQU9BLFFBQVFuQixlQUFlbUIsUUFBUWxCLGdCQUFnQmtCLFFBQVFyQixTQUFTb0IsVUFBVUMsUUFBUXBCO0lBQzNGO0lBQ0FxQixRQUFRO0FBQ1Y7QUFFQSxNQUFNQyxrQkFBa0IsSUFBSW5DLHdEQUFpQkEsQ0FBQyxDQUFDb0MsT0FBT0M7SUFDcEQsSUFBSSxFQUFDQyxJQUFJLEVBQUMsR0FBR0Y7SUFDYixJQUFJRSxRQUFRcEIsVUFBVW9CLFFBQVEsQ0FBQyxLQUFLRCxNQUFNTCxPQUFPLEVBQy9DSSxNQUFNRyxXQUFXLENBQUM1QjtBQUN0QixHQUFHO0lBQUM2QixZQUFZO0lB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STtRQUFJO1FBQUk7UUFBSWxCO1FBQWlCLElBQUlqQyxzREFBZUEsQ0FBQyw4UEFBOFAsS0FBSztRQUFNLElBQUlBLHNEQUFlQSxDQUFDLG1DQUFtQyxJQUFJO0tBQUs7SUFDemRpTixVQUFVO1FBQUMsVUFBUztZQUFDO1lBQUU7U0FBRTtRQUFDLG9CQUFtQjtZQUFDO1lBQUU7U0FBSTtRQUFDLG1CQUFrQjtZQUFDO1lBQUU7U0FBSTtJQUFBO0lBQzlFQyxVQUFVO1FBQUMvSixLQUFLO1FBQUdnSyxJQUFJO0lBQUs7SUFDNUJDLG9CQUFvQjtRQUFDLE1BQUs7UUFBRSxNQUFLO1FBQUUsTUFBSztRQUFFLE9BQU07UUFBRSxPQUFNO0lBQUM7SUFDekRDLGFBQWE7UUFBQztZQUFDdEwsTUFBTTtZQUFLOEosS0FBSyxDQUFDeUIsUUFBVXZGLGVBQWUsQ0FBQ3VGLE1BQU0sSUFBSSxDQUFDO1FBQUM7UUFBRTtZQUFDdkwsTUFBTTtZQUFLOEosS0FBSyxDQUFDeUIsUUFBVTFCLFNBQVMsQ0FBQzBCLE1BQU0sSUFBSSxDQUFDO1FBQUM7UUFBRTtZQUFDdkwsTUFBTTtZQUFJOEosS0FBSyxDQUFDeUIsUUFBVXBCLGFBQWEsQ0FBQ29CLE1BQU0sSUFBSSxDQUFDO1FBQUM7S0FBRTtJQUNuTEMsV0FBVztBQUNiO0FBRWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXJhLXBvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9AbGV6ZXIvamF2YXNjcmlwdC9kaXN0L2luZGV4LmpzPzEyY2QiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29udGV4dFRyYWNrZXIsIEV4dGVybmFsVG9rZW5pemVyLCBMUlBhcnNlciwgTG9jYWxUb2tlbkdyb3VwIH0gZnJvbSAnQGxlemVyL2xyJztcbmltcG9ydCB7IHN0eWxlVGFncywgdGFncyB9IGZyb20gJ0BsZXplci9oaWdobGlnaHQnO1xuXG4vLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBsZXplci1nZW5lcmF0b3IuIFlvdSBwcm9iYWJseSBzaG91bGRuJ3QgZWRpdCBpdC5cbmNvbnN0IG5vU2VtaSA9IDMxNSxcbiAgbm9TZW1pVHlwZSA9IDMxNixcbiAgaW5jZGVjID0gMSxcbiAgaW5jZGVjUHJlZml4ID0gMixcbiAgcXVlc3Rpb25Eb3QgPSAzLFxuICBKU1hTdGFydFRhZyA9IDQsXG4gIGluc2VydFNlbWkgPSAzMTcsXG4gIHNwYWNlcyA9IDMxOSxcbiAgbmV3bGluZSA9IDMyMCxcbiAgTGluZUNvbW1lbnQgPSA1LFxuICBCbG9ja0NvbW1lbnQgPSA2LFxuICBEaWFsZWN0X2pzeCA9IDA7XG5cbi8qIEhhbmQtd3JpdHRlbiB0b2tlbml6ZXJzIGZvciBKYXZhU2NyaXB0IHRva2VucyB0aGF0IGNhbid0IGJlXG4gICBleHByZXNzZWQgYnkgbGV6ZXIncyBidWlsdC1pbiB0b2tlbml6ZXIuICovXG5cbmNvbnN0IHNwYWNlID0gWzksIDEwLCAxMSwgMTIsIDEzLCAzMiwgMTMzLCAxNjAsIDU3NjAsIDgxOTIsIDgxOTMsIDgxOTQsIDgxOTUsIDgxOTYsIDgxOTcsIDgxOTgsIDgxOTksIDgyMDAsXG4gICAgICAgICAgICAgICA4MjAxLCA4MjAyLCA4MjMyLCA4MjMzLCA4MjM5LCA4Mjg3LCAxMjI4OF07XG5cbmNvbnN0IGJyYWNlUiA9IDEyNSwgc2VtaWNvbG9uID0gNTksIHNsYXNoID0gNDcsIHN0YXIgPSA0MiwgcGx1cyA9IDQzLCBtaW51cyA9IDQ1LCBsdCA9IDYwLCBjb21tYSA9IDQ0LFxuICAgICAgcXVlc3Rpb24gPSA2MywgZG90ID0gNDYsIGJyYWNrZXRMID0gOTE7XG5cbmNvbnN0IHRyYWNrTmV3bGluZSA9IG5ldyBDb250ZXh0VHJhY2tlcih7XG4gIHN0YXJ0OiBmYWxzZSxcbiAgc2hpZnQoY29udGV4dCwgdGVybSkge1xuICAgIHJldHVybiB0ZXJtID09IExpbmVDb21tZW50IHx8IHRlcm0gPT0gQmxvY2tDb21tZW50IHx8IHRlcm0gPT0gc3BhY2VzID8gY29udGV4dCA6IHRlcm0gPT0gbmV3bGluZVxuICB9LFxuICBzdHJpY3Q6IGZhbHNlXG59KTtcblxuY29uc3QgaW5zZXJ0U2VtaWNvbG9uID0gbmV3IEV4dGVybmFsVG9rZW5pemVyKChpbnB1dCwgc3RhY2spID0+IHtcbiAgbGV0IHtuZXh0fSA9IGlucHV0O1xuICBpZiAobmV4dCA9PSBicmFjZVIgfHwgbmV4dCA9PSAtMSB8fCBzdGFjay5jb250ZXh0KVxuICAgIGlucHV0LmFjY2VwdFRva2VuKGluc2VydFNlbWkpO1xufSwge2NvbnRleHR1YWw6IHRydWUsIGZhbGxiYWNrOiB0cnVlfSk7XG5cbmNvbnN0IG5vU2VtaWNvbG9uID0gbmV3IEV4dGVybmFsVG9rZW5pemVyKChpbnB1dCwgc3RhY2spID0+IHtcbiAgbGV0IHtuZXh0fSA9IGlucHV0LCBhZnRlcjtcbiAgaWYgKHNwYWNlLmluZGV4T2YobmV4dCkgPiAtMSkgcmV0dXJuXG4gIGlmIChuZXh0ID09IHNsYXNoICYmICgoYWZ0ZXIgPSBpbnB1dC5wZWVrKDEpKSA9PSBzbGFzaCB8fCBhZnRlciA9PSBzdGFyKSkgcmV0dXJuXG4gIGlmIChuZXh0ICE9IGJyYWNlUiAmJiBuZXh0ICE9IHNlbWljb2xvbiAmJiBuZXh0ICE9IC0xICYmICFzdGFjay5jb250ZXh0KVxuICAgIGlucHV0LmFjY2VwdFRva2VuKG5vU2VtaSk7XG59LCB7Y29udGV4dHVhbDogdHJ1ZX0pO1xuXG5jb25zdCBub1NlbWljb2xvblR5cGUgPSBuZXcgRXh0ZXJuYWxUb2tlbml6ZXIoKGlucHV0LCBzdGFjaykgPT4ge1xuICBpZiAoaW5wdXQubmV4dCA9PSBicmFja2V0TCAmJiAhc3RhY2suY29udGV4dCkgaW5wdXQuYWNjZXB0VG9rZW4obm9TZW1pVHlwZSk7XG59LCB7Y29udGV4dHVhbDogdHJ1ZX0pO1xuXG5jb25zdCBvcGVyYXRvclRva2VuID0gbmV3IEV4dGVybmFsVG9rZW5pemVyKChpbnB1dCwgc3RhY2spID0+IHtcbiAgbGV0IHtuZXh0fSA9IGlucHV0O1xuICBpZiAobmV4dCA9PSBwbHVzIHx8IG5leHQgPT0gbWludXMpIHtcbiAgICBpbnB1dC5hZHZhbmNlKCk7XG4gICAgaWYgKG5leHQgPT0gaW5wdXQubmV4dCkge1xuICAgICAgaW5wdXQuYWR2YW5jZSgpO1xuICAgICAgbGV0IG1heVBvc3RmaXggPSAhc3RhY2suY29udGV4dCAmJiBzdGFjay5jYW5TaGlmdChpbmNkZWMpO1xuICAgICAgaW5wdXQuYWNjZXB0VG9rZW4obWF5UG9zdGZpeCA/IGluY2RlYyA6IGluY2RlY1ByZWZpeCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKG5leHQgPT0gcXVlc3Rpb24gJiYgaW5wdXQucGVlaygxKSA9PSBkb3QpIHtcbiAgICBpbnB1dC5hZHZhbmNlKCk7IGlucHV0LmFkdmFuY2UoKTtcbiAgICBpZiAoaW5wdXQubmV4dCA8IDQ4IHx8IGlucHV0Lm5leHQgPiA1NykgLy8gTm8gZGlnaXQgYWZ0ZXJcbiAgICAgIGlucHV0LmFjY2VwdFRva2VuKHF1ZXN0aW9uRG90KTtcbiAgfVxufSwge2NvbnRleHR1YWw6IHRydWV9KTtcblxuZnVuY3Rpb24gaWRlbnRpZmllckNoYXIoY2gsIHN0YXJ0KSB7XG4gIHJldHVybiBjaCA+PSA2NSAmJiBjaCA8PSA5MCB8fCBjaCA+PSA5NyAmJiBjaCA8PSAxMjIgfHwgY2ggPT0gOTUgfHwgY2ggPj0gMTkyIHx8XG4gICAgIXN0YXJ0ICYmIGNoID49IDQ4ICYmIGNoIDw9IDU3XG59XG5cbmNvbnN0IGpzeCA9IG5ldyBFeHRlcm5hbFRva2VuaXplcigoaW5wdXQsIHN0YWNrKSA9PiB7XG4gIGlmIChpbnB1dC5uZXh0ICE9IGx0IHx8ICFzdGFjay5kaWFsZWN0RW5hYmxlZChEaWFsZWN0X2pzeCkpIHJldHVyblxuICBpbnB1dC5hZHZhbmNlKCk7XG4gIGlmIChpbnB1dC5uZXh0ID09IHNsYXNoKSByZXR1cm5cbiAgLy8gU2NhbiBmb3IgYW4gaWRlbnRpZmllciBmb2xsb3dlZCBieSBhIGNvbW1hIG9yICdleHRlbmRzJywgZG9uJ3RcbiAgLy8gdHJlYXQgdGhpcyBhcyBhIHN0YXJ0IHRhZyBpZiBwcmVzZW50LlxuICBsZXQgYmFjayA9IDA7XG4gIHdoaWxlIChzcGFjZS5pbmRleE9mKGlucHV0Lm5leHQpID4gLTEpIHsgaW5wdXQuYWR2YW5jZSgpOyBiYWNrKys7IH1cbiAgaWYgKGlkZW50aWZpZXJDaGFyKGlucHV0Lm5leHQsIHRydWUpKSB7XG4gICAgaW5wdXQuYWR2YW5jZSgpO1xuICAgIGJhY2srKztcbiAgICB3aGlsZSAoaWRlbnRpZmllckNoYXIoaW5wdXQubmV4dCwgZmFsc2UpKSB7IGlucHV0LmFkdmFuY2UoKTsgYmFjaysrOyB9XG4gICAgd2hpbGUgKHNwYWNlLmluZGV4T2YoaW5wdXQubmV4dCkgPiAtMSkgeyBpbnB1dC5hZHZhbmNlKCk7IGJhY2srKzsgfVxuICAgIGlmIChpbnB1dC5uZXh0ID09IGNvbW1hKSByZXR1cm5cbiAgICBmb3IgKGxldCBpID0gMDs7IGkrKykge1xuICAgICAgaWYgKGkgPT0gNykge1xuICAgICAgICBpZiAoIWlkZW50aWZpZXJDaGFyKGlucHV0Lm5leHQsIHRydWUpKSByZXR1cm5cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGlmIChpbnB1dC5uZXh0ICE9IFwiZXh0ZW5kc1wiLmNoYXJDb2RlQXQoaSkpIGJyZWFrXG4gICAgICBpbnB1dC5hZHZhbmNlKCk7XG4gICAgICBiYWNrKys7XG4gICAgfVxuICB9XG4gIGlucHV0LmFjY2VwdFRva2VuKEpTWFN0YXJ0VGFnLCAtYmFjayk7XG59KTtcblxuY29uc3QganNIaWdobGlnaHQgPSBzdHlsZVRhZ3Moe1xuICBcImdldCBzZXQgYXN5bmMgc3RhdGljXCI6IHRhZ3MubW9kaWZpZXIsXG4gIFwiZm9yIHdoaWxlIGRvIGlmIGVsc2Ugc3dpdGNoIHRyeSBjYXRjaCBmaW5hbGx5IHJldHVybiB0aHJvdyBicmVhayBjb250aW51ZSBkZWZhdWx0IGNhc2VcIjogdGFncy5jb250cm9sS2V5d29yZCxcbiAgXCJpbiBvZiBhd2FpdCB5aWVsZCB2b2lkIHR5cGVvZiBkZWxldGUgaW5zdGFuY2VvZiBhcyBzYXRpc2ZpZXNcIjogdGFncy5vcGVyYXRvcktleXdvcmQsXG4gIFwibGV0IHZhciBjb25zdCB1c2luZyBmdW5jdGlvbiBjbGFzcyBleHRlbmRzXCI6IHRhZ3MuZGVmaW5pdGlvbktleXdvcmQsXG4gIFwiaW1wb3J0IGV4cG9ydCBmcm9tXCI6IHRhZ3MubW9kdWxlS2V5d29yZCxcbiAgXCJ3aXRoIGRlYnVnZ2VyIG5ld1wiOiB0YWdzLmtleXdvcmQsXG4gIFRlbXBsYXRlU3RyaW5nOiB0YWdzLnNwZWNpYWwodGFncy5zdHJpbmcpLFxuICBzdXBlcjogdGFncy5hdG9tLFxuICBCb29sZWFuTGl0ZXJhbDogdGFncy5ib29sLFxuICB0aGlzOiB0YWdzLnNlbGYsXG4gIG51bGw6IHRhZ3MubnVsbCxcbiAgU3RhcjogdGFncy5tb2RpZmllcixcbiAgVmFyaWFibGVOYW1lOiB0YWdzLnZhcmlhYmxlTmFtZSxcbiAgXCJDYWxsRXhwcmVzc2lvbi9WYXJpYWJsZU5hbWUgVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uL1ZhcmlhYmxlTmFtZVwiOiB0YWdzLmZ1bmN0aW9uKHRhZ3MudmFyaWFibGVOYW1lKSxcbiAgVmFyaWFibGVEZWZpbml0aW9uOiB0YWdzLmRlZmluaXRpb24odGFncy52YXJpYWJsZU5hbWUpLFxuICBMYWJlbDogdGFncy5sYWJlbE5hbWUsXG4gIFByb3BlcnR5TmFtZTogdGFncy5wcm9wZXJ0eU5hbWUsXG4gIFByaXZhdGVQcm9wZXJ0eU5hbWU6IHRhZ3Muc3BlY2lhbCh0YWdzLnByb3BlcnR5TmFtZSksXG4gIFwiQ2FsbEV4cHJlc3Npb24vTWVtYmVyRXhwcmVzc2lvbi9Qcm9wZXJ0eU5hbWVcIjogdGFncy5mdW5jdGlvbih0YWdzLnByb3BlcnR5TmFtZSksXG4gIFwiRnVuY3Rpb25EZWNsYXJhdGlvbi9WYXJpYWJsZURlZmluaXRpb25cIjogdGFncy5mdW5jdGlvbih0YWdzLmRlZmluaXRpb24odGFncy52YXJpYWJsZU5hbWUpKSxcbiAgXCJDbGFzc0RlY2xhcmF0aW9uL1ZhcmlhYmxlRGVmaW5pdGlvblwiOiB0YWdzLmRlZmluaXRpb24odGFncy5jbGFzc05hbWUpLFxuICBcIk5ld0V4cHJlc3Npb24vVmFyaWFibGVOYW1lXCI6IHRhZ3MuY2xhc3NOYW1lLFxuICBQcm9wZXJ0eURlZmluaXRpb246IHRhZ3MuZGVmaW5pdGlvbih0YWdzLnByb3BlcnR5TmFtZSksXG4gIFByaXZhdGVQcm9wZXJ0eURlZmluaXRpb246IHRhZ3MuZGVmaW5pdGlvbih0YWdzLnNwZWNpYWwodGFncy5wcm9wZXJ0eU5hbWUpKSxcbiAgVXBkYXRlT3A6IHRhZ3MudXBkYXRlT3BlcmF0b3IsXG4gIFwiTGluZUNvbW1lbnQgSGFzaGJhbmdcIjogdGFncy5saW5lQ29tbWVudCxcbiAgQmxvY2tDb21tZW50OiB0YWdzLmJsb2NrQ29tbWVudCxcbiAgTnVtYmVyOiB0YWdzLm51bWJlcixcbiAgU3RyaW5nOiB0YWdzLnN0cmluZyxcbiAgRXNjYXBlOiB0YWdzLmVzY2FwZSxcbiAgQXJpdGhPcDogdGFncy5hcml0aG1ldGljT3BlcmF0b3IsXG4gIExvZ2ljT3A6IHRhZ3MubG9naWNPcGVyYXRvcixcbiAgQml0T3A6IHRhZ3MuYml0d2lzZU9wZXJhdG9yLFxuICBDb21wYXJlT3A6IHRhZ3MuY29tcGFyZU9wZXJhdG9yLFxuICBSZWdFeHA6IHRhZ3MucmVnZXhwLFxuICBFcXVhbHM6IHRhZ3MuZGVmaW5pdGlvbk9wZXJhdG9yLFxuICBBcnJvdzogdGFncy5mdW5jdGlvbih0YWdzLnB1bmN0dWF0aW9uKSxcbiAgXCI6IFNwcmVhZFwiOiB0YWdzLnB1bmN0dWF0aW9uLFxuICBcIiggKVwiOiB0YWdzLnBhcmVuLFxuICBcIlsgXVwiOiB0YWdzLnNxdWFyZUJyYWNrZXQsXG4gIFwieyB9XCI6IHRhZ3MuYnJhY2UsXG4gIFwiSW50ZXJwb2xhdGlvblN0YXJ0IEludGVycG9sYXRpb25FbmRcIjogdGFncy5zcGVjaWFsKHRhZ3MuYnJhY2UpLFxuICBcIi5cIjogdGFncy5kZXJlZk9wZXJhdG9yLFxuICBcIiwgO1wiOiB0YWdzLnNlcGFyYXRvcixcbiAgXCJAXCI6IHRhZ3MubWV0YSxcblxuICBUeXBlTmFtZTogdGFncy50eXBlTmFtZSxcbiAgVHlwZURlZmluaXRpb246IHRhZ3MuZGVmaW5pdGlvbih0YWdzLnR5cGVOYW1lKSxcbiAgXCJ0eXBlIGVudW0gaW50ZXJmYWNlIGltcGxlbWVudHMgbmFtZXNwYWNlIG1vZHVsZSBkZWNsYXJlXCI6IHRhZ3MuZGVmaW5pdGlvbktleXdvcmQsXG4gIFwiYWJzdHJhY3QgZ2xvYmFsIFByaXZhY3kgcmVhZG9ubHkgb3ZlcnJpZGVcIjogdGFncy5tb2RpZmllcixcbiAgXCJpcyBrZXlvZiB1bmlxdWUgaW5mZXIgYXNzZXJ0c1wiOiB0YWdzLm9wZXJhdG9yS2V5d29yZCxcblxuICBKU1hBdHRyaWJ1dGVWYWx1ZTogdGFncy5hdHRyaWJ1dGVWYWx1ZSxcbiAgSlNYVGV4dDogdGFncy5jb250ZW50LFxuICBcIkpTWFN0YXJ0VGFnIEpTWFN0YXJ0Q2xvc2VUYWcgSlNYU2VsZkNsb3NlRW5kVGFnIEpTWEVuZFRhZ1wiOiB0YWdzLmFuZ2xlQnJhY2tldCxcbiAgXCJKU1hJZGVudGlmaWVyIEpTWE5hbWVTcGFjZWROYW1lXCI6IHRhZ3MudGFnTmFtZSxcbiAgXCJKU1hBdHRyaWJ1dGUvSlNYSWRlbnRpZmllciBKU1hBdHRyaWJ1dGUvSlNYTmFtZVNwYWNlZE5hbWVcIjogdGFncy5hdHRyaWJ1dGVOYW1lLFxuICBcIkpTWEJ1aWx0aW4vSlNYSWRlbnRpZmllclwiOiB0YWdzLnN0YW5kYXJkKHRhZ3MudGFnTmFtZSlcbn0pO1xuXG4vLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBsZXplci1nZW5lcmF0b3IuIFlvdSBwcm9iYWJseSBzaG91bGRuJ3QgZWRpdCBpdC5cbmNvbnN0IHNwZWNfaWRlbnRpZmllciA9IHtfX3Byb3RvX186bnVsbCxleHBvcnQ6MjAsIGFzOjI1LCBmcm9tOjMzLCBkZWZhdWx0OjM2LCBhc3luYzo0MSwgZnVuY3Rpb246NDIsIGluOjUyLCBvdXQ6NTUsIGNvbnN0OjU2LCBleHRlbmRzOjYwLCB0aGlzOjY0LCB0cnVlOjcyLCBmYWxzZTo3MiwgbnVsbDo4NCwgdm9pZDo4OCwgdHlwZW9mOjkyLCBzdXBlcjoxMDgsIG5ldzoxNDIsIGRlbGV0ZToxNTQsIHlpZWxkOjE2MywgYXdhaXQ6MTY3LCBjbGFzczoxNzIsIHB1YmxpYzoyMzUsIHByaXZhdGU6MjM1LCBwcm90ZWN0ZWQ6MjM1LCByZWFkb25seToyMzcsIGluc3RhbmNlb2Y6MjU2LCBzYXRpc2ZpZXM6MjU5LCBpbXBvcnQ6MjkyLCBrZXlvZjozNDksIHVuaXF1ZTozNTMsIGluZmVyOjM1OSwgYXNzZXJ0czozOTUsIGlzOjM5NywgYWJzdHJhY3Q6NDE3LCBpbXBsZW1lbnRzOjQxOSwgdHlwZTo0MjEsIGxldDo0MjQsIHZhcjo0MjYsIHVzaW5nOjQyOSwgaW50ZXJmYWNlOjQzNSwgZW51bTo0MzksIG5hbWVzcGFjZTo0NDUsIG1vZHVsZTo0NDcsIGRlY2xhcmU6NDUxLCBnbG9iYWw6NDU1LCBmb3I6NDc0LCBvZjo0ODMsIHdoaWxlOjQ4Niwgd2l0aDo0OTAsIGRvOjQ5NCwgaWY6NDk4LCBlbHNlOjUwMCwgc3dpdGNoOjUwNCwgY2FzZTo1MTAsIHRyeTo1MTYsIGNhdGNoOjUyMCwgZmluYWxseTo1MjQsIHJldHVybjo1MjgsIHRocm93OjUzMiwgYnJlYWs6NTM2LCBjb250aW51ZTo1NDAsIGRlYnVnZ2VyOjU0NH07XG5jb25zdCBzcGVjX3dvcmQgPSB7X19wcm90b19fOm51bGwsYXN5bmM6MTI5LCBnZXQ6MTMxLCBzZXQ6MTMzLCBkZWNsYXJlOjE5NSwgcHVibGljOjE5NywgcHJpdmF0ZToxOTcsIHByb3RlY3RlZDoxOTcsIHN0YXRpYzoxOTksIGFic3RyYWN0OjIwMSwgb3ZlcnJpZGU6MjAzLCByZWFkb25seToyMDksIGFjY2Vzc29yOjIxMSwgbmV3OjQwMX07XG5jb25zdCBzcGVjX0xlc3NUaGFuID0ge19fcHJvdG9fXzpudWxsLFwiPFwiOjE5M307XG5jb25zdCBwYXJzZXIgPSBMUlBhcnNlci5kZXNlcmlhbGl6ZSh7XG4gIHZlcnNpb246IDE0LFxuICBzdGF0ZXM6IFwiJEVPUSVUUWxPT08lW1FsT09PJ19RcE9PUChsT2BPT08qelEhME14TycjQ2lPK1JPI3RPJyNDak8rYU8mak8nI0NqTytvTyNASXRPJyNEYU8uUVFsTycjRGdPLmJRbE8nI0RyTyVbUWxPJyNEek8wZlFsTycjRVNPT1EhMExmJyNFWycjRVtPMVBRYE8nI0VYT09RTycjRXAnI0VwT09RTycjSWsnI0lrTzFYUWBPJyNHc08xZFFgTycjRW9PMWlRYE8nI0VvTzNoUSEwTXhPJyNKcU82W1EhME14TycjSnJPNnVRYE8nI0ZdTzZ6USxVTycjRnRPT1EhMExmJyNGZicjRmZPN1ZPN2RPJyNGZk83ZVFNaE8nI0Z8TzlbUWBPJyNGe09PUSEwTGYnI0pyJyNKck9PUSEwTGInI0pxJyNKcU85YVFgTycjR3dPT1FbJyNLXicjS15POWxRYE8nI0lYTzlxUSEwTHJPJyNJWU9PUVsnI0pfJyNKX09PUVsnI0leJyNJXlFgUWxPT1FgUWxPT085eVEhTF5PJyNEdk86UVFsTycjRU9POlhRbE8nI0VRTzlnUWBPJyNHc086YFFNaE8nI0NvTzpuUWBPJyNFbk86eVFgTycjRXlPO09RTWhPJyNGZU87bVFgTycjR3NPT1FPJyNLXycjS19PO3JRYE8nI0tfTzxRUWBPJyNHe088UVFgTycjR3xPPFFRYE8nI0hPTzlnUWBPJyNIUk88d1FgTycjSFVPPmBRYE8nI0NlTz5wUWBPJyNIYk8+eFFgTycjSGhPPnhRYE8nI0hqT2BRbE8nI0hsTz54UWBPJyNIbk8+eFFgTycjSHFPPn1RYE8nI0h3Tz9TUSEwTHNPJyNIfU8lW1FsTycjSVBPP19RITBMc08nI0lSTz9qUSEwTHNPJyNJVE85cVEhMExyTycjSVZPP3VRITBNeE8nI0NpT0B3UXBPJyNEbFFPUWBPT08lW1FsTycjRVFPQV9RYE8nI0VUTzpgUU1oTycjRW5PQWpRYE8nI0VuT0F1USFiTycjRmVPT1FbJyNDZycjQ2dPT1EhMExiJyNEcScjRHFPT1EhMExiJyNKdScjSnVPJVtRbE8nI0p1T09RTycjSngnI0p4T09RTycjSWcnI0lnT0J1UXBPJyNFZ09PUSEwTGInI0VmJyNFZk9PUSEwTGInI0p8JyNKfE9DcVEhME1TTycjRWdPQ3tRcE8nI0VXT09RTycjSncnI0p3T0RhUXBPJyNKeE9FblFwTycjRVdPQ3tRcE8nI0VnUEV7TyYyRGpPJyNDYlBPT08pQ0R8KUNEfE9PT08nI0lfJyNJX09GV08jdE8sNTlVT09RITBMaCw1OVUsNTlVT09PTycjSWAnI0lgT0ZmTyZqTyw1OVVPRnRRIUxeTycjRGNPT09PJyNJYicjSWJPRntPI0BJdE8sNTl7T09RITBMZiw1OXssNTl7T0daUWxPJyNJY09HblFgTycjSnNPSW1RIWZPJyNKc08rfVFsTycjSnNPSXRRYE8sNTpST0pbUWBPJyNFcE9KaVFgTycjS1NPSnRRYE8nI0tST0p0UWBPJyNLUk9KfFFgTyw1O15PS1JRYE8nI0tRT09RITBMbiw1Ol4sNTpeT0tZUWxPLDU6Xk9NV1EhME14Tyw1OmZPTXdRYE8sNTpuT05iUSEwTHJPJyNLUE9OaVFgTycjS09POWFRYE8nI0tPT059UWBPJyNLT08hIFZRYE8sNTtdTyEgW1FgTycjS09PISNhUSFmTycjSnJPT1EhMExoJyNDaScjQ2lPJVtRbE8nI0VTTyEkUFEhZk8sNTpzT09RUycjSnknI0p5T09RTy1FPGktRTxpTzlnUWBPLDU9X08hJGdRYE8sNT1fTyEkbFFsTyw1O1pPISZvUU1oTycjRWtPIShZUWBPLDU7Wk8hKF9RbE8nI0R5TyEoaVFwTyw1O2RPIShxUXBPLDU7ZE8lW1FsTyw1O2RPT1FbJyNGVCcjRlRPT1FbJyNGVicjRlZPJVtRbE8sNTtlTyVbUWxPLDU7ZU8lW1FsTyw1O2VPJVtRbE8sNTtlTyVbUWxPLDU7ZU8lW1FsTyw1O2VPJVtRbE8sNTtlTyVbUWxPLDU7ZU8lW1FsTyw1O2VPJVtRbE8sNTtlT09RWycjRlonI0ZaTyEpUFFsTyw1O3RPT1EhMExmLDU7eSw1O3lPT1EhMExmLDU7eiw1O3pPT1EhMExmLDU7fCw1O3xPJVtRbE8nI0lvTyErU1EhMExyTyw1PGlPJVtRbE8sNTtlTyEmb1FNaE8sNTtlTyErcVFNaE8sNTtlTyEtY1FNaE8nI0VeTyVbUWxPLDU7d09PUSEwTGYsNTt7LDU7e08hLWpRLFVPJyNGak8hLmdRLFVPJyNLV08hLlJRLFVPJyNLV08hLm5RLFVPJyNLV09PUU8nI0tXJyNLV08hL1NRLFVPLDU8U09PT1csNTxgLDU8YE8hL2VRbE8nI0Z2T09PVycjSW4nI0luTzdWTzdkTyw1PFFPIS9sUSxVTycjRnhPT1EhMExmLDU8USw1PFFPITBdUSRJVU8nI0N5T09RITBMaCcjQ30nI0N9TyEwcE8jQEl0TycjRFJPITFeUU1qTyw1PGVPITFlUWBPLDU8aE8hM1FRKENXTycjR1hPITNfUWBPJyNHWU8hM2RRYE8nI0dZTyE1U1EoQ1dPJyNHXk8hNlhRcE8nI0diT09RTycjR24nI0duTyEreFFNaE8nI0dtT09RTycjR3AnI0dwTyEreFFNaE8nI0dvTyE2elEkSVVPJyNKa09PUSEwTGgnI0prJyNKa08hN1VRYE8nI0pqTyE3ZFFgTycjSmlPITdsUWBPJyNDdU9PUSEwTGgnI0N7JyNDe08hN31RYE8nI0N9T09RITBMaCcjRFYnI0RWT09RITBMaCcjRFgnI0RYTzFTUWBPJyNEWk8hK3hRTWhPJyNHUE8hK3hRTWhPJyNHUk8hOFNRYE8nI0dUTyE4WFFgTycjR1VPITNkUWBPJyNHW08hK3hRTWhPJyNHYU88UVFgTycjSmpPITheUWBPJyNFcU8hOHtRYE8sNTxnT09RITBMYicjQ3InI0NyTyE5VFFgTycjRXJPITl9UXBPJyNFc09PUSEwTGInI0tRJyNLUU8hOlVRITBMck8nI0tgTzlxUSEwTHJPLDU9Y09gUWxPLDU+c09PUVsnI0pnJyNKZ09PUVssNT50LDU+dE9PUVstRTxbLUU8W08hPFRRITBNeE8sNTpiTyE5eFFwTyw1OmBPIT5uUSEwTXhPLDU6ak8lW1FsTyw1OmpPIUFVUSEwTXhPLDU6bE9PUU8sNUB5LDVAeU8hQXVRTWhPLDU9X08hQlRRITBMck8nI0poTzlbUWBPJyNKaE8hQmZRITBMck8sNTlaTyFCcVFwTyw1OVpPIUJ5UU1oTyw1OVpPOmBRTWhPLDU5Wk8hQ1VRYE8sNTtaTyFDXlFgTycjSGFPIUNyUWBPJyNLY08lW1FsTyw1O31PITl4UXBPLDU8UE8hQ3pRYE8sNT16TyFEUFFgTyw1PXpPIURVUWBPLDU9ek85cVEhMExyTyw1PXpPPFFRYE8sNT1qT09RTycjQ3knI0N5TyFEZFFwTyw1PWdPIURsUU1oTyw1PWhPIUR3UWBPLDU9ak8hRHxRIWJPLDU9bU8hRVVRYE8nI0tfTz59UWBPJyNIV085Z1FgTycjSFlPIUVaUWBPJyNIWU86YFFNaE8nI0hbTyFFYFFgTycjSFtPT1FbLDU9cCw1PXBPIUVlUWBPJyNIXU8hRXZRYE8nI0NvTyFFe1FgTyw1OVBPIUZWUWBPLDU5UE8hSFtRbE8sNTlQT09RWyw1OVAsNTlQTyFIbFEhMExyTyw1OVBPJVtRbE8sNTlQTyFKd1FsTycjSGRPT1FbJyNIZScjSGVPT1FbJyNIZicjSGZPYFFsTyw1PXxPIUtfUWBPLDU9fE9gUWxPLDU+U09gUWxPLDU+VU8hS2RRYE8sNT5XT2BRbE8sNT5ZTyFLaVFgTyw1Pl1PIUtuUWxPLDU+Y09PUVssNT5pLDU+aU8lW1FsTyw1PmlPOXFRITBMck8sNT5rT09RWyw1Pm0sNT5tTyMgeFFgTyw1Pm1PT1FbLDU+byw1Pm9PIyB4UWBPLDU+b09PUVssNT5xLDU+cU8jIWZRcE8nI0RfTyVbUWxPJyNKdU8jI1hRcE8nI0p1TyMjY1FwTycjRG1PIyN0UXBPJyNEbU8jJlZRbE8nI0RtTyMmXlFgTycjSnRPIyZmUWBPLDU6V08jJmtRYE8nI0V0TyMmeVFgTycjS1RPIydSUWBPLDU7X08jJ1dRcE8nI0RtTyMnZVFwTycjRVZPT1EhMExmLDU6byw1Om9PJVtRbE8sNTpvTyMnbFFgTyw1Om9PPn1RYE8sNTtZTyFCcVFwTyw1O1lPIUJ5UU1oTyw1O1lPOmBRTWhPLDU7WU8jJ3RRYE8sNUBhTyMneVEwN2RPLDU6c09PUU8tRTxlLUU8ZU8jKVBRITBNU08sNTtST0N7UXBPLDU6ck8jKVpRcE8sNTpyT0N7UXBPLDU7Uk8hQmZRITBMck8sNTpyT09RITBMYicjRWonI0VqT09RTyw1O1IsNTtSTyVbUWxPLDU7Uk8jKWhRITBMck8sNTtSTyMpc1EhMExyTyw1O1JPIUJxUXBPLDU6ck9PUU8sNTtYLDU7WE8jKlJRITBMck8sNTtSUE9PTycjSV0nI0ldUCMqZ08mMkRqTyw1OHxQT09PLDU4fCw1OHxPT09PLUU8XS1FPF1PT1EhMExoMUcucDFHLnBPT09PLUU8Xi1FPF5PT09PLDU5fSw1OX1PIypyUSFiTyw1OX1PT09PLUU8YC1FPGBPT1EhMExmMUcvZzFHL2dPIyp3USFmTyw1Pn1PK31RbE8sNT59T09RTyw1P1QsNT9UTyMrUlFsTycjSWNPT1FPLUU8YS1FPGFPIytgUWBPLDVAX08jK2hRIWZPLDVAX08jK29RYE8sNUBtT09RITBMZjFHL20xRy9tTyVbUWxPLDVAbk8jK3dRYE8nI0lpT09RTy1FPGctRTxnTyMrb1FgTyw1QG1PT1EhMExiMUcweDFHMHhPT1EhMExuMUcveDFHL3hPT1EhMExuMUcwWTFHMFlPJVtRbE8sNUBrTyMsXVEhMExyTyw1QGtPIyxuUSEwTHJPLDVAa08jLHVRYE8sNUBqTzlhUWBPLDVAak8jLH1RYE8sNUBqTyMtXVFgTycjSWxPIyx1UWBPLDVAak9PUSEwTGIxRzB3MUcwd08hKGlRcE8sNTp1TyEodFFwTyw1OnVPT1FTLDU6dyw1OndPIy19UWRPLDU6d08jLlZRTWhPMUcyeU85Z1FgTzFHMnlPT1EhMExmMUcwdTFHMHVPIy5lUSEwTXhPMUcwdU8jL2pRITBNdk8sNTtWT09RITBMaCcjR1cnI0dXTyMwV1EhME16TycjSmtPISRsUWxPMUcwdU8jMmNRIWZPJyNKdk8lW1FsTycjSnZPIzJtUWBPLDU6ZU9PUSEwTGgnI0RfJyNEX09PUSEwTGYxRzFPMUcxT08lW1FsTzFHMU9PT1EhMExmMUcxZjFHMWZPIzJyUWBPMUcxT08jNVdRITBNeE8xRzFQTyM1X1EhME14TzFHMVBPIzd1USEwTXhPMUcxUE8jN3xRITBNeE8xRzFQTyM6ZFEhME14TzFHMVBPIzx6USEwTXhPMUcxUE8jPVJRITBNeE8xRzFQTyM9WVEhME14TzFHMVBPIz9wUSEwTXhPMUcxUE8jP3dRITBNeE8xRzFQTyNCVVE/TXRPJyNDaU8jRFBRP010TzFHMWBPI0RXUT9NdE8nI0pyTyNEa1EhME14Tyw1P1pPT1EhMExiLUU8bS1FPG1PI0Z4USEwTXhPMUcxUE8jR3VRITBNek8xRzFQT09RITBMZjFHMVAxRzFQTyNIeFFNak8nI0p7TyNJU1FgTyw1OnhPI0lYUSEwTXhPMUcxY08jSXtRLFVPLDU8V08jSlRRLFVPLDU8WE8jSl1RLFVPJyNGb08jSnRRYE8nI0ZuT09RTycjS1gnI0tYT09RTycjSW0nI0ltTyNKeVEsVU8xRzFuT09RITBMZjFHMW4xRzFuT09PVzFHMXkxRzF5TyNLW1E/TXRPJyNKcU8jS2ZRYE8sNTxiTyEpUFFsTyw1PGJPT09XLUU8bC1FPGxPT1EhMExmMUcxbDFHMWxPI0trUXBPJyNLV09PUSEwTGYsNTxkLDU8ZE8jS3NRcE8sNTxkTyNLeFFNaE8nI0RUT09PTycjSWEnI0lhTyNMUE8jQEl0Tyw1OW1PT1EhMExoLDU5bSw1OW1PJVtRbE8xRzJQTyE4WFFgTycjSXFPI0xbUWBPLDU8ek9PUSEwTGgsNTx3LDU8d08hK3hRTWhPJyNJdE8jTHhRTWpPLDU9WE8hK3hRTWhPJyNJdk8jTWtRTWpPLDU9Wk8hJm9RTWhPLDU9XU9PUU8xRzJTMUcyU08jTXVRIWRPJyNDck8jTllRKENXTycjRXJPJCBfUXBPJyNHYk8kIHVRIWRPLDU8c08kIHxRYE8nI0taTzlhUWBPJyNLWk8kIVtRYE8sNTx1TyEreFFNaE8sNTx0TyQhYVFgTycjR1pPJCFyUWBPLDU8dE8kIXdRIWRPJyNHV08kI1VRIWRPJyNLW08kI2BRYE8nI0tbTyEmb1FNaE8nI0tbTyQjZVFgTyw1PHhPJCNqUWxPJyNKdU8kI3RRcE8nI0djTyMjdFFwTycjR2NPJCRWUWBPJyNHZ08hM2RRYE8nI0drTyQkW1EhMExyTycjSXNPJCRnUXBPLDU8fE9PUSEwTHAsNTx8LDU8fE8kJG5RcE8nI0djTyQke1FwTycjR2RPJCVeUXBPJyNHZE8kJWNRTWpPLDU9WE8kJXNRTWpPLDU9Wk9PUSEwTGgsNT1eLDU9Xk8hK3hRTWhPLDVAVU8hK3hRTWhPLDVAVU8kJlRRYE8nI0l4TyQmaVFgTyw1QFRPJCZxUWBPLDU5YU9PUSEwTGgsNTlpLDU5aU8kJ2hRJElZTyw1OXVPT1EhMExoJyNKbycjSm9PJChaUU1qTyw1PGtPJCh8UU1qTyw1PG1PQG9RYE8sNTxvT09RITBMaCw1PHAsNTxwTyQpV1FgTyw1PHZPJCldUU1qTyw1PHtPJCltUWBPLDVAVU8kKXtRYE8nI0tPTyEkbFFsTzFHMlJPJCpRUWBPMUcyUk85YVFgTycjS1JPOWFRYE8nI0V0TyVbUWxPJyNFdE85YVFgTycjSXpPJCpWUSEwTHJPLDVAek9PUVsxRzJ9MUcyfU9PUVsxRzRfMUc0X09PUSEwTGYxRy98MUcvfE9PUSEwTGYxRy96MUcvek8kLFhRITBNeE8xRzBVT09RWzFHMnkxRzJ5TyEmb1FNaE8xRzJ5TyVbUWxPMUcyeU8jLllRYE8xRzJ5TyQuXVFNaE8nI0VrT09RITBMYiw1QFMsNUBTTyQualEhMExyTyw1QFNPT1FbMUcudTFHLnVPIUJmUSEwTHJPMUcudU8hQnFRcE8xRy51TyFCeVFNaE8xRy51TyQue1FgTzFHMHVPJC9RUWBPJyNDaU8kL11RYE8nI0tkTyQvZVFgTyw1PXtPJC9qUWBPJyNLZE8kL29RYE8nI0tkTyQvfVFgTycjSlFPJDBdUWBPLDVAfU8kMGVRIWZPMUcxaU9PUSEwTGYxRzFrMUcxa085Z1FgTzFHM2ZPQG9RYE8xRzNmTyQwbFFgTzFHM2ZPJDBxUWBPMUczZk9PUVsxRzNmMUczZk8hRHdRYE8xRzNVTyEmb1FNaE8xRzNSTyQwdlFgTzFHM1JPT1FbMUczUzFHM1NPISZvUU1oTzFHM1NPJDB7UWBPMUczU08kMVRRcE8nI0hRT09RWzFHM1UxRzNVTyE2U1FwTycjSXxPIUR8USFiTzFHM1hPT1FbMUczWDFHM1hPT1FbLDU9ciw1PXJPJDFdUU1oTyw1PXRPOWdRYE8sNT10TyQkVlFgTyw1PXZPOVtRYE8sNT12TyFCcVFwTyw1PXZPIUJ5UU1oTyw1PXZPOmBRTWhPLDU9dk8kMWtRYE8nI0tiTyQxdlFgTyw1PXdPT1FbMUcuazFHLmtPJDF7USEwTHJPMUcua09Ab1FgTzFHLmtPJDJXUWBPMUcua085cVEhMExyTzFHLmtPJDRgUSFmTyw1QVBPJDRtUWBPLDVBUE85YVFgTyw1QVBPJDR4UWxPLDU+T08kNVBRYE8sNT5PT09RWzFHM2gxRzNoT2BRbE8xRzNoT09RWzFHM24xRzNuT09RWzFHM3AxRzNwTz54UWBPMUczck8kNVVRbE8xRzN0TyQ5WVFsTycjSHNPT1FbMUczdzFHM3dPJDlnUWBPJyNIeU8+fVFgTycjSHtPT1FbMUczfTFHM31PJDlvUWxPMUczfU85cVEhMExyTzFHNFRPT1FbMUc0VjFHNFZPT1EhMExiJyNHXycjR19POXFRITBMck8xRzRYTzlxUSEwTHJPMUc0Wk8kPXZRYE8sNUBhTyEpUFFsTyw1O2BPOWFRYE8sNTtgTz59UWBPLDU6WE8hKVBRbE8sNTpYTyFCcVFwTyw1OlhPJD17UT9NdE8sNTpYT09RTyw1O2AsNTtgTyQ+VlFwTycjSWRPJD5tUWBPLDVAYE9PUSEwTGYxRy9yMUcvck8kPnVRcE8nI0lqTyQ/UFFgTyw1QG9PT1EhMExiMUcweTFHMHlPIyN0UXBPLDU6WE9PUU8nI0lmJyNJZk8kP1hRcE8sNTpxT09RITBMbiw1OnEsNTpxTyMnb1FgTzFHMFpPT1EhMExmMUcwWjFHMFpPJVtRbE8xRzBaT09RITBMZjFHMHQxRzB0Tz59UWBPMUcwdE8hQnFRcE8xRzB0TyFCeVFNaE8xRzB0T09RITBMYjFHNXsxRzV7TyFCZlEhMExyTzFHMF5PT1FPMUcwbTFHMG1PJVtRbE8xRzBtTyQ/YFEhMExyTzFHMG1PJD9rUSEwTHJPMUcwbU8hQnFRcE8xRzBeT0N7UXBPMUcwXk8kP3lRITBMck8xRzBtT09RTzFHMF4xRzBeTyRAX1EhME14TzFHMG1QT09PLUU8Wi1FPFpQT09PMUcuaDFHLmhPT09PMUcvaTFHL2lPJEBpUSFiTyw1PGlPJEBxUSFmTzFHNGlPT1FPMUc0bzFHNG9PJVtRbE8sNT59TyRAe1FgTzFHNXlPJEFUUWBPMUc2WE8kQV1RIWZPMUc2WU85YVFgTyw1P1RPJEFnUSEwTXhPMUc2Vk8lW1FsTzFHNlZPJEF3USEwTHJPMUc2Vk8kQllRYE8xRzZVTyRCWVFgTzFHNlVPOWFRYE8xRzZVTyRCYlFgTyw1P1dPOWFRYE8sNT9XT09RTyw1P1csNT9XTyRCdlFgTyw1P1dPJCl7UWBPLDU/V09PUU8tRTxqLUU8ak9PUVMxRzBhMUcwYU9PUVMxRzBjMUcwY08jLlFRYE8xRzBjT09RWzcrKGU3KyhlTyEmb1FNaE83KyhlTyVbUWxPNysoZU8kQ1VRYE83KyhlTyRDYVFNaE83KyhlTyRDb1EhME16Tyw1PVhPJEV6USEwTXpPLDU9Wk8kSFZRITBNek8sNT1YTyRKaFEhME16Tyw1PVpPJEx5USEwTXpPLDU5dU8lIE9RITBNek8sNTxrTyUjWlEhME16Tyw1PG1PJSVmUSEwTXpPLDU8e09PUSEwTGY3KyZhNysmYU8lJ3dRITBNeE83KyZhTyUoa1FsTycjSWVPJSh4UWBPLDVAYk8lKVFRIWZPLDVAYk9PUSEwTGYxRzBQMUcwUE8lKVtRYE83KyZqT09RITBMZjcrJmo3KyZqTyUpYVE/TXRPLDU6Zk8lW1FsTzcrJnpPJSlrUT9NdE8sNTpiTyUpeFE/TXRPLDU6ak8lKlNRP010Tyw1OmxPJSpeUU1oTycjSWhPJSpoUWBPLDVAZ09PUSEwTGgxRzBkMUcwZE9PUU8xRzFyMUcxck9PUU8xRzFzMUcxc08lKnBRIWpPLDU8Wk8hKVBRbE8sNTxZT09RTy1FPGstRTxrT09RITBMZjcrJ1k3KydZT09PVzcrJ2U3KydlT09PVzFHMXwxRzF8TyUqe1FgTzFHMXxPT1EhMExmMUcyTzFHMk9PT09PLDU5byw1OW9PJStRUSFkTyw1OW9PT09PLUU8Xy1FPF9PT1EhMExoMUcvWDFHL1hPJStYUSEwTXhPNysna09PUSEwTGgsNT9dLDU/XU8lK3tRTWhPMUcyZlAlLFNRYE8nI0lxUE9RITBMaC1FPG8tRTxvTyUscFFNak8sNT9gT09RITBMaC1FPHItRTxyTyUtY1FNak8sNT9iT09RITBMaC1FPHQtRTx0TyUtbVEhZE8xRzJ3TyUtdFEhZE8nI0NyTyUuW1FNaE8nI0tSTyQjalFsTycjSnVPT1EhMExoMUcyXzFHMl9PJS5jUWBPJyNJcE8lLndRYE8sNUB1TyUud1FgTyw1QHVPJS9QUWBPLDVAdU8lL1tRYE8sNUB1T09RTzFHMmExRzJhTyUvalFNak8xRzJgTyEreFFNaE8xRzJgTyUvelEoQ1dPJyNJck8lMFhRYE8sNUB2TyEmb1FNaE8sNUB2TyUwYVEhZE8sNUB2T09RITBMaDFHMmQxRzJkTyUycVEhZk8nI0NpTyUye1FgTyw1PVBPT1EhMExiLDU8fSw1PH1PJTNUUXBPLDU8fU9PUSEwTGIsNT1PLDU9T09DbFFgTyw1PH1PJTNgUXBPLDU8fU9PUSEwTGIsNT1SLDU9Uk8kKXtRYE8sNT1WT09RTyw1P18sNT9fT09RTy1FPHEtRTxxT09RITBMcDFHMmgxRzJoTyMjdFFwTyw1PH1PJCNqUWxPLDU9UE8lM25RYE8sNT1PTyUzeVFwTyw1PU9PISt4UU1oTycjSXRPJTRzUU1qTzFHMnNPISt4UU1oTycjSXZPJTVmUU1qTzFHMnVPJTVwUU1qTzFHNXBPJTV6UU1qTzFHNXBPT1FPLDU/ZCw1P2RPT1FPLUU8di1FPHZPT1FPMUcuezFHLntPITl4UXBPLDU5d08lW1FsTyw1OXdPT1EhMExoLDU8aiw1PGpPJTZYUWBPMUcyWk8hK3hRTWhPMUcyYk8hK3hRTWhPMUc1cE8hK3hRTWhPMUc1cE8lNl5RITBNeE83KydtT09RITBMZjcrJ203KydtTyEkbFFsTzcrJ21PJTdRUWBPLDU7YE9PUSEwTGIsNT9mLDU/Zk9PUSEwTGItRTx4LUU8eE8lN1ZRIWRPJyNLXU8jJ29RYE83KyhlTzRVUSFmTzcrKGVPJENYUWBPNysoZU8lN2FRITBNdk8nI0NpTyU3dFEhME12Tyw1PVNPJThmUWBPLDU9U08lOG5RYE8sNT1TT09RITBMYjFHNW4xRzVuT09RWzcrJGE3KyRhTyFCZlEhMExyTzcrJGFPIUJxUXBPNyskYU8hJGxRbE83KyZhTyU4c1FgTycjSlBPJTlbUWBPLDVBT09PUU8xRzNnMUczZ085Z1FgTyw1QU9PJTlbUWBPLDVBT08lOWRRYE8sNUFPT09RTyw1P2wsNT9sT09RTy1FPU8tRT1PT09RITBMZjcrJ1Q3KydUTyU5aVFgTzcrKVFPOXFRITBMck83KylRTzlnUWBPNyspUU9Ab1FgTzcrKVFPT1FbNysocDcrKHBPJTluUSEwTXZPNysobU8hJm9RTWhPNysobU8hRHJRYE83KyhuT09RWzcrKG43KyhuTyEmb1FNaE83KyhuTyU5eFFgTycjS2FPJTpUUWBPLDU9bE9PUU8sNT9oLDU/aE9PUU8tRTx6LUU8ek9PUVs3KyhzNysoc08lO2dRcE8nI0haT09RWzFHM2AxRzNgTyEmb1FNaE8xRzNgTyVbUWxPMUczYE8lO25RYE8xRzNgTyU7eVFNaE8xRzNgTzlxUSEwTHJPMUczYk8kJFZRYE8xRzNiTzlbUWBPMUczYk8hQnFRcE8xRzNiTyFCeVFNaE8xRzNiTyU8WFFgTycjSk9PJTxtUWBPLDVAfE8lPHVRcE8sNUB8T09RITBMYjFHM2MxRzNjT09RWzcrJFY3KyRWT0BvUWBPNyskVk85cVEhMExyTzcrJFZPJT1RUWBPNyskVk8lW1FsTzFHNmtPJVtRbE8xRzZsTyU9VlEhMExyTzFHNmtPJT1hUWxPMUczak8lPWhRYE8xRzNqTyU9bVFsTzFHM2pPT1FbNyspUzcrKVNPOXFRITBMck83KyleT2BRbE83KylgT09RWycjS2cnI0tnT09RWycjSlInI0pSTyU9dFFsTyw1Pl9PT1FbLDU+Xyw1Pl9PJVtRbE8nI0h0TyU+UlFgTycjSHZPT1FbLDU+ZSw1PmVPOWFRYE8sNT5lT09RWyw1PmcsNT5nT09RWzcrKWk3KylpT09RWzcrKW83KylvT09RWzcrKXM3KylzT09RWzcrKXU3Kyl1TyU+V1FwTzFHNXtPJT5yUT9NdE8xRzB6TyU+fFFgTzFHMHpPT1FPMUcvczFHL3NPJT9YUT9NdE8xRy9zTz59UWBPMUcvc08hKVBRbE8nI0RtT09RTyw1P08sNT9PT09RTy1FPGItRTxiT09RTyw1P1UsNT9VT09RTy1FPGgtRTxoTyFCcVFwTzFHL3NPT1FPLUU8ZC1FPGRPT1EhMExuMUcwXTFHMF1PT1EhMExmNysldTcrJXVPIydvUWBPNysldU9PUSEwTGY3KyZgNysmYE8+fVFgTzcrJmBPIUJxUXBPNysmYE9PUU83KyV4NysleE8kQF9RITBNeE83KyZYT09RTzcrJlg3KyZYTyVbUWxPNysmWE8lP2NRITBMck83KyZYTyFCZlEhMExyTzcrJXhPIUJxUXBPNysleE8lP25RITBMck83KyZYTyU/fFEhME14TzcrK3FPJVtRbE83KytxTyVAXlFgTzcrK3BPJUBeUWBPNysrcE9PUU8xRzRyMUc0ck85YVFgTzFHNHJPJUBmUWBPMUc0ck9PUVM3KyV9NyslfU8jJ29RYE88PExQTzRVUSFmTzw8TFBPJUB0UWBPPDxMUE9PUVs8PExQPDxMUE8hJm9RTWhPPDxMUE8lW1FsTzw8TFBPJUB8UWBPPDxMUE8lQVhRITBNek8sNT9gTyVDZFEhME16Tyw1P2JPJUVvUSEwTXpPMUcyYE8lSFFRITBNek8xRzJzTyVKXVEhME16TzFHMnVPJUxoUSFmTyw1P1BPJVtRbE8sNT9QT09RTy1FPGMtRTxjTyVMclFgTzFHNXxPT1EhMExmPDxKVTw8SlVPJUx6UT9NdE8xRzB1TyYgUlE/TXRPMUcxUE8mIFlRP010TzFHMVBPJiNaUT9NdE8xRzFQTyYjYlE/TXRPMUcxUE8mJWNRP010TzFHMVBPJidkUT9NdE8xRzFQTyYna1E/TXRPMUcxUE8mJ3JRP010TzFHMVBPJilzUT9NdE8xRzFQTyYpelE/TXRPMUcxUE8mKlJRITBNeE88PEpmTyYreVE/TXRPMUcxUE8mLHZRP012TzFHMVBPJi15UT9Ndk8nI0prTyYwUFE/TXRPMUcxY08mMF5RP010TzFHMFVPJjBoUU1qTyw1P1NPT1FPLUU8Zi1FPGZPISlQUWxPJyNGcU9PUU8nI0tZJyNLWU9PUU8xRzF1MUcxdU8mMHJRYE8xRzF0TyYwd1E/TXRPLDU/Wk9PT1c3KydoNysnaE9PT08xRy9aMUcvWk8mMVJRIWRPMUc0d09PUSEwTGg3KyhRNysoUVAhJm9RTWhPLDU/XU8hK3hRTWhPNysoY08mMVlRYE8sNT9bTzlhUWBPLDU/W09PUU8tRTxuLUU8bk8mMWhRYE8xRzZhTyYxaFFgTzFHNmFPJjFwUWBPMUc2YU8mMXtRTWpPNysnek8mMl1RIWRPLDU/Xk8mMmdRYE8sNT9eTyEmb1FNaE8sNT9eT09RTy1FPHAtRTxwTyYybFEhZE8xRzZiTyYydlFgTzFHNmJPJjNPUWBPMUcya08hJm9RTWhPMUcya09PUSEwTGIxRzJpMUcyaU9PUSEwTGIxRzJqMUcyak8lM1RRcE8xRzJpTyFCcVFwTzFHMmlPQ2xRYE8xRzJpT09RITBMYjFHMnExRzJxTyYzVFFwTzFHMmlPJjNjUWBPMUcya08kKXtRYE8xRzJqT0NsUWBPMUcyak8kI2pRbE8xRzJrTyYza1FgTzFHMmpPJjRfUU1qTyw1P2BPT1EhMExoLUU8cy1FPHNPJjVRUU1qTyw1P2JPT1EhMExoLUU8dS1FPHVPISt4UU1oTzcrK1tPT1EhMExoMUcvYzFHL2NPJjVbUWBPMUcvY09PUSEwTGg3Kyd1NysndU8mNWFRTWpPNysnfE8mNXFRTWpPNysrW08mNXtRTWpPNysrW08mNllRITBNeE88PEtYT09RITBMZjw8S1g8PEtYTyY2fFFgTzFHMHpPISZvUU1oTycjSXlPJjdSUWBPLDVAd08mOVRRIWZPPDxMUE8hJm9RTWhPMUcybk8mOVtRITBMck8xRzJuT09RWzw8R3s8PEd7TyFCZlEhMExyTzw8R3tPJjltUSEwTXhPPDxJe09PUSEwTGY8PEl7PDxJe09PUU8sNT9rLDU/a08mOmFRYE8sNT9rTyY6ZlFgTyw1P2tPT1FPLUU8fS1FPH1PJjp0UWBPMUc2ak8mOnRRYE8xRzZqTzlnUWBPMUc2ak9Ab1FgTzw8TGxPT1FbPDxMbDw8TGxPJjp8UWBPPDxMbE85cVEhMExyTzw8TGxPT1FbPDxMWDw8TFhPJTluUSEwTXZPPDxMWE9PUVs8PExZPDxMWU8hRHJRYE88PExZTyY7UlFwTycjSXtPJjteUWBPLDVAe08hKVBRbE8sNUB7T09RWzFHM1cxRzNXT09RTycjSX0nI0l9TzlxUSEwTHJPJyNJfU8mO2ZRcE8sNT11T09RWyw1PXUsNT11TyY7bVFwTycjRWdPJjt0UXBPJyNHZU8mO3lRYE83Kyh6TyY8T1FgTzcrKHpPT1FbNysoejcrKHpPISZvUU1oTzcrKHpPJVtRbE83Kyh6TyY8V1FgTzcrKHpPT1FbNysofDcrKHxPOXFRITBMck83Kyh8TyQkVlFgTzcrKHxPOVtRYE83Kyh8TyFCcVFwTzcrKHxPJjxjUWBPLDU/ak9PUU8tRTx8LUU8fE9PUU8nI0heJyNIXk8mPG5RYE8xRzZoTzlxUSEwTHJPPDxHcU9PUVs8PEdxPDxHcU9Ab1FgTzw8R3FPJjx2UWBPNyssVk8mPHtRYE83KyxXTyVbUWxPNyssVk8lW1FsTzcrLFdPT1FbNyspVTcrKVVPJj1RUWBPNyspVU8mPVZRbE83KylVTyY9XlFgTzcrKVVPT1FbPDxMeDw8THhPT1FbPDxMejw8THpPT1FbLUU9UC1FPVBPT1FbMUczeTFHM3lPJj1jUWBPLDU+YE9PUVssNT5iLDU+Yk8mPWhRYE8xRzRQTzlhUWBPNysmZk8hKVBRbE83KyZmT09RTzcrJV83KyVfTyY9bVE/TXRPMUc2WU8+fVFgTzcrJV9PT1EhMExmPDxJYTw8SWFPT1EhMExmPDxJejw8SXpPPn1RYE88PEl6T09RTzw8SXM8PElzTyRAX1EhME14Tzw8SXNPJVtRbE88PElzT09RTzw8SWQ8PElkTyFCZlEhMExyTzw8SWRPJj13USEwTHJPPDxJc08mPlNRITBNeE88PSBdTyY+ZFFgTzw9IFtPT1FPNysqXjcrKl5POWFRYE83KypeT09RW0FOQWtBTkFrTyY+bFEhZk9BTkFrTyEmb1FNaE9BTkFrTyMnb1FgT0FOQWtPNFVRIWZPQU5Ba08mPnNRYE9BTkFrTyVbUWxPQU5Ba08mPntRITBNek83Kyd6TyZBXlEhME16Tyw1P2BPJkNpUSEwTXpPLDU/Yk8mRXRRITBNek83Kyd8TyZIVlEhZk8xRzRrTyZIYVE/TXRPNysmYU8mSmVRP012Tyw1PVhPJkxsUT9Ndk8sNT1aTyZMfFE/TXZPLDU9WE8mTV5RP012Tyw1PVpPJk1uUT9Ndk8sNTl1TycgdFE/TXZPLDU8a08nI3dRP012Tyw1PG1PJyZdUT9Ndk8sNTx7TycoUlE/TXRPNysna08nKGBRP010TzcrJ21PJyhtUWBPLDU8XU9PUU83KydgNysnYE9PUSEwTGg3KypjNysqY08nKHJRTWpPPDxLfU9PUU8xRzR2MUc0dk8nKHlRYE8xRzR2TycpVVFgTzFHNHZPJylkUWBPNysre08nKWRRYE83Kyt7TyEmb1FNaE8xRzR4TycpbFEhZE8xRzR4TycpdlFgTzcrK3xPJypPUWBPNysoVk8nKlpRIWRPNysoVk9PUSEwTGI3KyhUNysoVE9PUSEwTGI3KyhVNysoVU8hQnFRcE83KyhUT0NsUWBPNysoVE8nKmVRYE83KyhWTyEmb1FNaE83KyhWTyQpe1FgTzcrKFVPJypqUWBPNysoVk9DbFFgTzcrKFVPJypyUU1qTzw8TnZPT1EhMExoNyskfTcrJH1PISt4UU1oTzw8TnZPJyp8USFkTyw1P2VPT1FPLUU8dy1FPHdPJytXUSEwTXZPNysoWU8hJm9RTWhPNysoWU9PUVtBTj1nQU49Z085Z1FgTzFHNVZPT1FPMUc1VjFHNVZPJytoUWBPMUc1Vk8nK21RYE83KyxVTycrbVFgTzcrLFVPOXFRITBMck9BTkJXT0BvUWBPQU5CV09PUVtBTkJXQU5CV09PUVtBTkFzQU5Bc09PUVtBTkF0QU5BdE8nK3VRYE8sNT9nT09RTy1FPHktRTx5TycsUVE/TXRPMUc2Z09PUU8sNT9pLDU/aU9PUU8tRTx7LUU8e09PUVsxRzNhMUczYU8nLFtRYE8sNT1QT09RWzw8TGY8PExmTyEmb1FNaE88PExmTyY7eVFgTzw8TGZPJyxhUWBPPDxMZk8lW1FsTzw8TGZPT1FbPDxMaDw8TGhPOXFRITBMck88PExoTyQkVlFgTzw8TGhPOVtRYE88PExoTycsaVFwTzFHNVVPJyx0UWBPNyssU09PUVtBTj1dQU49XU85cVEhMExyT0FOPV1PT1FbPD0gcTw9IHFPT1FbPD0gcjw9IHJPJyx8UWBPPD0gcU8nLVJRYE88PSByT09RWzw8THA8PExwTyctV1FgTzw8THBPJy1dUWxPPDxMcE9PUVsxRzN6MUczek8+fVFgTzcrKWtPJy1kUWBPPDxKUU8nLW9RP010Tzw8SlFPT1FPPDxIeTw8SHlPT1EhMExmQU4/ZkFOP2ZPT1FPQU4/X0FOP19PJEBfUSEwTXhPQU4/X09PUU9BTj9PQU4/T08lW1FsT0FOP19PT1FPPDxNeDw8TXhPT1FbRzI3VkcyN1ZPISZvUU1oT0cyN1ZPIydvUWBPRzI3Vk8nLXlRIWZPRzI3Vk80VVEhZk9HMjdWTycuUVFgT0cyN1ZPJy5ZUT9NdE88PEpmTycuZ1E/TXZPMUcyYE8nMF1RP012Tyw1P2BPJzJgUT9Ndk8sNT9iTyc0Y1E/TXZPMUcyc08nNmZRP012TzFHMnVPJzhpUT9NdE88PEtYTyc4dlE/TXRPPDxJe09PUU8xRzF3MUcxd08hK3hRTWhPQU5BaU9PUU83KypiNysqYk8nOVRRYE83KypiTyc5YFFgTzw9IGdPJzloUSFkTzcrKmRPT1EhMExiPDxLcTw8S3FPJCl7UWBPPDxLcU9DbFFgTzw8S3FPJzlyUWBPPDxLcU8hJm9RTWhPPDxLcU9PUSEwTGI8PEtvPDxLb08hQnFRcE88PEtvTyc5fVEhZE88PEtxT09RITBMYjw8S3A8PEtwTyc6WFFgTzw8S3FPISZvUU1oTzw8S3FPJCl7UWBPPDxLcE8nOl5RTWpPQU5EYk8nOmhRITBNdk88PEt0T09RTzcrKnE3KypxTzlnUWBPNysqcU8nOnhRYE88PSBwT09RW0cyN3JHMjdyTzlxUSEwTHJPRzI3ck8hKVBRbE8xRzVSTyc7UVFgTzcrLFJPJztZUWBPMUcya08mO3lRYE9BTkJRT09RW0FOQlFBTkJRTyEmb1FNaE9BTkJRTyc7X1FgT0FOQlFPT1FbQU5CU0FOQlNPOXFRITBMck9BTkJTTyQkVlFgT0FOQlNPT1FPJyNIXycjSF9PT1FPNysqcDcrKnBPT1FbRzIyd0cyMndPT1FbQU5FXUFORV1PT1FbQU5FXkFORV5PT1FbQU5CW0FOQltPJztnUWBPQU5CW09PUVs8PE1WPDxNVk8hKVBRbE9BTj9sT09RT0cyNHlHMjR5TyRAX1EhME14T0cyNHlPIydvUWBPTEQscU9PUVtMRCxxTEQscU8hJm9RTWhPTEQscU8nO2xRIWZPTEQscU8nO3NRP012TzcrJ3pPJz1pUT9Ndk8sNT9gTyc/bFE/TXZPLDU/Yk8nQW9RP012TzcrJ3xPJ0NlUU1qT0cyN1RPT1FPPDxNfDw8TXxPT1EhMExiQU5BXUFOQV1PJCl7UWBPQU5BXU9DbFFgT0FOQV1PJ0N1USFkT0FOQV1PT1EhMExiQU5BWkFOQVpPJ0N8UWBPQU5BXU8hJm9RTWhPQU5BXU8nRFhRIWRPQU5BXU9PUSEwTGJBTkFbQU5BW09PUU88PE5dPDxOXU9PUVtMRC1eTEQtXk8nRGNRP010TzcrKm1PT1FPJyNHZicjR2ZPT1FbRzI3bEcyN2xPJjt5UWBPRzI3bE8hJm9RTWhPRzI3bE9PUVtHMjduRzI3bk85cVEhMExyT0cyN25PT1FbRzI3dkcyN3ZPJ0RtUT9NdE9HMjVXT09RT0xEKmVMRCplT09RWyEkKCFdISQoIV1PIydvUWBPISQoIV1PISZvUU1oTyEkKCFdTydEd1EhME16T0cyN1RPT1EhMExiRzI2d0cyNndPJCl7UWBPRzI2d08nR1lRYE9HMjZ3T0NsUWBPRzI2d08nR2VRIWRPRzI2d08hJm9RTWhPRzI2d09PUVtMRC1XTEQtV08mO3lRYE9MRC1XT09RW0xELVlMRC1ZT09RWyEpOUV3ISk5RXdPIydvUWBPISk5RXdPT1EhMExiTEQsY0xELGNPJCl7UWBPTEQsY09DbFFgT0xELGNPJ0dsUWBPTEQsY08nR3dRIWRPTEQsY09PUVshJCghciEkKCFyT09RWyEuSztjIS5LO2NPJ0hPUT9Ndk9HMjdUT09RITBMYiEkKCB9ISQoIH1PJCl7UWBPISQoIH1PQ2xRYE8hJCggfU8nSXRRYE8hJCggfU9PUSEwTGIhKTlFaSEpOUVpTyQpe1FgTyEpOUVpT0NsUWBPISk5RWlPT1EhMExiIS5LO1QhLks7VE8kKXtRYE8hLks7VE9PUSEwTGIhNC8wbyE0LzBvTyEpUFFsTycjRHpPMVBRYE8nI0VYTydKUFEhZk8nI0pxTydKV1EhTF5PJyNEdk8nSl9RbE8nI0VPTydKZlEhZk8nI0NpTydMfFEhZk8nI0NpTyEpUFFsTycjRVFPJ01eUWxPLDU7Wk8hKVBRbE8sNTtlTyEpUFFsTyw1O2VPISlQUWxPLDU7ZU8hKVBRbE8sNTtlTyEpUFFsTyw1O2VPISlQUWxPLDU7ZU8hKVBRbE8sNTtlTyEpUFFsTyw1O2VPISlQUWxPLDU7ZU8hKVBRbE8sNTtlTyEpUFFsTycjSW9PKCBhUWBPLDU8aU8hKVBRbE8sNTtlTyggaVFNaE8sNTtlTygjU1FNaE8sNTtlTyEpUFFsTyw1O3dPISZvUU1oTycjR21PKCBpUU1oTycjR21PISZvUU1oTycjR29PKCBpUU1oTycjR29PMVNRYE8nI0RaTzFTUWBPJyNEWk8hJm9RTWhPJyNHUE8oIGlRTWhPJyNHUE8hJm9RTWhPJyNHUk8oIGlRTWhPJyNHUk8hJm9RTWhPJyNHYU8oIGlRTWhPJyNHYU8hKVBRbE8sNTpqTygjWlFwTycjRF9PKCNlUXBPJyNKdU8hKVBRbE8sNUBuTydNXlFsTzFHMHVPKCNvUT9NdE8nI0NpTyEpUFFsTzFHMlBPISZvUU1oTycjSXRPKCBpUU1oTycjSXRPISZvUU1oTycjSXZPKCBpUU1oTycjSXZPKCN5USFkTycjQ3JPISZvUU1oTyw1PHRPKCBpUU1oTyw1PHRPJ01eUWxPMUcyUk8hKVBRbE83KyZ6TyEmb1FNaE8xRzJgTyggaVFNaE8xRzJgTyEmb1FNaE8nI0l0TyggaVFNaE8nI0l0TyEmb1FNaE8nI0l2TyggaVFNaE8nI0l2TyEmb1FNaE8xRzJiTyggaVFNaE8xRzJiTydNXlFsTzcrJ21PJ01eUWxPNysmYU8hJm9RTWhPQU5BaU8oIGlRTWhPQU5BaU8oJF5RYE8nI0VvTygkY1FgTycjRW9PKCRrUWBPJyNGXU8oJHBRYE8nI0V5TygkdVFgTycjS1NPKCVRUWBPJyNLUU8oJV1RYE8sNTtaTyglYlFNak8sNTxlTyglaVFgTycjR1lPKCVuUWBPJyNHWU8oJXNRYE8sNTxnTygle1FgTyw1O1pPKCZUUT9NdE8xRzFgTygmW1FgTyw1PHRPKCZhUWBPLDU8dE8oJmZRYE8sNTx2Tygma1FgTyw1PHZPKCZwUWBPMUcyUk8oJnVRYE8xRzB1TygmelFNak88PEt9TygnUlFNak88PEt9TzdlUU1oTycjRnxPOVtRYE8nI0Z7T0FqUWBPJyNFbk8hKVBRbE8sNTt0TyEzZFFgTycjR1lPITNkUWBPJyNHWU8hM2RRYE8nI0dbTyEzZFFgTycjR1tPISt4UU1oTzcrKGNPISt4UU1oTzcrKGNPJS1tUSFkTzFHMndPJS1tUSFkTzFHMndPISZvUU1oTyw1PV1PISZvUU1oTyw1PV1cIixcbiAgc3RhdGVEYXRhOiBcIigoWH5PJ3tPUyd8T1NUT1MnfVJRfk9QWU9RWU9TZk9ZIVZPYXFPZHpPZXlPbCFQT3BrT3JZT3NrT3RrT3prT3xZTyFPWU8hU1dPIVdrTyFYa08hX1hPIWl1TyFsWk8hb1lPIXBZTyFxWU8hc3ZPIXV3TyF4eE8hfF1PJFd8TyRuaU8laH1PJWohUU8lbCFPTyVtIU9PJW4hT08lcSFSTyVzIVNPJXYhVE8ldyFUTyV5IVVPJlYhV08mXSFYTyZfIVlPJmEhWk8mYyFbTyZmIV1PJmwhXk8mciFfTyZ0IWBPJnYhYU8meCFiTyZ6IWNPKFNTTyhVVE8oWFVPKGBWTyhuW09+T1d0T35QYE9QWU9RWU9TZk9kIWpPZSFpT3BrT3JZT3NrT3RrT3prT3xZTyFPWU8hU1dPIVdrTyFYa08hXyFlTyFpdU8hbFpPIW9ZTyFwWU8hcVlPIXN2TyF1IWdPIXghaE8kVyFrTyRuaU8oUyFkTyhVVE8oWFVPKGBWTyhuW09+T2Ehd09zIW5PIVMhb08hYiF5TyFjIXZPIWQhdk8hfDt3TyNUIXBPI1UhcE8jViF4TyNXIXBPI1ghcE8jWyF6TyNdIXpPKFQhbE8oVVRPKFhVTyhkIW1PKG4hc09+Tyd9IXtPfk9QXVhSXVhbXVhhXVhqXVhyXVghUV1YIVNdWCFdXVghbF1YIXBdWCNSXVgjU11YI2BdWCNrZlgjbl1YI29dWCNwXVgjcV1YI3JdWCNzXVgjdF1YI3VdWCN2XVgjeF1YI3pdWCN7XVgkUV1YJ3ldWChgXVgocV1YKHhdWCh5XVh+TyFnJVJYflAocU9fIX1PKFUjUE8oViF9TyhXI1BPfk9fI1FPKFcjUE8oWCNQTyhZI1FPfk94I1NPIVUjVE8oYSNUTyhiI1ZPfk9QWU9RWU9TZk9kIWpPZSFpT3BrT3JZT3NrT3RrT3prT3xZTyFPWU8hU1dPIVdrTyFYa08hXyFlTyFpdU8hbFpPIW9ZTyFwWU8hcVlPIXN2TyF1IWdPIXghaE8kVyFrTyRuaU8oUzt7TyhVVE8oWFVPKGBWTyhuW09+TyFbI1pPIV0jV08hWShnUCFZKHVQflArfU8hXiNjT35QYE9QWU9RWU9TZk9kIWpPZSFpT3JZT3NrT3RrT3prT3xZTyFPWU8hU1dPIVdrTyFYa08hXyFlTyFpdU8hbFpPIW9ZTyFwWU8hcVlPIXN2TyF1IWdPIXghaE8kVyFrTyRuaU8oVVRPKFhVTyhgVk8obltPfk9wI21PIVsjaU8hfF1PI2kjbE8jaiNpTyhTO3xPIWsoclB+UC5pTyFsI29PKFMjbk9+TyF4I3NPIXxdTyVoI3RPfk8jayN1T35PIWcjdk8jayN1T35PUCRbT1Ijek9bJGNPaiRST3IkYU8hUSN5TyFTI3tPIV0kX08hbCN4TyFwJFtPI1IkUk8jbiRPTyNvJFBPI3AkUE8jcSRQTyNyJFFPI3MkUk8jdCRSTyN1JGJPI3YkU08jeCRVTyN6JFdPI3skWE8oYFZPKHEkWU8oeCN8Tyh5I31Pfk9hKGVYJ3koZVgndihlWCFrKGVYIVkoZVghXyhlWCVpKGVYIWcoZVh+UDFxTyNTJGRPI2AkZU8kUSRlT1AoZlhSKGZYWyhmWGooZlhyKGZYIVEoZlghUyhmWCFdKGZYIWwoZlghcChmWCNSKGZYI24oZlgjbyhmWCNwKGZYI3EoZlgjcihmWCNzKGZYI3QoZlgjdShmWCN2KGZYI3goZlgjeihmWCN7KGZYKGAoZlgocShmWCh4KGZYKHkoZlghXyhmWCVpKGZYfk9hKGZYJ3koZlgndihmWCFZKGZYIWsoZlh2KGZYIWcoZlh+UDRVTyNgJGVPfk8kXSRoTyRfJGdPJGYkbU9+T1NmTyFfJG5PJGkkb08kayRxT35PaCVWT2olY09rJWNPbCVjT3AlV09yJVhPcyR0T3QkdE96JVlPfCVaTyFPJVtPIVMke08hXyR8TyFpJWFPIWwkeE8jaiViTyRXJV9PJHQlXU8kdiVeTyR5JWBPKFMkc08oVVRPKFhVTyhgJHVPKHgkfU8oeSVQT2coXVB+TyFsJWRPfk8hUyVnTyFfJWhPKFMlZk9+TyFnJWxPfk9hJW1PJ3klbU9+TyFRJXFPflAlW08oVCFsT35QJVtPJW4ldU9+UCVbT2glVk8hbCVkTyhTJWZPKFQhbE9+T2UlfE8hbCVkTyhTJWZPfk9qJFJPfk8hUSZSTyFfJk9PIWwmUU8laiZVTyhTJWZPKFQhbE8oVVRPKFhVT2ApVlB+TyF4I3NPfk8lcyZXTyFTKVJYIV8pUlgoUylSWH5PKFMmWE9+T2whUE8hdSZeTyVqIVFPJWwhT08lbSFPTyVuIU9PJXEhUk8lcyFTTyV2IVRPJXchVE9+T2QmY09lJmJPIXgmYE8laCZhTyV7Jl9PflA8Vk9kJmZPZXlPbCFQTyFfJmVPIXUmXk8heHhPIXxdTyVofU8lbCFPTyVtIU9PJW4hT08lcSFSTyVzIVNPJXYhVE8ldyFUTyV5IVVPfk9iJmlPI2AmbE8laiZnTyhUIWxPflA9W08hbCZtTyF1JnFPfk8hbCNvT35PIV9YT35PYSVtTyd3JnlPJ3klbU9+T2ElbU8ndyZ8Tyd5JW1Pfk9hJW1PJ3cnT08neSVtT35PJ3ZdWCFZXVh2XVgha11YJlpdWCFfXVglaV1YIWddWH5QKHFPIWInXU8hYydVTyFkJ1VPKFQhbE8oVVRPKFhVT35PcydTTyFTJ1JPIVsnVk8oZCdRTyFeKGhQIV4od1B+UEBjT24nYE8hXydeTyhTJWZPfk9lJ2VPIWwlZE8oUyVmT35PIVEmUk8hbCZRT35PcyFuTyFTIW9PIXw7d08jVCFwTyNVIXBPI1chcE8jWCFwTyhUIWxPKFVUTyhYVU8oZCFtTyhuIXNPfk8hYidrTyFjJ2pPIWQnak8jViFwTyNbJ2xPI10nbE9+UEF9T2ElbU9oJVZPIWcjdk8hbCVkTyd5JW1PKHEnbk9+TyFwJ3JPI2AncE9+UENdT3Mhbk8hUyFvTyhVVE8oWFVPKGQhbU8obiFzT35PIV9YT3MobFghUyhsWCFiKGxYIWMobFghZChsWCF8KGxYI1QobFgjVShsWCNWKGxYI1cobFgjWChsWCNbKGxYI10obFgoVChsWChVKGxYKFgobFgoZChsWChuKGxYfk8hYydqTyFkJ2pPKFQhbE9+UEN7TyhPJ3ZPKFAndk8oUSd4T35PXyF9TyhVJ3pPKFYhfU8oVyd6T35PXyNRTyhXJ3pPKFgnek8oWSNRT35Pdid8T35QJVtPeCNTTyFVI1RPKGEjVE8oYihQT35PIVsoUk8hWSdWWCFZJ11YIV0nVlghXSddWH5QK31PIV0oVE8hWShnWH5PUCRbT1Ijek9bJGNPaiRST3IkYU8hUSN5TyFTI3tPIV0oVE8hbCN4TyFwJFtPI1IkUk8jbiRPTyNvJFBPI3AkUE8jcSRQTyNyJFFPI3MkUk8jdCRSTyN1JGJPI3YkU08jeCRVTyN6JFdPI3skWE8oYFZPKHEkWU8oeCN8Tyh5I31Pfk8hWShnWH5QR3ZPIVkoWU9+TyFZKHRYIV0odFghZyh0WCFrKHRYKHEodFh+TyNgKHRYI2sjZFghXih0WH5QSXlPI2AoWk8hWSh2WCFdKHZYfk8hXShbTyFZKHVYfk8hWShfT35PI2AkZU9+UEl5TyFeKGBPflBgT1Ijek8hUSN5TyFTI3tPIWwjeE8oYFZPUCFuYVshbmFqIW5hciFuYSFdIW5hIXAhbmEjUiFuYSNuIW5hI28hbmEjcCFuYSNxIW5hI3IhbmEjcyFuYSN0IW5hI3UhbmEjdiFuYSN4IW5hI3ohbmEjeyFuYShxIW5hKHghbmEoeSFuYX5PYSFuYSd5IW5hJ3YhbmEhWSFuYSFrIW5hdiFuYSFfIW5hJWkhbmEhZyFuYX5QS2FPIWsoYU9+TyFnI3ZPI2AoYk8ocSduTyFdKHNYYShzWCd5KHNYfk8hayhzWH5QTXxPIVMlZ08hXyVoTyF8XU8jaShnTyNqKGZPKFMlZk9+TyFdKGhPIWsoclh+TyFrKGpPfk8hUyVnTyFfJWhPI2ooZk8oUyVmT35PUChmWFIoZlhbKGZYaihmWHIoZlghUShmWCFTKGZYIV0oZlghbChmWCFwKGZYI1IoZlgjbihmWCNvKGZYI3AoZlgjcShmWCNyKGZYI3MoZlgjdChmWCN1KGZYI3YoZlgjeChmWCN6KGZYI3soZlgoYChmWChxKGZYKHgoZlgoeShmWH5PIWcjdk8hayhmWH5QISBqT1IobE8hUShrTyFsI3hPI1MkZE8hfCF7YSFTIXthfk8heCF7YSVoIXthIV8he2EjaSF7YSNqIXthKFMhe2F+UCEja08heChwT35PUFlPUVlPU2ZPZCFqT2UhaU9wa09yWU9za090a096a098WU8hT1lPIVNXTyFXa08hWGtPIV9YTyFpdU8hbFpPIW9ZTyFwWU8hcVlPIXN2TyF1IWdPIXghaE8kVyFrTyRuaU8oUyFkTyhVVE8oWFVPKGBWTyhuW09+T2glVk9wJVdPciVYT3MkdE90JHRPeiVZT3wlWk8hTzxlTyFTJHtPIV8kfE8haT12TyFsJHhPI2o8a08kVyVfTyR0PGdPJHY8aU8keSVgTyhTKHRPKFVUTyhYVU8oYCR1Tyh4JH1PKHklUE9+TyNrKHZPfk8hWyh4TyFrKGpQflAlW08oZCh6TyhuW09+TyFTKHxPIWwjeE8oZCh6TyhuW09+T1A7dk9RO3ZPU2ZPZD1yT2UhaU9wa09yO3ZPc2tPdGtPemtPfDt2TyFPO3ZPIVNXTyFXa08hWGtPIV8hZU8haTt5TyFsWk8hbzt2TyFwO3ZPIXE7dk8hczt6TyF1O31PIXghaE8kVyFrTyRuPXBPKFMpWk8oVVRPKFhVTyhgVk8obltPfk8hXSRfT2EkcWEneSRxYSd2JHFhIWskcWEhWSRxYSFfJHFhJWkkcWEhZyRxYX5PbCliT35QISZvT2glVk9wJVdPciVYT3MkdE90JHRPeiVZT3wlWk8hTyVbTyFTJHtPIV8kfE8haSVhTyFsJHhPI2olYk8kVyVfTyR0JV1PJHYlXk8keSVgTyhTKHRPKFVUTyhYVU8oYCR1Tyh4JH1PKHklUE9+T2cob1B+UCEreE8hUSlnTyFnKWZPIV8kXlgkWiReWCRdJF5YJF8kXlgkZiReWH5PIWcpZk8hXyh6WCRaKHpYJF0oelgkXyh6WCRmKHpYfk8hUSlnT35QIS5STyFRKWdPIV8oelgkWih6WCRdKHpYJF8oelgkZih6WH5PIV8paU8kWiltTyRdKWhPJF8paE8kZiluT35PIVspcU9+UCEpUE8kXSRoTyRfJGdPJGYpdU9+T24kelghUSR6WCNTJHpYJ3gkelgoeCR6WCh5JHpYfk9nbVhnJHpYbm1YIV1tWCNgbVh+UCEvd094KXdPKGEpeE8oYil6T35PbipUTyFRKXxPJ3gpfU8oeCR9Tyh5JVBPfk9nKXtPflAhMHtPZypVT35PaCVWT3AlV09yJVhPcyR0T3QkdE96JVlPfCVaTyFPPGVPIVMqV08hXypYTyFpPXZPIWwkeE8jajxrTyRXJV9PJHQ8Z08kdjxpTyR5JWBPKFVUTyhYVU8oYCR1Tyh4JH1PKHklUE9+TyFbKltPKFMqVk8hayh9UH5QITFqTyNrKl5Pfk8hbCpfT35PaCVWT3AlV09yJVhPcyR0T3QkdE96JVlPfCVaTyFPPGVPIVMke08hXyR8TyFpPXZPIWwkeE8jajxrTyRXJV9PJHQ8Z08kdjxpTyR5JWBPKFMqYU8oVVRPKFhVTyhgJHVPKHgkfU8oeSVQT35PIVsqZE8hWSlPUH5QITNpT3IqcE9zIW5PIVMqZk8hYipuTyFjKmhPIWQqaE8hbCpfTyNbKm9PJWAqak8oVCFsTyhVVE8oWFVPKGQhbU9+TyFeKm1PflAhNV5PI1MkZE9uKF9YIVEoX1gneChfWCh4KF9YKHkoX1ghXShfWCNgKF9Yfk9nKF9YJE8oX1h+UCE2YE9uKnVPI2AqdE9nKF5YIV0oXlh+TyFdKnZPZyhdWH5PaiVjT2slY09sJWNPKFMmWE9nKF1Qfk9zKnlPfk8hbCtPT35PKFModE9+T3ArVE8hUyVnTyFbI2lPIV8laE8hfF1PI2kjbE8jaiNpTyhTJWZPIWsoclB+TyFnI3ZPI2srVU9+TyFTJWdPIVsrV08hXShbTyFfJWhPKFMlZk8hWSh1UH5PcydZTyFTK1lPIVsrWE8oVVRPKFhVTyhkKHpPfk8hXih3UH5QITlpTyFdK1pPYSlTWCd5KVNYfk9QJFtPUiN6T1skY09qJFJPciRhTyFRI3lPIVMje08hbCN4TyFwJFtPI1IkUk8jbiRPTyNvJFBPI3AkUE8jcSRQTyNyJFFPI3MkUk8jdCRSTyN1JGJPI3YkU08jeCRVTyN6JFdPI3skWE8oYFZPKHEkWU8oeCN8Tyh5I31Pfk9hIWphIV0hamEneSFqYSd2IWphIVkhamEhayFqYXYhamEhXyFqYSVpIWphIWchamF+UCE6YU9SI3pPIVEjeU8hUyN7TyFsI3hPKGBWT1AhcmFbIXJhaiFyYXIhcmEhXSFyYSFwIXJhI1IhcmEjbiFyYSNvIXJhI3AhcmEjcSFyYSNyIXJhI3MhcmEjdCFyYSN1IXJhI3YhcmEjeCFyYSN6IXJhI3shcmEocSFyYSh4IXJhKHkhcmF+T2EhcmEneSFyYSd2IXJhIVkhcmEhayFyYXYhcmEhXyFyYSVpIXJhIWchcmF+UCE8d09SI3pPIVEjeU8hUyN7TyFsI3hPKGBWT1AhdGFbIXRhaiF0YXIhdGEhXSF0YSFwIXRhI1IhdGEjbiF0YSNvIXRhI3AhdGEjcSF0YSNyIXRhI3MhdGEjdCF0YSN1IXRhI3YhdGEjeCF0YSN6IXRhI3shdGEocSF0YSh4IXRhKHkhdGF+T2EhdGEneSF0YSd2IXRhIVkhdGEhayF0YXYhdGEhXyF0YSVpIXRhIWchdGF+UCE/X09oJVZPbitkTyFfJ15PJWkrY09+TyFnK2ZPYShbWCFfKFtYJ3koW1ghXShbWH5PYSVtTyFfWE8neSVtT35PaCVWTyFsJWRPfk9oJVZPIWwlZE8oUyVmT35PIWcjdk8jayh2T35PYitxTyVqK3JPKFMrbk8oVVRPKFhVTyFeKVdQfk8hXStzT2ApVlh+T1srd09+T2AreE9+TyFfJk9PKFMlZk8oVCFsT2ApVlB+T2glVk8jYCt9T35PaCVWT24sUU8hXyR8T35PIV8sU09+TyFRLFVPIV9YT35PJW4ldU9+TyF4LFpPfk9lLGBPfk9iLGFPKFMjbk8oVVRPKFhVTyFeKVVQfk9lJXxPfk8laiFRTyhTJlhPflA9W09bLGZPYCxlT35PUFlPUVlPU2ZPZHpPZXlPcGtPcllPc2tPdGtPemtPfFlPIU9ZTyFTV08hV2tPIVhrTyFpdU8hbFpPIW9ZTyFwWU8hcVlPIXN2TyF4eE8hfF1PJG5pTyVofU8oVVRPKFhVTyhgVk8obltPfk8hXyFlTyF1IWdPJFcha08oUyFkT35QIUZfT2AsZU9hJW1PJ3klbU9+T1BZT1FZT1NmT2Qhak9lIWlPcGtPcllPc2tPdGtPemtPfFlPIU9ZTyFTV08hV2tPIVhrTyFfIWVPIWl1TyFsWk8hb1lPIXBZTyFxWU8hc3ZPIXghaE8kVyFrTyRuaU8oUyFkTyhVVE8oWFVPKGBWTyhuW09+T2Esa09sIU9PIXV3TyVsIU9PJW0hT08lbiFPT35QIUh3TyFsJm1Pfk8mXSxxT35PIV8sc09+TyZuLHVPJnAsdk9QJmthUSZrYVMma2FZJmthYSZrYWQma2FlJmthbCZrYXAma2FyJmthcyZrYXQma2F6JmthfCZrYSFPJmthIVMma2EhVyZrYSFYJmthIV8ma2EhaSZrYSFsJmthIW8ma2EhcCZrYSFxJmthIXMma2EhdSZrYSF4JmthIXwma2EkVyZrYSRuJmthJWgma2ElaiZrYSVsJmthJW0ma2ElbiZrYSVxJmthJXMma2EldiZrYSV3JmthJXkma2EmViZrYSZdJmthJl8ma2EmYSZrYSZjJmthJmYma2EmbCZrYSZyJmthJnQma2EmdiZrYSZ4JmthJnoma2EndiZrYShTJmthKFUma2EoWCZrYShgJmthKG4ma2EhXiZrYSZkJmthYiZrYSZpJmthfk8oUyx7T35PaCFlWCFdIVJYIV4hUlghZyFSWCFnIWVYIWwhZVgjYCFSWH5PIV0hZVghXiFlWH5QIyB9TyFnLVFPI2AtUE9oKGlYIV0jaFghXiNoWCFnKGlYIWwoaVh+TyFdKGlYIV4oaVh+UCMhcE9oJVZPIWctU08hbCVkTyFdIWFYIV4hYVh+T3Mhbk8hUyFvTyhVVE8oWFVPKGQhbU9+T1A7dk9RO3ZPU2ZPZD1yT2UhaU9wa09yO3ZPc2tPdGtPemtPfDt2TyFPO3ZPIVNXTyFXa08hWGtPIV8hZU8haTt5TyFsWk8hbzt2TyFwO3ZPIXE7dk8hczt6TyF1O31PIXghaE8kVyFrTyRuPXBPKFVUTyhYVU8oYFZPKG5bT35PKFM8ck9+UCMkVk8hXS1XTyFeKGhYfk8hXi1ZT35PIWctUU8jYC1QTyFdI2hYIV4jaFh+TyFdLVpPIV4od1h+TyFeLV1Pfk8hYy1eTyFkLV5PKFQhbE9+UCMjdE8hXi1hT35QJ19Pbi1kTyFfJ15Pfk8hWS1pT35PcyF7YSFiIXthIWMhe2EhZCF7YSNUIXthI1Uhe2EjViF7YSNXIXthI1ghe2EjWyF7YSNdIXthKFQhe2EoVSF7YShYIXthKGQhe2EobiF7YX5QISNrTyFwLW5PI2AtbE9+UENdTyFjLXBPIWQtcE8oVCFsT35QQ3tPYSVtTyNgLWxPJ3klbU9+T2ElbU8hZyN2TyNgLWxPJ3klbU9+T2ElbU8hZyN2TyFwLW5PI2AtbE8neSVtTyhxJ25Pfk8oTyd2TyhQJ3ZPKFEtdU9+T3Ytdk9+TyFZJ1ZhIV0nVmF+UCE6YU8hWy16TyFZJ1ZYIV0nVlh+UCVbTyFdKFRPIVkoZ2F+TyFZKGdhflBHdk8hXShbTyFZKHVhfk8hUyVnTyFbLk9PIV8laE8oUyVmTyFZJ11YIV0nXVh+TyNgLlFPIV0oc2EhayhzYWEoc2EneShzYX5PIWcjdk9+UCMsXU8hXShoTyFrKHJhfk8hUyVnTyFfJWhPI2ouVU8oUyVmT35PcC5aTyFTJWdPIVsuV08hXyVoTyF8XU8jaS5ZTyNqLldPKFMlZk8hXSdgWCFrJ2BYfk9SLl9PIWwjeE9+T2glVk9uLmJPIV8nXk8laS5hT35PYSNjaSFdI2NpJ3kjY2kndiNjaSFZI2NpIWsjY2l2I2NpIV8jY2klaSNjaSFnI2NpflAhOmFPbj18TyFRKXxPJ3gpfU8oeCR9Tyh5JVBPfk8jayNfYWEjX2EjYCNfYSd5I19hIV0jX2EhayNfYSFfI19hIVkjX2F+UCMvWE8jayhfWFAoX1hSKF9YWyhfWGEoX1hqKF9YcihfWCFTKF9YIWwoX1ghcChfWCNSKF9YI24oX1gjbyhfWCNwKF9YI3EoX1gjcihfWCNzKF9YI3QoX1gjdShfWCN2KF9YI3goX1gjeihfWCN7KF9YJ3koX1goYChfWChxKF9YIWsoX1ghWShfWCd2KF9YdihfWCFfKF9YJWkoX1ghZyhfWH5QITZgTyFdLm9PIWsoalh+UCE6YU8hay5yT35PIVkudE9+T1AkW09SI3pPIVEjeU8hUyN7TyFsI3hPIXAkW08oYFZPWyNtaWEjbWlqI21pciNtaSFdI21pI1IjbWkjbyNtaSNwI21pI3EjbWkjciNtaSNzI21pI3QjbWkjdSNtaSN2I21pI3gjbWkjeiNtaSN7I21pJ3kjbWkocSNtaSh4I21pKHkjbWkndiNtaSFZI21pIWsjbWl2I21pIV8jbWklaSNtaSFnI21pfk8jbiNtaX5QIzJ3TyNuJE9PflAjMndPUCRbT1Ijek9yJGFPIVEjeU8hUyN7TyFsI3hPIXAkW08jbiRPTyNvJFBPI3AkUE8jcSRQTyhgVk9bI21pYSNtaWojbWkhXSNtaSNSI21pI3MjbWkjdCNtaSN1I21pI3YjbWkjeCNtaSN6I21pI3sjbWkneSNtaShxI21pKHgjbWkoeSNtaSd2I21pIVkjbWkhayNtaXYjbWkhXyNtaSVpI21pIWcjbWl+TyNyI21pflAjNWZPI3IkUU9+UCM1Zk9QJFtPUiN6T1skY09qJFJPciRhTyFRI3lPIVMje08hbCN4TyFwJFtPI1IkUk8jbiRPTyNvJFBPI3AkUE8jcSRQTyNyJFFPI3MkUk8jdCRSTyN1JGJPKGBWT2EjbWkhXSNtaSN4I21pI3ojbWkjeyNtaSd5I21pKHEjbWkoeCNtaSh5I21pJ3YjbWkhWSNtaSFrI21pdiNtaSFfI21pJWkjbWkhZyNtaX5PI3YjbWl+UCM4VE9QJFtPUiN6T1skY09qJFJPciRhTyFRI3lPIVMje08hbCN4TyFwJFtPI1IkUk8jbiRPTyNvJFBPI3AkUE8jcSRQTyNyJFFPI3MkUk8jdCRSTyN1JGJPI3YkU08oYFZPKHkjfU9hI21pIV0jbWkjeiNtaSN7I21pJ3kjbWkocSNtaSh4I21pJ3YjbWkhWSNtaSFrI21pdiNtaSFfI21pJWkjbWkhZyNtaX5PI3gkVU9+UCM6a08jeCNtaX5QIzprTyN2JFNPflAjOFRPUCRbT1Ijek9bJGNPaiRST3IkYU8hUSN5TyFTI3tPIWwjeE8hcCRbTyNSJFJPI24kT08jbyRQTyNwJFBPI3EkUE8jciRRTyNzJFJPI3QkUk8jdSRiTyN2JFNPI3gkVU8oYFZPKHgjfE8oeSN9T2EjbWkhXSNtaSN7I21pJ3kjbWkocSNtaSd2I21pIVkjbWkhayNtaXYjbWkhXyNtaSVpI21pIWcjbWl+TyN6I21pflAjPWFPI3okV09+UCM9YU9QXVhSXVhbXVhqXVhyXVghUV1YIVNdWCFsXVghcF1YI1JdWCNTXVgjYF1YI2tmWCNuXVgjb11YI3BdWCNxXVgjcl1YI3NdWCN0XVgjdV1YI3ZdWCN4XVgjel1YI3tdWCRRXVgoYF1YKHFdWCh4XVgoeV1YIV1dWCFeXVh+TyRPXVh+UCNAT09QJFtPUiN6T1s8X09qPFNPcjxdTyFRI3lPIVMje08hbCN4TyFwJFtPI1I8U08jbjxQTyNvPFFPI3A8UU8jcTxRTyNyPFJPI3M8U08jdDxTTyN1PF5PI3Y8VE8jeDxWTyN6PFhPI3s8WU8oYFZPKHEkWU8oeCN8Tyh5I31Pfk8kTy52T35QI0JdTyNTJGRPI2A8YE8kUTxgTyRPKGZYIV4oZlh+UCEgak9hJ2NhIV0nY2EneSdjYSd2J2NhIWsnY2EhWSdjYXYnY2EhXydjYSVpJ2NhIWcnY2F+UCE6YU9bI21pYSNtaWojbWlyI21pIV0jbWkjUiNtaSNyI21pI3MjbWkjdCNtaSN1I21pI3YjbWkjeCNtaSN6I21pI3sjbWkneSNtaShxI21pJ3YjbWkhWSNtaSFrI21pdiNtaSFfI21pJWkjbWkhZyNtaX5PUCRbT1Ijek8hUSN5TyFTI3tPIWwjeE8hcCRbTyNuJE9PI28kUE8jcCRQTyNxJFBPKGBWTyh4I21pKHkjbWl+UCNFX09uPXxPIVEpfE8neCl9Tyh4JH1PKHklUE9QI21pUiNtaSFTI21pIWwjbWkhcCNtaSNuI21pI28jbWkjcCNtaSNxI21pKGAjbWl+UCNFX08hXS56T2cob1h+UCEwe09nLnxPfk9hJFBpIV0kUGkneSRQaSd2JFBpIVkkUGkhayRQaXYkUGkhXyRQaSVpJFBpIWckUGl+UCE6YU8kXS59TyRfLn1Pfk8kXS9PTyRfL09Pfk8hZylmTyNgL1BPIV8kY1gkWiRjWCRdJGNYJF8kY1gkZiRjWH5PIVsvUU9+TyFfKWlPJFovU08kXSloTyRfKWhPJGYvVE9+TyFdPFpPIV4oZVh+UCNCXU8hXi9VT35PIWcpZk8kZih6WH5PJGYvV09+T3YvWE9+UCEmb094KXdPKGEpeE8oYi9bT35PIVMvX09+Tyh4JH1PbiVhYSFRJWFhJ3glYWEoeSVhYSFdJWFhI2AlYWF+T2clYWEkTyVhYX5QI0xhTyh5JVBPbiVjYSFRJWNhJ3glY2EoeCVjYSFdJWNhI2AlY2F+T2clY2EkTyVjYX5QI01TTyFdZlghZ2ZYIWtmWCFrJHpYKHFmWH5QIS93TyFbL2hPIV0oW08oUy9nTyFZKHVQIVkpT1B+UCExak9yKnBPIWIqbk8hYypoTyFkKmhPIWwqX08jWypvTyVgKmpPKFQhbE8oVVRPKFhVT35PczxvTyFTL2lPIVsrWE8hXiptTyhkPG5PIV4od1B+UCNObU8hay9qT35QIy9YTyFdL2tPIWcjdk8ocSduTyFrKH1Yfk8hay9wT35PIVMlZ08hWypbTyFfJWhPKFMlZk8hayh9UH5PI2svck9+TyFZJHpYIV0kelghZyVSWH5QIS93TyFdL3NPIVkpT1h+UCMvWE8hZy91T35PIVkvd09+T3BrTyhTL3hPflAuaU9oJVZPci99TyFnI3ZPIWwlZE8ocSduT35PIWcrZk9+T2ElbU8hXTBSTyd5JW1Pfk8hXjBUT35QITVeTyFjMFVPIWQwVU8oVCFsT35QIyN0T3Mhbk8hUzBWTyhVVE8oWFVPKGQhbU9+TyNbMFhPfk9nJWFhIV0lYWEjYCVhYSRPJWFhflAhMHtPZyVjYSFdJWNhI2AlY2EkTyVjYX5QITB7T2olY09rJWNPbCVjTyhTJlhPZydsWCFdJ2xYfk8hXSp2T2coXWF+T2cwYk9+T1IwY08hUTBjTyFTMGRPI1MkZE9ufWEneH1hKHh9YSh5fWEhXX1hI2B9YX5PZ31hJE99YX5QJCZ2TyFRKXxPJ3gpfU9uJHNhKHgkc2EoeSRzYSFdJHNhI2Akc2F+T2ckc2EkTyRzYX5QJCdyTyFRKXxPJ3gpfU9uJHVhKHgkdWEoeSR1YSFdJHVhI2AkdWF+T2ckdWEkTyR1YX5QJChlTyNrMGdPfk9nJVRhIV0lVGEjYCVUYSRPJVRhflAhMHtPbjBpTyNgMGhPZyheYSFdKF5hfk8hZyN2T35PI2swbE9+TyFdK1pPYSlTYSd5KVNhfk9SI3pPIVEjeU8hUyN7TyFsI3hPKGBWT1AhcmlbIXJpaiFyaXIhcmkhXSFyaSFwIXJpI1IhcmkjbiFyaSNvIXJpI3AhcmkjcSFyaSNyIXJpI3MhcmkjdCFyaSN1IXJpI3YhcmkjeCFyaSN6IXJpI3shcmkocSFyaSh4IXJpKHkhcml+T2EhcmkneSFyaSd2IXJpIVkhcmkhayFyaXYhcmkhXyFyaSVpIXJpIWchcml+UCQqYk9oJVZPciVYT3MkdE90JHRPeiVZT3wlWk8hTzxlTyFTJHtPIV8kfE8haT12TyFsJHhPI2o8a08kVyVfTyR0PGdPJHY8aU8keSVgTyhVVE8oWFVPKGAkdU8oeCR9Tyh5JVBPfk9wMHVPJV0wdk8oUzB0T35QJCx4TyFnK2ZPYShbYSFfKFthJ3koW2EhXShbYX5PI2swfE9+T1tdWCFdZlghXmZYfk8hXTB9TyFeKVdYfk8hXjFQT35PWzFRT35PYjFTTyhTK25PKFVUTyhYVU9+TyFfJk9PKFMlZk9gJ3RYIV0ndFh+TyFdK3NPYClWYX5PIWsxVk9+UCE6YU9bMVlPfk9gMVpPfk8jYDFeT35PbjFhTyFfJHxPfk8oZCh6TyFeKVRQfk9oJVZPbjFqTyFfMWdPJWkxaU9+T1sxdE8hXTFyTyFeKVVYfk8hXjF1T35PYDF3T2ElbU8neSVtT35PKFMjbk8oVVRPKFhVT35PI1MkZE8jYCRlTyRRJGVPUChmWFIoZlhbKGZYcihmWCFRKGZYIVMoZlghXShmWCFsKGZYIXAoZlgjUihmWCNuKGZYI28oZlgjcChmWCNxKGZYI3IoZlgjcyhmWCN0KGZYI3UoZlgjdihmWCN4KGZYI3ooZlgjeyhmWChgKGZYKHEoZlgoeChmWCh5KGZYfk9qMXpPJloxe09hKGZYflAkMmNPajF6TyNgJGVPJloxe09+T2ExfU9+UCVbT2EyUE9+TyZkMlNPUCZiaVEmYmlTJmJpWSZiaWEmYmlkJmJpZSZiaWwmYmlwJmJpciZiaXMmYml0JmJpeiZiaXwmYmkhTyZiaSFTJmJpIVcmYmkhWCZiaSFfJmJpIWkmYmkhbCZiaSFvJmJpIXAmYmkhcSZiaSFzJmJpIXUmYmkheCZiaSF8JmJpJFcmYmkkbiZiaSVoJmJpJWomYmklbCZiaSVtJmJpJW4mYmklcSZiaSVzJmJpJXYmYmkldyZiaSV5JmJpJlYmYmkmXSZiaSZfJmJpJmEmYmkmYyZiaSZmJmJpJmwmYmkmciZiaSZ0JmJpJnYmYmkmeCZiaSZ6JmJpJ3YmYmkoUyZiaShVJmJpKFgmYmkoYCZiaShuJmJpIV4mYmliJmJpJmkmYml+T2IyWU8hXjJXTyZpMlhPflBgTyFfWE8hbDJbT35PJnAsdk9QJmtpUSZraVMma2lZJmtpYSZraWQma2llJmtpbCZraXAma2lyJmtpcyZraXQma2l6JmtpfCZraSFPJmtpIVMma2khVyZraSFYJmtpIV8ma2khaSZraSFsJmtpIW8ma2khcCZraSFxJmtpIXMma2khdSZraSF4JmtpIXwma2kkVyZraSRuJmtpJWgma2klaiZraSVsJmtpJW0ma2klbiZraSVxJmtpJXMma2kldiZraSV3JmtpJXkma2kmViZraSZdJmtpJl8ma2kmYSZraSZjJmtpJmYma2kmbCZraSZyJmtpJnQma2kmdiZraSZ4JmtpJnoma2kndiZraShTJmtpKFUma2koWCZraShgJmtpKG4ma2khXiZraSZkJmtpYiZraSZpJmtpfk8hWTJiT35PIV0hYWEhXiFhYX5QI0JdT3Mhbk8hUyFvTyFbMmhPKGQhbU8hXSdXWCFeJ1dYflBAY08hXS1XTyFeKGhhfk8hXSdeWCFeJ15YflAhOWlPIV0tWk8hXih3YX5PIV4yb09+UCdfT2ElbU8jYDJ4Tyd5JW1Pfk9hJW1PIWcjdk8jYDJ4Tyd5JW1Pfk9hJW1PIWcjdk8hcDJ8TyNgMnhPJ3klbU8ocSduT35PYSVtTyd5JW1PflAhOmFPIV0kX092JHFhfk8hWSdWaSFdJ1ZpflAhOmFPIV0oVE8hWShnaX5PIV0oW08hWSh1aX5PIVkodmkhXSh2aX5QITphTyFdKHNpIWsoc2lhKHNpJ3koc2l+UCE6YU8jYDNPTyFdKHNpIWsoc2lhKHNpJ3koc2l+TyFdKGhPIWsocml+TyFTJWdPIV8laE8hfF1PI2kzVE8jajNTTyhTJWZPfk8hUyVnTyFfJWhPI2ozU08oUyVmT35PbjNbTyFfJ15PJWkzWk9+T2glVk9uM1tPIV8nXk8laTNaT35PI2slYWFQJWFhUiVhYVslYWFhJWFhaiVhYXIlYWEhUyVhYSFsJWFhIXAlYWEjUiVhYSNuJWFhI28lYWEjcCVhYSNxJWFhI3IlYWEjcyVhYSN0JWFhI3UlYWEjdiVhYSN4JWFhI3olYWEjeyVhYSd5JWFhKGAlYWEocSVhYSFrJWFhIVklYWEndiVhYXYlYWEhXyVhYSVpJWFhIWclYWF+UCNMYU8jayVjYVAlY2FSJWNhWyVjYWElY2FqJWNhciVjYSFTJWNhIWwlY2EhcCVjYSNSJWNhI24lY2EjbyVjYSNwJWNhI3ElY2EjciVjYSNzJWNhI3QlY2EjdSVjYSN2JWNhI3glY2EjeiVjYSN7JWNhJ3klY2EoYCVjYShxJWNhIWslY2EhWSVjYSd2JWNhdiVjYSFfJWNhJWklY2EhZyVjYX5QI01TTyNrJWFhUCVhYVIlYWFbJWFhYSVhYWolYWFyJWFhIVMlYWEhXSVhYSFsJWFhIXAlYWEjUiVhYSNuJWFhI28lYWEjcCVhYSNxJWFhI3IlYWEjcyVhYSN0JWFhI3UlYWEjdiVhYSN4JWFhI3olYWEjeyVhYSd5JWFhKGAlYWEocSVhYSFrJWFhIVklYWEndiVhYSNgJWFhdiVhYSFfJWFhJWklYWEhZyVhYX5QIy9YTyNrJWNhUCVjYVIlY2FbJWNhYSVjYWolY2FyJWNhIVMlY2EhXSVjYSFsJWNhIXAlY2EjUiVjYSNuJWNhI28lY2EjcCVjYSNxJWNhI3IlY2EjcyVjYSN0JWNhI3UlY2EjdiVjYSN4JWNhI3olY2EjeyVjYSd5JWNhKGAlY2EocSVjYSFrJWNhIVklY2EndiVjYSNgJWNhdiVjYSFfJWNhJWklY2EhZyVjYX5QIy9YTyNrfWFQfWFbfWFhfWFqfWFyfWEhbH1hIXB9YSNSfWEjbn1hI299YSNwfWEjcX1hI3J9YSNzfWEjdH1hI3V9YSN2fWEjeH1hI3p9YSN7fWEneX1hKGB9YShxfWEha31hIVl9YSd2fWF2fWEhX31hJWl9YSFnfWF+UCQmdk8jayRzYVAkc2FSJHNhWyRzYWEkc2FqJHNhciRzYSFTJHNhIWwkc2EhcCRzYSNSJHNhI24kc2EjbyRzYSNwJHNhI3Ekc2EjciRzYSNzJHNhI3Qkc2EjdSRzYSN2JHNhI3gkc2EjeiRzYSN7JHNhJ3kkc2EoYCRzYShxJHNhIWskc2EhWSRzYSd2JHNhdiRzYSFfJHNhJWkkc2EhZyRzYX5QJCdyTyNrJHVhUCR1YVIkdWFbJHVhYSR1YWokdWFyJHVhIVMkdWEhbCR1YSFwJHVhI1IkdWEjbiR1YSNvJHVhI3AkdWEjcSR1YSNyJHVhI3MkdWEjdCR1YSN1JHVhI3YkdWEjeCR1YSN6JHVhI3skdWEneSR1YShgJHVhKHEkdWEhayR1YSFZJHVhJ3YkdWF2JHVhIV8kdWElaSR1YSFnJHVhflAkKGVPI2slVGFQJVRhUiVUYVslVGFhJVRhaiVUYXIlVGEhUyVUYSFdJVRhIWwlVGEhcCVUYSNSJVRhI24lVGEjbyVUYSNwJVRhI3ElVGEjciVUYSNzJVRhI3QlVGEjdSVUYSN2JVRhI3glVGEjeiVUYSN7JVRhJ3klVGEoYCVUYShxJVRhIWslVGEhWSVUYSd2JVRhI2AlVGF2JVRhIV8lVGElaSVUYSFnJVRhflAjL1hPYSNjcSFdI2NxJ3kjY3EndiNjcSFZI2NxIWsjY3F2I2NxIV8jY3ElaSNjcSFnI2NxflAhOmFPIVszZE8hXSdYWCFrJ1hYflAlW08hXS5vTyFrKGphfk8hXS5vTyFrKGphflAhOmFPIVkzZ09+TyRPIW5hIV4hbmF+UEthTyRPIWphIV0hamEhXiFqYX5QI0JdTyRPIXJhIV4hcmF+UCE8d08kTyF0YSFeIXRhflAhP19PZydbWCFdJ1tYflAhK3hPIV0uek9nKG9hfk9TZk8hXzN7TyRkM3xPfk8hXjRRT35PdjRST35QIy9YT2EkbXEhXSRtcSd5JG1xJ3YkbXEhWSRtcSFrJG1xdiRtcSFfJG1xJWkkbXEhZyRtcX5QITphTyFZNFRPflAhJm9PIVM0VU9+TyFRKXxPJ3gpfU8oeSVQT24naGEoeCdoYSFdJ2hhI2AnaGF+T2cnaGEkTydoYX5QJSxYTyFRKXxPJ3gpfU9uJ2phKHgnamEoeSdqYSFdJ2phI2AnamF+T2cnamEkTydqYX5QJSx6TyhxJFlPflAjL1hPIVlmWCFZJHpYIV1mWCFdJHpYIWclUlgjYGZYflAhL3dPKFM8eE9+UCExak8hUyVnTyFbNFhPIV8laE8oUyVmTyFdJ2RYIWsnZFh+TyFdL2tPIWsofWF+TyFdL2tPIWcjdk8hayh9YX5PIV0va08hZyN2TyhxJ25PIWsofWF+T2ckfGkhXSR8aSNgJHxpJE8kfGl+UCEwe08hWzRhTyFZJ2ZYIV0nZlh+UCEzaU8hXS9zTyFZKU9hfk8hXS9zTyFZKU9hflAjL1hPUF1YUl1YW11Yal1Ycl1YIVFdWCFTXVghWV1YIV1dWCFsXVghcF1YI1JdWCNTXVgjYF1YI2tmWCNuXVgjb11YI3BdWCNxXVgjcl1YI3NdWCN0XVgjdV1YI3ZdWCN4XVgjel1YI3tdWCRRXVgoYF1YKHFdWCh4XVgoeV1Yfk9qJVlYIWclWVh+UCUwa09qNGZPIWcjdk9+T2glVk8hZyN2TyFsJWRPfk9oJVZPcjRrTyFsJWRPKHEnbk9+T3I0cE8hZyN2TyhxJ25Pfk9zIW5PIVM0cU8oVVRPKFhVTyhkIW1Pfk8oeCR9T24lYWkhUSVhaSd4JWFpKHklYWkhXSVhaSNgJWFpfk9nJWFpJE8lYWl+UCU0W08oeSVQT24lY2khUSVjaSd4JWNpKHglY2khXSVjaSNgJWNpfk9nJWNpJE8lY2l+UCU0fU9nKF5pIV0oXml+UCEwe08jYDR3T2coXmkhXSheaX5QITB7TyFrNHpPfk9hJG9xIV0kb3EneSRvcSd2JG9xIVkkb3EhayRvcXYkb3EhXyRvcSVpJG9xIWckb3F+UCE6YU8hWTVRT35PIV01Uk8hXylQWH5QIy9YT2EkelghXyR6WCVeXVgneSR6WCFdJHpYflAhL3dPJV41VU9hb1hub1ghUW9YIV9vWCd4b1gneW9YKHhvWCh5b1ghXW9Yfk9wNVZPKFMjbk9+TyVeNVVPfk9iNV1PJWo1Xk8oUytuTyhVVE8oWFVPIV0nc1ghXidzWH5PIV0wfU8hXilXYX5PWzViT35PYDVjT35PYSVtTyd5JW1PflAjL1hPIV01a08jYDVtTyFeKVRYfk8hXjVuT35PcjV0T3Mhbk8hUypmTyFiIXlPIWMhdk8hZCF2TyF8O3dPI1QhcE8jVSFwTyNWIXBPI1chcE8jWCFwTyNbNXNPI10hek8oVCFsTyhVVE8oWFVPKGQhbU8obiFzT35PIV41ck9+UCU6WU9uNXlPIV8xZ08laTV4T35PaCVWT241eU8hXzFnTyVpNXhPfk9iNlFPKFMjbk8oVVRPKFhVTyFdJ3JYIV4nclh+TyFdMXJPIV4pVWF+TyhVVE8oWFVPKGQ2U09+T2A2V09+T2o2Wk8mWjZbT35QTXxPIWs2XU9+UCVbT2E2X09+T2E2X09+UCVbT2IyWU8hXjZkTyZpMlhPflBgTyFnNmZPfk8hZzZoT2goaWkhXShpaSFeKGlpIWcoaWkhbChpaXIoaWkocShpaX5PIV0jaGkhXiNoaX5QI0JdTyNgNmlPIV0jaGkhXiNoaX5PIV0hYWkhXiFhaX5QI0JdT2ElbU8jYDZyTyd5JW1Pfk9hJW1PIWcjdk8jYDZyTyd5JW1Pfk8hXShzcSFrKHNxYShzcSd5KHNxflAhOmFPIV0oaE8hayhycX5PIVMlZ08hXyVoTyNqNnlPKFMlZk9+TyFfJ15PJWk2fE9+T243UU8hXydeTyVpNnxPfk8jaydoYVAnaGFSJ2hhWydoYWEnaGFqJ2hhcidoYSFTJ2hhIWwnaGEhcCdoYSNSJ2hhI24naGEjbydoYSNwJ2hhI3EnaGEjcidoYSNzJ2hhI3QnaGEjdSdoYSN2J2hhI3gnaGEjeidoYSN7J2hhJ3knaGEoYCdoYShxJ2hhIWsnaGEhWSdoYSd2J2hhdidoYSFfJ2hhJWknaGEhZydoYX5QJSxYTyNrJ2phUCdqYVInamFbJ2phYSdqYWonamFyJ2phIVMnamEhbCdqYSFwJ2phI1InamEjbidqYSNvJ2phI3AnamEjcSdqYSNyJ2phI3MnamEjdCdqYSN1J2phI3YnamEjeCdqYSN6J2phI3snamEneSdqYShgJ2phKHEnamEhaydqYSFZJ2phJ3YnamF2J2phIV8namElaSdqYSFnJ2phflAlLHpPI2skfGlQJHxpUiR8aVskfGlhJHxpaiR8aXIkfGkhUyR8aSFdJHxpIWwkfGkhcCR8aSNSJHxpI24kfGkjbyR8aSNwJHxpI3EkfGkjciR8aSNzJHxpI3QkfGkjdSR8aSN2JHxpI3gkfGkjeiR8aSN7JHxpJ3kkfGkoYCR8aShxJHxpIWskfGkhWSR8aSd2JHxpI2AkfGl2JHxpIV8kfGklaSR8aSFnJHxpflAjL1hPI2slYWlQJWFpUiVhaVslYWlhJWFpaiVhaXIlYWkhUyVhaSFsJWFpIXAlYWkjUiVhaSNuJWFpI28lYWkjcCVhaSNxJWFpI3IlYWkjcyVhaSN0JWFpI3UlYWkjdiVhaSN4JWFpI3olYWkjeyVhaSd5JWFpKGAlYWkocSVhaSFrJWFpIVklYWkndiVhaXYlYWkhXyVhaSVpJWFpIWclYWl+UCU0W08jayVjaVAlY2lSJWNpWyVjaWElY2lqJWNpciVjaSFTJWNpIWwlY2khcCVjaSNSJWNpI24lY2kjbyVjaSNwJWNpI3ElY2kjciVjaSNzJWNpI3QlY2kjdSVjaSN2JWNpI3glY2kjeiVjaSN7JWNpJ3klY2koYCVjaShxJWNpIWslY2khWSVjaSd2JWNpdiVjaSFfJWNpJWklY2khZyVjaX5QJTR9TyFdJ1hhIWsnWGF+UCE6YU8hXS5vTyFrKGppfk8kTyNjaSFdI2NpIV4jY2l+UCNCXU9QJFtPUiN6TyFRI3lPIVMje08hbCN4TyFwJFtPKGBWT1sjbWlqI21pciNtaSNSI21pI28jbWkjcCNtaSNxI21pI3IjbWkjcyNtaSN0I21pI3UjbWkjdiNtaSN4I21pI3ojbWkjeyNtaSRPI21pKHEjbWkoeCNtaSh5I21pIV0jbWkhXiNtaX5PI24jbWl+UCVNWE8jbjxQT35QJU1YT1AkW09SI3pPcjxdTyFRI3lPIVMje08hbCN4TyFwJFtPI248UE8jbzxRTyNwPFFPI3E8UU8oYFZPWyNtaWojbWkjUiNtaSNzI21pI3QjbWkjdSNtaSN2I21pI3gjbWkjeiNtaSN7I21pJE8jbWkocSNtaSh4I21pKHkjbWkhXSNtaSFeI21pfk8jciNtaX5QJiBhTyNyPFJPflAmIGFPUCRbT1Ijek9bPF9PajxTT3I8XU8hUSN5TyFTI3tPIWwjeE8hcCRbTyNSPFNPI248UE8jbzxRTyNwPFFPI3E8UU8jcjxSTyNzPFNPI3Q8U08jdTxeTyhgVk8jeCNtaSN6I21pI3sjbWkkTyNtaShxI21pKHgjbWkoeSNtaSFdI21pIV4jbWl+TyN2I21pflAmI2lPUCRbT1Ijek9bPF9PajxTT3I8XU8hUSN5TyFTI3tPIWwjeE8hcCRbTyNSPFNPI248UE8jbzxRTyNwPFFPI3E8UU8jcjxSTyNzPFNPI3Q8U08jdTxeTyN2PFRPKGBWTyh5I31PI3ojbWkjeyNtaSRPI21pKHEjbWkoeCNtaSFdI21pIV4jbWl+TyN4PFZPflAmJWpPI3gjbWl+UCYlak8jdjxUT35QJiNpT1AkW09SI3pPWzxfT2o8U09yPF1PIVEjeU8hUyN7TyFsI3hPIXAkW08jUjxTTyNuPFBPI288UU8jcDxRTyNxPFFPI3I8Uk8jczxTTyN0PFNPI3U8Xk8jdjxUTyN4PFZPKGBWTyh4I3xPKHkjfU8jeyNtaSRPI21pKHEjbWkhXSNtaSFeI21pfk8jeiNtaX5QJid5TyN6PFhPflAmJ3lPYSN8eSFdI3x5J3kjfHkndiN8eSFZI3x5IWsjfHl2I3x5IV8jfHklaSN8eSFnI3x5flAhOmFPWyNtaWojbWlyI21pI1IjbWkjciNtaSNzI21pI3QjbWkjdSNtaSN2I21pI3gjbWkjeiNtaSN7I21pJE8jbWkocSNtaSFdI21pIV4jbWl+T1AkW09SI3pPIVEjeU8hUyN7TyFsI3hPIXAkW08jbjxQTyNvPFFPI3A8UU8jcTxRTyhgVk8oeCNtaSh5I21pflAmKnVPbj19TyFRKXxPJ3gpfU8oeCR9Tyh5JVBPUCNtaVIjbWkhUyNtaSFsI21pIXAjbWkjbiNtaSNvI21pI3AjbWkjcSNtaShgI21pflAmKnVPI1MkZE9QKF9YUihfWFsoX1hqKF9YbihfWHIoX1ghUShfWCFTKF9YIWwoX1ghcChfWCNSKF9YI24oX1gjbyhfWCNwKF9YI3EoX1gjcihfWCNzKF9YI3QoX1gjdShfWCN2KF9YI3goX1gjeihfWCN7KF9YJE8oX1gneChfWChgKF9YKHEoX1goeChfWCh5KF9YIV0oX1ghXihfWH5PJE8kUGkhXSRQaSFeJFBpflAjQl1PJE8hcmkhXiFyaX5QJCpiT2cnW2EhXSdbYX5QITB7TyFeN2RPfk8hXSdjYSFeJ2NhflAjQl1PIVk3ZU9+UCMvWE8hZyN2TyhxJ25PIV0nZGEhaydkYX5PIV0va08hayh9aX5PIV0va08hZyN2TyFrKH1pfk9nJHxxIV0kfHEjYCR8cSRPJHxxflAhMHtPIVknZmEhXSdmYX5QIy9YTyFnN2xPfk8hXS9zTyFZKU9pflAjL1hPIV0vc08hWSlPaX5PIVk3b09+T2glVk9yN3RPIWwlZE8ocSduT35Pajd2TyFnI3ZPfk9yN3lPIWcjdk8ocSduT35PIVEpfE8neCl9Tyh5JVBPbidpYSh4J2lhIV0naWEjYCdpYX5PZydpYSRPJ2lhflAmM3ZPIVEpfE8neCl9T24na2EoeCdrYSh5J2thIV0na2EjYCdrYX5PZydrYSRPJ2thflAmNGlPIVk3e09+T2clT3EhXSVPcSNgJU9xJE8lT3F+UCEwe09nKF5xIV0oXnF+UCEwe08jYDd8T2coXnEhXShecX5QITB7T2Ekb3khXSRveSd5JG95J3Ykb3khWSRveSFrJG95diRveSFfJG95JWkkb3khZyRveX5QITphTyFnNmhPfk8hXTVSTyFfKVBhfk8hXydeT1AkVGFSJFRhWyRUYWokVGFyJFRhIVEkVGEhUyRUYSFdJFRhIWwkVGEhcCRUYSNSJFRhI24kVGEjbyRUYSNwJFRhI3EkVGEjciRUYSNzJFRhI3QkVGEjdSRUYSN2JFRhI3gkVGEjeiRUYSN7JFRhKGAkVGEocSRUYSh4JFRhKHkkVGF+TyVpNnxPflAmN1pPJV44UU9hJVtpIV8lW2kneSVbaSFdJVtpfk9hI2N5IV0jY3kneSNjeSd2I2N5IVkjY3khayNjeXYjY3khXyNjeSVpI2N5IWcjY3l+UCE6YU9bOFNPfk9iOFVPKFMrbk8oVVRPKFhVT35PIV0wfU8hXilXaX5PYDhZT35PKGQoek8hXSdvWCFeJ29Yfk8hXTVrTyFeKVRhfk8hXjhjT35QJTpZTyhuIXNPflAkJHtPI1s4ZE9+TyFfMWdPfk8hXzFnTyVpOGZPfk9uOGlPIV8xZ08laThmT35PWzhuTyFdJ3JhIV4ncmF+TyFdMXJPIV4pVWl+TyFrOHJPfk8hazhzT35PIWs4dk9+TyFrOHZPflAlW09hOHhPfk8hZzh5T35PIWs4ek9+TyFdKHZpIV4odml+UCNCXU9hJW1PI2A5U08neSVtT35PIV0oc3khayhzeWEoc3kneShzeX5QITphTyFdKGhPIWsocnl+TyVpOVZPflAmN1pPIV8nXk8laTlWT35PI2skfHFQJHxxUiR8cVskfHFhJHxxaiR8cXIkfHEhUyR8cSFdJHxxIWwkfHEhcCR8cSNSJHxxI24kfHEjbyR8cSNwJHxxI3EkfHEjciR8cSNzJHxxI3QkfHEjdSR8cSN2JHxxI3gkfHEjeiR8cSN7JHxxJ3kkfHEoYCR8cShxJHxxIWskfHEhWSR8cSd2JHxxI2AkfHF2JHxxIV8kfHElaSR8cSFnJHxxflAjL1hPI2snaWFQJ2lhUidpYVsnaWFhJ2lhaidpYXInaWEhUydpYSFsJ2lhIXAnaWEjUidpYSNuJ2lhI28naWEjcCdpYSNxJ2lhI3InaWEjcydpYSN0J2lhI3UnaWEjdidpYSN4J2lhI3onaWEjeydpYSd5J2lhKGAnaWEocSdpYSFrJ2lhIVknaWEndidpYXYnaWEhXydpYSVpJ2lhIWcnaWF+UCYzdk8jaydrYVAna2FSJ2thWydrYWEna2FqJ2thcidrYSFTJ2thIWwna2EhcCdrYSNSJ2thI24na2EjbydrYSNwJ2thI3Ena2EjcidrYSNzJ2thI3Qna2EjdSdrYSN2J2thI3gna2EjeidrYSN7J2thJ3kna2EoYCdrYShxJ2thIWsna2EhWSdrYSd2J2thdidrYSFfJ2thJWkna2EhZydrYX5QJjRpTyNrJU9xUCVPcVIlT3FbJU9xYSVPcWolT3FyJU9xIVMlT3EhXSVPcSFsJU9xIXAlT3EjUiVPcSNuJU9xI28lT3EjcCVPcSNxJU9xI3IlT3EjcyVPcSN0JU9xI3UlT3EjdiVPcSN4JU9xI3olT3EjeyVPcSd5JU9xKGAlT3EocSVPcSFrJU9xIVklT3EndiVPcSNgJU9xdiVPcSFfJU9xJWklT3EhZyVPcX5QIy9YTyFdJ1hpIWsnWGl+UCE6YU8kTyNjcSFdI2NxIV4jY3F+UCNCXU8oeCR9T1AlYWFSJWFhWyVhYWolYWFyJWFhIVMlYWEhbCVhYSFwJWFhI1IlYWEjbiVhYSNvJWFhI3AlYWEjcSVhYSNyJWFhI3MlYWEjdCVhYSN1JWFhI3YlYWEjeCVhYSN6JWFhI3slYWEkTyVhYShgJWFhKHElYWEhXSVhYSFeJWFhfk9uJWFhIVElYWEneCVhYSh5JWFhflAmSG5PKHklUE9QJWNhUiVjYVslY2FqJWNhciVjYSFTJWNhIWwlY2EhcCVjYSNSJWNhI24lY2EjbyVjYSNwJWNhI3ElY2EjciVjYSNzJWNhI3QlY2EjdSVjYSN2JWNhI3glY2EjeiVjYSN7JWNhJE8lY2EoYCVjYShxJWNhIV0lY2EhXiVjYX5PbiVjYSFRJWNhJ3glY2EoeCVjYX5QJkp1T249fU8hUSl8Tyd4KX1PKHklUE9+UCZIbk9uPX1PIVEpfE8neCl9Tyh4JH1PflAmSnVPUjBjTyFRMGNPIVMwZE8jUyRkT1B9YVt9YWp9YW59YXJ9YSFsfWEhcH1hI1J9YSNufWEjb31hI3B9YSNxfWEjcn1hI3N9YSN0fWEjdX1hI3Z9YSN4fWEjen1hI3t9YSRPfWEneH1hKGB9YShxfWEoeH1hKHl9YSFdfWEhXn1hfk8hUSl8Tyd4KX1PUCRzYVIkc2FbJHNhaiRzYW4kc2FyJHNhIVMkc2EhbCRzYSFwJHNhI1Ikc2EjbiRzYSNvJHNhI3Akc2EjcSRzYSNyJHNhI3Mkc2EjdCRzYSN1JHNhI3Ykc2EjeCRzYSN6JHNhI3skc2EkTyRzYShgJHNhKHEkc2EoeCRzYSh5JHNhIV0kc2EhXiRzYX5PIVEpfE8neCl9T1AkdWFSJHVhWyR1YWokdWFuJHVhciR1YSFTJHVhIWwkdWEhcCR1YSNSJHVhI24kdWEjbyR1YSNwJHVhI3EkdWEjciR1YSNzJHVhI3QkdWEjdSR1YSN2JHVhI3gkdWEjeiR1YSN7JHVhJE8kdWEoYCR1YShxJHVhKHgkdWEoeSR1YSFdJHVhIV4kdWF+T249fU8hUSl8Tyd4KX1PKHgkfU8oeSVQT35PUCVUYVIlVGFbJVRhaiVUYXIlVGEhUyVUYSFsJVRhIXAlVGEjUiVUYSNuJVRhI28lVGEjcCVUYSNxJVRhI3IlVGEjcyVUYSN0JVRhI3UlVGEjdiVUYSN4JVRhI3olVGEjeyVUYSRPJVRhKGAlVGEocSVUYSFdJVRhIV4lVGF+UCclek8kTyRtcSFdJG1xIV4kbXF+UCNCXU8kTyRvcSFdJG9xIV4kb3F+UCNCXU8hXjlkT35PJE85ZU9+UCEwe08hZyN2TyFdJ2RpIWsnZGl+TyFnI3ZPKHEnbk8hXSdkaSFrJ2Rpfk8hXS9rTyFrKH1xfk8hWSdmaSFdJ2ZpflAjL1hPIV0vc08hWSlPcX5PcjlsTyFnI3ZPKHEnbk9+T1s5bk8hWTltT35QIy9YTyFZOW1Pfk9qOXRPIWcjdk9+T2coXnkhXSheeX5QITB7TyFdJ21hIV8nbWF+UCMvWE9hJVtxIV8lW3EneSVbcSFdJVtxflAjL1hPWzl5T35PIV0wfU8hXilXcX5PI2A5fU8hXSdvYSFeJ29hfk8hXTVrTyFeKVRpflAjQl1PIVM6UE9+TyFfMWdPJWk6U09+TyhVVE8oWFVPKGQ6WE9+TyFdMXJPIV4pVXF+TyFrOltPfk8hazpdT35PIWs6Xk9+TyFrOl5PflAlW08jYDphTyFdI2h5IV4jaHl+TyFdI2h5IV4jaHl+UCNCXU8laTpmT35QJjdaTyFfJ15PJWk6Zk9+TyRPI3x5IV0jfHkhXiN8eX5QI0JdT1AkfGlSJHxpWyR8aWokfGlyJHxpIVMkfGkhbCR8aSFwJHxpI1IkfGkjbiR8aSNvJHxpI3AkfGkjcSR8aSNyJHxpI3MkfGkjdCR8aSN1JHxpI3YkfGkjeCR8aSN6JHxpI3skfGkkTyR8aShgJHxpKHEkfGkhXSR8aSFeJHxpflAnJXpPIVEpfE8neCl9Tyh5JVBPUCdoYVInaGFbJ2hhaidoYW4naGFyJ2hhIVMnaGEhbCdoYSFwJ2hhI1InaGEjbidoYSNvJ2hhI3AnaGEjcSdoYSNyJ2hhI3MnaGEjdCdoYSN1J2hhI3YnaGEjeCdoYSN6J2hhI3snaGEkTydoYShgJ2hhKHEnaGEoeCdoYSFdJ2hhIV4naGF+TyFRKXxPJ3gpfU9QJ2phUidqYVsnamFqJ2phbidqYXInamEhUydqYSFsJ2phIXAnamEjUidqYSNuJ2phI28namEjcCdqYSNxJ2phI3InamEjcydqYSN0J2phI3UnamEjdidqYSN4J2phI3onamEjeydqYSRPJ2phKGAnamEocSdqYSh4J2phKHknamEhXSdqYSFeJ2phfk8oeCR9T1AlYWlSJWFpWyVhaWolYWluJWFpciVhaSFRJWFpIVMlYWkhbCVhaSFwJWFpI1IlYWkjbiVhaSNvJWFpI3AlYWkjcSVhaSNyJWFpI3MlYWkjdCVhaSN1JWFpI3YlYWkjeCVhaSN6JWFpI3slYWkkTyVhaSd4JWFpKGAlYWkocSVhaSh5JWFpIV0lYWkhXiVhaX5PKHklUE9QJWNpUiVjaVslY2lqJWNpbiVjaXIlY2khUSVjaSFTJWNpIWwlY2khcCVjaSNSJWNpI24lY2kjbyVjaSNwJWNpI3ElY2kjciVjaSNzJWNpI3QlY2kjdSVjaSN2JWNpI3glY2kjeiVjaSN7JWNpJE8lY2kneCVjaShgJWNpKHElY2koeCVjaSFdJWNpIV4lY2l+TyRPJG95IV0kb3khXiRveX5QI0JdTyRPI2N5IV0jY3khXiNjeX5QI0JdTyFnI3ZPIV0nZHEhaydkcX5PIV0va08hayh9eX5PIVknZnEhXSdmcX5QIy9YT3I6cE8hZyN2TyhxJ25Pfk9bOnRPIVk6c09+UCMvWE8hWTpzT35PZyheIVIhXSheIVJ+UCEwe09hJVt5IV8lW3kneSVbeSFdJVt5flAjL1hPIV0wfU8hXilXeX5PIV01a08hXilUcX5PKFM6ek9+TyFfMWdPJWk6fU9+TyFrO1FPfk8laTtWT35QJjdaT1AkfHFSJHxxWyR8cWokfHFyJHxxIVMkfHEhbCR8cSFwJHxxI1IkfHEjbiR8cSNvJHxxI3AkfHEjcSR8cSNyJHxxI3MkfHEjdCR8cSN1JHxxI3YkfHEjeCR8cSN6JHxxI3skfHEkTyR8cShgJHxxKHEkfHEhXSR8cSFeJHxxflAnJXpPIVEpfE8neCl9Tyh5JVBPUCdpYVInaWFbJ2lhaidpYW4naWFyJ2lhIVMnaWEhbCdpYSFwJ2lhI1InaWEjbidpYSNvJ2lhI3AnaWEjcSdpYSNyJ2lhI3MnaWEjdCdpYSN1J2lhI3YnaWEjeCdpYSN6J2lhI3snaWEkTydpYShgJ2lhKHEnaWEoeCdpYSFdJ2lhIV4naWF+TyFRKXxPJ3gpfU9QJ2thUidrYVsna2FqJ2thbidrYXIna2EhUydrYSFsJ2thIXAna2EjUidrYSNuJ2thI28na2EjcCdrYSNxJ2thI3Ina2EjcydrYSN0J2thI3Una2EjdidrYSN4J2thI3ona2EjeydrYSRPJ2thKGAna2EocSdrYSh4J2thKHkna2EhXSdrYSFeJ2thfk9QJU9xUiVPcVslT3FqJU9xciVPcSFTJU9xIWwlT3EhcCVPcSNSJU9xI24lT3EjbyVPcSNwJU9xI3ElT3EjciVPcSNzJU9xI3QlT3EjdSVPcSN2JU9xI3glT3EjeiVPcSN7JU9xJE8lT3EoYCVPcShxJU9xIV0lT3EhXiVPcX5QJyV6T2clZSFaIV0lZSFaI2AlZSFaJE8lZSFaflAhMHtPIVk7Wk9+UCMvWE9yO1tPIWcjdk8ocSduT35PWzteTyFZO1pPflAjL1hPIV0nb3EhXidvcX5QI0JdTyFdI2ghWiFeI2ghWn5QI0JdTyNrJWUhWlAlZSFaUiVlIVpbJWUhWmElZSFaaiVlIVpyJWUhWiFTJWUhWiFdJWUhWiFsJWUhWiFwJWUhWiNSJWUhWiNuJWUhWiNvJWUhWiNwJWUhWiNxJWUhWiNyJWUhWiNzJWUhWiN0JWUhWiN1JWUhWiN2JWUhWiN4JWUhWiN6JWUhWiN7JWUhWid5JWUhWihgJWUhWihxJWUhWiFrJWUhWiFZJWUhWid2JWUhWiNgJWUhWnYlZSFaIV8lZSFaJWklZSFaIWclZSFaflAjL1hPcjtmTyFnI3ZPKHEnbk9+TyFZO2dPflAjL1hPcjtuTyFnI3ZPKHEnbk9+TyFZO29PflAjL1hPUCVlIVpSJWUhWlslZSFaaiVlIVpyJWUhWiFTJWUhWiFsJWUhWiFwJWUhWiNSJWUhWiNuJWUhWiNvJWUhWiNwJWUhWiNxJWUhWiNyJWUhWiNzJWUhWiN0JWUhWiN1JWUhWiN2JWUhWiN4JWUhWiN6JWUhWiN7JWUhWiRPJWUhWihgJWUhWihxJWUhWiFdJWUhWiFeJWUhWn5QJyV6T3I7ck8hZyN2TyhxJ25Pfk92KGVYflAxcU8hUSVxT35QISlQTyhUIWxPflAhKVBPIVlmWCFdZlgjYGZYflAlMGtPUF1YUl1YW11Yal1Ycl1YIVFdWCFTXVghXV1YIV1mWCFsXVghcF1YI1JdWCNTXVgjYF1YI2BmWCNrZlgjbl1YI29dWCNwXVgjcV1YI3JdWCNzXVgjdF1YI3VdWCN2XVgjeF1YI3pdWCN7XVgkUV1YKGBdWChxXVgoeF1YKHldWH5PIWdmWCFrXVgha2ZYKHFmWH5QJ0pzT1A7dk9RO3ZPU2ZPZD1yT2UhaU9wa09yO3ZPc2tPdGtPemtPfDt2TyFPO3ZPIVNXTyFXa08hWGtPIV9YTyFpO3lPIWxaTyFvO3ZPIXA7dk8hcTt2TyFzO3pPIXU7fU8heCFoTyRXIWtPJG49cE8oUylaTyhVVE8oWFVPKGBWTyhuW09+TyFdPFpPIV4kcWF+T2glVk9wJVdPciVYT3MkdE90JHRPeiVZT3wlWk8hTzxmTyFTJHtPIV8kfE8haT13TyFsJHhPI2o8bE8kVyVfTyR0PGhPJHY8ak8keSVgTyhTKHRPKFVUTyhYVU8oYCR1Tyh4JH1PKHklUE9+T2wpYk9+UCggaU9yIWVYKHEhZVh+UCMgfU9yKGlYKHEoaVh+UCMhcE8hXl1YIV5mWH5QJ0pzTyFZZlghWSR6WCFdZlghXSR6WCNgZlh+UCEvd08jazxPT35PIWcjdk8jazxPT35PI2A8YE9+T2o8U09+TyNgPHBPIV0odlghXih2WH5PI2A8YE8hXSh0WCFeKHRYfk8jazxxT35PZzxzT35QITB7TyNrPHlPfk8jazx6T35PIWcjdk8jazx7T35PIWcjdk8jazxxT35PJE88fE9+UCNCXU8jazx9T35PI2s9T09+TyNrPVRPfk8jaz1VT35PI2s9Vk9+TyNrPVdPfk8kTz1YT35QITB7TyRPPVlPflAhMHtPayNTI1QjVSNXI1gjWyNpI2ojdSRuJHQkdiR5JV0lXiVoJWklaiVxJXMldiV3JXkle34nfVQjbyFYJ3soVCNwcyNuI3FyIVEnfCRdJ3woUyRfKGR+XCIsXG4gIGdvdG86IFwiJDhnKVtQUFBQUFApXVBQKWBQKXFQK1IvV1BQUFA2YlBQNnhQUDxwUFBQQGRQQHpQQHpQUFBAelBDU1BAelBAelBAelBDV1BDXVBDelBIdFBQUEh4UFBQUEh4S3tQUFBMUkxzUEh4UEh4UFAhIFJIeFBQUEh4UEh4UCEjWUh4UCEmcCEndSEoT1AhKHIhKHYhKHIhLFRQUFBQUFBQISx0ISd1UFAhLVUhLnZQITJTSHhIeCEyWCE1ZSE6UiE6UiE+UVBQUCE+WUh4UFBQUFBQUFBQIUFpUCFCdlBQSHghRFhQSHhQSHhIeEh4SHhIeFBIeCFFa1AhSHVQIUt7UCFMUCFMWiFMXyFMX1AhSHJQIUxjIUxjUCMgaVAjIG1IeFBIeCMgcyMkeENXQHpQQHpQQHpAelAjJlZAekB6IyhpQHojK2FAeiMtbUB6QHojLl0jMHEjMHEjMHYjMVAjMHEjMVtQUCMwcVBAeiMxdEB6IzVzQHpAejZiUFBQIzl4UFBQIzpjIzpjUCM6Y1AjOnkjOmNQUCM7UFAjOnZQIzp2IztkIzp2IzxPIzxVIzxYKWAjPFspYFAjPGMjPGMjPGNQKWBQKWBQKWBQKWBQUClgUCM8aSM8bFAjPGwpYFAjPHBQIzxzUClgUClgUClgUClgUClgUClgKWBQUCM8eSM9UCM9WyM9YiM9aCM9biM9dCM+UyM+WSM+ZCM+aiM+dCM+eiM/WyM/YiNAUyNAZiNAbCNAciNBUSNBZyNDWyNDaiNDcSNFXSNFayNHXSNHayNHcSNHdyNHfSNIWCNIXyNIZSNIbyNJUiNJWFBQUFBQUFBQUFBQI0lfUFBQUFBQUCNKUyNNWiNOcyNOeiQgU1BQUCQmblAkJnckKXAkMFokMF4kMGEkMWAkMWMkMWokMXJQJDF4JDF7UCQyaSQybSQzZSQ0cyQ0eCQ1YFBQJDVlJDVrJDVvJDVyJDV2JDV6JDZ2JDdfJDd2JDd6JDd9JDhRJDhXJDhaJDhfJDhjUiF8Um9xT1hzdCFaI2QlbCZwJnImcyZ1LG4sczJTMlZZIXZRJ14tYDFnNXFRJXN2USV7eVEmU3xRJmghVlMnVSFlLVdRJ2QhaVMnaiFyIXlVKmgkfCpYKmxRK2wlfFEreSZVUSxfJmJRLV4nXVEtaCdlUS1wJ2tRMFUqblExcSxgUjxtO3olU2RPUFdYWVpzdHV2dyFaIWAhZyFvI1MjVyNaI2QjbyN1I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJF8kYSRlJWwlcyZRJmkmbCZwJnImcyZ1JnknUidgJ3AoUihUKFooYih2KHgofCl7KmYrVStZLGssbixzLWQtbC16LlEuby52L2kwVjBkMGwwfDFqMXoxezF9MlAyUzJWMlgyeDNPM2Q0cTV5Nlo2WzZfNnI4aTh4OVNTI3FdO3chcildJFokbidWKXEtUC1TL1EyaDN7NW02aTl9OmE7djt5O3o7fTxPPFA8UTxSPFM8VDxVPFY8VzxYPFk8WjxdPGA8bTxwPHE8czx7PHw9Vj1XPXNVKnslWzxlPGZRK3EmT1EsYSZlUSxoJm1RMHIrZFEwdytmUTFTK3JRMXksZlEzVy5iUTVWMHZRNV0wfVE2UTFyUTdPM1tROFU1XlI5WTdRJ1FrT1BXWFlac3R1dnchWiFgIWchbyNTI1cjWiNkI28jdSN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRaJF8kYSRlJG4lbCVzJlEmaSZsJm0mcCZyJnMmdSZ5J1InVidgJ3AoUihUKFooYih2KHgofClxKXsqZitVK1krZCxrLG4scy1QLVMtZC1sLXouUS5iLm8udi9RL2kwVjBkMGwwfDFqMXoxezF9MlAyUzJWMlgyaDJ4M08zWzNkM3s0cTVtNXk2WjZbNl82aTZyN1E4aTh4OVM5fTphO3Y7eTt6O308TzxQPFE8UjxTPFQ8VTxWPFc8WDxZPFo8XTxgPG08cDxxPHM8ezx8PVY9Vz1zIVMhblEhciF2IXkheiR8J1UnXSdeJ2onaydsKmgqbCpuKm8tVy1eLWAtcDBVMFgxZzVxNXMlWyR0aSN2JGIkYyRkJHgkeyVPJVElXSVeJWIpdypQKlIqVCpXKl4qZCp0KnUrYytmK30sUS5hLnovXy9oL3Ivcy91MFkwWzBnMGgwaTFeMWExaTNaNFU0VjRhNGY0dzVSNVU1eDZ8N2w3djd8OFE4ZjlWOWU5bjl0OlM6Zjp0On07VjtePF48XzxhPGI8YzxkPGc8aDxpPGo8azxsPHQ8dTx2PHc8eTx6PH09Tz1QPVE9Uj1TPVQ9VT1YPVk9cD14PXk9fD19USZWfFEnUyFlUydZJWgtWlErcSZPUSxhJmVRMGYrT1ExUytyUTFYK3hRMXgsZVExeSxmUTVdMH1RNWYxWlE2UTFyUTZUMXRRNlUxd1E4VTVeUThYNWNROHE2V1E5fDhZUTpZOG5SPG8qWHJuT1hzdCFWIVojZCVsJmcmcCZyJnMmdSxuLHMyUzJWUixjJmkmel5PUFhZc3R1dnd6IVohYCFnIWohbyNTI2QjbyN1I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJFokXyRhJGUkbiVsJXMmUSZpJmwmbSZwJnImcyZ1JnknUidgJ3AoVChaKGIodih4KHwpcSl7KmYrVStZK2QsayxuLHMtUC1TLWQtbC16LlEuYi5vLnYvUS9pMFYwZDBsMHwxajF6MXsxfTJQMlMyVjJYMmgyeDNPM1szZDN7NHE1bTV5Nlo2WzZfNmk2cjdROGk4eDlTOX06YTt2O3k7ejt9PE88UDxRPFI8UzxUPFU8VjxXPFg8WTxaPF08YDxtPHA8cTxzPHs8fD1WPVc9cj1zWyNdV1ojVyNaJ1YoUiFiJWltI2gjaSNsJHglZCVnKFsoZihnKGgqVypbKl8rVytYK1osai1RLk8uVS5WLlcuWS9oL2syWzNTM1Q0WDZoNnlRJXZ4USV6eVMmUHwmVVEmXSFUUSdhIWhRJ2MhaVEobyNzUytrJXslfFErbyZPUSxZJmBRLF4mYlMtZydkJ2VRLmQocFEweytsUTFSK3JRMVQrc1ExVyt3UTFsLFpTMXAsXyxgUTJ0LWhRNVswfVE1YDFRUTVlMVlRNlAxcVE4VDVeUThXNWJROXg4U1I6dzl5IVUkemkkZCVPJVElXSVeJWIqUCpSKl4qdCp1LnovcjBZMFswZzBoMGk0VjR3N3w5ZT1wPXg9eSFeJXh5IWkhdSV6JXslfCdUJ2MnZCdlJ2kncypnK2srbC1ULWctaC1vL3swTzB7Mm0ydDJ7NGk0ajRtN3M5cFErZSV2USxPJllRLFImWlEsXSZiUS5jKG9RMWssWVUxbyxeLF8sYFEzXS5kUTV6MWxTNk8xcDFxUThtNlAjZj10I3YkYiRjJHgkeyl3KlQqVypkK2MrZit9LFEuYS9fL2gvcy91MV4xYTFpM1o0VTRhNGY1UjVVNXg2fDdsN3Y4UThmOVY5bjl0OlM6Zjp0On07VjtePGE8YzxnPGk8azx0PHY8eTx9PVA9Uj1UPVg9fD19bz11PF48XzxiPGQ8aDxqPGw8dTx3PHo9Tz1RPVM9VT1ZVyVUaSVWKnY9cFMmWSFRJmdRJlohUlEmWyFTUStTJWNSK3wmVyVdJVNpI3YkYiRjJGQkeCR7JU8lUSVdJV4lYil3KlAqUipUKlcqXipkKnQqdStjK2YrfSxRLmEuei9fL2gvci9zL3UwWTBbMGcwaDBpMV4xYTFpM1o0VTRWNGE0ZjR3NVI1VTV4Nnw3bDd2N3w4UThmOVY5ZTluOXQ6UzpmOnQ6fTtWO148XjxfPGE8YjxjPGQ8ZzxoPGk8ajxrPGw8dDx1PHY8dzx5PHo8fT1PPVA9UT1SPVM9VD1VPVg9WT1wPXg9eT18PX1UKXgkdSl5Vip7JVs8ZTxmVydZIWUlaCpYLVpTKHsjeSN6UStgJXFRK3YmUlMuXShrKGxRMWIsU1E0eDBjUjheNWsnUWtPUFdYWVpzdHV2dyFaIWAhZyFvI1MjVyNaI2QjbyN1I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJFokXyRhJGUkbiVsJXMmUSZpJmwmbSZwJnImcyZ1JnknUidWJ2AncChSKFQoWihiKHYoeCh8KXEpeypmK1UrWStkLGssbixzLVAtUy1kLWwtei5RLmIuby52L1EvaTBWMGQwbDB8MWoxejF7MX0yUDJTMlYyWDJoMngzTzNbM2QzezRxNW01eTZaNls2XzZpNnI3UThpOHg5Uzl9OmE7djt5O3o7fTxPPFA8UTxSPFM8VDxVPFY8VzxYPFk8WjxdPGA8bTxwPHE8czx7PHw9Vj1XPXMkaSReYyNZI2UlcCVyJXQoUShXKHIodylQKVEpUilTKVQpVSlWKVcpWClZKVspXilgKWUpbythK3UtVS1zLXgtfS5QLm4ucS51LncueC55L10wajJjMmYydjJ9M2MzaDNpM2ozazNsM20zbjNvM3AzcTNyM3MzdDN3M3g0UDVPNVk2azZxNnY3VjdXN2E3YjhgOHw5UTlbOWI5YzpjOnk7Ujt4PWdUI1RWI1UnUmtPUFdYWVpzdHV2dyFaIWAhZyFvI1MjVyNaI2QjbyN1I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJFokXyRhJGUkbiVsJXMmUSZpJmwmbSZwJnImcyZ1JnknUidWJ2AncChSKFQoWihiKHYoeCh8KXEpeypmK1UrWStkLGssbixzLVAtUy1kLWwtei5RLmIuby52L1EvaTBWMGQwbDB8MWoxejF7MX0yUDJTMlYyWDJoMngzTzNbM2QzezRxNW01eTZaNls2XzZpNnI3UThpOHg5Uzl9OmE7djt5O3o7fTxPPFA8UTxSPFM8VDxVPFY8VzxYPFk8WjxdPGA8bTxwPHE8czx7PHw9Vj1XPXNRJ1chZVIyaS1XIVchblEhZSFyIXYheSF6JHwnVSddJ14naidrJ2wqWCpoKmwqbipvLVctXi1gLXAwVTBYMWc1cTVzUjFkLFVucU9Yc3QhWiNkJWwmcCZyJnMmdSxuLHMyUzJWUSZ3IV5RJ3QheFMocSN1PE9RK2kleVEsVyZdUSxYJl9RLWUnYlEtcidtUy5tKHY8cVMwaytVPHtRMHkralExZixWUTJaLHVRMl0sdlEyZS1SUTJyLWZRMnUtalM1UDBsPVZRNVcwelM1WjB8PVdRNmoyZ1E2bjJzUTZzMnpROFI1WFE4fTZsUTlPNm9ROVI2dFI6YDh6JGQkXWMjWSNlJXIldChRKFcocih3KVApUSlSKVMpVClVKVYpVylYKVkpWyleKWApZSlvK2ErdS1VLXMteC19LlAubi5xLnUueC55L10wajJjMmYydjJ9M2MzaDNpM2ozazNsM20zbjNvM3AzcTNyM3MzdDN3M3g0UDVPNVk2azZxNnY3VjdXN2E3YjhgOHw5UTlbOWI5YzpjOnk7Ujt4PWdTKG0jcCdnUSh9I3pTK18lcC53Uy5eKGwoblIzVS5fJ1FrT1BXWFlac3R1dnchWiFgIWchbyNTI1cjWiNkI28jdSN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRaJF8kYSRlJG4lbCVzJlEmaSZsJm0mcCZyJnMmdSZ5J1InVidgJ3AoUihUKFooYih2KHgofClxKXsqZitVK1krZCxrLG4scy1QLVMtZC1sLXouUS5iLm8udi9RL2kwVjBkMGwwfDFqMXoxezF9MlAyUzJWMlgyaDJ4M08zWzNkM3s0cTVtNXk2WjZbNl82aTZyN1E4aTh4OVM5fTphO3Y7eTt6O308TzxQPFE8UjxTPFQ8VTxWPFc8WDxZPFo8XTxgPG08cDxxPHM8ezx8PVY9Vz1zUyNxXTt3USZyIVhRJnMhWVEmdSFbUSZ2IV1SMlIscVEnXyFoUStiJXZRLWMnYVMuYChvK2VRMnAtYlczWS5jLmQwcTBzUTZtMnFXNnozVjNYM101VFU5VTZ7Nn03UFU6ZTlXOVg5WlM7VDpkOmdRO2I7VVI7ajtjVSF3USdeLWBUNW8xZzVxIVFfT1haYHN0IVYhWiNkI2glZCVsJmcmaSZwJnImcyZ1KGgsbixzLlYyUzJWXSFwUSFyJ14tYDFnNXFUI3FdO3clXntPUFdYWVpzdHV2dyFaIWAhZyFvI1MjVyNaI2QjbyN1I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJF8kYSRlJWwlcyZRJmkmbCZtJnAmciZzJnUmeSdSJ2AncChSKFQoWihiKHYoeCh8KXsqZitVK1krZCxrLG4scy1kLWwtei5RLmIuby52L2kwVjBkMGwwfDFqMXoxezF9MlAyUzJWMlgyeDNPM1szZDRxNXk2WjZbNl82cjdROGk4eDlTUyh7I3kjelMuXShrKGwhcz1eJFokbidWKXEtUC1TL1EyaDN7NW02aTl9OmE7djt5O3o7fTxPPFA8UTxSPFM8VDxVPFY8VzxYPFk8WjxdPGA8bTxwPHE8czx7PHw9Vj1XPXNVJGZkKV0saFMobiNwJ2dVKnMlUih1M3ZVMGUqei5pN11RNVQwclE2ezNXUTlYN09SOmc5WW0hdFEhciF2IXkheideJ2onaydsLWAtcDFnNXE1c1EnciF1UyhkI2cxfFMtbidpJ3VRL24qWlEveypnUTJ8LXFRNF0vb1E0aS99UTRqME9RNG8wV1E3aDRXUzdzNGs0bVM3dzRwNHJROWc3aVE5azdvUTlwN3RROXU3eVM6bzlsOW1TO1k6cDpzUztlO1o7W1M7bTtmO2dTO3E7bjtvUjt0O3JRI3diUSdxIXVTKGMjZzF8UyhlI20rVFErViVlUStnJXdRK20lfVUtbSdpJ3IndVEuUihkUS9tKlpRL3wqZ1EwUCppUTB4K2hRMW0sW1MyeS1uLXFRM1IuWlM0Wy9uL29RNGUveVM0aC97MFdRNGwwUVE1fDFuUTZ1MnxRN2c0V1E3azRdVTdyNGk0bzRyUTd1NG5ROGs1fVM5ZjdoN2lROWo3b1E5cjd3UTlzN3hROlY4bFE6bTlnUzpuOWs5bVE6djl1UTtQOldTO1g6bzpzUztkO1k7WlM7bDtlO2dTO3A7bTtvUTtzO3FRO3U7dFE9YT1bUT1sPWVSPW09ZlYhd1EnXi1gJV5hT1BXWFlac3R1dnchWiFgIWchbyNTI1cjWiNkI28jdSN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRfJGEkZSVsJXMmUSZpJmwmbSZwJnImcyZ1JnknUidgJ3AoUihUKFooYih2KHgofCl7KmYrVStZK2QsayxuLHMtZC1sLXouUS5iLm8udi9pMFYwZDBsMHwxajF6MXsxfTJQMlMyVjJYMngzTzNbM2Q0cTV5Nlo2WzZfNnI3UThpOHg5U1Mjd3ohaiFyPVokWiRuJ1YpcS1QLVMvUTJoM3s1bTZpOX06YTt2O3k7ejt9PE88UDxRPFI8UzxUPFU8VjxXPFg8WTxaPF08YDxtPHA8cTxzPHs8fD1WPVc9c1I9YT1yJV5iT1BXWFlac3R1dnchWiFgIWchbyNTI1cjWiNkI28jdSN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRfJGEkZSVsJXMmUSZpJmwmbSZwJnImcyZ1JnknUidgJ3AoUihUKFooYih2KHgofCl7KmYrVStZK2QsayxuLHMtZC1sLXouUS5iLm8udi9pMFYwZDBsMHwxajF6MXsxfTJQMlMyVjJYMngzTzNbM2Q0cTV5Nlo2WzZfNnI3UThpOHg5U1ElZWohXiV3eSFpIXUleiV7JXwnVCdjJ2QnZSdpJ3MqZytrK2wtVC1nLWgtby97ME8wezJtMnQyezRpNGo0bTdzOXBTJX16IWpRK2gleFEsWyZiVzFuLF0sXixfLGBVNX0xbzFwMXFTOGw2TzZQUTpXOG0hcj1bJFokbidWKXEtUC1TL1EyaDN7NW02aTl9OmE7djt5O3o7fTxPPFA8UTxSPFM8VDxVPFY8VzxYPFk8WjxdPGA8bTxwPHE8czx7PHw9Vj1XPXNRPWU9cVI9Zj1yJVFlT1BYWXN0dXZ3IVohYCFnIW8jUyNkI28jdSN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRfJGEkZSVsJXMmUSZpJmwmcCZyJnMmdSZ5J1InYCdwKFQoWihiKHYoeCh8KXsqZitVK1krZCxrLG4scy1kLWwtei5RLmIuby52L2kwVjBkMGwwfDFqMXoxezF9MlAyUzJWMlgyeDNPM1szZDRxNXk2WjZbNl82cjdROGk4eDlTWSNiV1ojVyNaKFIhYiVpbSNoI2kjbCR4JWQlZyhbKGYoZyhoKlcqWypfK1crWCtaLGotUS5PLlUuVi5XLlkvaC9rMlszUzNUNFg2aDZ5USxpJm0hcD1dJFokbilxLVAtUy9RMmgzezVtNmk5fTphO3Y7eTt6O308TzxQPFE8UjxTPFQ8VTxWPFc8WDxZPFo8XTxgPG08cDxxPHM8ezx8PVY9Vz1zUj1gJ1ZVJ1ohZSVoKlhSMmstWiVTZE9QV1hZWnN0dXZ3IVohYCFnIW8jUyNXI1ojZCNvI3UjeCN7JE8kUCRRJFIkUyRUJFUkViRXJFgkXyRhJGUlbCVzJlEmaSZsJnAmciZzJnUmeSdSJ2AncChSKFQoWihiKHYoeCh8KXsqZitVK1ksayxuLHMtZC1sLXouUS5vLnYvaTBWMGQwbDB8MWoxejF7MX0yUDJTMlYyWDJ4M08zZDRxNXk2WjZbNl82cjhpOHg5UyFyKV0kWiRuJ1YpcS1QLVMvUTJoM3s1bTZpOX06YTt2O3k7ejt9PE88UDxRPFI8UzxUPFU8VjxXPFg8WTxaPF08YDxtPHA8cTxzPHs8fD1WPVc9c1EsaCZtUTByK2RRM1cuYlE3TzNbUjlZN1EhYiRUYyNZJXAoUShXKHIodylYKVkpXillK3Utcy14LX0uUC5uLnEvXTBqMnYyfTNjM3M1TzVZNnE2djdWOVE6Yzt4IVA8VSlbKW8tVS53MmMyZjNoM3EzcjN3NFA2azdXN2E3YjhgOHw5WzliOWM6eTtSPWchZiRWYyNZJXAoUShXKHIodylVKVYpWClZKV4pZSt1LXMteC19LlAubi5xL10wajJ2Mn0zYzNzNU81WTZxNnY3VjlROmM7eCFUPFcpWylvLVUudzJjMmYzaDNuM28zcTNyM3c0UDZrN1c3YTdiOGA4fDlbOWI5Yzp5O1I9ZyFeJFpjI1klcChRKFcocih3KV4pZSt1LXMteC19LlAubi5xL10wajJ2Mn0zYzNzNU81WTZxNnY3VjlROmM7eFE0Vi9mej1zKVspby1VLncyYzJmM2gzdzRQNms3VzdhN2I4YDh8OVs5YjljOnk7Uj1nUT14PXpSPXk9eydRa09QV1hZWnN0dXZ3IVohYCFnIW8jUyNXI1ojZCNvI3UjeCN7JE8kUCRRJFIkUyRUJFUkViRXJFgkWiRfJGEkZSRuJWwlcyZRJmkmbCZtJnAmciZzJnUmeSdSJ1YnYCdwKFIoVChaKGIodih4KHwpcSl7KmYrVStZK2QsayxuLHMtUC1TLWQtbC16LlEuYi5vLnYvUS9pMFYwZDBsMHwxajF6MXsxfTJQMlMyVjJYMmgyeDNPM1szZDN7NHE1bTV5Nlo2WzZfNmk2cjdROGk4eDlTOX06YTt2O3k7ejt9PE88UDxRPFI8UzxUPFU8VjxXPFg8WTxaPF08YDxtPHA8cTxzPHs8fD1WPVc9c1Mkb2gkcFIzfC9QJ1hnT1BXWFlaaHN0dXZ3IVohYCFnIW8jUyNXI1ojZCNvI3UjeCN7JE8kUCRRJFIkUyRUJFUkViRXJFgkWiRfJGEkZSRuJHAlbCVzJlEmaSZsJm0mcCZyJnMmdSZ5J1InVidgJ3AoUihUKFooYih2KHgofClxKXsqZitVK1krZCxrLG4scy1QLVMtZC1sLXouUS5iLm8udi9QL1EvaTBWMGQwbDB8MWoxejF7MX0yUDJTMlYyWDJoMngzTzNbM2QzezRxNW01eTZaNls2XzZpNnI3UThpOHg5Uzl9OmE7djt5O3o7fTxPPFA8UTxSPFM8VDxVPFY8VzxYPFk8WjxdPGA8bTxwPHE8czx7PHw9Vj1XPXNUJGtmJHFRJGlmUyloJGwpbFIpdCRxVCRqZiRxVClqJGwpbCdYaE9QV1hZWmhzdHV2dyFaIWAhZyFvI1MjVyNaI2QjbyN1I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJFokXyRhJGUkbiRwJWwlcyZRJmkmbCZtJnAmciZzJnUmeSdSJ1YnYCdwKFIoVChaKGIodih4KHwpcSl7KmYrVStZK2QsayxuLHMtUC1TLWQtbC16LlEuYi5vLnYvUC9RL2kwVjBkMGwwfDFqMXoxezF9MlAyUzJWMlgyaDJ4M08zWzNkM3s0cTVtNXk2WjZbNl82aTZyN1E4aTh4OVM5fTphO3Y7eTt6O308TzxQPFE8UjxTPFQ8VTxWPFc8WDxZPFo8XTxgPG08cDxxPHM8ezx8PVY9Vz1zVCRvaCRwUSRyaFIpcyRwJV5qT1BXWFlac3R1dnchWiFgIWchbyNTI1cjWiNkI28jdSN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRfJGEkZSVsJXMmUSZpJmwmbSZwJnImcyZ1JnknUidgJ3AoUihUKFooYih2KHgofCl7KmYrVStZK2QsayxuLHMtZC1sLXouUS5iLm8udi9pMFYwZDBsMHwxajF6MXsxfTJQMlMyVjJYMngzTzNbM2Q0cTV5Nlo2WzZfNnI3UThpOHg5UyFzPXEkWiRuJ1YpcS1QLVMvUTJoM3s1bTZpOX06YTt2O3k7ejt9PE88UDxRPFI8UzxUPFU8VjxXPFg8WTxaPF08YDxtPHA8cTxzPHs8fD1WPVc9cyNnbE9QWFpzdCFaIWAhbyNTI2QjbyN7JG4lbCZpJmwmbSZwJnImcyZ1JnknUidgKHwpcSpmK1krZCxrLG4scy1kLmIvUS9pMFYwZDFqMXoxezF9MlAyUzJWMlgzWzN7NHE1eTZaNls2XzdROGk4eCFVJVJpJGQlTyVRJV0lXiViKlAqUipeKnQqdS56L3IwWTBbMGcwaDBpNFY0dzd8OWU9cD14PXkjZih1I3YkYiRjJHgkeyl3KlQqVypkK2MrZit9LFEuYS9fL2gvcy91MV4xYTFpM1o0VTRhNGY1UjVVNXg2fDdsN3Y4UThmOVY5bjl0OlM6Zjp0On07VjtePGE8YzxnPGk8azx0PHY8eTx9PVA9Uj1UPVg9fD19UStQJWBRL14pfG8zdjxePF88YjxkPGg8ajxsPHU8dzx6PU89UT1TPVU9WSFVJHlpJGQlTyVRJV0lXiViKlAqUipeKnQqdS56L3IwWTBbMGcwaDBpNFY0dzd8OWU9cD14PXlRKmAkelUqaSR8KlgqbFErUSVhUTBRKmojZj1jI3YkYiRjJHgkeyl3KlQqVypkK2MrZit9LFEuYS9fL2gvcy91MV4xYTFpM1o0VTRhNGY1UjVVNXg2fDdsN3Y4UThmOVY5bjl0OlM6Zjp0On07VjtePGE8YzxnPGk8azx0PHY8eTx9PVA9Uj1UPVg9fD19bj1kPF48XzxiPGQ8aDxqPGw8dTx3PHo9Tz1RPVM9VT1ZUT1oPXRRPWk9dVE9aj12Uj1rPXchVSVSaSRkJU8lUSVdJV4lYipQKlIqXip0KnUuei9yMFkwWzBnMGgwaTRWNHc3fDllPXA9eD15I2YodSN2JGIkYyR4JHspdypUKlcqZCtjK2YrfSxRLmEvXy9oL3MvdTFeMWExaTNaNFU0YTRmNVI1VTV4Nnw3bDd2OFE4ZjlWOW45dDpTOmY6dDp9O1Y7XjxhPGM8ZzxpPGs8dDx2PHk8fT1QPVI9VD1YPXw9fW8zdjxePF88YjxkPGg8ajxsPHU8dzx6PU89UT1TPVU9WW5vT1hzdCFaI2QlbCZwJnImcyZ1LG4sczJTMlZTKmMkeypXUSx8JnxRLH0nT1I0YC9zJVslU2kjdiRiJGMkZCR4JHslTyVRJV0lXiViKXcqUCpSKlQqVypeKmQqdCp1K2MrZit9LFEuYS56L18vaC9yL3MvdTBZMFswZzBoMGkxXjFhMWkzWjRVNFY0YTRmNHc1UjVVNXg2fDdsN3Y3fDhROGY5VjllOW45dDpTOmY6dDp9O1Y7XjxePF88YTxiPGM8ZDxnPGg8aTxqPGs8bDx0PHU8djx3PHk8ejx9PU89UD1RPVI9Uz1UPVU9WD1ZPXA9eD15PXw9fVEsUCZaUTFgLFJRNWkxX1I4XTVqViprJHwqWCpsVSprJHwqWCpsVDVwMWc1cVMveSpmL2lRNG4wVlQ3eDRxOlBRK2cld1EwUCppUTB4K2hRMW0sW1E1fDFuUThrNX1ROlY4bFI7UDpXIVUlT2kkZCVPJVElXSVeJWIqUCpSKl4qdCp1LnovcjBZMFswZzBoMGk0VjR3N3w5ZT1wPXg9eXgqUCR2KWMqUSpyK1IvcTBeMF8zeTReNHs0fDR9N2Y3ejl2Omw9Yj1uPW9TMFkqcTBaI2Y8YSN2JGIkYyR4JHspdypUKlcqZCtjK2YrfSxRLmEvXy9oL3MvdTFeMWExaTNaNFU0YTRmNVI1VTV4Nnw3bDd2OFE4ZjlWOW45dDpTOmY6dDp9O1Y7XjxhPGM8ZzxpPGs8dDx2PHk8fT1QPVI9VD1YPXw9fW48YjxePF88YjxkPGg8ajxsPHU8dzx6PU89UT1TPVU9WSFkPHQocylhKlkqYi5lLmgubC9ZL2YvdjBwMV0zYDRTNF80YzVoN1I3VTdtN3A3fThQOWk5cTl3OnE6dTtXO107aD16PXtgPHUzdTdYN1s3YDldOmg6aztrUz1QLmczYVQ9UTdaOWAhVSVRaSRkJU8lUSVdJV4lYipQKlIqXip0KnUuei9yMFkwWzBnMGgwaTRWNHc3fDllPXA9eD15fCpSJHYpYypTKnErUi9iL3EwXjBfM3k0XjRzNHs0fDR9N2Y3ejl2Omw9Yj1uPW9TMFsqcjBdI2Y8YyN2JGIkYyR4JHspdypUKlcqZCtjK2YrfSxRLmEvXy9oL3MvdTFeMWExaTNaNFU0YTRmNVI1VTV4Nnw3bDd2OFE4ZjlWOW45dDpTOmY6dDp9O1Y7XjxhPGM8ZzxpPGs8dDx2PHk8fT1QPVI9VD1YPXw9fW48ZDxePF88YjxkPGg8ajxsPHU8dzx6PU89UT1TPVU9WSFoPHYocylhKlkqYi5mLmcubC9ZL2YvdjBwMV0zXjNgNFM0XzRjNWg3UjdTN1U3bTdwN304UDlpOXE5dzpxOnU7VztdO2g9ej17ZDx3M3U3WTdaN2A5XTleOmg6aTprO2tTPVIuaDNiVD1TN1s5YXJuT1hzdCFWIVojZCVsJmcmcCZyJnMmdSxuLHMyUzJWUSZkIVVSLGsmbXJuT1hzdCFWIVojZCVsJmcmcCZyJnMmdSxuLHMyUzJWUiZkIVVRLFQmW1IxWyt8c25PWHN0IVYhWiNkJWwmZyZwJnImcyZ1LG4sczJTMlZRMWgsWVM1dzFrMWxVOGU1dTV2NXpTOlI4ZzhoUzp7OlE6VFE7Xzp8UjtpO2BRJmshVlIsZCZnUjZUMXRSOlk4blMmUHwmVVIxVCtzUSZwIVdSLG4mcVIsdCZ2VDJULHMyVlIseCZ3USx3JndSMl4seFEndyF7Ui10J3dTc090USNkWFQlb3MjZFEjT1RSJ3kjT1EjUlVSJ3sjUlEpeSR1Ui9aKXlRI1VWUihPI1VRI1hXVShVI1goVi17UShWI1lSLXsoV1EtWCdXUjJqLVhRLnAod1MzZS5wM2ZSM2YucVEtYCdeUjJuLWBZIXJRJ14tYDFnNXFSJ2ghclEueyljUjN6LntVI19XJWcqV1UoXSNfKF4tfFEoXiNgUi18KFhRLVsnWlIybC1bdGBPWHN0IVYhWiNkJWwmZyZpJnAmciZzJnUsbixzMlMyVlMjaFolZFUjcmAjaC5WUi5WKGhRKGkjalEuUyhlVy5bKGkuUzNQNndRM1AuVFI2dzNRUSlsJGxSL1IpbFEkcGhSKXIkcFEkYGNVKV8kYC13PFtRLXc7eFI8WylvUS9sKlpXNFkvbDRaN2o5aFU0Wi9tL24vb1M3ajRbNF1SOWg3ayRlKk8kdihzKWEpYypZKmIqcSpyKnwqfStSLmcuaC5qLmsubC9ZL2IvZC9mL3EvdjBeMF8wcDFdM14zXzNgM3UzeTRTNF40XzRjNHM0dTR7NHw0fTVoN1I3UzdUN1U3WjdbN143XzdgN2Y3bTdwN3o3fThQOV05XjlfOWk5cTl2OXc6aDppOmo6azpsOnE6dTtXO107aDtrPWI9bj1vPXo9e1EvdCpiVTRiL3Q0ZDduUTRkL3ZSN240Y1MqbCR8KlhSMFMqbHgqUSR2KWMqcSpyK1IvcTBeMF8zeTReNHs0fDR9N2Y3ejl2Omw9Yj1uPW8hZC5lKHMpYSpZKmIuZy5oLmwvWS9mL3YwcDFdM2A0UzRfNGM1aDdSN1U3bTdwN304UDlpOXE5dzpxOnU7VztdO2g9ej17VS9jKlEuZTdYYTdYM3U3WjdbN2A5XTpoOms7a1EwWipxUTNhLmdVNHQwWjNhOWBSOWA3WnwqUyR2KWMqcSpyK1IvYi9xMF4wXzN5NF40czR7NHw0fTdmN3o5djpsPWI9bj1vIWguZihzKWEqWSpiLmcuaC5sL1kvZi92MHAxXTNeM2A0UzRfNGM1aDdSN1M3VTdtN3A3fThQOWk5cTl3OnE6dTtXO107aD16PXtVL2UqUy5mN1llN1kzdTdaN1s3YDldOV46aDppOms7a1EwXSpyUTNiLmhVNHYwXTNiOWFSOWE3W1EqdyVVUjBhKndRNVMwcFI4TzVTUStbJWpSMG8rW1E1bDFiUzhfNWw6T1I6TzhgUSxWJl1SMWUsVlE1cTFnUjhiNXFRMXMsYVM2UjFzOG9SOG82VFExTytvVzVfMU81YThWOXpRNWExUlE4VjVgUjl6OFdRK3QmUFIxVSt0UTJWLHNSNmMyVllyT1hzdCNkUSZ0IVpRK14lbFEsbSZwUSxvJnJRLHAmc1EsciZ1UTJRLG5TMlQsczJWUjZiMlNRJW5wUSZ4IV9RJnshYVEmfSFiUSdQIWNRJ28hdVErXSVrUStpJXlRK3smVlEsYyZrUSx6JnpXLWsnaSdxJ3IndVEtcidtUTBSKmtRMHkralMxdixkLGdRMl8seVEyYCx8UTJhLH1RMnUtalcydy1tLW4tcS1zUTVXMHpRNWQxWFE1ZzFdUTV7MW1RNlYxeFE2YTJSVTZwMnYyeTJ8UTZzMnpROFI1WFE4WjVmUThbNWhROGE1cFE4ajV8UThwNlVTOVA2cTZ1UTlSNnRROXs4WFE6VThrUTpaOHFROmI5UVE6eDl8UTtPOlZRO1M6Y1I7YTtQUSV5eVEnYiFpUSdtIXVVK2oleiV7JXxRLVInVFUtZidjJ2QnZVMtaidpJ3NRL3oqZ1MweitrK2xRMmctVFMycy1nLWhRMnotb1M0Zy97ME9RNVgwe1E2bDJtUTZvMnRRNnQye1U3cTRpNGo0bVE5bzdzUjpyOXBTJHdpPXBSKnglVlUlVWklVj1wUjBgKnZRJHZpUyhzI3YrZlMpYSRiJGNRKWMkZFEqWSR4UypiJHsqV1EqcSVPUSpyJVFRKnwlXVEqfSVeUStSJWJRLmc8YVEuaDxjUS5qPGdRLms8aVEubDxrUS9ZKXdRL2IqUFEvZCpSUS9mKlRRL3EqXlMvdipkL2hRMF4qdFEwXyp1bDBwK2MsUS5hMWExaTNaNXg2fDhmOVY6UzpmOn07VlExXSt9UTNePHRRM188dlEzYDx5UzN1PF48X1EzeS56UzRTL180VVE0Xi9yUTRfL3NRNGMvdVE0czBZUTR1MFtRNHswZ1E0fDBoUTR9MGlRNWgxXlE3Ujx9UTdTPVBRN1Q9UlE3VT1UUTdaPGJRN1s8ZFE3XjxoUTdfPGpRN2A8bFE3ZjRWUTdtNGFRN3A0ZlE3ejR3UTd9NVJROFA1VVE5XTx6UTlePHVROV88d1E5aTdsUTlxN3ZROXY3fFE5dzhRUTpoPU9ROmk9UVE6aj1TUTprPVVROmw5ZVE6cTluUTp1OXRRO1c9WFE7XTp0UTtoO15RO2s9WVE9Yj1wUT1uPXhRPW89eVE9ej18Uj17PX1RKnolW1EuaTxlUjddPGZucE9Yc3QhWiNkJWwmcCZyJnMmdSxuLHMyUzJWUSFmUFMjZlojb1EmeiFgVydmIW8qZjBWNHFRJ30jU1EpTyN7USlwJG5TLGcmaSZsUSxsJm1RLHkmeVMtTydSL2lRLWInYFEucyh8US9WKXFRMG0rWVEwcytkUTJPLGtRMnEtZFEzWC5iUTRPL1FRNHkwZFE1djFqUTZYMXpRNlkxe1E2XjF9UTZgMlBRNmUyWFE3UDNbUTdjM3tROGg1eVE4dDZaUTh1NltROHc2X1E5WjdRUTpUOGlSOl84eCNbY09QWFpzdCFaIWAhbyNkI28jeyVsJmkmbCZtJnAmciZzJnUmeSdSJ2AofCpmK1krZCxrLG4scy1kLmIvaTBWMGQxajF6MXsxfTJQMlMyVjJYM1s0cTV5Nlo2WzZfN1E4aTh4USNZV1EjZVlRJXB1USVydlMldHchZ1MoUSNXKFRRKFcjWlEociN1USh3I3hRKVAkT1EpUSRQUSlSJFFRKVMkUlEpVCRTUSlVJFRRKVYkVVEpVyRWUSlYJFdRKVkkWFEpWyRaUSleJF9RKWAkYVEpZSRlVylvJG4pcS9RM3tRK2Elc1ErdSZRUy1VJ1YyaFEtcydwUy14KFItelEtfShaUS5QKGJRLm4odlEucSh4US51O3ZRLnc7eVEueDt6US55O31RL10pe1EwaitVUTJjLVBRMmYtU1Eydi1sUTJ9LlFRM2Mub1EzaDxPUTNpPFBRM2o8UVEzazxSUTNsPFNRM208VFEzbjxVUTNvPFZRM3A8V1EzcTxYUTNyPFlRM3MudlEzdDxdUTN3PGBRM3g8bVE0UDxaUTVPMGxRNVkwfFE2azxwUTZxMnhRNnYzT1E3VjNkUTdXPHFRN2E8c1E3Yjx7UThgNW1ROHw2aVE5UTZyUTlbPHxROWI9VlE5Yz1XUTpjOVNROnk5fVE7UjphUTt4I1NSPWc9c1IjW1dSJ1ghZWwhdFEhciF2IXkheideJ2onaydsLWAtcDFnNXE1c1MnVCFlLVdVKmckfCpYKmxTLVQnVSddUzBPKmgqblEwVypvUTJtLV5RNG0wVVI0cjBYUih5I3hRIWZRVC1fJ14tYF0hcVEhcideLWAxZzVxUSNwXVInZzt3UilkJGRZIXVRJ14tYDFnNXFRJ2khclMncyF2IXlTJ3UhejVzUy1vJ2ona1EtcSdsUjJ7LXBUI2taJWRTI2paJWRTJWptLGpVKGUjaCNpI2xTLlQoZihnUS5YKGhRMG4rWlEzUS5VVTNSLlYuVy5ZUzZ4M1MzVFI5VDZ5ZCNeVyNXI1olZyhSKFsqVytXLk8vaHIjZ1ptI2gjaSNsJWQoZihnKGgrWi5VLlYuVy5ZM1MzVDZ5UypaJHgqX1EvbypbUTF8LGpRMmQtUVE0Vy9rUTZnMltRN2k0WFE4ezZoVD1fJ1YrWFYjYVclZypXVSNgVyVnKldTKFMjVyhbVShYI1orVy9oUy1WJ1YrWFQteShSLk9WJ1shZSVoKlhRJGxmUil2JHFUKWskbClsUjN9L1BUKl0keCpfVCplJHsqV1EwcStjUTFfLFFRM1YuYVE1ajFhUTV1MWlRNn0zWlE4ZzV4UTlXNnxROlE4ZlE6ZDlWUTp8OlNRO1U6ZlE7YDp9UjtjO1ZucU9Yc3QhWiNkJWwmcCZyJnMmdSxuLHMyUzJWUSZqIVZSLGMmZ3RtT1hzdCFVIVYhWiNkJWwmZyZwJnImcyZ1LG4sczJTMlZSLGombVQla20salIxYyxTUixiJmVRJlR8Uit6JlVSK3AmT1QmbiFXJnFUJm8hVyZxVDJVLHMyVlwiLFxuICBub2RlTmFtZXM6IFwi4pqgIEFyaXRoT3AgQXJpdGhPcCA/LiBKU1hTdGFydFRhZyBMaW5lQ29tbWVudCBCbG9ja0NvbW1lbnQgU2NyaXB0IEhhc2hiYW5nIEV4cG9ydERlY2xhcmF0aW9uIGV4cG9ydCBTdGFyIGFzIFZhcmlhYmxlTmFtZSBTdHJpbmcgRXNjYXBlIGZyb20gOyBkZWZhdWx0IEZ1bmN0aW9uRGVjbGFyYXRpb24gYXN5bmMgZnVuY3Rpb24gVmFyaWFibGVEZWZpbml0aW9uID4gPCBUeXBlUGFyYW1MaXN0IGluIG91dCBjb25zdCBUeXBlRGVmaW5pdGlvbiBleHRlbmRzIFRoaXNUeXBlIHRoaXMgTGl0ZXJhbFR5cGUgQXJpdGhPcCBOdW1iZXIgQm9vbGVhbkxpdGVyYWwgVGVtcGxhdGVUeXBlIEludGVycG9sYXRpb25FbmQgSW50ZXJwb2xhdGlvbiBJbnRlcnBvbGF0aW9uU3RhcnQgTnVsbFR5cGUgbnVsbCBWb2lkVHlwZSB2b2lkIFR5cGVvZlR5cGUgdHlwZW9mIE1lbWJlckV4cHJlc3Npb24gLiBQcm9wZXJ0eU5hbWUgWyBUZW1wbGF0ZVN0cmluZyBFc2NhcGUgSW50ZXJwb2xhdGlvbiBzdXBlciBSZWdFeHAgXSBBcnJheUV4cHJlc3Npb24gU3ByZWFkICwgfSB7IE9iamVjdEV4cHJlc3Npb24gUHJvcGVydHkgYXN5bmMgZ2V0IHNldCBQcm9wZXJ0eURlZmluaXRpb24gQmxvY2sgOiBOZXdUYXJnZXQgbmV3IE5ld0V4cHJlc3Npb24gKSAoIEFyZ0xpc3QgVW5hcnlFeHByZXNzaW9uIGRlbGV0ZSBMb2dpY09wIEJpdE9wIFlpZWxkRXhwcmVzc2lvbiB5aWVsZCBBd2FpdEV4cHJlc3Npb24gYXdhaXQgUGFyZW50aGVzaXplZEV4cHJlc3Npb24gQ2xhc3NFeHByZXNzaW9uIGNsYXNzIENsYXNzQm9keSBNZXRob2REZWNsYXJhdGlvbiBEZWNvcmF0b3IgQCBNZW1iZXJFeHByZXNzaW9uIFByaXZhdGVQcm9wZXJ0eU5hbWUgQ2FsbEV4cHJlc3Npb24gVHlwZUFyZ0xpc3QgQ29tcGFyZU9wIDwgZGVjbGFyZSBQcml2YWN5IHN0YXRpYyBhYnN0cmFjdCBvdmVycmlkZSBQcml2YXRlUHJvcGVydHlEZWZpbml0aW9uIFByb3BlcnR5RGVjbGFyYXRpb24gcmVhZG9ubHkgYWNjZXNzb3IgT3B0aW9uYWwgVHlwZUFubm90YXRpb24gRXF1YWxzIFN0YXRpY0Jsb2NrIEZ1bmN0aW9uRXhwcmVzc2lvbiBBcnJvd0Z1bmN0aW9uIFBhcmFtTGlzdCBQYXJhbUxpc3QgQXJyYXlQYXR0ZXJuIE9iamVjdFBhdHRlcm4gUGF0dGVyblByb3BlcnR5IFByaXZhY3kgcmVhZG9ubHkgQXJyb3cgTWVtYmVyRXhwcmVzc2lvbiBCaW5hcnlFeHByZXNzaW9uIEFyaXRoT3AgQXJpdGhPcCBBcml0aE9wIEFyaXRoT3AgQml0T3AgQ29tcGFyZU9wIGluc3RhbmNlb2Ygc2F0aXNmaWVzIENvbXBhcmVPcCBCaXRPcCBCaXRPcCBCaXRPcCBMb2dpY09wIExvZ2ljT3AgQ29uZGl0aW9uYWxFeHByZXNzaW9uIExvZ2ljT3AgTG9naWNPcCBBc3NpZ25tZW50RXhwcmVzc2lvbiBVcGRhdGVPcCBQb3N0Zml4RXhwcmVzc2lvbiBDYWxsRXhwcmVzc2lvbiBJbnN0YW50aWF0aW9uRXhwcmVzc2lvbiBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24gRHluYW1pY0ltcG9ydCBpbXBvcnQgSW1wb3J0TWV0YSBKU1hFbGVtZW50IEpTWFNlbGZDbG9zZUVuZFRhZyBKU1hTZWxmQ2xvc2luZ1RhZyBKU1hJZGVudGlmaWVyIEpTWEJ1aWx0aW4gSlNYSWRlbnRpZmllciBKU1hOYW1lc3BhY2VkTmFtZSBKU1hNZW1iZXJFeHByZXNzaW9uIEpTWFNwcmVhZEF0dHJpYnV0ZSBKU1hBdHRyaWJ1dGUgSlNYQXR0cmlidXRlVmFsdWUgSlNYRXNjYXBlIEpTWEVuZFRhZyBKU1hPcGVuVGFnIEpTWEZyYWdtZW50VGFnIEpTWFRleHQgSlNYRXNjYXBlIEpTWFN0YXJ0Q2xvc2VUYWcgSlNYQ2xvc2VUYWcgUHJlZml4Q2FzdCA8IEFycm93RnVuY3Rpb24gVHlwZVBhcmFtTGlzdCBTZXF1ZW5jZUV4cHJlc3Npb24gSW5zdGFudGlhdGlvbkV4cHJlc3Npb24gS2V5b2ZUeXBlIGtleW9mIFVuaXF1ZVR5cGUgdW5pcXVlIEltcG9ydFR5cGUgSW5mZXJyZWRUeXBlIGluZmVyIFR5cGVOYW1lIFBhcmVudGhlc2l6ZWRUeXBlIEZ1bmN0aW9uU2lnbmF0dXJlIFBhcmFtTGlzdCBOZXdTaWduYXR1cmUgSW5kZXhlZFR5cGUgVHVwbGVUeXBlIExhYmVsIEFycmF5VHlwZSBSZWFkb25seVR5cGUgT2JqZWN0VHlwZSBNZXRob2RUeXBlIFByb3BlcnR5VHlwZSBJbmRleFNpZ25hdHVyZSBQcm9wZXJ0eURlZmluaXRpb24gQ2FsbFNpZ25hdHVyZSBUeXBlUHJlZGljYXRlIGFzc2VydHMgaXMgTmV3U2lnbmF0dXJlIG5ldyBVbmlvblR5cGUgTG9naWNPcCBJbnRlcnNlY3Rpb25UeXBlIExvZ2ljT3AgQ29uZGl0aW9uYWxUeXBlIFBhcmFtZXRlcml6ZWRUeXBlIENsYXNzRGVjbGFyYXRpb24gYWJzdHJhY3QgaW1wbGVtZW50cyB0eXBlIFZhcmlhYmxlRGVjbGFyYXRpb24gbGV0IHZhciB1c2luZyBUeXBlQWxpYXNEZWNsYXJhdGlvbiBJbnRlcmZhY2VEZWNsYXJhdGlvbiBpbnRlcmZhY2UgRW51bURlY2xhcmF0aW9uIGVudW0gRW51bUJvZHkgTmFtZXNwYWNlRGVjbGFyYXRpb24gbmFtZXNwYWNlIG1vZHVsZSBBbWJpZW50RGVjbGFyYXRpb24gZGVjbGFyZSBHbG9iYWxEZWNsYXJhdGlvbiBnbG9iYWwgQ2xhc3NEZWNsYXJhdGlvbiBDbGFzc0JvZHkgQW1iaWVudEZ1bmN0aW9uRGVjbGFyYXRpb24gRXhwb3J0R3JvdXAgVmFyaWFibGVOYW1lIFZhcmlhYmxlTmFtZSBJbXBvcnREZWNsYXJhdGlvbiBJbXBvcnRHcm91cCBGb3JTdGF0ZW1lbnQgZm9yIEZvclNwZWMgRm9ySW5TcGVjIEZvck9mU3BlYyBvZiBXaGlsZVN0YXRlbWVudCB3aGlsZSBXaXRoU3RhdGVtZW50IHdpdGggRG9TdGF0ZW1lbnQgZG8gSWZTdGF0ZW1lbnQgaWYgZWxzZSBTd2l0Y2hTdGF0ZW1lbnQgc3dpdGNoIFN3aXRjaEJvZHkgQ2FzZUxhYmVsIGNhc2UgRGVmYXVsdExhYmVsIFRyeVN0YXRlbWVudCB0cnkgQ2F0Y2hDbGF1c2UgY2F0Y2ggRmluYWxseUNsYXVzZSBmaW5hbGx5IFJldHVyblN0YXRlbWVudCByZXR1cm4gVGhyb3dTdGF0ZW1lbnQgdGhyb3cgQnJlYWtTdGF0ZW1lbnQgYnJlYWsgQ29udGludWVTdGF0ZW1lbnQgY29udGludWUgRGVidWdnZXJTdGF0ZW1lbnQgZGVidWdnZXIgTGFiZWxlZFN0YXRlbWVudCBFeHByZXNzaW9uU3RhdGVtZW50IFNpbmdsZUV4cHJlc3Npb24gU2luZ2xlQ2xhc3NJdGVtXCIsXG4gIG1heFRlcm06IDM3OSxcbiAgY29udGV4dDogdHJhY2tOZXdsaW5lLFxuICBub2RlUHJvcHM6IFtcbiAgICBbXCJpc29sYXRlXCIsIC04LDUsNiwxNCwzNywzOSw1MSw1Myw1NSxcIlwiXSxcbiAgICBbXCJncm91cFwiLCAtMjYsOSwxNywxOSw2OCwyMDcsMjExLDIxNSwyMTYsMjE4LDIyMSwyMjQsMjM0LDIzNiwyNDIsMjQ0LDI0NiwyNDgsMjUxLDI1NywyNjMsMjY1LDI2NywyNjksMjcxLDI3MywyNzQsXCJTdGF0ZW1lbnRcIiwtMzQsMTMsMTQsMzIsMzUsMzYsNDIsNTEsNTQsNTUsNTcsNjIsNzAsNzIsNzYsODAsODIsODQsODUsMTEwLDExMSwxMjAsMTIxLDEzNiwxMzksMTQxLDE0MiwxNDMsMTQ0LDE0NSwxNDcsMTQ4LDE2NywxNjksMTcxLFwiRXhwcmVzc2lvblwiLC0yMywzMSwzMywzNyw0MSw0Myw0NSwxNzMsMTc1LDE3NywxNzgsMTgwLDE4MSwxODIsMTg0LDE4NSwxODYsMTg4LDE4OSwxOTAsMjAxLDIwMywyMDUsMjA2LFwiVHlwZVwiLC0zLDg4LDEwMywxMDksXCJDbGFzc0l0ZW1cIl0sXG4gICAgW1wib3BlbmVkQnlcIiwgMjMsXCI8XCIsMzgsXCJJbnRlcnBvbGF0aW9uU3RhcnRcIiw1NixcIltcIiw2MCxcIntcIiw3MyxcIihcIiwxNjAsXCJKU1hTdGFydENsb3NlVGFnXCJdLFxuICAgIFtcImNsb3NlZEJ5XCIsIC0yLDI0LDE2OCxcIj5cIiw0MCxcIkludGVycG9sYXRpb25FbmRcIiw1MCxcIl1cIiw2MSxcIn1cIiw3NCxcIilcIiwxNjUsXCJKU1hFbmRUYWdcIl1cbiAgXSxcbiAgcHJvcFNvdXJjZXM6IFtqc0hpZ2hsaWdodF0sXG4gIHNraXBwZWROb2RlczogWzAsNSw2LDI3N10sXG4gIHJlcGVhdE5vZGVDb3VudDogMzcsXG4gIHRva2VuRGF0YTogXCIkRnEwN1tSIWJPWCVaWFkrZ1laLXlaWytnW10lWl1eLmNecCVacHErZ3FyL21yczNjc3Q6X3R1RXJ1dkpTdndMa3d4ISBZeHkhJ2l5eiEoc3p7ISl9e3whLHF8fSEuT30hTyEscSFPIVAhL1khUCFRITlqIVEhUiM6TyFSIVsjPF8hWyFdI0lfIV0hXiNKayFeIV8jS3UhXyFgJCFbIWAhYSQkdiFhIWIkKlQhYiFjJCxyIWMhfUVyIX0jTyQtfCNPI1AkL1cjUCNRJDRvI1EjUiQ1eSNSI1NFciNTI1QkN1cjVCNvJDhiI28jcCQ8ciNwI3EkPWgjcSNyJD54I3IjcyRAVSNzJGYlWiRmJGcrZyRnI0JZRXIjQlkjQlokQWAjQlokSVNFciRJUyRJXyRBYCRJXyRJfEVyJEl8JEl9JERrJEl9JEpPJERrJEpPJEpURXIkSlQkSlUkQWAkSlUkS1ZFciRLViRLVyRBYCRLVyZGVUVyJkZVJkZWJEFgJkZWOydTRXI7J1M7PWBJfDwlbD9IVEVyP0hUP0hVJEFgP0hVT0VyKG4lZF8kaSZqKFZwKFkhYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJmomaFQkaSZqTyFeJmMhXyNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmMmaiZ6UDs9YDwlbCZjJ3wnVV0kaSZqKFkhYk9ZJn1ZWiZjWncmfXd4JmN4IV4mfSFeIV8nfSFfI08mfSNPI1AmYyNQI28mfSNvI3AnfSNwOydTJn07J1M7PWAobDwlbE8mfSFiKFNVKFkhYk9ZJ31adyd9eCNPJ30jUDsnUyd9OydTOz1gKGY8JWxPJ30hYihpUDs9YDwlbCd9J3wob1A7PWA8JWwmfSdbKHldJGkmaihWcE9ZKHJZWiZjWnIocnJzJmNzIV4ociFeIV8pciFfI08ociNPI1AmYyNQI28ociNvI3ApciNwOydTKHI7J1M7PWAqYTwlbE8ocnApd1UoVnBPWSlyWnIpcnMjTylyI1A7J1MpcjsnUzs9YCpaPCVsTylycCpeUDs9YDwlbClyJ1sqZFA7PWA8JWwociNTKm5YKFZwKFkhYk9ZKmdacipncnMnfXN3Kmd3eClyeCNPKmcjUDsnUypnOydTOz1gK1o8JWxPKmcjUyteUDs9YDwlbCpnKG4rZFA7PWA8JWwlWjA3WytycSRpJmooVnAoWSFiJ3swL2xPWCVaWFkrZ1laJmNaWytnW3AlWnBxK2dxciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcCRmJVokZiRnK2ckZyNCWSVaI0JZI0JaK2cjQlokSVMlWiRJUyRJXytnJElfJEpUJVokSlQkSlUrZyRKVSRLViVaJEtWJEtXK2ckS1cmRlUlWiZGVSZGVitnJkZWOydTJVo7J1M7PWArYTwlbD9IVCVaP0hUP0hVK2c/SFVPJVowN1suU1QoVyNTJGkmaid8MC9sTyFeJmMhXyNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmMwN1subl8kaSZqKFZwKFkhYid8MC9sT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVopM3AveGAkaSZqIXApLFEoVnAoWSFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgMHohYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVooS1cxVmAjdihDaCRpJmooVnAoWSFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgMlghYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVooS1cyZF8jdihDaCRpJmooVnAoWSFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonQXQzbF8oVSc6ZiRpJmooWSFiT1k0a1laNXFacjRrcnM3bnN3NGt3eDVxeCFeNGshXiFfOHAhXyNPNGsjTyNQNXEjUCNvNGsjbyNwOHAjcDsnUzRrOydTOz1gOlg8JWxPNGsoXjRyXyRpJmooWSFiT1k0a1laNXFacjRrcnM3bnN3NGt3eDVxeCFeNGshXiFfOHAhXyNPNGsjTyNQNXEjUCNvNGsjbyNwOHAjcDsnUzRrOydTOz1gOlg8JWxPNGsmejV2WCRpJmpPcjVxcnM2Y3MhXjVxIV4hXzZ5IV8jbzVxI28jcDZ5I3A7J1M1cTsnUzs9YDdoPCVsTzVxJno2alQkZGAkaSZqTyFeJmMhXyNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmNgNnxUT3I2eXJzN11zOydTNnk7J1M7PWA3YjwlbE82eWA3Yk8kZGBgN2VQOz1gPCVsNnkmejdrUDs9YDwlbDVxKF43d10kZGAkaSZqKFkhYk9ZJn1ZWiZjWncmfXd4JmN4IV4mfSFeIV8nfSFfI08mfSNPI1AmYyNQI28mfSNvI3AnfSNwOydTJn07J1M7PWAobDwlbE8mfSFyOHVaKFkhYk9ZOHBZWjZ5WnI4cHJzOWhzdzhwd3g2eXgjTzhwI08jUDZ5I1A7J1M4cDsnUzs9YDpSPCVsTzhwIXI5b1UkZGAoWSFiT1knfVp3J314I08nfSNQOydTJ307J1M7PWAoZjwlbE8nfSFyOlVQOz1gPCVsOHAoXjpbUDs9YDwlbDRrJTlbOmhoJGkmaihWcChZIWJPWSVaWVomY1pxJVpxcjxTcnMmfXN0JVp0dUNydXclWnd4KHJ4IV4lWiFeIV8qZyFfIWMlWiFjIX1DciF9I08lWiNPI1AmYyNQI1IlWiNSI1NDciNTI1QlWiNUI29DciNvI3AqZyNwJGclWiRnOydTQ3I7J1M7PWBFbDwlbE9DcihyPF9fV1MkaSZqKFZwKFkhYk9ZPFNZWiZjWnI8U3JzPV5zdzxTd3hAbnghXjxTIV4hX0JtIV8jTzxTI08jUD5gI1AjbzxTI28jcEJtI3A7J1M8UzsnUzs9YENsPCVsTzxTKFE9Z11XUyRpJmooWSFiT1k9XllaJmNadz1ed3g+YHghXj1eIV4hXz9xIV8jTz1eI08jUD5gI1Ajbz1eI28jcD9xI3A7J1M9XjsnUzs9YEBoPCVsTz1eJm4+Z1hXUyRpJmpPWT5gWVomY1ohXj5gIV4hXz9TIV8jbz5gI28jcD9TI3A7J1M+YDsnUzs9YD9rPCVsTz5gUz9YU1dTT1k/U1o7J1M/UzsnUzs9YD9lPCVsTz9TUz9oUDs9YDwlbD9TJm4/blA7PWA8JWw+YCFmP3hXV1MoWSFiT1k/cVp3P3F3eD9TeCNPP3EjTyNQP1MjUDsnUz9xOydTOz1gQGI8JWxPP3EhZkBlUDs9YDwlbD9xKFFAa1A7PWA8JWw9XidgQHddV1MkaSZqKFZwT1lAbllaJmNackBucnM+YHMhXkBuIV4hX0FwIV8jT0BuI08jUD5gI1Ajb0BuI28jcEFwI3A7J1NAbjsnUzs9YEJnPCVsT0BudEF3V1dTKFZwT1lBcFpyQXBycz9TcyNPQXAjTyNQP1MjUDsnU0FwOydTOz1gQmE8JWxPQXB0QmRQOz1gPCVsQXAnYEJqUDs9YDwlbEBuI1dCdllXUyhWcChZIWJPWUJtWnJCbXJzP3Fzd0Jtd3hBcHgjT0JtI08jUD9TI1A7J1NCbTsnUzs9YENmPCVsT0JtI1dDaVA7PWA8JWxCbShyQ29QOz1gPCVsPFMlOVtDfWkkaSZqKG4lMWwoVnAoWSFiT1klWllaJmNaciVacnMmfXN0JVp0dUNydXclWnd4KHJ4IVElWiFRIVtDciFbIV4lWiFeIV8qZyFfIWMlWiFjIX1DciF9I08lWiNPI1AmYyNQI1IlWiNSI1NDciNTI1QlWiNUI29DciNvI3AqZyNwJGclWiRnOydTQ3I7J1M7PWBFbDwlbE9DciU5W0VvUDs9YDwlbENyMDdbRlJrJGkmaihWcChZIWIkXSN0KFMsMmooZCRJW09ZJVpZWiZjWnIlWnJzJn1zdCVadHVFcnV3JVp3eChyeH0lWn0hT0d2IU8hUSVaIVEhW0VyIVshXiVaIV4hXypnIV8hYyVaIWMhfUVyIX0jTyVaI08jUCZjI1AjUiVaI1IjU0VyI1MjVCVaI1Qjb0VyI28jcCpnI3AkZyVaJGc7J1NFcjsnUzs9YEl8PCVsT0VyK2RIUmskaSZqKFZwKFkhYiRdI3RPWSVaWVomY1pyJVpycyZ9c3QlWnR1R3Z1dyVad3gocnh9JVp9IU9HdiFPIVElWiFRIVtHdiFbIV4lWiFeIV8qZyFfIWMlWiFjIX1HdiF9I08lWiNPI1AmYyNQI1IlWiNSI1NHdiNTI1QlWiNUI29HdiNvI3AqZyNwJGclWiRnOydTR3Y7J1M7PWBJdjwlbE9HditkSXlQOz1gPCVsR3YwN1tKUFA7PWA8JWxFcihLV0pfYCRpJmooVnAoWSFiI3AoQ2hPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfIWBLYSFgI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWihLV0tsXyRpJmokUShDaChWcChZIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiwjeEx2YSh5K0pZJGkmaihWcChZIWJPWSVaWVomY1pyJVpycyZ9c3YlWnZ3TXt3eChyeCFeJVohXiFfKmchXyFgS2EhYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVooS1dOV2AkaSZqI3ooQ2goVnAoWSFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgS2EhYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonQXQhIGNfKFgnO1ckaSZqKFZwT1khIWJZWiEjaFpyISFicnMhI2hzdyEhYnd4ISR4eCFeISFiIV4hXyEleiFfI08hIWIjTyNQISNoI1AjbyEhYiNvI3AhJXojcDsnUyEhYjsnUzs9YCEnYzwlbE8hIWInbCEhaV8kaSZqKFZwT1khIWJZWiEjaFpyISFicnMhI2hzdyEhYnd4ISR4eCFeISFiIV4hXyEleiFfI08hIWIjTyNQISNoI1AjbyEhYiNvI3AhJXojcDsnUyEhYjsnUzs9YCEnYzwlbE8hIWImeiEjbVgkaSZqT3chI2h3eDZjeCFeISNoIV4hXyEkWSFfI28hI2gjbyNwISRZI3A7J1MhI2g7J1M7PWAhJHI8JWxPISNoYCEkXVRPdyEkWXd4N114OydTISRZOydTOz1gISRsPCVsTyEkWWAhJG9QOz1gPCVsISRZJnohJHVQOz1gPCVsISNoJ2whJVJdJGRgJGkmaihWcE9ZKHJZWiZjWnIocnJzJmNzIV4ociFeIV8pciFfI08ociNPI1AmYyNQI28ociNvI3ApciNwOydTKHI7J1M7PWAqYTwlbE8ociFRISZQWihWcE9ZISV6WVohJFlaciElenJzISRZc3chJXp3eCEmcngjTyEleiNPI1AhJFkjUDsnUyElejsnUzs9YCEnXTwlbE8hJXohUSEmeVUkZGAoVnBPWSlyWnIpcnMjTylyI1A7J1MpcjsnUzs9YCpaPCVsTylyIVEhJ2BQOz1gPCVsISV6J2whJ2ZQOz1gPCVsISFiLzV8ISd0XyFsLy5eJGkmaihWcChZIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiMmVSEpT18hayFMZiRpJmooVnAoWSFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVotIW4hKltiJGkmaihWcChZIWIoVCUmZiNxKENoT1klWllaJmNaciVacnMmfXN3JVp3eChyeHolWnp7IStkeyFeJVohXiFfKmchXyFgS2EhYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVooS1chK29gJGkmaihWcChZIWIjbihDaE9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYEthIWAjTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKzt4ISx8YCRpJmooVnAoWSFicis0WU9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYEthIWAjTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaLCRVIS5aXyFdK0pmJGkmaihWcChZIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWjA3WyEvZWMkaSZqKFZwKFkhYiFRLjJeT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFPJVohTyFQITBwIVAhUSVaIVEhWyEzWSFbIV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiMlfCEweWEkaSZqKFZwKFkhYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghTyVaIU8hUCEyTyFQIV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiMlfCEyWl8hWyFMXiRpJmooVnAoWSFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonQWQhM2VnJGkmaihWcChZIWJzJzl0T1klWllaJmNaciVacnMmfXN3JVp3eChyeCFRJVohUSFbITNZIVshXiVaIV4hXypnIV8hZyVaIWchaCE0fCFoI08lWiNPI1AmYyNQI1IlWiNSI1MhM1kjUyNYJVojWCNZITR8I1kjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJ0FkITVWZyRpJmooVnAoWSFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeHslWnt8ITZufH0lWn0hTyE2biFPIVElWiFRIVshOFMhWyFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNSJVojUiNTIThTI1MjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJ0FkITZ3YyRpJmooVnAoWSFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFRJVohUSFbIThTIVshXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjUiVaI1IjUyE4UyNTI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWidBZCE4X2MkaSZqKFZwKFkhYnMnOXRPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IVElWiFRIVshOFMhWyFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNSJVojUiNTIThTI1MjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaMDdbITl1ZiRpJmooVnAoWSFiI28oQ2hPWSE7WllaJmNaciE7WnJzITxuc3chO1p3eCFMY3h6ITtaensjLX17IVAhO1ohUCFRIy9kIVEhXiE7WiFeIV8jKGkhXyFgIzdTIWAhYSM4aSFhIX0hO1ohfSNPIyxmI08jUCFEeSNQI28hO1ojbyNwIyhpI3A7J1MhO1o7J1M7PWAjLXc8JWxPITtaP08hO2ZiJGkmaihWcChZIWIhWDdgT1khO1pZWiZjWnIhO1pycyE8bnN3ITtad3ghTGN4IVAhO1ohUCFRIyZgIVEhXiE7WiFeIV8jKGkhXyF9ITtaIX0jTyMsZiNPI1AhRHkjUCNvITtaI28jcCMoaSNwOydTITtaOydTOz1gIy13PCVsTyE7Wj5eITx3YCRpJmooWSFiIVg3YE9ZITxuWVomY1p3ITxud3ghPXl4IVAhPG4hUCFRIUVxIVEhXiE8biFeIV8hR3IhXyF9ITxuIX0jTyFLUyNPI1AhRHkjUCNvITxuI28jcCFHciNwOydTITxuOydTOz1gIUxdPCVsTyE8bjx6IT5RXiRpJmohWDdgT1khPXlZWiZjWiFQIT15IVAhUSE+fCFRIV4hPXkhXiFfIUBjIV8hfSE9eSF9I08hQ1cjTyNQIUR5I1AjbyE9eSNvI3AhQGMjcDsnUyE9eTsnUzs9YCFFazwlbE8hPXk8eiE/VGQkaSZqIVg3YE8hXiZjIV8jVyZjI1cjWCE+fCNYI1omYyNaI1shPnwjWyNdJmMjXSNeIT58I14jYSZjI2EjYiE+fCNiI2cmYyNnI2ghPnwjaCNpJmMjaSNqIT58I2ojayE+fCNrI20mYyNtI24hPnwjbiNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmM3YCFAaFghWDdgT1khQGNaIVAhQGMhUCFRIUFUIVEhfSFAYyF9I08hQXIjTyNQIUJxI1A7J1MhQGM7J1M7PWAhQ1E8JWxPIUBjN2AhQVlXIVg3YCNXI1ghQVQjWiNbIUFUI10jXiFBVCNhI2IhQVQjZyNoIUFUI2kjaiFBVCNqI2shQVQjbSNuIUFUN2AhQXVWT1khQXJaI08hQXIjTyNQIUJbI1AjUSFAYyNROydTIUFyOydTOz1gIUJrPCVsTyFBcjdgIUJfU09ZIUFyWjsnUyFBcjsnUzs9YCFCazwlbE8hQXI3YCFCblA7PWA8JWwhQXI3YCFCdFNPWSFAY1o7J1MhQGM7J1M7PWAhQ1E8JWxPIUBjN2AhQ1RQOz1gPCVsIUBjPHohQ11bJGkmak9ZIUNXWVomY1ohXiFDVyFeIV8hQXIhXyNPIUNXI08jUCFEUiNQI1EhPXkjUSNvIUNXI28jcCFBciNwOydTIUNXOydTOz1gIURzPCVsTyFDVzx6IURXWCRpJmpPWSFDV1laJmNaIV4hQ1chXiFfIUFyIV8jbyFDVyNvI3AhQXIjcDsnUyFDVzsnUzs9YCFEczwlbE8hQ1c8eiFEdlA7PWA8JWwhQ1c8eiFFT1gkaSZqT1khPXlZWiZjWiFeIT15IV4hXyFAYyFfI28hPXkjbyNwIUBjI3A7J1MhPXk7J1M7PWAhRWs8JWxPIT15PHohRW5QOz1gPCVsIT15Pl4hRXpsJGkmaihZIWIhWDdgT1kmfVlaJmNadyZ9d3gmY3ghXiZ9IV4hXyd9IV8jTyZ9I08jUCZjI1AjVyZ9I1cjWCFFcSNYI1omfSNaI1shRXEjWyNdJn0jXSNeIUVxI14jYSZ9I2EjYiFFcSNiI2cmfSNnI2ghRXEjaCNpJn0jaSNqIUVxI2ojayFFcSNrI20mfSNtI24hRXEjbiNvJn0jbyNwJ30jcDsnUyZ9OydTOz1gKGw8JWxPJn04ciFHeVooWSFiIVg3YE9ZIUdyWnchR3J3eCFAY3ghUCFHciFQIVEhSGwhUSF9IUdyIX0jTyFKVSNPI1AhQnEjUDsnUyFHcjsnUzs9YCFKfDwlbE8hR3I4ciFIc2UoWSFiIVg3YE9ZJ31adyd9eCNPJ30jUCNXJ30jVyNYIUhsI1gjWid9I1ojWyFIbCNbI10nfSNdI14hSGwjXiNhJ30jYSNiIUhsI2IjZyd9I2cjaCFIbCNoI2knfSNpI2ohSGwjaiNrIUhsI2sjbSd9I20jbiFIbCNuOydTJ307J1M7PWAoZjwlbE8nfThyIUpaWChZIWJPWSFKVVp3IUpVd3ghQXJ4I08hSlUjTyNQIUJbI1AjUSFHciNROydTIUpVOydTOz1gIUp2PCVsTyFKVThyIUp5UDs9YDwlbCFKVThyIUtQUDs9YDwlbCFHcj5eIUtaXiRpJmooWSFiT1khS1NZWiZjWnchS1N3eCFDV3ghXiFLUyFeIV8hSlUhXyNPIUtTI08jUCFEUiNQI1EhPG4jUSNvIUtTI28jcCFKVSNwOydTIUtTOydTOz1gIUxWPCVsTyFLUz5eIUxZUDs9YDwlbCFLUz5eIUxgUDs9YDwlbCE8bj1sIUxsYCRpJmooVnAhWDdgT1khTGNZWiZjWnIhTGNycyE9eXMhUCFMYyFQIVEhTW4hUSFeIUxjIV4hXyMgbyFfIX0hTGMhfSNPIyVQI08jUCFEeSNQI28hTGMjbyNwIyBvI3A7J1MhTGM7J1M7PWAjJlk8JWxPIUxjPWwhTXdsJGkmaihWcCFYN2BPWShyWVomY1pyKHJycyZjcyFeKHIhXiFfKXIhXyNPKHIjTyNQJmMjUCNXKHIjVyNYIU1uI1gjWihyI1ojWyFNbiNbI10ociNdI14hTW4jXiNhKHIjYSNiIU1uI2IjZyhyI2cjaCFNbiNoI2kociNpI2ohTW4jaiNrIU1uI2sjbShyI20jbiFNbiNuI28ociNvI3ApciNwOydTKHI7J1M7PWAqYTwlbE8ocjhRIyB2WihWcCFYN2BPWSMgb1pyIyBvcnMhQGNzIVAjIG8hUCFRIyFpIVEhfSMgbyF9I08jJFIjTyNQIUJxI1A7J1MjIG87J1M7PWAjJHk8JWxPIyBvOFEjIXBlKFZwIVg3YE9ZKXJacilycyNPKXIjUCNXKXIjVyNYIyFpI1gjWilyI1ojWyMhaSNbI10pciNdI14jIWkjXiNhKXIjYSNiIyFpI2IjZylyI2cjaCMhaSNoI2kpciNpI2ojIWkjaiNrIyFpI2sjbSlyI20jbiMhaSNuOydTKXI7J1M7PWAqWjwlbE8pcjhRIyRXWChWcE9ZIyRSWnIjJFJycyFBcnMjTyMkUiNPI1AhQlsjUCNRIyBvI1E7J1MjJFI7J1M7PWAjJHM8JWxPIyRSOFEjJHZQOz1gPCVsIyRSOFEjJHxQOz1gPCVsIyBvPWwjJVdeJGkmaihWcE9ZIyVQWVomY1pyIyVQcnMhQ1dzIV4jJVAhXiFfIyRSIV8jTyMlUCNPI1AhRFIjUCNRIUxjI1EjbyMlUCNvI3AjJFIjcDsnUyMlUDsnUzs9YCMmUzwlbE8jJVA9bCMmVlA7PWA8JWwjJVA9bCMmXVA7PWA8JWwhTGM/TyMma24kaSZqKFZwKFkhYiFYN2BPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI1clWiNXI1gjJmAjWCNaJVojWiNbIyZgI1sjXSVaI10jXiMmYCNeI2ElWiNhI2IjJmAjYiNnJVojZyNoIyZgI2gjaSVaI2kjaiMmYCNqI2sjJmAjayNtJVojbSNuIyZgI24jbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaOWQjKHJdKFZwKFkhYiFYN2BPWSMoaVpyIyhpcnMhR3JzdyMoaXd4IyBveCFQIyhpIVAhUSMpayFRIX0jKGkhfSNPIytgI08jUCFCcSNQOydTIyhpOydTOz1gIyxgPCVsTyMoaTlkIyl0aChWcChZIWIhWDdgT1kqZ1pyKmdycyd9c3cqZ3d4KXJ4I08qZyNQI1cqZyNXI1gjKWsjWCNaKmcjWiNbIylrI1sjXSpnI10jXiMpayNeI2EqZyNhI2IjKWsjYiNnKmcjZyNoIylrI2gjaSpnI2kjaiMpayNqI2sjKWsjayNtKmcjbSNuIylrI247J1MqZzsnUzs9YCtaPCVsTypnOWQjK2daKFZwKFkhYk9ZIytgWnIjK2BycyFKVXN3Iytgd3gjJFJ4I08jK2AjTyNQIUJbI1AjUSMoaSNROydTIytgOydTOz1gIyxZPCVsTyMrYDlkIyxdUDs9YDwlbCMrYDlkIyxjUDs9YDwlbCMoaT9PIyxvYCRpJmooVnAoWSFiT1kjLGZZWiZjWnIjLGZycyFLU3N3Iyxmd3gjJVB4IV4jLGYhXiFfIytgIV8jTyMsZiNPI1AhRFIjUCNRITtaI1EjbyMsZiNvI3AjK2AjcDsnUyMsZjsnUzs9YCMtcTwlbE8jLGY/TyMtdFA7PWA8JWwjLGY/TyMtelA7PWA8JWwhO1owN1sjLltiJGkmaihWcChZIWInfTAvbCFYN2BPWSE7WllaJmNaciE7WnJzITxuc3chO1p3eCFMY3ghUCE7WiFQIVEjJmAhUSFeITtaIV4hXyMoaSFfIX0hO1ohfSNPIyxmI08jUCFEeSNQI28hO1ojbyNwIyhpI3A7J1MhO1o7J1M7PWAjLXc8JWxPITtaMDdbIy9vXyRpJmooVnAoWSFiVDAvbE9ZIy9kWVomY1pyIy9kcnMjMG5zdyMvZHd4IzRPeCFeIy9kIV4hXyM1fSFfI08jL2QjTyNQIzFwI1AjbyMvZCNvI3AjNX0jcDsnUyMvZDsnUzs9YCM2fDwlbE8jL2QwNmojMHddJGkmaihZIWJUMC9sT1kjMG5ZWiZjWncjMG53eCMxcHghXiMwbiFeIV8jM1IhXyNPIzBuI08jUCMxcCNQI28jMG4jbyNwIzNSI3A7J1MjMG47J1M7PWAjM3g8JWxPIzBuMDVXIzF3WCRpJmpUMC9sT1kjMXBZWiZjWiFeIzFwIV4hXyMyZCFfI28jMXAjbyNwIzJkI3A7J1MjMXA7J1M7PWAjMns8JWxPIzFwMC9sIzJpU1QwL2xPWSMyZFo7J1MjMmQ7J1M7PWAjMnU8JWxPIzJkMC9sIzJ4UDs9YDwlbCMyZDA1VyMzT1A7PWA8JWwjMXAwMU8jM1lXKFkhYlQwL2xPWSMzUlp3IzNSd3gjMmR4I08jM1IjTyNQIzJkI1A7J1MjM1I7J1M7PWAjM3I8JWxPIzNSMDFPIzN1UDs9YDwlbCMzUjA2aiMze1A7PWA8JWwjMG4wNXgjNFhdJGkmaihWcFQwL2xPWSM0T1laJmNaciM0T3JzIzFwcyFeIzRPIV4hXyM1USFfI08jNE8jTyNQIzFwI1AjbyM0TyNvI3AjNVEjcDsnUyM0TzsnUzs9YCM1dzwlbE8jNE8wMF4jNVhXKFZwVDAvbE9ZIzVRWnIjNVFycyMyZHMjTyM1USNPI1AjMmQjUDsnUyM1UTsnUzs9YCM1cTwlbE8jNVEwMF4jNXRQOz1gPCVsIzVRMDV4IzV6UDs9YDwlbCM0TzAxcCM2V1koVnAoWSFiVDAvbE9ZIzV9WnIjNX1ycyMzUnN3IzV9d3gjNVF4I08jNX0jTyNQIzJkI1A7J1MjNX07J1M7PWAjNnY8JWxPIzV9MDFwIzZ5UDs9YDwlbCM1fTA3WyM3UFA7PWA8JWwjL2QpM2gjN2FiJGkmaiRRKENoKFZwKFkhYiFYN2BPWSE7WllaJmNaciE7WnJzITxuc3chO1p3eCFMY3ghUCE7WiFQIVEjJmAhUSFeITtaIV4hXyMoaSFfIX0hO1ohfSNPIyxmI08jUCFEeSNQI28hO1ojbyNwIyhpI3A7J1MhO1o7J1M7PWAjLXc8JWxPITtaQXQjOHZiJFojdCRpJmooVnAoWSFiIVg3YE9ZITtaWVomY1pyITtacnMhPG5zdyE7Wnd4IUxjeCFQITtaIVAhUSMmYCFRIV4hO1ohXiFfIyhpIV8hfSE7WiF9I08jLGYjTyNQIUR5I1AjbyE7WiNvI3AjKGkjcDsnUyE7WjsnUzs9YCMtdzwlbE8hO1onQWQjOlpwJGkmaihWcChZIWJzJzl0T1klWllaJmNaciVacnMmfXN3JVp3eChyeCFPJVohTyFQITNZIVAhUSVaIVEhWyM8XyFbIV4lWiFeIV8qZyFfIWclWiFnIWghNHwhaCNPJVojTyNQJmMjUCNSJVojUiNTIzxfI1MjVSVaI1UjViM/aSNWI1glWiNYI1khNHwjWSNiJVojYiNjIz5fI2MjZCNCcSNkI2wlWiNsI20jRXMjbSNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonQWQjPGprJGkmaihWcChZIWJzJzl0T1klWllaJmNaciVacnMmfXN3JVp3eChyeCFPJVohTyFQITNZIVAhUSVaIVEhWyM8XyFbIV4lWiFeIV8qZyFfIWclWiFnIWghNHwhaCNPJVojTyNQJmMjUCNSJVojUiNTIzxfI1MjWCVaI1gjWSE0fCNZI2IlWiNiI2MjPl8jYyNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonQWQjPmpfJGkmaihWcChZIWJzJzl0T1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonQWQjP3JkJGkmaihWcChZIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IVElWiFRIVIjQVEhUiFTI0FRIVMhXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjUiVaI1IjUyNBUSNTI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWidBZCNBXWYkaSZqKFZwKFkhYnMnOXRPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IVElWiFRIVIjQVEhUiFTI0FRIVMhXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjUiVaI1IjUyNBUSNTI2IlWiNiI2MjPl8jYyNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonQWQjQnpjJGkmaihWcChZIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IVElWiFRIVkjRFYhWSFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNSJVojUiNTI0RWI1MjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJ0FkI0RiZSRpJmooVnAoWSFicyc5dE9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghUSVaIVEhWSNEViFZIV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI1IlWiNSI1MjRFYjUyNiJVojYiNjIz5fI2MjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJ0FkI0V8ZyRpJmooVnAoWSFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFRJVohUSFbI0dlIVshXiVaIV4hXypnIV8hYyVaIWMhaSNHZSFpI08lWiNPI1AmYyNQI1IlWiNSI1MjR2UjUyNUJVojVCNaI0dlI1ojbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJ0FkI0dwaSRpJmooVnAoWSFicyc5dE9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghUSVaIVEhWyNHZSFbIV4lWiFeIV8qZyFfIWMlWiFjIWkjR2UhaSNPJVojTyNQJmMjUCNSJVojUiNTI0dlI1MjVCVaI1QjWiNHZSNaI2IlWiNiI2MjPl8jYyNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVoqKXgjSWxfIWckYiRpJmokTylMdihWcChZIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWilbI0p2X2FsJGkmaihWcChZIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWjA0ZiNMU15oIylgI1ItPFUoVnAoWSFiJG43YE9ZKmdacipncnMnfXN3Kmd3eClyeCFQKmchUCFRI01PIVEhXipnIV4hXyNNdCFfIWAkIGYhYCNPKmcjUDsnUypnOydTOz1gK1o8JWxPKmcobiNNWFgkayZqKFZwKFkhYk9ZKmdacipncnMnfXN3Kmd3eClyeCNPKmcjUDsnUypnOydTOz1gK1o8JWxPKmcoRWwjTX1aI3IoQ2goVnAoWSFiT1kqZ1pyKmdycyd9c3cqZ3d4KXJ4IV8qZyFfIWAjTnAhYCNPKmcjUDsnUypnOydTOz1gK1o8JWxPKmcoRWwjTnlYJFEoQ2goVnAoWSFiT1kqZ1pyKmdycyd9c3cqZ3d4KXJ4I08qZyNQOydTKmc7J1M7PWArWjwlbE8qZyhFbCQgb1gjcyhDaChWcChZIWJPWSpnWnIqZ3JzJ31zdypnd3gpcngjTypnI1A7J1MqZzsnUzs9YCtaPCVsTypnKil4JCFnYSNgKiFZJGkmaihWcChZIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfIWAweiFgIWEkI2whYSNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVooS1skI3dfI2soQ2wkaSZqKFZwKFkhYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKil4JCVWYWchKnIjcyhDaCRmI3wkaSZqKFZwKFkhYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYCQmWyFgIWEkJ2YhYSNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVooS1ckJmdfI3MoQ2gkaSZqKFZwKFkhYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKEtXJCdxYSNyKENoJGkmaihWcChZIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfIWBLYSFgIWEkKHYhYSNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVooS1ckKVJgI3IoQ2gkaSZqKFZwKFkhYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYEthIWAjTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKEtkJCpgYShxKEN0JGkmaihWcChZIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfIWElWiFhIWIkK2UhYiNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVooS1ckK3BgJGkmaiN7KENoKFZwKFkhYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYEthIWAjTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJSNgJCx9XyF8JElwJGkmaihWcChZIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWjA0ZiQuWF8hUzAsdiRpJmooVnAoWSFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVoobiQvXVokaSZqTyFeJDBPIV4hXyQwZiFfI2kkME8jaSNqJDBrI2ojbCQwTyNsI20kMl4jbSNvJDBPI28jcCQwZiNwOydTJDBPOydTOz1gJDRpPCVsTyQwTyhuJDBWVF8jUyRpJmpPIV4mYyFfI28mYyNwOydTJmM7J1M7PWAmdzwlbE8mYyNTJDBrT18jUyhuJDBwWyRpJmpPIVEmYyFRIVskMWYhWyFeJmMhXyFjJmMhYyFpJDFmIWkjVCZjI1QjWiQxZiNaI28mYyNvI3AkM3wjcDsnUyZjOydTOz1gJnc8JWxPJmMobiQxa1okaSZqTyFRJmMhUSFbJDJeIVshXiZjIV8hYyZjIWMhaSQyXiFpI1QmYyNUI1okMl4jWiNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmMobiQyY1okaSZqTyFRJmMhUSFbJDNVIVshXiZjIV8hYyZjIWMhaSQzVSFpI1QmYyNUI1okM1UjWiNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmMobiQzWlokaSZqTyFRJmMhUSFbJDBPIVshXiZjIV8hYyZjIWMhaSQwTyFpI1QmYyNUI1okME8jWiNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmMjUyQ0UFIhUSFbJDRZIWMhaSQ0WSNUI1okNFkjUyQ0XVMhUSFbJDRZIWMhaSQ0WSNUI1okNFkjcSNyJDBmKG4kNGxQOz1gPCVsJDBPIzFbJDR6XyFZIylsJGkmaihWcChZIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWihLVyQ2VWAjeChDaCRpJmooVnAoWSFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgS2EhYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVorO3AkN2NfJGkmaihWcChZIWIoYCs0UU9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaMDdbJDhxayRpJmooVnAoWSFiKFMsMmokXyN0KGQkSVtPWSVaWVomY1pyJVpycyZ9c3QlWnR1JDhidXclWnd4KHJ4fSVafSFPJDpmIU8hUSVaIVEhWyQ4YiFbIV4lWiFeIV8qZyFfIWMlWiFjIX0kOGIhfSNPJVojTyNQJmMjUCNSJVojUiNTJDhiI1MjVCVaI1QjbyQ4YiNvI3AqZyNwJGclWiRnOydTJDhiOydTOz1gJDxsPCVsTyQ4YitkJDpxayRpJmooVnAoWSFiJF8jdE9ZJVpZWiZjWnIlWnJzJn1zdCVadHUkOmZ1dyVad3gocnh9JVp9IU8kOmYhTyFRJVohUSFbJDpmIVshXiVaIV4hXypnIV8hYyVaIWMhfSQ6ZiF9I08lWiNPI1AmYyNQI1IlWiNSI1MkOmYjUyNUJVojVCNvJDpmI28jcCpnI3AkZyVaJGc7J1MkOmY7J1M7PWAkPGY8JWxPJDpmK2QkPGlQOz1gPCVsJDpmMDdbJDxvUDs9YDwlbCQ4YiNKZiQ8e1ghXyNIYihWcChZIWJPWSpnWnIqZ3JzJ31zdypnd3gpcngjTypnI1A7J1MqZzsnUzs9YCtaPCVsTypnLCN4JD1zYSh4K0pZJGkmaihWcChZIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfIWBLYSFgI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwI3EkK2UjcTsnUyVaOydTOz1gK2E8JWxPJVopPnYkP1ZfIV4oQ2R2QnIkaSZqKFZwKFkhYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaP08kQGFfIXE3YCRpJmooVnAoWSFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVowN1skQXF8JGkmaihWcChZIWInezAvbCRdI3QoUywyaihkJElbT1glWlhZK2dZWiZjWlsrZ1twJVpwcStncXIlWnJzJn1zdCVadHVFcnV3JVp3eChyeH0lWn0hT0d2IU8hUSVaIVEhW0VyIVshXiVaIV4hXypnIV8hYyVaIWMhfUVyIX0jTyVaI08jUCZjI1AjUiVaI1IjU0VyI1MjVCVaI1Qjb0VyI28jcCpnI3AkZiVaJGYkZytnJGcjQllFciNCWSNCWiRBYCNCWiRJU0VyJElTJElfJEFgJElfJEpURXIkSlQkSlUkQWAkSlUkS1ZFciRLViRLVyRBYCRLVyZGVUVyJkZVJkZWJEFgJkZWOydTRXI7J1M7PWBJfDwlbD9IVEVyP0hUP0hVJEFgP0hVT0VyMDdbJER8ayRpJmooVnAoWSFiJ3wwL2wkXSN0KFMsMmooZCRJW09ZJVpZWiZjWnIlWnJzJn1zdCVadHVFcnV3JVp3eChyeH0lWn0hT0d2IU8hUSVaIVEhW0VyIVshXiVaIV4hXypnIV8hYyVaIWMhfUVyIX0jTyVaI08jUCZjI1AjUiVaI1IjU0VyI1MjVCVaI1Qjb0VyI28jcCpnI3AkZyVaJGc7J1NFcjsnUzs9YEl8PCVsT0VyXCIsXG4gIHRva2VuaXplcnM6IFtub1NlbWljb2xvbiwgbm9TZW1pY29sb25UeXBlLCBvcGVyYXRvclRva2VuLCBqc3gsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgaW5zZXJ0U2VtaWNvbG9uLCBuZXcgTG9jYWxUb2tlbkdyb3VwKFwiJFN+UlJ0dVsjTyNQZyNTI1QjfH5fUCNvI3BifmdPeH5+alZPI2khUCNpI2ohVSNqI2whUCNsI20hcSNtOydTIVA7J1M7PWAjdjwlbE8hUH4hVU8hVX5+IVhTIVEhWyFlIWMhaSFlI1QjWiFlI28jcCNafiFoUiFRIVshcSFjIWkhcSNUI1ohcX4hdFIhUSFbIX0hYyFpIX0jVCNaIX1+I1FSIVEhWyFQIWMhaSFQI1QjWiFQfiNeUiFRIVsjZyFjIWkjZyNUI1ojZ34jalMhUSFbI2chYyFpI2cjVCNaI2cjcSNyIVB+I3lQOz1gPCVsIVB+JFJPKGJ+flwiLCAxNDEsIDMzOSksIG5ldyBMb2NhbFRva2VuR3JvdXAoXCJqflJRWVpYentefl5PKFB+fmFQIVAhUWR+aU8oUX5+XCIsIDI1LCAzMjIpXSxcbiAgdG9wUnVsZXM6IHtcIlNjcmlwdFwiOlswLDddLFwiU2luZ2xlRXhwcmVzc2lvblwiOlsxLDI3NV0sXCJTaW5nbGVDbGFzc0l0ZW1cIjpbMiwyNzZdfSxcbiAgZGlhbGVjdHM6IHtqc3g6IDAsIHRzOiAxNTA5OH0sXG4gIGR5bmFtaWNQcmVjZWRlbmNlczoge1wiODBcIjoxLFwiODJcIjoxLFwiOTRcIjoxLFwiMTY5XCI6MSxcIjE5OVwiOjF9LFxuICBzcGVjaWFsaXplZDogW3t0ZXJtOiAzMjYsIGdldDogKHZhbHVlKSA9PiBzcGVjX2lkZW50aWZpZXJbdmFsdWVdIHx8IC0xfSx7dGVybTogMzQyLCBnZXQ6ICh2YWx1ZSkgPT4gc3BlY193b3JkW3ZhbHVlXSB8fCAtMX0se3Rlcm06IDk1LCBnZXQ6ICh2YWx1ZSkgPT4gc3BlY19MZXNzVGhhblt2YWx1ZV0gfHwgLTF9XSxcbiAgdG9rZW5QcmVjOiAxNTEyNFxufSk7XG5cbmV4cG9ydCB7IHBhcnNlciB9O1xuIl0sIm5hbWVzIjpbIkNvbnRleHRUcmFja2VyIiwiRXh0ZXJuYWxUb2tlbml6ZXIiLCJMUlBhcnNlciIsIkxvY2FsVG9rZW5Hcm91cCIsInN0eWxlVGFncyIsInRhZ3MiLCJub1NlbWkiLCJub1NlbWlUeXBlIiwiaW5jZGVjIiwiaW5jZGVjUHJlZml4IiwicXVlc3Rpb25Eb3QiLCJKU1hTdGFydFRhZyIsImluc2VydFNlbWkiLCJzcGFjZXMiLCJuZXdsaW5lIiwiTGluZUNvbW1lbnQiLCJCbG9ja0NvbW1lbnQiLCJEaWFsZWN0X2pzeCIsInNwYWNlIiwiYnJhY2VSIiwic2VtaWNvbG9uIiwic2xhc2giLCJzdGFyIiwicGx1cyIsIm1pbnVzIiwibHQiLCJjb21tYSIsInF1ZXN0aW9uIiwiZG90IiwiYnJhY2tldEwiLCJ0cmFja05ld2xpbmUiLCJzdGFydCIsInNoaWZ0IiwiY29udGV4dCIsInRlcm0iLCJzdHJpY3QiLCJpbnNlcnRTZW1pY29sb24iLCJpbnB1dCIsInN0YWNrIiwibmV4dCIsImFjY2VwdFRva2VuIiwiY29udGV4dHVhbCIsImZhbGxiYWNrIiwibm9TZW1pY29sb24iLCJhZnRlciIsImluZGV4T2YiLCJwZWVrIiwibm9TZW1pY29sb25UeXBlIiwib3BlcmF0b3JUb2tlbiIsImFkdmFuY2UiLCJtYXlQb3N0Zml4IiwiY2FuU2hpZnQiLCJpZGVudGlmaWVyQ2hhciIsImNoIiwianN4IiwiZGlhbGVjdEVuYWJsZWQiLCJiYWNrIiwiaSIsImNoYXJDb2RlQXQiLCJqc0hpZ2hsaWdodCIsIm1vZGlmaWVyIiwiY29udHJvbEtleXdvcmQiLCJvcGVyYXRvcktleXdvcmQiLCJkZWZpbml0aW9uS2V5d29yZCIsIm1vZHVsZUtleXdvcmQiLCJrZXl3b3JkIiwiVGVtcGxhdGVTdHJpbmciLCJzcGVjaWFsIiwic3RyaW5nIiwic3VwZXIiLCJhdG9tIiwiQm9vbGVhbkxpdGVyYWwiLCJib29sIiwidGhpcyIsInNlbGYiLCJudWxsIiwiU3RhciIsIlZhcmlhYmxlTmFtZSIsInZhcmlhYmxlTmFtZSIsImZ1bmN0aW9uIiwiVmFyaWFibGVEZWZpbml0aW9uIiwiZGVmaW5pdGlvbiIsIkxhYmVsIiwibGFiZWxOYW1lIiwiUHJvcGVydHlOYW1lIiwicHJvcGVydHlOYW1lIiwiUHJpdmF0ZVByb3BlcnR5TmFtZSIsImNsYXNzTmFtZSIsIlByb3BlcnR5RGVmaW5pdGlvbiIsIlByaXZhdGVQcm9wZXJ0eURlZmluaXRpb24iLCJVcGRhdGVPcCIsInVwZGF0ZU9wZXJhdG9yIiwibGluZUNvbW1lbnQiLCJibG9ja0NvbW1lbnQiLCJOdW1iZXIiLCJudW1iZXIiLCJTdHJpbmciLCJFc2NhcGUiLCJlc2NhcGUiLCJBcml0aE9wIiwiYXJpdGhtZXRpY09wZXJhdG9yIiwiTG9naWNPcCIsImxvZ2ljT3BlcmF0b3IiLCJCaXRPcCIsImJpdHdpc2VPcGVyYXRvciIsIkNvbXBhcmVPcCIsImNvbXBhcmVPcGVyYXRvciIsIlJlZ0V4cCIsInJlZ2V4cCIsIkVxdWFscyIsImRlZmluaXRpb25PcGVyYXRvciIsIkFycm93IiwicHVuY3R1YXRpb24iLCJwYXJlbiIsInNxdWFyZUJyYWNrZXQiLCJicmFjZSIsImRlcmVmT3BlcmF0b3IiLCJzZXBhcmF0b3IiLCJtZXRhIiwiVHlwZU5hbWUiLCJ0eXBlTmFtZSIsIlR5cGVEZWZpbml0aW9uIiwiSlNYQXR0cmlidXRlVmFsdWUiLCJhdHRyaWJ1dGVWYWx1ZSIsIkpTWFRleHQiLCJjb250ZW50IiwiYW5nbGVCcmFja2V0IiwidGFnTmFtZSIsImF0dHJpYnV0ZU5hbWUiLCJzdGFuZGFyZCIsInNwZWNfaWRlbnRpZmllciIsIl9fcHJvdG9fXyIsImV4cG9ydCIsImFzIiwiZnJvbSIsImRlZmF1bHQiLCJhc3luYyIsImluIiwib3V0IiwiY29uc3QiLCJleHRlbmRzIiwidHJ1ZSIsImZhbHNlIiwidm9pZCIsInR5cGVvZiIsIm5ldyIsImRlbGV0ZSIsInlpZWxkIiwiYXdhaXQiLCJjbGFzcyIsInB1YmxpYyIsInByaXZhdGUiLCJwcm90ZWN0ZWQiLCJyZWFkb25seSIsImluc3RhbmNlb2YiLCJzYXRpc2ZpZXMiLCJpbXBvcnQiLCJrZXlvZiIsInVuaXF1ZSIsImluZmVyIiwiYXNzZXJ0cyIsImlzIiwiYWJzdHJhY3QiLCJpbXBsZW1lbnRzIiwidHlwZSIsImxldCIsInZhciIsInVzaW5nIiwiaW50ZXJmYWNlIiwiZW51bSIsIm5hbWVzcGFjZSIsIm1vZHVsZSIsImRlY2xhcmUiLCJnbG9iYWwiLCJmb3IiLCJvZiIsIndoaWxlIiwid2l0aCIsImRvIiwiaWYiLCJlbHNlIiwic3dpdGNoIiwiY2FzZSIsInRyeSIsImNhdGNoIiwiZmluYWxseSIsInJldHVybiIsInRocm93IiwiYnJlYWsiLCJjb250aW51ZSIsImRlYnVnZ2VyIiwic3BlY193b3JkIiwiZ2V0Iiwic2V0Iiwic3RhdGljIiwib3ZlcnJpZGUiLCJhY2Nlc3NvciIsInNwZWNfTGVzc1RoYW4iLCJwYXJzZXIiLCJkZXNlcmlhbGl6ZSIsInZlcnNpb24iLCJzdGF0ZXMiLCJzdGF0ZURhdGEiLCJnb3RvIiwibm9kZU5hbWVzIiwibWF4VGVybSIsIm5vZGVQcm9wcyIsInByb3BTb3VyY2VzIiwic2tpcHBlZE5vZGVzIiwicmVwZWF0Tm9kZUNvdW50IiwidG9rZW5EYXRhIiwidG9rZW5pemVycyIsInRvcFJ1bGVzIiwiZGlhbGVjdHMiLCJ0cyIsImR5bmFtaWNQcmVjZWRlbmNlcyIsInNwZWNpYWxpemVkIiwidmFsdWUiLCJ0b2tlblByZWMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lezer/javascript/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lezer/lr/dist/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@lezer/lr/dist/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContextTracker: () => (/* binding */ ContextTracker),\n/* harmony export */   ExternalTokenizer: () => (/* binding */ ExternalTokenizer),\n/* harmony export */   InputStream: () => (/* binding */ InputStream),\n/* harmony export */   LRParser: () => (/* binding */ LRParser),\n/* harmony export */   LocalTokenGroup: () => (/* binding */ LocalTokenGroup),\n/* harmony export */   Stack: () => (/* binding */ Stack)\n/* harmony export */ });\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"(ssr)/./node_modules/@lezer/common/dist/index.js\");\n\n/**\nA parse stack. These are used internally by the parser to track\nparsing progress. They also provide some properties and methods\nthat external code such as a tokenizer can use to get information\nabout the parse state.\n*/ class Stack {\n    /**\n    @internal\n    */ constructor(/**\n    The parse that this stack is part of @internal\n    */ p, /**\n    Holds state, input pos, buffer index triplets for all but the\n    top state @internal\n    */ stack, /**\n    The current parse state @internal\n    */ state, // The position at which the next reduce should take place. This\n    // can be less than `this.pos` when skipped expressions have been\n    // added to the stack (which should be moved outside of the next\n    // reduction)\n    /**\n    @internal\n    */ reducePos, /**\n    The input position up to which this stack has parsed.\n    */ pos, /**\n    The dynamic score of the stack, including dynamic precedence\n    and error-recovery penalties\n    @internal\n    */ score, // The output buffer. Holds (type, start, end, size) quads\n    // representing nodes created by the parser, where `size` is\n    // amount of buffer array entries covered by this node.\n    /**\n    @internal\n    */ buffer, // The base offset of the buffer. When stacks are split, the split\n    // instance shared the buffer history with its parent up to\n    // `bufferBase`, which is the absolute offset (including the\n    // offset of previous splits) into the buffer at which this stack\n    // starts writing.\n    /**\n    @internal\n    */ bufferBase, /**\n    @internal\n    */ curContext, /**\n    @internal\n    */ lookAhead = 0, // A parent stack from which this was split off, if any. This is\n    // set up so that it always points to a stack that has some\n    // additional buffer content, never to a stack with an equal\n    // `bufferBase`.\n    /**\n    @internal\n    */ parent){\n        this.p = p;\n        this.stack = stack;\n        this.state = state;\n        this.reducePos = reducePos;\n        this.pos = pos;\n        this.score = score;\n        this.buffer = buffer;\n        this.bufferBase = bufferBase;\n        this.curContext = curContext;\n        this.lookAhead = lookAhead;\n        this.parent = parent;\n    }\n    /**\n    @internal\n    */ toString() {\n        return `[${this.stack.filter((_, i)=>i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? \"!\" + this.score : \"\"}`;\n    }\n    // Start an empty stack\n    /**\n    @internal\n    */ static start(p, state, pos = 0) {\n        let cx = p.parser.context;\n        return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);\n    }\n    /**\n    The stack's current [context](#lr.ContextTracker) value, if\n    any. Its type will depend on the context tracker's type\n    parameter, or it will be `null` if there is no context\n    tracker.\n    */ get context() {\n        return this.curContext ? this.curContext.context : null;\n    }\n    // Push a state onto the stack, tracking its start position as well\n    // as the buffer base at that point.\n    /**\n    @internal\n    */ pushState(state, start) {\n        this.stack.push(this.state, start, this.bufferBase + this.buffer.length);\n        this.state = state;\n    }\n    // Apply a reduce action\n    /**\n    @internal\n    */ reduce(action) {\n        var _a;\n        let depth = action >> 19 /* Action.ReduceDepthShift */ , type = action & 65535 /* Action.ValueMask */ ;\n        let { parser } = this.p;\n        let lookaheadRecord = this.reducePos < this.pos - 25 /* Lookahead.Margin */ ;\n        if (lookaheadRecord) this.setLookAhead(this.pos);\n        let dPrec = parser.dynamicPrecedence(type);\n        if (dPrec) this.score += dPrec;\n        if (depth == 0) {\n            this.pushState(parser.getGoto(this.state, type, true), this.reducePos);\n            // Zero-depth reductions are a special caseâ€”they add stuff to\n            // the stack without popping anything off.\n            if (type < parser.minRepeatTerm) this.storeNode(type, this.reducePos, this.reducePos, lookaheadRecord ? 8 : 4, true);\n            this.reduceContext(type, this.reducePos);\n            return;\n        }\n        // Find the base index into `this.stack`, content after which will\n        // be dropped. Note that with `StayFlag` reductions we need to\n        // consume two extra frames (the dummy parent node for the skipped\n        // expression and the state that we'll be staying in, which should\n        // be moved to `this.state`).\n        let base = this.stack.length - (depth - 1) * 3 - (action & 262144 /* Action.StayFlag */  ? 6 : 0);\n        let start = base ? this.stack[base - 2] : this.p.ranges[0].from, size = this.reducePos - start;\n        // This is a kludge to try and detect overly deep left-associative\n        // trees, which will not increase the parse stack depth and thus\n        // won't be caught by the regular stack-depth limit check.\n        if (size >= 2000 /* Recover.MinBigReduction */  && !((_a = this.p.parser.nodeSet.types[type]) === null || _a === void 0 ? void 0 : _a.isAnonymous)) {\n            if (start == this.p.lastBigReductionStart) {\n                this.p.bigReductionCount++;\n                this.p.lastBigReductionSize = size;\n            } else if (this.p.lastBigReductionSize < size) {\n                this.p.bigReductionCount = 1;\n                this.p.lastBigReductionStart = start;\n                this.p.lastBigReductionSize = size;\n            }\n        }\n        let bufferBase = base ? this.stack[base - 1] : 0, count = this.bufferBase + this.buffer.length - bufferBase;\n        // Store normal terms or `R -> R R` repeat reductions\n        if (type < parser.minRepeatTerm || action & 131072 /* Action.RepeatFlag */ ) {\n            let pos = parser.stateFlag(this.state, 1 /* StateFlag.Skipped */ ) ? this.pos : this.reducePos;\n            this.storeNode(type, start, pos, count + 4, true);\n        }\n        if (action & 262144 /* Action.StayFlag */ ) {\n            this.state = this.stack[base];\n        } else {\n            let baseStateID = this.stack[base - 3];\n            this.state = parser.getGoto(baseStateID, type, true);\n        }\n        while(this.stack.length > base)this.stack.pop();\n        this.reduceContext(type, start);\n    }\n    // Shift a value into the buffer\n    /**\n    @internal\n    */ storeNode(term, start, end, size = 4, mustSink = false) {\n        if (term == 0 /* Term.Err */  && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {\n            // Try to omit/merge adjacent error nodes\n            let cur = this, top = this.buffer.length;\n            if (top == 0 && cur.parent) {\n                top = cur.bufferBase - cur.parent.bufferBase;\n                cur = cur.parent;\n            }\n            if (top > 0 && cur.buffer[top - 4] == 0 /* Term.Err */  && cur.buffer[top - 1] > -1) {\n                if (start == end) return;\n                if (cur.buffer[top - 2] >= start) {\n                    cur.buffer[top - 2] = end;\n                    return;\n                }\n            }\n        }\n        if (!mustSink || this.pos == end) {\n            this.buffer.push(term, start, end, size);\n        } else {\n            let index = this.buffer.length;\n            if (index > 0 && this.buffer[index - 4] != 0 /* Term.Err */ ) {\n                let mustMove = false;\n                for(let scan = index; scan > 0 && this.buffer[scan - 2] > end; scan -= 4){\n                    if (this.buffer[scan - 1] >= 0) {\n                        mustMove = true;\n                        break;\n                    }\n                }\n                if (mustMove) while(index > 0 && this.buffer[index - 2] > end){\n                    // Move this record forward\n                    this.buffer[index] = this.buffer[index - 4];\n                    this.buffer[index + 1] = this.buffer[index - 3];\n                    this.buffer[index + 2] = this.buffer[index - 2];\n                    this.buffer[index + 3] = this.buffer[index - 1];\n                    index -= 4;\n                    if (size > 4) size -= 4;\n                }\n            }\n            this.buffer[index] = term;\n            this.buffer[index + 1] = start;\n            this.buffer[index + 2] = end;\n            this.buffer[index + 3] = size;\n        }\n    }\n    // Apply a shift action\n    /**\n    @internal\n    */ shift(action, type, start, end) {\n        if (action & 131072 /* Action.GotoFlag */ ) {\n            this.pushState(action & 65535 /* Action.ValueMask */ , this.pos);\n        } else if ((action & 262144 /* Action.StayFlag */ ) == 0) {\n            let nextState = action, { parser } = this.p;\n            if (end > this.pos || type <= parser.maxNode) {\n                this.pos = end;\n                if (!parser.stateFlag(nextState, 1 /* StateFlag.Skipped */ )) this.reducePos = end;\n            }\n            this.pushState(nextState, start);\n            this.shiftContext(type, start);\n            if (type <= parser.maxNode) this.buffer.push(type, start, end, 4);\n        } else {\n            this.pos = end;\n            this.shiftContext(type, start);\n            if (type <= this.p.parser.maxNode) this.buffer.push(type, start, end, 4);\n        }\n    }\n    // Apply an action\n    /**\n    @internal\n    */ apply(action, next, nextStart, nextEnd) {\n        if (action & 65536 /* Action.ReduceFlag */ ) this.reduce(action);\n        else this.shift(action, next, nextStart, nextEnd);\n    }\n    // Add a prebuilt (reused) node into the buffer.\n    /**\n    @internal\n    */ useNode(value, next) {\n        let index = this.p.reused.length - 1;\n        if (index < 0 || this.p.reused[index] != value) {\n            this.p.reused.push(value);\n            index++;\n        }\n        let start = this.pos;\n        this.reducePos = this.pos = start + value.length;\n        this.pushState(next, start);\n        this.buffer.push(index, start, this.reducePos, -1 /* size == -1 means this is a reused value */ );\n        if (this.curContext) this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));\n    }\n    // Split the stack. Due to the buffer sharing and the fact\n    // that `this.stack` tends to stay quite shallow, this isn't very\n    // expensive.\n    /**\n    @internal\n    */ split() {\n        let parent = this;\n        let off = parent.buffer.length;\n        // Because the top of the buffer (after this.pos) may be mutated\n        // to reorder reductions and skipped tokens, and shared buffers\n        // should be immutable, this copies any outstanding skipped tokens\n        // to the new buffer, and puts the base pointer before them.\n        while(off > 0 && parent.buffer[off - 2] > parent.reducePos)off -= 4;\n        let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;\n        // Make sure parent points to an actual parent with content, if there is such a parent.\n        while(parent && base == parent.bufferBase)parent = parent.parent;\n        return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);\n    }\n    // Try to recover from an error by 'deleting' (ignoring) one token.\n    /**\n    @internal\n    */ recoverByDelete(next, nextEnd) {\n        let isNode = next <= this.p.parser.maxNode;\n        if (isNode) this.storeNode(next, this.pos, nextEnd, 4);\n        this.storeNode(0 /* Term.Err */ , this.pos, nextEnd, isNode ? 8 : 4);\n        this.pos = this.reducePos = nextEnd;\n        this.score -= 190 /* Recover.Delete */ ;\n    }\n    /**\n    Check if the given term would be able to be shifted (optionally\n    after some reductions) on this stack. This can be useful for\n    external tokenizers that want to make sure they only provide a\n    given token when it applies.\n    */ canShift(term) {\n        for(let sim = new SimulatedStack(this);;){\n            let action = this.p.parser.stateSlot(sim.state, 4 /* ParseState.DefaultReduce */ ) || this.p.parser.hasAction(sim.state, term);\n            if (action == 0) return false;\n            if ((action & 65536 /* Action.ReduceFlag */ ) == 0) return true;\n            sim.reduce(action);\n        }\n    }\n    // Apply up to Recover.MaxNext recovery actions that conceptually\n    // inserts some missing token or rule.\n    /**\n    @internal\n    */ recoverByInsert(next) {\n        if (this.stack.length >= 300 /* Recover.MaxInsertStackDepth */ ) return [];\n        let nextStates = this.p.parser.nextStates(this.state);\n        if (nextStates.length > 4 /* Recover.MaxNext */  << 1 || this.stack.length >= 120 /* Recover.DampenInsertStackDepth */ ) {\n            let best = [];\n            for(let i = 0, s; i < nextStates.length; i += 2){\n                if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next)) best.push(nextStates[i], s);\n            }\n            if (this.stack.length < 120 /* Recover.DampenInsertStackDepth */ ) for(let i = 0; best.length < 4 /* Recover.MaxNext */  << 1 && i < nextStates.length; i += 2){\n                let s = nextStates[i + 1];\n                if (!best.some((v, i)=>i & 1 && v == s)) best.push(nextStates[i], s);\n            }\n            nextStates = best;\n        }\n        let result = [];\n        for(let i = 0; i < nextStates.length && result.length < 4 /* Recover.MaxNext */ ; i += 2){\n            let s = nextStates[i + 1];\n            if (s == this.state) continue;\n            let stack = this.split();\n            stack.pushState(s, this.pos);\n            stack.storeNode(0 /* Term.Err */ , stack.pos, stack.pos, 4, true);\n            stack.shiftContext(nextStates[i], this.pos);\n            stack.reducePos = this.pos;\n            stack.score -= 200 /* Recover.Insert */ ;\n            result.push(stack);\n        }\n        return result;\n    }\n    // Force a reduce, if possible. Return false if that can't\n    // be done.\n    /**\n    @internal\n    */ forceReduce() {\n        let { parser } = this.p;\n        let reduce = parser.stateSlot(this.state, 5 /* ParseState.ForcedReduce */ );\n        if ((reduce & 65536 /* Action.ReduceFlag */ ) == 0) return false;\n        if (!parser.validAction(this.state, reduce)) {\n            let depth = reduce >> 19 /* Action.ReduceDepthShift */ , term = reduce & 65535 /* Action.ValueMask */ ;\n            let target = this.stack.length - depth * 3;\n            if (target < 0 || parser.getGoto(this.stack[target], term, false) < 0) {\n                let backup = this.findForcedReduction();\n                if (backup == null) return false;\n                reduce = backup;\n            }\n            this.storeNode(0 /* Term.Err */ , this.pos, this.pos, 4, true);\n            this.score -= 100 /* Recover.Reduce */ ;\n        }\n        this.reducePos = this.pos;\n        this.reduce(reduce);\n        return true;\n    }\n    /**\n    Try to scan through the automaton to find some kind of reduction\n    that can be applied. Used when the regular ForcedReduce field\n    isn't a valid action. @internal\n    */ findForcedReduction() {\n        let { parser } = this.p, seen = [];\n        let explore = (state, depth)=>{\n            if (seen.includes(state)) return;\n            seen.push(state);\n            return parser.allActions(state, (action)=>{\n                if (action & (262144 /* Action.StayFlag */  | 131072 /* Action.GotoFlag */ )) ;\n                else if (action & 65536 /* Action.ReduceFlag */ ) {\n                    let rDepth = (action >> 19 /* Action.ReduceDepthShift */ ) - depth;\n                    if (rDepth > 1) {\n                        let term = action & 65535 /* Action.ValueMask */ , target = this.stack.length - rDepth * 3;\n                        if (target >= 0 && parser.getGoto(this.stack[target], term, false) >= 0) return rDepth << 19 /* Action.ReduceDepthShift */  | 65536 /* Action.ReduceFlag */  | term;\n                    }\n                } else {\n                    let found = explore(action, depth + 1);\n                    if (found != null) return found;\n                }\n            });\n        };\n        return explore(this.state, 0);\n    }\n    /**\n    @internal\n    */ forceAll() {\n        while(!this.p.parser.stateFlag(this.state, 2 /* StateFlag.Accepting */ )){\n            if (!this.forceReduce()) {\n                this.storeNode(0 /* Term.Err */ , this.pos, this.pos, 4, true);\n                break;\n            }\n        }\n        return this;\n    }\n    /**\n    Check whether this state has no further actions (assumed to be a direct descendant of the\n    top state, since any other states must be able to continue\n    somehow). @internal\n    */ get deadEnd() {\n        if (this.stack.length != 3) return false;\n        let { parser } = this.p;\n        return parser.data[parser.stateSlot(this.state, 1 /* ParseState.Actions */ )] == 65535 /* Seq.End */  && !parser.stateSlot(this.state, 4 /* ParseState.DefaultReduce */ );\n    }\n    /**\n    Restart the stack (put it back in its start state). Only safe\n    when this.stack.length == 3 (state is directly below the top\n    state). @internal\n    */ restart() {\n        this.storeNode(0 /* Term.Err */ , this.pos, this.pos, 4, true);\n        this.state = this.stack[0];\n        this.stack.length = 0;\n    }\n    /**\n    @internal\n    */ sameState(other) {\n        if (this.state != other.state || this.stack.length != other.stack.length) return false;\n        for(let i = 0; i < this.stack.length; i += 3)if (this.stack[i] != other.stack[i]) return false;\n        return true;\n    }\n    /**\n    Get the parser used by this stack.\n    */ get parser() {\n        return this.p.parser;\n    }\n    /**\n    Test whether a given dialect (by numeric ID, as exported from\n    the terms file) is enabled.\n    */ dialectEnabled(dialectID) {\n        return this.p.parser.dialect.flags[dialectID];\n    }\n    shiftContext(term, start) {\n        if (this.curContext) this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));\n    }\n    reduceContext(term, start) {\n        if (this.curContext) this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));\n    }\n    /**\n    @internal\n    */ emitContext() {\n        let last = this.buffer.length - 1;\n        if (last < 0 || this.buffer[last] != -3) this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);\n    }\n    /**\n    @internal\n    */ emitLookAhead() {\n        let last = this.buffer.length - 1;\n        if (last < 0 || this.buffer[last] != -4) this.buffer.push(this.lookAhead, this.pos, this.pos, -4);\n    }\n    updateContext(context) {\n        if (context != this.curContext.context) {\n            let newCx = new StackContext(this.curContext.tracker, context);\n            if (newCx.hash != this.curContext.hash) this.emitContext();\n            this.curContext = newCx;\n        }\n    }\n    /**\n    @internal\n    */ setLookAhead(lookAhead) {\n        if (lookAhead > this.lookAhead) {\n            this.emitLookAhead();\n            this.lookAhead = lookAhead;\n        }\n    }\n    /**\n    @internal\n    */ close() {\n        if (this.curContext && this.curContext.tracker.strict) this.emitContext();\n        if (this.lookAhead > 0) this.emitLookAhead();\n    }\n}\nclass StackContext {\n    constructor(tracker, context){\n        this.tracker = tracker;\n        this.context = context;\n        this.hash = tracker.strict ? tracker.hash(context) : 0;\n    }\n}\n// Used to cheaply run some reductions to scan ahead without mutating\n// an entire stack\nclass SimulatedStack {\n    constructor(start){\n        this.start = start;\n        this.state = start.state;\n        this.stack = start.stack;\n        this.base = this.stack.length;\n    }\n    reduce(action) {\n        let term = action & 65535 /* Action.ValueMask */ , depth = action >> 19 /* Action.ReduceDepthShift */ ;\n        if (depth == 0) {\n            if (this.stack == this.start.stack) this.stack = this.stack.slice();\n            this.stack.push(this.state, 0, 0);\n            this.base += 3;\n        } else {\n            this.base -= (depth - 1) * 3;\n        }\n        let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);\n        this.state = goto;\n    }\n}\n// This is given to `Tree.build` to build a buffer, and encapsulates\n// the parent-stack-walking necessary to read the nodes.\nclass StackBufferCursor {\n    constructor(stack, pos, index){\n        this.stack = stack;\n        this.pos = pos;\n        this.index = index;\n        this.buffer = stack.buffer;\n        if (this.index == 0) this.maybeNext();\n    }\n    static create(stack, pos = stack.bufferBase + stack.buffer.length) {\n        return new StackBufferCursor(stack, pos, pos - stack.bufferBase);\n    }\n    maybeNext() {\n        let next = this.stack.parent;\n        if (next != null) {\n            this.index = this.stack.bufferBase - next.bufferBase;\n            this.stack = next;\n            this.buffer = next.buffer;\n        }\n    }\n    get id() {\n        return this.buffer[this.index - 4];\n    }\n    get start() {\n        return this.buffer[this.index - 3];\n    }\n    get end() {\n        return this.buffer[this.index - 2];\n    }\n    get size() {\n        return this.buffer[this.index - 1];\n    }\n    next() {\n        this.index -= 4;\n        this.pos -= 4;\n        if (this.index == 0) this.maybeNext();\n    }\n    fork() {\n        return new StackBufferCursor(this.stack, this.pos, this.index);\n    }\n}\n// See lezer-generator/src/encode.ts for comments about the encoding\n// used here\nfunction decodeArray(input, Type = Uint16Array) {\n    if (typeof input != \"string\") return input;\n    let array = null;\n    for(let pos = 0, out = 0; pos < input.length;){\n        let value = 0;\n        for(;;){\n            let next = input.charCodeAt(pos++), stop = false;\n            if (next == 126 /* Encode.BigValCode */ ) {\n                value = 65535 /* Encode.BigVal */ ;\n                break;\n            }\n            if (next >= 92 /* Encode.Gap2 */ ) next--;\n            if (next >= 34 /* Encode.Gap1 */ ) next--;\n            let digit = next - 32 /* Encode.Start */ ;\n            if (digit >= 46 /* Encode.Base */ ) {\n                digit -= 46 /* Encode.Base */ ;\n                stop = true;\n            }\n            value += digit;\n            if (stop) break;\n            value *= 46 /* Encode.Base */ ;\n        }\n        if (array) array[out++] = value;\n        else array = new Type(value);\n    }\n    return array;\n}\nclass CachedToken {\n    constructor(){\n        this.start = -1;\n        this.value = -1;\n        this.end = -1;\n        this.extended = -1;\n        this.lookAhead = 0;\n        this.mask = 0;\n        this.context = 0;\n    }\n}\nconst nullToken = new CachedToken;\n/**\n[Tokenizers](#lr.ExternalTokenizer) interact with the input\nthrough this interface. It presents the input as a stream of\ncharacters, tracking lookahead and hiding the complexity of\n[ranges](#common.Parser.parse^ranges) from tokenizer code.\n*/ class InputStream {\n    /**\n    @internal\n    */ constructor(/**\n    @internal\n    */ input, /**\n    @internal\n    */ ranges){\n        this.input = input;\n        this.ranges = ranges;\n        /**\n        @internal\n        */ this.chunk = \"\";\n        /**\n        @internal\n        */ this.chunkOff = 0;\n        /**\n        Backup chunk\n        */ this.chunk2 = \"\";\n        this.chunk2Pos = 0;\n        /**\n        The character code of the next code unit in the input, or -1\n        when the stream is at the end of the input.\n        */ this.next = -1;\n        /**\n        @internal\n        */ this.token = nullToken;\n        this.rangeIndex = 0;\n        this.pos = this.chunkPos = ranges[0].from;\n        this.range = ranges[0];\n        this.end = ranges[ranges.length - 1].to;\n        this.readNext();\n    }\n    /**\n    @internal\n    */ resolveOffset(offset, assoc) {\n        let range = this.range, index = this.rangeIndex;\n        let pos = this.pos + offset;\n        while(pos < range.from){\n            if (!index) return null;\n            let next = this.ranges[--index];\n            pos -= range.from - next.to;\n            range = next;\n        }\n        while(assoc < 0 ? pos > range.to : pos >= range.to){\n            if (index == this.ranges.length - 1) return null;\n            let next = this.ranges[++index];\n            pos += next.from - range.to;\n            range = next;\n        }\n        return pos;\n    }\n    /**\n    @internal\n    */ clipPos(pos) {\n        if (pos >= this.range.from && pos < this.range.to) return pos;\n        for (let range of this.ranges)if (range.to > pos) return Math.max(pos, range.from);\n        return this.end;\n    }\n    /**\n    Look at a code unit near the stream position. `.peek(0)` equals\n    `.next`, `.peek(-1)` gives you the previous character, and so\n    on.\n    \n    Note that looking around during tokenizing creates dependencies\n    on potentially far-away content, which may reduce the\n    effectiveness incremental parsingâ€”when looking forwardâ€”or even\n    cause invalid reparses when looking backward more than 25 code\n    units, since the library does not track lookbehind.\n    */ peek(offset) {\n        let idx = this.chunkOff + offset, pos, result;\n        if (idx >= 0 && idx < this.chunk.length) {\n            pos = this.pos + offset;\n            result = this.chunk.charCodeAt(idx);\n        } else {\n            let resolved = this.resolveOffset(offset, 1);\n            if (resolved == null) return -1;\n            pos = resolved;\n            if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {\n                result = this.chunk2.charCodeAt(pos - this.chunk2Pos);\n            } else {\n                let i = this.rangeIndex, range = this.range;\n                while(range.to <= pos)range = this.ranges[++i];\n                this.chunk2 = this.input.chunk(this.chunk2Pos = pos);\n                if (pos + this.chunk2.length > range.to) this.chunk2 = this.chunk2.slice(0, range.to - pos);\n                result = this.chunk2.charCodeAt(0);\n            }\n        }\n        if (pos >= this.token.lookAhead) this.token.lookAhead = pos + 1;\n        return result;\n    }\n    /**\n    Accept a token. By default, the end of the token is set to the\n    current stream position, but you can pass an offset (relative to\n    the stream position) to change that.\n    */ acceptToken(token, endOffset = 0) {\n        let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;\n        if (end == null || end < this.token.start) throw new RangeError(\"Token end out of bounds\");\n        this.token.value = token;\n        this.token.end = end;\n    }\n    /**\n    Accept a token ending at a specific given position.\n    */ acceptTokenTo(token, endPos) {\n        this.token.value = token;\n        this.token.end = endPos;\n    }\n    getChunk() {\n        if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {\n            let { chunk, chunkPos } = this;\n            this.chunk = this.chunk2;\n            this.chunkPos = this.chunk2Pos;\n            this.chunk2 = chunk;\n            this.chunk2Pos = chunkPos;\n            this.chunkOff = this.pos - this.chunkPos;\n        } else {\n            this.chunk2 = this.chunk;\n            this.chunk2Pos = this.chunkPos;\n            let nextChunk = this.input.chunk(this.pos);\n            let end = this.pos + nextChunk.length;\n            this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;\n            this.chunkPos = this.pos;\n            this.chunkOff = 0;\n        }\n    }\n    readNext() {\n        if (this.chunkOff >= this.chunk.length) {\n            this.getChunk();\n            if (this.chunkOff == this.chunk.length) return this.next = -1;\n        }\n        return this.next = this.chunk.charCodeAt(this.chunkOff);\n    }\n    /**\n    Move the stream forward N (defaults to 1) code units. Returns\n    the new value of [`next`](#lr.InputStream.next).\n    */ advance(n = 1) {\n        this.chunkOff += n;\n        while(this.pos + n >= this.range.to){\n            if (this.rangeIndex == this.ranges.length - 1) return this.setDone();\n            n -= this.range.to - this.pos;\n            this.range = this.ranges[++this.rangeIndex];\n            this.pos = this.range.from;\n        }\n        this.pos += n;\n        if (this.pos >= this.token.lookAhead) this.token.lookAhead = this.pos + 1;\n        return this.readNext();\n    }\n    setDone() {\n        this.pos = this.chunkPos = this.end;\n        this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];\n        this.chunk = \"\";\n        return this.next = -1;\n    }\n    /**\n    @internal\n    */ reset(pos, token) {\n        if (token) {\n            this.token = token;\n            token.start = pos;\n            token.lookAhead = pos + 1;\n            token.value = token.extended = -1;\n        } else {\n            this.token = nullToken;\n        }\n        if (this.pos != pos) {\n            this.pos = pos;\n            if (pos == this.end) {\n                this.setDone();\n                return this;\n            }\n            while(pos < this.range.from)this.range = this.ranges[--this.rangeIndex];\n            while(pos >= this.range.to)this.range = this.ranges[++this.rangeIndex];\n            if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {\n                this.chunkOff = pos - this.chunkPos;\n            } else {\n                this.chunk = \"\";\n                this.chunkOff = 0;\n            }\n            this.readNext();\n        }\n        return this;\n    }\n    /**\n    @internal\n    */ read(from, to) {\n        if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length) return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);\n        if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length) return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);\n        if (from >= this.range.from && to <= this.range.to) return this.input.read(from, to);\n        let result = \"\";\n        for (let r of this.ranges){\n            if (r.from >= to) break;\n            if (r.to > from) result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));\n        }\n        return result;\n    }\n}\n/**\n@internal\n*/ class TokenGroup {\n    constructor(data, id){\n        this.data = data;\n        this.id = id;\n    }\n    token(input, stack) {\n        let { parser } = stack.p;\n        readToken(this.data, input, stack, this.id, parser.data, parser.tokenPrecTable);\n    }\n}\nTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;\n/**\n@hide\n*/ class LocalTokenGroup {\n    constructor(data, precTable, elseToken){\n        this.precTable = precTable;\n        this.elseToken = elseToken;\n        this.data = typeof data == \"string\" ? decodeArray(data) : data;\n    }\n    token(input, stack) {\n        let start = input.pos, skipped = 0;\n        for(;;){\n            let atEof = input.next < 0, nextPos = input.resolveOffset(1, 1);\n            readToken(this.data, input, stack, 0, this.data, this.precTable);\n            if (input.token.value > -1) break;\n            if (this.elseToken == null) return;\n            if (!atEof) skipped++;\n            if (nextPos == null) break;\n            input.reset(nextPos, input.token);\n        }\n        if (skipped) {\n            input.reset(start, input.token);\n            input.acceptToken(this.elseToken, skipped);\n        }\n    }\n}\nLocalTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;\n/**\n`@external tokens` declarations in the grammar should resolve to\nan instance of this class.\n*/ class ExternalTokenizer {\n    /**\n    Create a tokenizer. The first argument is the function that,\n    given an input stream, scans for the types of tokens it\n    recognizes at the stream's position, and calls\n    [`acceptToken`](#lr.InputStream.acceptToken) when it finds\n    one.\n    */ constructor(/**\n    @internal\n    */ token, options = {}){\n        this.token = token;\n        this.contextual = !!options.contextual;\n        this.fallback = !!options.fallback;\n        this.extend = !!options.extend;\n    }\n}\n// Tokenizer data is stored a big uint16 array containing, for each\n// state:\n//\n//  - A group bitmask, indicating what token groups are reachable from\n//    this state, so that paths that can only lead to tokens not in\n//    any of the current groups can be cut off early.\n//\n//  - The position of the end of the state's sequence of accepting\n//    tokens\n//\n//  - The number of outgoing edges for the state\n//\n//  - The accepting tokens, as (token id, group mask) pairs\n//\n//  - The outgoing edges, as (start character, end character, state\n//    index) triples, with end character being exclusive\n//\n// This function interprets that data, running through a stream as\n// long as new states with the a matching group mask can be reached,\n// and updating `input.token` when it matches a token.\nfunction readToken(data, input, stack, group, precTable, precOffset) {\n    let state = 0, groupMask = 1 << group, { dialect } = stack.p.parser;\n    scan: for(;;){\n        if ((groupMask & data[state]) == 0) break;\n        let accEnd = data[state + 1];\n        // Check whether this state can lead to a token in the current group\n        // Accept tokens in this state, possibly overwriting\n        // lower-precedence / shorter tokens\n        for(let i = state + 3; i < accEnd; i += 2)if ((data[i + 1] & groupMask) > 0) {\n            let term = data[i];\n            if (dialect.allows(term) && (input.token.value == -1 || input.token.value == term || overrides(term, input.token.value, precTable, precOffset))) {\n                input.acceptToken(term);\n                break;\n            }\n        }\n        let next = input.next, low = 0, high = data[state + 2];\n        // Special case for EOF\n        if (input.next < 0 && high > low && data[accEnd + high * 3 - 3] == 65535 /* Seq.End */ ) {\n            state = data[accEnd + high * 3 - 1];\n            continue scan;\n        }\n        // Do a binary search on the state's edges\n        for(; low < high;){\n            let mid = low + high >> 1;\n            let index = accEnd + mid + (mid << 1);\n            let from = data[index], to = data[index + 1] || 0x10000;\n            if (next < from) high = mid;\n            else if (next >= to) low = mid + 1;\n            else {\n                state = data[index + 2];\n                input.advance();\n                continue scan;\n            }\n        }\n        break;\n    }\n}\nfunction findOffset(data, start, term) {\n    for(let i = start, next; (next = data[i]) != 65535 /* Seq.End */ ; i++)if (next == term) return i - start;\n    return -1;\n}\nfunction overrides(token, prev, tableData, tableOffset) {\n    let iPrev = findOffset(tableData, tableOffset, prev);\n    return iPrev < 0 || findOffset(tableData, tableOffset, token) < iPrev;\n}\n// Environment variable used to control console output\nconst verbose = typeof process != \"undefined\" && process.env && /\\bparse\\b/.test(process.env.LOG);\nlet stackIDs = null;\nfunction cutAt(tree, pos, side) {\n    let cursor = tree.cursor(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.IterMode.IncludeAnonymous);\n    cursor.moveTo(pos);\n    for(;;){\n        if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos))) for(;;){\n            if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError) return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25 /* Lookahead.Margin */ )) : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25 /* Lookahead.Margin */ ));\n            if (side < 0 ? cursor.prevSibling() : cursor.nextSibling()) break;\n            if (!cursor.parent()) return side < 0 ? 0 : tree.length;\n        }\n    }\n}\nclass FragmentCursor {\n    constructor(fragments, nodeSet){\n        this.fragments = fragments;\n        this.nodeSet = nodeSet;\n        this.i = 0;\n        this.fragment = null;\n        this.safeFrom = -1;\n        this.safeTo = -1;\n        this.trees = [];\n        this.start = [];\n        this.index = [];\n        this.nextFragment();\n    }\n    nextFragment() {\n        let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];\n        if (fr) {\n            this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;\n            this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;\n            while(this.trees.length){\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n            }\n            this.trees.push(fr.tree);\n            this.start.push(-fr.offset);\n            this.index.push(0);\n            this.nextStart = this.safeFrom;\n        } else {\n            this.nextStart = 1e9;\n        }\n    }\n    // `pos` must be >= any previously given `pos` for this cursor\n    nodeAt(pos) {\n        if (pos < this.nextStart) return null;\n        while(this.fragment && this.safeTo <= pos)this.nextFragment();\n        if (!this.fragment) return null;\n        for(;;){\n            let last = this.trees.length - 1;\n            if (last < 0) {\n                this.nextFragment();\n                return null;\n            }\n            let top = this.trees[last], index = this.index[last];\n            if (index == top.children.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n                continue;\n            }\n            let next = top.children[index];\n            let start = this.start[last] + top.positions[index];\n            if (start > pos) {\n                this.nextStart = start;\n                return null;\n            }\n            if (next instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) {\n                if (start == pos) {\n                    if (start < this.safeFrom) return null;\n                    let end = start + next.length;\n                    if (end <= this.safeTo) {\n                        let lookAhead = next.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.lookAhead);\n                        if (!lookAhead || end + lookAhead < this.fragment.to) return next;\n                    }\n                }\n                this.index[last]++;\n                if (start + next.length >= Math.max(this.safeFrom, pos)) {\n                    this.trees.push(next);\n                    this.start.push(start);\n                    this.index.push(0);\n                }\n            } else {\n                this.index[last]++;\n                this.nextStart = start + next.length;\n            }\n        }\n    }\n}\nclass TokenCache {\n    constructor(parser, stream){\n        this.stream = stream;\n        this.tokens = [];\n        this.mainToken = null;\n        this.actions = [];\n        this.tokens = parser.tokenizers.map((_)=>new CachedToken);\n    }\n    getActions(stack) {\n        let actionIndex = 0;\n        let main = null;\n        let { parser } = stack.p, { tokenizers } = parser;\n        let mask = parser.stateSlot(stack.state, 3 /* ParseState.TokenizerMask */ );\n        let context = stack.curContext ? stack.curContext.hash : 0;\n        let lookAhead = 0;\n        for(let i = 0; i < tokenizers.length; i++){\n            if ((1 << i & mask) == 0) continue;\n            let tokenizer = tokenizers[i], token = this.tokens[i];\n            if (main && !tokenizer.fallback) continue;\n            if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {\n                this.updateCachedToken(token, tokenizer, stack);\n                token.mask = mask;\n                token.context = context;\n            }\n            if (token.lookAhead > token.end + 25 /* Lookahead.Margin */ ) lookAhead = Math.max(token.lookAhead, lookAhead);\n            if (token.value != 0 /* Term.Err */ ) {\n                let startIndex = actionIndex;\n                if (token.extended > -1) actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);\n                actionIndex = this.addActions(stack, token.value, token.end, actionIndex);\n                if (!tokenizer.extend) {\n                    main = token;\n                    if (actionIndex > startIndex) break;\n                }\n            }\n        }\n        while(this.actions.length > actionIndex)this.actions.pop();\n        if (lookAhead) stack.setLookAhead(lookAhead);\n        if (!main && stack.pos == this.stream.end) {\n            main = new CachedToken;\n            main.value = stack.p.parser.eofTerm;\n            main.start = main.end = stack.pos;\n            actionIndex = this.addActions(stack, main.value, main.end, actionIndex);\n        }\n        this.mainToken = main;\n        return this.actions;\n    }\n    getMainToken(stack) {\n        if (this.mainToken) return this.mainToken;\n        let main = new CachedToken, { pos, p } = stack;\n        main.start = pos;\n        main.end = Math.min(pos + 1, p.stream.end);\n        main.value = pos == p.stream.end ? p.parser.eofTerm : 0 /* Term.Err */ ;\n        return main;\n    }\n    updateCachedToken(token, tokenizer, stack) {\n        let start = this.stream.clipPos(stack.pos);\n        tokenizer.token(this.stream.reset(start, token), stack);\n        if (token.value > -1) {\n            let { parser } = stack.p;\n            for(let i = 0; i < parser.specialized.length; i++)if (parser.specialized[i] == token.value) {\n                let result = parser.specializers[i](this.stream.read(token.start, token.end), stack);\n                if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {\n                    if ((result & 1) == 0 /* Specialize.Specialize */ ) token.value = result >> 1;\n                    else token.extended = result >> 1;\n                    break;\n                }\n            }\n        } else {\n            token.value = 0 /* Term.Err */ ;\n            token.end = this.stream.clipPos(start + 1);\n        }\n    }\n    putAction(action, token, end, index) {\n        // Don't add duplicate actions\n        for(let i = 0; i < index; i += 3)if (this.actions[i] == action) return index;\n        this.actions[index++] = action;\n        this.actions[index++] = token;\n        this.actions[index++] = end;\n        return index;\n    }\n    addActions(stack, token, end, index) {\n        let { state } = stack, { parser } = stack.p, { data } = parser;\n        for(let set = 0; set < 2; set++){\n            for(let i = parser.stateSlot(state, set ? 2 /* ParseState.Skip */  : 1 /* ParseState.Actions */ );; i += 3){\n                if (data[i] == 65535 /* Seq.End */ ) {\n                    if (data[i + 1] == 1 /* Seq.Next */ ) {\n                        i = pair(data, i + 2);\n                    } else {\n                        if (index == 0 && data[i + 1] == 2 /* Seq.Other */ ) index = this.putAction(pair(data, i + 2), token, end, index);\n                        break;\n                    }\n                }\n                if (data[i] == token) index = this.putAction(pair(data, i + 1), token, end, index);\n            }\n        }\n        return index;\n    }\n}\nclass Parse {\n    constructor(parser, input, fragments, ranges){\n        this.parser = parser;\n        this.input = input;\n        this.ranges = ranges;\n        this.recovering = 0;\n        this.nextStackID = 0x2654; // â™”, â™•, â™–, â™—, â™˜, â™™, â™ , â™¡, â™¢, â™£, â™¤, â™¥, â™¦, â™§\n        this.minStackPos = 0;\n        this.reused = [];\n        this.stoppedAt = null;\n        this.lastBigReductionStart = -1;\n        this.lastBigReductionSize = 0;\n        this.bigReductionCount = 0;\n        this.stream = new InputStream(input, ranges);\n        this.tokens = new TokenCache(parser, this.stream);\n        this.topTerm = parser.top[1];\n        let { from } = ranges[0];\n        this.stacks = [\n            Stack.start(this, parser.top[0], from)\n        ];\n        this.fragments = fragments.length && this.stream.end - from > parser.bufferLength * 4 ? new FragmentCursor(fragments, parser.nodeSet) : null;\n    }\n    get parsedPos() {\n        return this.minStackPos;\n    }\n    // Move the parser forward. This will process all parse stacks at\n    // `this.pos` and try to advance them to a further position. If no\n    // stack for such a position is found, it'll start error-recovery.\n    //\n    // When the parse is finished, this will return a syntax tree. When\n    // not, it returns `null`.\n    advance() {\n        let stacks = this.stacks, pos = this.minStackPos;\n        // This will hold stacks beyond `pos`.\n        let newStacks = this.stacks = [];\n        let stopped, stoppedTokens;\n        // If a large amount of reductions happened with the same start\n        // position, force the stack out of that production in order to\n        // avoid creating a tree too deep to recurse through.\n        // (This is an ugly kludge, because unfortunately there is no\n        // straightforward, cheap way to check for this happening, due to\n        // the history of reductions only being available in an\n        // expensive-to-access format in the stack buffers.)\n        if (this.bigReductionCount > 300 /* Rec.MaxLeftAssociativeReductionCount */  && stacks.length == 1) {\n            let [s] = stacks;\n            while(s.forceReduce() && s.stack.length && s.stack[s.stack.length - 2] >= this.lastBigReductionStart){}\n            this.bigReductionCount = this.lastBigReductionSize = 0;\n        }\n        // Keep advancing any stacks at `pos` until they either move\n        // forward or can't be advanced. Gather stacks that can't be\n        // advanced further in `stopped`.\n        for(let i = 0; i < stacks.length; i++){\n            let stack = stacks[i];\n            for(;;){\n                this.tokens.mainToken = null;\n                if (stack.pos > pos) {\n                    newStacks.push(stack);\n                } else if (this.advanceStack(stack, newStacks, stacks)) {\n                    continue;\n                } else {\n                    if (!stopped) {\n                        stopped = [];\n                        stoppedTokens = [];\n                    }\n                    stopped.push(stack);\n                    let tok = this.tokens.getMainToken(stack);\n                    stoppedTokens.push(tok.value, tok.end);\n                }\n                break;\n            }\n        }\n        if (!newStacks.length) {\n            let finished = stopped && findFinished(stopped);\n            if (finished) {\n                if (verbose) console.log(\"Finish with \" + this.stackID(finished));\n                return this.stackToTree(finished);\n            }\n            if (this.parser.strict) {\n                if (verbose && stopped) console.log(\"Stuck with token \" + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : \"none\"));\n                throw new SyntaxError(\"No parse at \" + pos);\n            }\n            if (!this.recovering) this.recovering = 5 /* Rec.Distance */ ;\n        }\n        if (this.recovering && stopped) {\n            let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0] : this.runRecovery(stopped, stoppedTokens, newStacks);\n            if (finished) {\n                if (verbose) console.log(\"Force-finish \" + this.stackID(finished));\n                return this.stackToTree(finished.forceAll());\n            }\n        }\n        if (this.recovering) {\n            let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3 /* Rec.MaxRemainingPerStep */ ;\n            if (newStacks.length > maxRemaining) {\n                newStacks.sort((a, b)=>b.score - a.score);\n                while(newStacks.length > maxRemaining)newStacks.pop();\n            }\n            if (newStacks.some((s)=>s.reducePos > pos)) this.recovering--;\n        } else if (newStacks.length > 1) {\n            // Prune stacks that are in the same state, or that have been\n            // running without splitting for a while, to avoid getting stuck\n            // with multiple successful stacks running endlessly on.\n            outer: for(let i = 0; i < newStacks.length - 1; i++){\n                let stack = newStacks[i];\n                for(let j = i + 1; j < newStacks.length; j++){\n                    let other = newStacks[j];\n                    if (stack.sameState(other) || stack.buffer.length > 500 /* Rec.MinBufferLengthPrune */  && other.buffer.length > 500 /* Rec.MinBufferLengthPrune */ ) {\n                        if ((stack.score - other.score || stack.buffer.length - other.buffer.length) > 0) {\n                            newStacks.splice(j--, 1);\n                        } else {\n                            newStacks.splice(i--, 1);\n                            continue outer;\n                        }\n                    }\n                }\n            }\n            if (newStacks.length > 12 /* Rec.MaxStackCount */ ) newStacks.splice(12 /* Rec.MaxStackCount */ , newStacks.length - 12 /* Rec.MaxStackCount */ );\n        }\n        this.minStackPos = newStacks[0].pos;\n        for(let i = 1; i < newStacks.length; i++)if (newStacks[i].pos < this.minStackPos) this.minStackPos = newStacks[i].pos;\n        return null;\n    }\n    stopAt(pos) {\n        if (this.stoppedAt != null && this.stoppedAt < pos) throw new RangeError(\"Can't move stoppedAt forward\");\n        this.stoppedAt = pos;\n    }\n    // Returns an updated version of the given stack, or null if the\n    // stack can't advance normally. When `split` and `stacks` are\n    // given, stacks split off by ambiguous operations will be pushed to\n    // `split`, or added to `stacks` if they move `pos` forward.\n    advanceStack(stack, stacks, split) {\n        let start = stack.pos, { parser } = this;\n        let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n        if (this.stoppedAt != null && start > this.stoppedAt) return stack.forceReduce() ? stack : null;\n        if (this.fragments) {\n            let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;\n            for(let cached = this.fragments.nodeAt(start); cached;){\n                let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;\n                if (match > -1 && cached.length && (!strictCx || (cached.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.contextHash) || 0) == cxHash)) {\n                    stack.useNode(cached, match);\n                    if (verbose) console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);\n                    return true;\n                }\n                if (!(cached instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) || cached.children.length == 0 || cached.positions[0] > 0) break;\n                let inner = cached.children[0];\n                if (inner instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree && cached.positions[0] == 0) cached = inner;\n                else break;\n            }\n        }\n        let defaultReduce = parser.stateSlot(stack.state, 4 /* ParseState.DefaultReduce */ );\n        if (defaultReduce > 0) {\n            stack.reduce(defaultReduce);\n            if (verbose) console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535 /* Action.ValueMask */ )})`);\n            return true;\n        }\n        if (stack.stack.length >= 8400 /* Rec.CutDepth */ ) {\n            while(stack.stack.length > 6000 /* Rec.CutTo */  && stack.forceReduce()){}\n        }\n        let actions = this.tokens.getActions(stack);\n        for(let i = 0; i < actions.length;){\n            let action = actions[i++], term = actions[i++], end = actions[i++];\n            let last = i == actions.length || !split;\n            let localStack = last ? stack : stack.split();\n            let main = this.tokens.mainToken;\n            localStack.apply(action, term, main ? main.start : localStack.pos, end);\n            if (verbose) console.log(base + this.stackID(localStack) + ` (via ${(action & 65536 /* Action.ReduceFlag */ ) == 0 ? \"shift\" : `reduce of ${parser.getName(action & 65535 /* Action.ValueMask */ )}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? \"\" : \", split\"})`);\n            if (last) return true;\n            else if (localStack.pos > start) stacks.push(localStack);\n            else split.push(localStack);\n        }\n        return false;\n    }\n    // Advance a given stack forward as far as it will go. Returns the\n    // (possibly updated) stack if it got stuck, or null if it moved\n    // forward and was given to `pushStackDedup`.\n    advanceFully(stack, newStacks) {\n        let pos = stack.pos;\n        for(;;){\n            if (!this.advanceStack(stack, null, null)) return false;\n            if (stack.pos > pos) {\n                pushStackDedup(stack, newStacks);\n                return true;\n            }\n        }\n    }\n    runRecovery(stacks, tokens, newStacks) {\n        let finished = null, restarted = false;\n        for(let i = 0; i < stacks.length; i++){\n            let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];\n            let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n            if (stack.deadEnd) {\n                if (restarted) continue;\n                restarted = true;\n                stack.restart();\n                if (verbose) console.log(base + this.stackID(stack) + \" (restarted)\");\n                let done = this.advanceFully(stack, newStacks);\n                if (done) continue;\n            }\n            let force = stack.split(), forceBase = base;\n            for(let j = 0; force.forceReduce() && j < 10 /* Rec.ForceReduceLimit */ ; j++){\n                if (verbose) console.log(forceBase + this.stackID(force) + \" (via force-reduce)\");\n                let done = this.advanceFully(force, newStacks);\n                if (done) break;\n                if (verbose) forceBase = this.stackID(force) + \" -> \";\n            }\n            for (let insert of stack.recoverByInsert(token)){\n                if (verbose) console.log(base + this.stackID(insert) + \" (via recover-insert)\");\n                this.advanceFully(insert, newStacks);\n            }\n            if (this.stream.end > stack.pos) {\n                if (tokenEnd == stack.pos) {\n                    tokenEnd++;\n                    token = 0 /* Term.Err */ ;\n                }\n                stack.recoverByDelete(token, tokenEnd);\n                if (verbose) console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);\n                pushStackDedup(stack, newStacks);\n            } else if (!finished || finished.score < stack.score) {\n                finished = stack;\n            }\n        }\n        return finished;\n    }\n    // Convert the stack's buffer to a syntax tree.\n    stackToTree(stack) {\n        stack.close();\n        return _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.build({\n            buffer: StackBufferCursor.create(stack),\n            nodeSet: this.parser.nodeSet,\n            topID: this.topTerm,\n            maxBufferLength: this.parser.bufferLength,\n            reused: this.reused,\n            start: this.ranges[0].from,\n            length: stack.pos - this.ranges[0].from,\n            minRepeatType: this.parser.minRepeatTerm\n        });\n    }\n    stackID(stack) {\n        let id = (stackIDs || (stackIDs = new WeakMap)).get(stack);\n        if (!id) stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));\n        return id + stack;\n    }\n}\nfunction pushStackDedup(stack, newStacks) {\n    for(let i = 0; i < newStacks.length; i++){\n        let other = newStacks[i];\n        if (other.pos == stack.pos && other.sameState(stack)) {\n            if (newStacks[i].score < stack.score) newStacks[i] = stack;\n            return;\n        }\n    }\n    newStacks.push(stack);\n}\nclass Dialect {\n    constructor(source, flags, disabled){\n        this.source = source;\n        this.flags = flags;\n        this.disabled = disabled;\n    }\n    allows(term) {\n        return !this.disabled || this.disabled[term] == 0;\n    }\n}\nconst id = (x)=>x;\n/**\nContext trackers are used to track stateful context (such as\nindentation in the Python grammar, or parent elements in the XML\ngrammar) needed by external tokenizers. You declare them in a\ngrammar file as `@context exportName from \"module\"`.\n\nContext values should be immutable, and can be updated (replaced)\non shift or reduce actions.\n\nThe export used in a `@context` declaration should be of this\ntype.\n*/ class ContextTracker {\n    /**\n    Define a context tracker.\n    */ constructor(spec){\n        this.start = spec.start;\n        this.shift = spec.shift || id;\n        this.reduce = spec.reduce || id;\n        this.reuse = spec.reuse || id;\n        this.hash = spec.hash || (()=>0);\n        this.strict = spec.strict !== false;\n    }\n}\n/**\nHolds the parse tables for a given grammar, as generated by\n`lezer-generator`, and provides [methods](#common.Parser) to parse\ncontent with.\n*/ class LRParser extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {\n    /**\n    @internal\n    */ constructor(spec){\n        super();\n        /**\n        @internal\n        */ this.wrappers = [];\n        if (spec.version != 14 /* File.Version */ ) throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14 /* File.Version */ })`);\n        let nodeNames = spec.nodeNames.split(\" \");\n        this.minRepeatTerm = nodeNames.length;\n        for(let i = 0; i < spec.repeatNodeCount; i++)nodeNames.push(\"\");\n        let topTerms = Object.keys(spec.topRules).map((r)=>spec.topRules[r][1]);\n        let nodeProps = [];\n        for(let i = 0; i < nodeNames.length; i++)nodeProps.push([]);\n        function setProp(nodeID, prop, value) {\n            nodeProps[nodeID].push([\n                prop,\n                prop.deserialize(String(value))\n            ]);\n        }\n        if (spec.nodeProps) for (let propSpec of spec.nodeProps){\n            let prop = propSpec[0];\n            if (typeof prop == \"string\") prop = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp[prop];\n            for(let i = 1; i < propSpec.length;){\n                let next = propSpec[i++];\n                if (next >= 0) {\n                    setProp(next, prop, propSpec[i++]);\n                } else {\n                    let value = propSpec[i + -next];\n                    for(let j = -next; j > 0; j--)setProp(propSpec[i++], prop, value);\n                    i++;\n                }\n            }\n        }\n        this.nodeSet = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeSet(nodeNames.map((name, i)=>_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({\n                name: i >= this.minRepeatTerm ? undefined : name,\n                id: i,\n                props: nodeProps[i],\n                top: topTerms.indexOf(i) > -1,\n                error: i == 0,\n                skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1\n            })));\n        if (spec.propSources) this.nodeSet = this.nodeSet.extend(...spec.propSources);\n        this.strict = false;\n        this.bufferLength = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.DefaultBufferLength;\n        let tokenArray = decodeArray(spec.tokenData);\n        this.context = spec.context;\n        this.specializerSpecs = spec.specialized || [];\n        this.specialized = new Uint16Array(this.specializerSpecs.length);\n        for(let i = 0; i < this.specializerSpecs.length; i++)this.specialized[i] = this.specializerSpecs[i].term;\n        this.specializers = this.specializerSpecs.map(getSpecializer);\n        this.states = decodeArray(spec.states, Uint32Array);\n        this.data = decodeArray(spec.stateData);\n        this.goto = decodeArray(spec.goto);\n        this.maxTerm = spec.maxTerm;\n        this.tokenizers = spec.tokenizers.map((value)=>typeof value == \"number\" ? new TokenGroup(tokenArray, value) : value);\n        this.topRules = spec.topRules;\n        this.dialects = spec.dialects || {};\n        this.dynamicPrecedences = spec.dynamicPrecedences || null;\n        this.tokenPrecTable = spec.tokenPrec;\n        this.termNames = spec.termNames || null;\n        this.maxNode = this.nodeSet.types.length - 1;\n        this.dialect = this.parseDialect();\n        this.top = this.topRules[Object.keys(this.topRules)[0]];\n    }\n    createParse(input, fragments, ranges) {\n        let parse = new Parse(this, input, fragments, ranges);\n        for (let w of this.wrappers)parse = w(parse, input, fragments, ranges);\n        return parse;\n    }\n    /**\n    Get a goto table entry @internal\n    */ getGoto(state, term, loose = false) {\n        let table = this.goto;\n        if (term >= table[0]) return -1;\n        for(let pos = table[term + 1];;){\n            let groupTag = table[pos++], last = groupTag & 1;\n            let target = table[pos++];\n            if (last && loose) return target;\n            for(let end = pos + (groupTag >> 1); pos < end; pos++)if (table[pos] == state) return target;\n            if (last) return -1;\n        }\n    }\n    /**\n    Check if this state has an action for a given terminal @internal\n    */ hasAction(state, terminal) {\n        let data = this.data;\n        for(let set = 0; set < 2; set++){\n            for(let i = this.stateSlot(state, set ? 2 /* ParseState.Skip */  : 1 /* ParseState.Actions */ ), next;; i += 3){\n                if ((next = data[i]) == 65535 /* Seq.End */ ) {\n                    if (data[i + 1] == 1 /* Seq.Next */ ) next = data[i = pair(data, i + 2)];\n                    else if (data[i + 1] == 2 /* Seq.Other */ ) return pair(data, i + 2);\n                    else break;\n                }\n                if (next == terminal || next == 0 /* Term.Err */ ) return pair(data, i + 1);\n            }\n        }\n        return 0;\n    }\n    /**\n    @internal\n    */ stateSlot(state, slot) {\n        return this.states[state * 6 /* ParseState.Size */  + slot];\n    }\n    /**\n    @internal\n    */ stateFlag(state, flag) {\n        return (this.stateSlot(state, 0 /* ParseState.Flags */ ) & flag) > 0;\n    }\n    /**\n    @internal\n    */ validAction(state, action) {\n        return !!this.allActions(state, (a)=>a == action ? true : null);\n    }\n    /**\n    @internal\n    */ allActions(state, action) {\n        let deflt = this.stateSlot(state, 4 /* ParseState.DefaultReduce */ );\n        let result = deflt ? action(deflt) : undefined;\n        for(let i = this.stateSlot(state, 1 /* ParseState.Actions */ ); result == null; i += 3){\n            if (this.data[i] == 65535 /* Seq.End */ ) {\n                if (this.data[i + 1] == 1 /* Seq.Next */ ) i = pair(this.data, i + 2);\n                else break;\n            }\n            result = action(pair(this.data, i + 1));\n        }\n        return result;\n    }\n    /**\n    Get the states that can follow this one through shift actions or\n    goto jumps. @internal\n    */ nextStates(state) {\n        let result = [];\n        for(let i = this.stateSlot(state, 1 /* ParseState.Actions */ );; i += 3){\n            if (this.data[i] == 65535 /* Seq.End */ ) {\n                if (this.data[i + 1] == 1 /* Seq.Next */ ) i = pair(this.data, i + 2);\n                else break;\n            }\n            if ((this.data[i + 2] & 65536 /* Action.ReduceFlag */  >> 16) == 0) {\n                let value = this.data[i + 1];\n                if (!result.some((v, i)=>i & 1 && v == value)) result.push(this.data[i], value);\n            }\n        }\n        return result;\n    }\n    /**\n    Configure the parser. Returns a new parser instance that has the\n    given settings modified. Settings not provided in `config` are\n    kept from the original parser.\n    */ configure(config) {\n        // Hideous reflection-based kludge to make it easy to create a\n        // slightly modified copy of a parser.\n        let copy = Object.assign(Object.create(LRParser.prototype), this);\n        if (config.props) copy.nodeSet = this.nodeSet.extend(...config.props);\n        if (config.top) {\n            let info = this.topRules[config.top];\n            if (!info) throw new RangeError(`Invalid top rule name ${config.top}`);\n            copy.top = info;\n        }\n        if (config.tokenizers) copy.tokenizers = this.tokenizers.map((t)=>{\n            let found = config.tokenizers.find((r)=>r.from == t);\n            return found ? found.to : t;\n        });\n        if (config.specializers) {\n            copy.specializers = this.specializers.slice();\n            copy.specializerSpecs = this.specializerSpecs.map((s, i)=>{\n                let found = config.specializers.find((r)=>r.from == s.external);\n                if (!found) return s;\n                let spec = Object.assign(Object.assign({}, s), {\n                    external: found.to\n                });\n                copy.specializers[i] = getSpecializer(spec);\n                return spec;\n            });\n        }\n        if (config.contextTracker) copy.context = config.contextTracker;\n        if (config.dialect) copy.dialect = this.parseDialect(config.dialect);\n        if (config.strict != null) copy.strict = config.strict;\n        if (config.wrap) copy.wrappers = copy.wrappers.concat(config.wrap);\n        if (config.bufferLength != null) copy.bufferLength = config.bufferLength;\n        return copy;\n    }\n    /**\n    Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)\n    are registered for this parser.\n    */ hasWrappers() {\n        return this.wrappers.length > 0;\n    }\n    /**\n    Returns the name associated with a given term. This will only\n    work for all terms when the parser was generated with the\n    `--names` option. By default, only the names of tagged terms are\n    stored.\n    */ getName(term) {\n        return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);\n    }\n    /**\n    The eof term id is always allocated directly after the node\n    types. @internal\n    */ get eofTerm() {\n        return this.maxNode + 1;\n    }\n    /**\n    The type of top node produced by the parser.\n    */ get topNode() {\n        return this.nodeSet.types[this.top[1]];\n    }\n    /**\n    @internal\n    */ dynamicPrecedence(term) {\n        let prec = this.dynamicPrecedences;\n        return prec == null ? 0 : prec[term] || 0;\n    }\n    /**\n    @internal\n    */ parseDialect(dialect) {\n        let values = Object.keys(this.dialects), flags = values.map(()=>false);\n        if (dialect) for (let part of dialect.split(\" \")){\n            let id = values.indexOf(part);\n            if (id >= 0) flags[id] = true;\n        }\n        let disabled = null;\n        for(let i = 0; i < values.length; i++)if (!flags[i]) {\n            for(let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535 /* Seq.End */ ;)(disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;\n        }\n        return new Dialect(dialect, flags, disabled);\n    }\n    /**\n    Used by the output of the parser generator. Not available to\n    user code. @hide\n    */ static deserialize(spec) {\n        return new LRParser(spec);\n    }\n}\nfunction pair(data, off) {\n    return data[off] | data[off + 1] << 16;\n}\nfunction findFinished(stacks) {\n    let best = null;\n    for (let stack of stacks){\n        let stopped = stack.p.stoppedAt;\n        if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) && stack.p.parser.stateFlag(stack.state, 2 /* StateFlag.Accepting */ ) && (!best || best.score < stack.score)) best = stack;\n    }\n    return best;\n}\nfunction getSpecializer(spec) {\n    if (spec.external) {\n        let mask = spec.extend ? 1 /* Specialize.Extend */  : 0 /* Specialize.Specialize */ ;\n        return (value, stack)=>spec.external(value, stack) << 1 | mask;\n    }\n    return spec.get;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxlemVyL2xyL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUF5RztBQUV6Rzs7Ozs7QUFLQSxHQUNBLE1BQU1PO0lBQ0Y7O0lBRUEsR0FDQUMsWUFDQTs7SUFFQSxHQUNBQyxDQUFDLEVBQ0Q7OztJQUdBLEdBQ0FDLEtBQUssRUFDTDs7SUFFQSxHQUNBQyxLQUFLLEVBQ0wsZ0VBQWdFO0lBQ2hFLGlFQUFpRTtJQUNqRSxnRUFBZ0U7SUFDaEUsYUFBYTtJQUNiOztJQUVBLEdBQ0FDLFNBQVMsRUFDVDs7SUFFQSxHQUNBQyxHQUFHLEVBQ0g7Ozs7SUFJQSxHQUNBQyxLQUFLLEVBQ0wsMERBQTBEO0lBQzFELDREQUE0RDtJQUM1RCx1REFBdUQ7SUFDdkQ7O0lBRUEsR0FDQUMsTUFBTSxFQUNOLGtFQUFrRTtJQUNsRSwyREFBMkQ7SUFDM0QsNERBQTREO0lBQzVELGlFQUFpRTtJQUNqRSxrQkFBa0I7SUFDbEI7O0lBRUEsR0FDQUMsVUFBVSxFQUNWOztJQUVBLEdBQ0FDLFVBQVUsRUFDVjs7SUFFQSxHQUNBQyxZQUFZLENBQUMsRUFDYixnRUFBZ0U7SUFDaEUsMkRBQTJEO0lBQzNELDREQUE0RDtJQUM1RCxnQkFBZ0I7SUFDaEI7O0lBRUEsR0FDQUMsTUFBTSxDQUFFO1FBQ0osSUFBSSxDQUFDVixDQUFDLEdBQUdBO1FBQ1QsSUFBSSxDQUFDQyxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDQyxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDQyxTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ0MsR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQ0MsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0MsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0MsVUFBVSxHQUFHQTtRQUNsQixJQUFJLENBQUNDLFVBQVUsR0FBR0E7UUFDbEIsSUFBSSxDQUFDQyxTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ0MsTUFBTSxHQUFHQTtJQUNsQjtJQUNBOztJQUVBLEdBQ0FDLFdBQVc7UUFDUCxPQUFPLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQ1YsS0FBSyxDQUFDVyxNQUFNLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUEsSUFBSSxLQUFLLEdBQUdDLE1BQU0sQ0FBQyxJQUFJLENBQUNiLEtBQUssRUFBRSxFQUFFLEVBQUUsSUFBSSxDQUFDRSxHQUFHLENBQUMsRUFBRSxJQUFJLENBQUNDLEtBQUssR0FBRyxNQUFNLElBQUksQ0FBQ0EsS0FBSyxHQUFHLEdBQUcsQ0FBQztJQUM3SDtJQUNBLHVCQUF1QjtJQUN2Qjs7SUFFQSxHQUNBLE9BQU9XLE1BQU1oQixDQUFDLEVBQUVFLEtBQUssRUFBRUUsTUFBTSxDQUFDLEVBQUU7UUFDNUIsSUFBSWEsS0FBS2pCLEVBQUVrQixNQUFNLENBQUNDLE9BQU87UUFDekIsT0FBTyxJQUFJckIsTUFBTUUsR0FBRyxFQUFFLEVBQUVFLE9BQU9FLEtBQUtBLEtBQUssR0FBRyxFQUFFLEVBQUUsR0FBR2EsS0FBSyxJQUFJRyxhQUFhSCxJQUFJQSxHQUFHRCxLQUFLLElBQUksTUFBTSxHQUFHO0lBQ3RHO0lBQ0E7Ozs7O0lBS0EsR0FDQSxJQUFJRyxVQUFVO1FBQUUsT0FBTyxJQUFJLENBQUNYLFVBQVUsR0FBRyxJQUFJLENBQUNBLFVBQVUsQ0FBQ1csT0FBTyxHQUFHO0lBQU07SUFDekUsbUVBQW1FO0lBQ25FLG9DQUFvQztJQUNwQzs7SUFFQSxHQUNBRSxVQUFVbkIsS0FBSyxFQUFFYyxLQUFLLEVBQUU7UUFDcEIsSUFBSSxDQUFDZixLQUFLLENBQUNxQixJQUFJLENBQUMsSUFBSSxDQUFDcEIsS0FBSyxFQUFFYyxPQUFPLElBQUksQ0FBQ1QsVUFBVSxHQUFHLElBQUksQ0FBQ0QsTUFBTSxDQUFDaUIsTUFBTTtRQUN2RSxJQUFJLENBQUNyQixLQUFLLEdBQUdBO0lBQ2pCO0lBQ0Esd0JBQXdCO0lBQ3hCOztJQUVBLEdBQ0FzQixPQUFPQyxNQUFNLEVBQUU7UUFDWCxJQUFJQztRQUNKLElBQUlDLFFBQVFGLFVBQVUsR0FBRywyQkFBMkIsS0FBSUcsT0FBT0gsU0FBUyxNQUFNLG9CQUFvQjtRQUNsRyxJQUFJLEVBQUVQLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQ2xCLENBQUM7UUFDdkIsSUFBSTZCLGtCQUFrQixJQUFJLENBQUMxQixTQUFTLEdBQUcsSUFBSSxDQUFDQyxHQUFHLEdBQUcsR0FBRyxvQkFBb0I7UUFDekUsSUFBSXlCLGlCQUNBLElBQUksQ0FBQ0MsWUFBWSxDQUFDLElBQUksQ0FBQzFCLEdBQUc7UUFDOUIsSUFBSTJCLFFBQVFiLE9BQU9jLGlCQUFpQixDQUFDSjtRQUNyQyxJQUFJRyxPQUNBLElBQUksQ0FBQzFCLEtBQUssSUFBSTBCO1FBQ2xCLElBQUlKLFNBQVMsR0FBRztZQUNaLElBQUksQ0FBQ04sU0FBUyxDQUFDSCxPQUFPZSxPQUFPLENBQUMsSUFBSSxDQUFDL0IsS0FBSyxFQUFFMEIsTUFBTSxPQUFPLElBQUksQ0FBQ3pCLFNBQVM7WUFDckUsNkRBQTZEO1lBQzdELDBDQUEwQztZQUMxQyxJQUFJeUIsT0FBT1YsT0FBT2dCLGFBQWEsRUFDM0IsSUFBSSxDQUFDQyxTQUFTLENBQUNQLE1BQU0sSUFBSSxDQUFDekIsU0FBUyxFQUFFLElBQUksQ0FBQ0EsU0FBUyxFQUFFMEIsa0JBQWtCLElBQUksR0FBRztZQUNsRixJQUFJLENBQUNPLGFBQWEsQ0FBQ1IsTUFBTSxJQUFJLENBQUN6QixTQUFTO1lBQ3ZDO1FBQ0o7UUFDQSxrRUFBa0U7UUFDbEUsOERBQThEO1FBQzlELGtFQUFrRTtRQUNsRSxrRUFBa0U7UUFDbEUsNkJBQTZCO1FBQzdCLElBQUlrQyxPQUFPLElBQUksQ0FBQ3BDLEtBQUssQ0FBQ3NCLE1BQU0sR0FBSSxDQUFDSSxRQUFRLEtBQUssSUFBTUYsQ0FBQUEsU0FBUyxPQUFPLG1CQUFtQixNQUFLLElBQUk7UUFDaEcsSUFBSVQsUUFBUXFCLE9BQU8sSUFBSSxDQUFDcEMsS0FBSyxDQUFDb0MsT0FBTyxFQUFFLEdBQUcsSUFBSSxDQUFDckMsQ0FBQyxDQUFDc0MsTUFBTSxDQUFDLEVBQUUsQ0FBQ0MsSUFBSSxFQUFFQyxPQUFPLElBQUksQ0FBQ3JDLFNBQVMsR0FBR2E7UUFDekYsa0VBQWtFO1FBQ2xFLGdFQUFnRTtRQUNoRSwwREFBMEQ7UUFDMUQsSUFBSXdCLFFBQVEsS0FBSywyQkFBMkIsT0FBTSxDQUFFLEVBQUNkLEtBQUssSUFBSSxDQUFDMUIsQ0FBQyxDQUFDa0IsTUFBTSxDQUFDdUIsT0FBTyxDQUFDQyxLQUFLLENBQUNkLEtBQUssTUFBTSxRQUFRRixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdpQixXQUFXLEdBQUc7WUFDL0ksSUFBSTNCLFNBQVMsSUFBSSxDQUFDaEIsQ0FBQyxDQUFDNEMscUJBQXFCLEVBQUU7Z0JBQ3ZDLElBQUksQ0FBQzVDLENBQUMsQ0FBQzZDLGlCQUFpQjtnQkFDeEIsSUFBSSxDQUFDN0MsQ0FBQyxDQUFDOEMsb0JBQW9CLEdBQUdOO1lBQ2xDLE9BQ0ssSUFBSSxJQUFJLENBQUN4QyxDQUFDLENBQUM4QyxvQkFBb0IsR0FBR04sTUFBTTtnQkFDekMsSUFBSSxDQUFDeEMsQ0FBQyxDQUFDNkMsaUJBQWlCLEdBQUc7Z0JBQzNCLElBQUksQ0FBQzdDLENBQUMsQ0FBQzRDLHFCQUFxQixHQUFHNUI7Z0JBQy9CLElBQUksQ0FBQ2hCLENBQUMsQ0FBQzhDLG9CQUFvQixHQUFHTjtZQUNsQztRQUNKO1FBQ0EsSUFBSWpDLGFBQWE4QixPQUFPLElBQUksQ0FBQ3BDLEtBQUssQ0FBQ29DLE9BQU8sRUFBRSxHQUFHLEdBQUdVLFFBQVEsSUFBSSxDQUFDeEMsVUFBVSxHQUFHLElBQUksQ0FBQ0QsTUFBTSxDQUFDaUIsTUFBTSxHQUFHaEI7UUFDakcscURBQXFEO1FBQ3JELElBQUlxQixPQUFPVixPQUFPZ0IsYUFBYSxJQUFLVCxTQUFTLE9BQU8scUJBQXFCLEtBQUs7WUFDMUUsSUFBSXJCLE1BQU1jLE9BQU84QixTQUFTLENBQUMsSUFBSSxDQUFDOUMsS0FBSyxFQUFFLEVBQUUscUJBQXFCLE9BQU0sSUFBSSxDQUFDRSxHQUFHLEdBQUcsSUFBSSxDQUFDRCxTQUFTO1lBQzdGLElBQUksQ0FBQ2dDLFNBQVMsQ0FBQ1AsTUFBTVosT0FBT1osS0FBSzJDLFFBQVEsR0FBRztRQUNoRDtRQUNBLElBQUl0QixTQUFTLE9BQU8sbUJBQW1CLEtBQUk7WUFDdkMsSUFBSSxDQUFDdkIsS0FBSyxHQUFHLElBQUksQ0FBQ0QsS0FBSyxDQUFDb0MsS0FBSztRQUNqQyxPQUNLO1lBQ0QsSUFBSVksY0FBYyxJQUFJLENBQUNoRCxLQUFLLENBQUNvQyxPQUFPLEVBQUU7WUFDdEMsSUFBSSxDQUFDbkMsS0FBSyxHQUFHZ0IsT0FBT2UsT0FBTyxDQUFDZ0IsYUFBYXJCLE1BQU07UUFDbkQ7UUFDQSxNQUFPLElBQUksQ0FBQzNCLEtBQUssQ0FBQ3NCLE1BQU0sR0FBR2MsS0FDdkIsSUFBSSxDQUFDcEMsS0FBSyxDQUFDaUQsR0FBRztRQUNsQixJQUFJLENBQUNkLGFBQWEsQ0FBQ1IsTUFBTVo7SUFDN0I7SUFDQSxnQ0FBZ0M7SUFDaEM7O0lBRUEsR0FDQW1CLFVBQVVnQixJQUFJLEVBQUVuQyxLQUFLLEVBQUVvQyxHQUFHLEVBQUVaLE9BQU8sQ0FBQyxFQUFFYSxXQUFXLEtBQUssRUFBRTtRQUNwRCxJQUFJRixRQUFRLEVBQUUsWUFBWSxPQUNyQixFQUFDLElBQUksQ0FBQ2xELEtBQUssQ0FBQ3NCLE1BQU0sSUFBSSxJQUFJLENBQUN0QixLQUFLLENBQUMsSUFBSSxDQUFDQSxLQUFLLENBQUNzQixNQUFNLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQ2pCLE1BQU0sQ0FBQ2lCLE1BQU0sR0FBRyxJQUFJLENBQUNoQixVQUFVLEdBQUc7WUFDbEcseUNBQXlDO1lBQ3pDLElBQUkrQyxNQUFNLElBQUksRUFBRUMsTUFBTSxJQUFJLENBQUNqRCxNQUFNLENBQUNpQixNQUFNO1lBQ3hDLElBQUlnQyxPQUFPLEtBQUtELElBQUk1QyxNQUFNLEVBQUU7Z0JBQ3hCNkMsTUFBTUQsSUFBSS9DLFVBQVUsR0FBRytDLElBQUk1QyxNQUFNLENBQUNILFVBQVU7Z0JBQzVDK0MsTUFBTUEsSUFBSTVDLE1BQU07WUFDcEI7WUFDQSxJQUFJNkMsTUFBTSxLQUFLRCxJQUFJaEQsTUFBTSxDQUFDaUQsTUFBTSxFQUFFLElBQUksRUFBRSxZQUFZLE9BQU1ELElBQUloRCxNQUFNLENBQUNpRCxNQUFNLEVBQUUsR0FBRyxDQUFDLEdBQUc7Z0JBQ2hGLElBQUl2QyxTQUFTb0MsS0FDVDtnQkFDSixJQUFJRSxJQUFJaEQsTUFBTSxDQUFDaUQsTUFBTSxFQUFFLElBQUl2QyxPQUFPO29CQUM5QnNDLElBQUloRCxNQUFNLENBQUNpRCxNQUFNLEVBQUUsR0FBR0g7b0JBQ3RCO2dCQUNKO1lBQ0o7UUFDSjtRQUNBLElBQUksQ0FBQ0MsWUFBWSxJQUFJLENBQUNqRCxHQUFHLElBQUlnRCxLQUFLO1lBQzlCLElBQUksQ0FBQzlDLE1BQU0sQ0FBQ2dCLElBQUksQ0FBQzZCLE1BQU1uQyxPQUFPb0MsS0FBS1o7UUFDdkMsT0FDSztZQUNELElBQUlnQixRQUFRLElBQUksQ0FBQ2xELE1BQU0sQ0FBQ2lCLE1BQU07WUFDOUIsSUFBSWlDLFFBQVEsS0FBSyxJQUFJLENBQUNsRCxNQUFNLENBQUNrRCxRQUFRLEVBQUUsSUFBSSxFQUFFLFlBQVksS0FBSTtnQkFDekQsSUFBSUMsV0FBVztnQkFDZixJQUFLLElBQUlDLE9BQU9GLE9BQU9FLE9BQU8sS0FBSyxJQUFJLENBQUNwRCxNQUFNLENBQUNvRCxPQUFPLEVBQUUsR0FBR04sS0FBS00sUUFBUSxFQUFHO29CQUN2RSxJQUFJLElBQUksQ0FBQ3BELE1BQU0sQ0FBQ29ELE9BQU8sRUFBRSxJQUFJLEdBQUc7d0JBQzVCRCxXQUFXO3dCQUNYO29CQUNKO2dCQUNKO2dCQUNBLElBQUlBLFVBQ0EsTUFBT0QsUUFBUSxLQUFLLElBQUksQ0FBQ2xELE1BQU0sQ0FBQ2tELFFBQVEsRUFBRSxHQUFHSixJQUFLO29CQUM5QywyQkFBMkI7b0JBQzNCLElBQUksQ0FBQzlDLE1BQU0sQ0FBQ2tELE1BQU0sR0FBRyxJQUFJLENBQUNsRCxNQUFNLENBQUNrRCxRQUFRLEVBQUU7b0JBQzNDLElBQUksQ0FBQ2xELE1BQU0sQ0FBQ2tELFFBQVEsRUFBRSxHQUFHLElBQUksQ0FBQ2xELE1BQU0sQ0FBQ2tELFFBQVEsRUFBRTtvQkFDL0MsSUFBSSxDQUFDbEQsTUFBTSxDQUFDa0QsUUFBUSxFQUFFLEdBQUcsSUFBSSxDQUFDbEQsTUFBTSxDQUFDa0QsUUFBUSxFQUFFO29CQUMvQyxJQUFJLENBQUNsRCxNQUFNLENBQUNrRCxRQUFRLEVBQUUsR0FBRyxJQUFJLENBQUNsRCxNQUFNLENBQUNrRCxRQUFRLEVBQUU7b0JBQy9DQSxTQUFTO29CQUNULElBQUloQixPQUFPLEdBQ1BBLFFBQVE7Z0JBQ2hCO1lBQ1I7WUFDQSxJQUFJLENBQUNsQyxNQUFNLENBQUNrRCxNQUFNLEdBQUdMO1lBQ3JCLElBQUksQ0FBQzdDLE1BQU0sQ0FBQ2tELFFBQVEsRUFBRSxHQUFHeEM7WUFDekIsSUFBSSxDQUFDVixNQUFNLENBQUNrRCxRQUFRLEVBQUUsR0FBR0o7WUFDekIsSUFBSSxDQUFDOUMsTUFBTSxDQUFDa0QsUUFBUSxFQUFFLEdBQUdoQjtRQUM3QjtJQUNKO0lBQ0EsdUJBQXVCO0lBQ3ZCOztJQUVBLEdBQ0FtQixNQUFNbEMsTUFBTSxFQUFFRyxJQUFJLEVBQUVaLEtBQUssRUFBRW9DLEdBQUcsRUFBRTtRQUM1QixJQUFJM0IsU0FBUyxPQUFPLG1CQUFtQixLQUFJO1lBQ3ZDLElBQUksQ0FBQ0osU0FBUyxDQUFDSSxTQUFTLE1BQU0sb0JBQW9CLEtBQUksSUFBSSxDQUFDckIsR0FBRztRQUNsRSxPQUNLLElBQUksQ0FBQ3FCLFNBQVMsT0FBTyxtQkFBbUIsR0FBckIsS0FBNEIsR0FBRztZQUNuRCxJQUFJbUMsWUFBWW5DLFFBQVEsRUFBRVAsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDbEIsQ0FBQztZQUMzQyxJQUFJb0QsTUFBTSxJQUFJLENBQUNoRCxHQUFHLElBQUl3QixRQUFRVixPQUFPMkMsT0FBTyxFQUFFO2dCQUMxQyxJQUFJLENBQUN6RCxHQUFHLEdBQUdnRDtnQkFDWCxJQUFJLENBQUNsQyxPQUFPOEIsU0FBUyxDQUFDWSxXQUFXLEVBQUUscUJBQXFCLE1BQ3BELElBQUksQ0FBQ3pELFNBQVMsR0FBR2lEO1lBQ3pCO1lBQ0EsSUFBSSxDQUFDL0IsU0FBUyxDQUFDdUMsV0FBVzVDO1lBQzFCLElBQUksQ0FBQzhDLFlBQVksQ0FBQ2xDLE1BQU1aO1lBQ3hCLElBQUlZLFFBQVFWLE9BQU8yQyxPQUFPLEVBQ3RCLElBQUksQ0FBQ3ZELE1BQU0sQ0FBQ2dCLElBQUksQ0FBQ00sTUFBTVosT0FBT29DLEtBQUs7UUFDM0MsT0FDSztZQUNELElBQUksQ0FBQ2hELEdBQUcsR0FBR2dEO1lBQ1gsSUFBSSxDQUFDVSxZQUFZLENBQUNsQyxNQUFNWjtZQUN4QixJQUFJWSxRQUFRLElBQUksQ0FBQzVCLENBQUMsQ0FBQ2tCLE1BQU0sQ0FBQzJDLE9BQU8sRUFDN0IsSUFBSSxDQUFDdkQsTUFBTSxDQUFDZ0IsSUFBSSxDQUFDTSxNQUFNWixPQUFPb0MsS0FBSztRQUMzQztJQUNKO0lBQ0Esa0JBQWtCO0lBQ2xCOztJQUVBLEdBQ0FXLE1BQU10QyxNQUFNLEVBQUV1QyxJQUFJLEVBQUVDLFNBQVMsRUFBRUMsT0FBTyxFQUFFO1FBQ3BDLElBQUl6QyxTQUFTLE1BQU0scUJBQXFCLEtBQ3BDLElBQUksQ0FBQ0QsTUFBTSxDQUFDQzthQUVaLElBQUksQ0FBQ2tDLEtBQUssQ0FBQ2xDLFFBQVF1QyxNQUFNQyxXQUFXQztJQUM1QztJQUNBLGdEQUFnRDtJQUNoRDs7SUFFQSxHQUNBQyxRQUFRQyxLQUFLLEVBQUVKLElBQUksRUFBRTtRQUNqQixJQUFJUixRQUFRLElBQUksQ0FBQ3hELENBQUMsQ0FBQ3FFLE1BQU0sQ0FBQzlDLE1BQU0sR0FBRztRQUNuQyxJQUFJaUMsUUFBUSxLQUFLLElBQUksQ0FBQ3hELENBQUMsQ0FBQ3FFLE1BQU0sQ0FBQ2IsTUFBTSxJQUFJWSxPQUFPO1lBQzVDLElBQUksQ0FBQ3BFLENBQUMsQ0FBQ3FFLE1BQU0sQ0FBQy9DLElBQUksQ0FBQzhDO1lBQ25CWjtRQUNKO1FBQ0EsSUFBSXhDLFFBQVEsSUFBSSxDQUFDWixHQUFHO1FBQ3BCLElBQUksQ0FBQ0QsU0FBUyxHQUFHLElBQUksQ0FBQ0MsR0FBRyxHQUFHWSxRQUFRb0QsTUFBTTdDLE1BQU07UUFDaEQsSUFBSSxDQUFDRixTQUFTLENBQUMyQyxNQUFNaEQ7UUFDckIsSUFBSSxDQUFDVixNQUFNLENBQUNnQixJQUFJLENBQUNrQyxPQUFPeEMsT0FBTyxJQUFJLENBQUNiLFNBQVMsRUFBRSxDQUFDLEVBQUUsMkNBQTJDO1FBQzdGLElBQUksSUFBSSxDQUFDSyxVQUFVLEVBQ2YsSUFBSSxDQUFDOEQsYUFBYSxDQUFDLElBQUksQ0FBQzlELFVBQVUsQ0FBQytELE9BQU8sQ0FBQ0MsS0FBSyxDQUFDLElBQUksQ0FBQ2hFLFVBQVUsQ0FBQ1csT0FBTyxFQUFFaUQsT0FBTyxJQUFJLEVBQUUsSUFBSSxDQUFDcEUsQ0FBQyxDQUFDeUUsTUFBTSxDQUFDQyxLQUFLLENBQUMsSUFBSSxDQUFDdEUsR0FBRyxHQUFHZ0UsTUFBTTdDLE1BQU07SUFDMUk7SUFDQSwwREFBMEQ7SUFDMUQsaUVBQWlFO0lBQ2pFLGFBQWE7SUFDYjs7SUFFQSxHQUNBb0QsUUFBUTtRQUNKLElBQUlqRSxTQUFTLElBQUk7UUFDakIsSUFBSWtFLE1BQU1sRSxPQUFPSixNQUFNLENBQUNpQixNQUFNO1FBQzlCLGdFQUFnRTtRQUNoRSwrREFBK0Q7UUFDL0Qsa0VBQWtFO1FBQ2xFLDREQUE0RDtRQUM1RCxNQUFPcUQsTUFBTSxLQUFLbEUsT0FBT0osTUFBTSxDQUFDc0UsTUFBTSxFQUFFLEdBQUdsRSxPQUFPUCxTQUFTLENBQ3ZEeUUsT0FBTztRQUNYLElBQUl0RSxTQUFTSSxPQUFPSixNQUFNLENBQUN1RSxLQUFLLENBQUNELE1BQU12QyxPQUFPM0IsT0FBT0gsVUFBVSxHQUFHcUU7UUFDbEUsdUZBQXVGO1FBQ3ZGLE1BQU9sRSxVQUFVMkIsUUFBUTNCLE9BQU9ILFVBQVUsQ0FDdENHLFNBQVNBLE9BQU9BLE1BQU07UUFDMUIsT0FBTyxJQUFJWixNQUFNLElBQUksQ0FBQ0UsQ0FBQyxFQUFFLElBQUksQ0FBQ0MsS0FBSyxDQUFDNEUsS0FBSyxJQUFJLElBQUksQ0FBQzNFLEtBQUssRUFBRSxJQUFJLENBQUNDLFNBQVMsRUFBRSxJQUFJLENBQUNDLEdBQUcsRUFBRSxJQUFJLENBQUNDLEtBQUssRUFBRUMsUUFBUStCLE1BQU0sSUFBSSxDQUFDN0IsVUFBVSxFQUFFLElBQUksQ0FBQ0MsU0FBUyxFQUFFQztJQUNsSjtJQUNBLG1FQUFtRTtJQUNuRTs7SUFFQSxHQUNBb0UsZ0JBQWdCZCxJQUFJLEVBQUVFLE9BQU8sRUFBRTtRQUMzQixJQUFJYSxTQUFTZixRQUFRLElBQUksQ0FBQ2hFLENBQUMsQ0FBQ2tCLE1BQU0sQ0FBQzJDLE9BQU87UUFDMUMsSUFBSWtCLFFBQ0EsSUFBSSxDQUFDNUMsU0FBUyxDQUFDNkIsTUFBTSxJQUFJLENBQUM1RCxHQUFHLEVBQUU4RCxTQUFTO1FBQzVDLElBQUksQ0FBQy9CLFNBQVMsQ0FBQyxFQUFFLFlBQVksS0FBSSxJQUFJLENBQUMvQixHQUFHLEVBQUU4RCxTQUFTYSxTQUFTLElBQUk7UUFDakUsSUFBSSxDQUFDM0UsR0FBRyxHQUFHLElBQUksQ0FBQ0QsU0FBUyxHQUFHK0Q7UUFDNUIsSUFBSSxDQUFDN0QsS0FBSyxJQUFJLElBQUksa0JBQWtCO0lBQ3hDO0lBQ0E7Ozs7O0lBS0EsR0FDQTJFLFNBQVM3QixJQUFJLEVBQUU7UUFDWCxJQUFLLElBQUk4QixNQUFNLElBQUlDLGVBQWUsSUFBSSxJQUFLO1lBQ3ZDLElBQUl6RCxTQUFTLElBQUksQ0FBQ3pCLENBQUMsQ0FBQ2tCLE1BQU0sQ0FBQ2lFLFNBQVMsQ0FBQ0YsSUFBSS9FLEtBQUssRUFBRSxFQUFFLDRCQUE0QixRQUFPLElBQUksQ0FBQ0YsQ0FBQyxDQUFDa0IsTUFBTSxDQUFDa0UsU0FBUyxDQUFDSCxJQUFJL0UsS0FBSyxFQUFFaUQ7WUFDeEgsSUFBSTFCLFVBQVUsR0FDVixPQUFPO1lBQ1gsSUFBSSxDQUFDQSxTQUFTLE1BQU0scUJBQXFCLEdBQXZCLEtBQThCLEdBQzVDLE9BQU87WUFDWHdELElBQUl6RCxNQUFNLENBQUNDO1FBQ2Y7SUFDSjtJQUNBLGlFQUFpRTtJQUNqRSxzQ0FBc0M7SUFDdEM7O0lBRUEsR0FDQTRELGdCQUFnQnJCLElBQUksRUFBRTtRQUNsQixJQUFJLElBQUksQ0FBQy9ELEtBQUssQ0FBQ3NCLE1BQU0sSUFBSSxJQUFJLCtCQUErQixLQUN4RCxPQUFPLEVBQUU7UUFDYixJQUFJK0QsYUFBYSxJQUFJLENBQUN0RixDQUFDLENBQUNrQixNQUFNLENBQUNvRSxVQUFVLENBQUMsSUFBSSxDQUFDcEYsS0FBSztRQUNwRCxJQUFJb0YsV0FBVy9ELE1BQU0sR0FBRyxFQUFFLG1CQUFtQixPQUFNLEtBQUssSUFBSSxDQUFDdEIsS0FBSyxDQUFDc0IsTUFBTSxJQUFJLElBQUksa0NBQWtDLEtBQUk7WUFDbkgsSUFBSWdFLE9BQU8sRUFBRTtZQUNiLElBQUssSUFBSXpFLElBQUksR0FBRzBFLEdBQUcxRSxJQUFJd0UsV0FBVy9ELE1BQU0sRUFBRVQsS0FBSyxFQUFHO2dCQUM5QyxJQUFJLENBQUMwRSxJQUFJRixVQUFVLENBQUN4RSxJQUFJLEVBQUUsS0FBSyxJQUFJLENBQUNaLEtBQUssSUFBSSxJQUFJLENBQUNGLENBQUMsQ0FBQ2tCLE1BQU0sQ0FBQ2tFLFNBQVMsQ0FBQ0ksR0FBR3hCLE9BQ3BFdUIsS0FBS2pFLElBQUksQ0FBQ2dFLFVBQVUsQ0FBQ3hFLEVBQUUsRUFBRTBFO1lBQ2pDO1lBQ0EsSUFBSSxJQUFJLENBQUN2RixLQUFLLENBQUNzQixNQUFNLEdBQUcsSUFBSSxrQ0FBa0MsS0FDMUQsSUFBSyxJQUFJVCxJQUFJLEdBQUd5RSxLQUFLaEUsTUFBTSxHQUFHLEVBQUUsbUJBQW1CLE9BQU0sS0FBS1QsSUFBSXdFLFdBQVcvRCxNQUFNLEVBQUVULEtBQUssRUFBRztnQkFDekYsSUFBSTBFLElBQUlGLFVBQVUsQ0FBQ3hFLElBQUksRUFBRTtnQkFDekIsSUFBSSxDQUFDeUUsS0FBS0UsSUFBSSxDQUFDLENBQUNDLEdBQUc1RSxJQUFNLElBQUssS0FBTTRFLEtBQUtGLElBQ3JDRCxLQUFLakUsSUFBSSxDQUFDZ0UsVUFBVSxDQUFDeEUsRUFBRSxFQUFFMEU7WUFDakM7WUFDSkYsYUFBYUM7UUFDakI7UUFDQSxJQUFJSSxTQUFTLEVBQUU7UUFDZixJQUFLLElBQUk3RSxJQUFJLEdBQUdBLElBQUl3RSxXQUFXL0QsTUFBTSxJQUFJb0UsT0FBT3BFLE1BQU0sR0FBRyxFQUFFLG1CQUFtQixLQUFJVCxLQUFLLEVBQUc7WUFDdEYsSUFBSTBFLElBQUlGLFVBQVUsQ0FBQ3hFLElBQUksRUFBRTtZQUN6QixJQUFJMEUsS0FBSyxJQUFJLENBQUN0RixLQUFLLEVBQ2Y7WUFDSixJQUFJRCxRQUFRLElBQUksQ0FBQzBFLEtBQUs7WUFDdEIxRSxNQUFNb0IsU0FBUyxDQUFDbUUsR0FBRyxJQUFJLENBQUNwRixHQUFHO1lBQzNCSCxNQUFNa0MsU0FBUyxDQUFDLEVBQUUsWUFBWSxLQUFJbEMsTUFBTUcsR0FBRyxFQUFFSCxNQUFNRyxHQUFHLEVBQUUsR0FBRztZQUMzREgsTUFBTTZELFlBQVksQ0FBQ3dCLFVBQVUsQ0FBQ3hFLEVBQUUsRUFBRSxJQUFJLENBQUNWLEdBQUc7WUFDMUNILE1BQU1FLFNBQVMsR0FBRyxJQUFJLENBQUNDLEdBQUc7WUFDMUJILE1BQU1JLEtBQUssSUFBSSxJQUFJLGtCQUFrQjtZQUNyQ3NGLE9BQU9yRSxJQUFJLENBQUNyQjtRQUNoQjtRQUNBLE9BQU8wRjtJQUNYO0lBQ0EsMERBQTBEO0lBQzFELFdBQVc7SUFDWDs7SUFFQSxHQUNBQyxjQUFjO1FBQ1YsSUFBSSxFQUFFMUUsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDbEIsQ0FBQztRQUN2QixJQUFJd0IsU0FBU04sT0FBT2lFLFNBQVMsQ0FBQyxJQUFJLENBQUNqRixLQUFLLEVBQUUsRUFBRSwyQkFBMkI7UUFDdkUsSUFBSSxDQUFDc0IsU0FBUyxNQUFNLHFCQUFxQixHQUF2QixLQUE4QixHQUM1QyxPQUFPO1FBQ1gsSUFBSSxDQUFDTixPQUFPMkUsV0FBVyxDQUFDLElBQUksQ0FBQzNGLEtBQUssRUFBRXNCLFNBQVM7WUFDekMsSUFBSUcsUUFBUUgsVUFBVSxHQUFHLDJCQUEyQixLQUFJMkIsT0FBTzNCLFNBQVMsTUFBTSxvQkFBb0I7WUFDbEcsSUFBSXNFLFNBQVMsSUFBSSxDQUFDN0YsS0FBSyxDQUFDc0IsTUFBTSxHQUFHSSxRQUFRO1lBQ3pDLElBQUltRSxTQUFTLEtBQUs1RSxPQUFPZSxPQUFPLENBQUMsSUFBSSxDQUFDaEMsS0FBSyxDQUFDNkYsT0FBTyxFQUFFM0MsTUFBTSxTQUFTLEdBQUc7Z0JBQ25FLElBQUk0QyxTQUFTLElBQUksQ0FBQ0MsbUJBQW1CO2dCQUNyQyxJQUFJRCxVQUFVLE1BQ1YsT0FBTztnQkFDWHZFLFNBQVN1RTtZQUNiO1lBQ0EsSUFBSSxDQUFDNUQsU0FBUyxDQUFDLEVBQUUsWUFBWSxLQUFJLElBQUksQ0FBQy9CLEdBQUcsRUFBRSxJQUFJLENBQUNBLEdBQUcsRUFBRSxHQUFHO1lBQ3hELElBQUksQ0FBQ0MsS0FBSyxJQUFJLElBQUksa0JBQWtCO1FBQ3hDO1FBQ0EsSUFBSSxDQUFDRixTQUFTLEdBQUcsSUFBSSxDQUFDQyxHQUFHO1FBQ3pCLElBQUksQ0FBQ29CLE1BQU0sQ0FBQ0E7UUFDWixPQUFPO0lBQ1g7SUFDQTs7OztJQUlBLEdBQ0F3RSxzQkFBc0I7UUFDbEIsSUFBSSxFQUFFOUUsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDbEIsQ0FBQyxFQUFFaUcsT0FBTyxFQUFFO1FBQ2xDLElBQUlDLFVBQVUsQ0FBQ2hHLE9BQU95QjtZQUNsQixJQUFJc0UsS0FBS0UsUUFBUSxDQUFDakcsUUFDZDtZQUNKK0YsS0FBSzNFLElBQUksQ0FBQ3BCO1lBQ1YsT0FBT2dCLE9BQU9rRixVQUFVLENBQUNsRyxPQUFPLENBQUN1QjtnQkFDN0IsSUFBSUEsU0FBVSxRQUFPLG1CQUFtQixNQUFLLE9BQU8sbUJBQW1CLEdBQXJCO3FCQUM3QyxJQUFJQSxTQUFTLE1BQU0scUJBQXFCLEtBQUk7b0JBQzdDLElBQUk0RSxTQUFTLENBQUM1RSxVQUFVLEdBQUcsMkJBQTJCLEdBQTdCLElBQW1DRTtvQkFDNUQsSUFBSTBFLFNBQVMsR0FBRzt3QkFDWixJQUFJbEQsT0FBTzFCLFNBQVMsTUFBTSxvQkFBb0IsS0FBSXFFLFNBQVMsSUFBSSxDQUFDN0YsS0FBSyxDQUFDc0IsTUFBTSxHQUFHOEUsU0FBUzt3QkFDeEYsSUFBSVAsVUFBVSxLQUFLNUUsT0FBT2UsT0FBTyxDQUFDLElBQUksQ0FBQ2hDLEtBQUssQ0FBQzZGLE9BQU8sRUFBRTNDLE1BQU0sVUFBVSxHQUNsRSxPQUFPLFVBQVcsR0FBRywyQkFBMkIsTUFBTSxNQUFNLHFCQUFxQixNQUFLQTtvQkFDOUY7Z0JBQ0osT0FDSztvQkFDRCxJQUFJbUQsUUFBUUosUUFBUXpFLFFBQVFFLFFBQVE7b0JBQ3BDLElBQUkyRSxTQUFTLE1BQ1QsT0FBT0E7Z0JBQ2Y7WUFDSjtRQUNKO1FBQ0EsT0FBT0osUUFBUSxJQUFJLENBQUNoRyxLQUFLLEVBQUU7SUFDL0I7SUFDQTs7SUFFQSxHQUNBcUcsV0FBVztRQUNQLE1BQU8sQ0FBQyxJQUFJLENBQUN2RyxDQUFDLENBQUNrQixNQUFNLENBQUM4QixTQUFTLENBQUMsSUFBSSxDQUFDOUMsS0FBSyxFQUFFLEVBQUUsdUJBQXVCLEtBQUs7WUFDdEUsSUFBSSxDQUFDLElBQUksQ0FBQzBGLFdBQVcsSUFBSTtnQkFDckIsSUFBSSxDQUFDekQsU0FBUyxDQUFDLEVBQUUsWUFBWSxLQUFJLElBQUksQ0FBQy9CLEdBQUcsRUFBRSxJQUFJLENBQUNBLEdBQUcsRUFBRSxHQUFHO2dCQUN4RDtZQUNKO1FBQ0o7UUFDQSxPQUFPLElBQUk7SUFDZjtJQUNBOzs7O0lBSUEsR0FDQSxJQUFJb0csVUFBVTtRQUNWLElBQUksSUFBSSxDQUFDdkcsS0FBSyxDQUFDc0IsTUFBTSxJQUFJLEdBQ3JCLE9BQU87UUFDWCxJQUFJLEVBQUVMLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQ2xCLENBQUM7UUFDdkIsT0FBT2tCLE9BQU91RixJQUFJLENBQUN2RixPQUFPaUUsU0FBUyxDQUFDLElBQUksQ0FBQ2pGLEtBQUssRUFBRSxFQUFFLHNCQUFzQixLQUFJLElBQUksTUFBTSxXQUFXLE9BQzdGLENBQUNnQixPQUFPaUUsU0FBUyxDQUFDLElBQUksQ0FBQ2pGLEtBQUssRUFBRSxFQUFFLDRCQUE0QjtJQUNwRTtJQUNBOzs7O0lBSUEsR0FDQXdHLFVBQVU7UUFDTixJQUFJLENBQUN2RSxTQUFTLENBQUMsRUFBRSxZQUFZLEtBQUksSUFBSSxDQUFDL0IsR0FBRyxFQUFFLElBQUksQ0FBQ0EsR0FBRyxFQUFFLEdBQUc7UUFDeEQsSUFBSSxDQUFDRixLQUFLLEdBQUcsSUFBSSxDQUFDRCxLQUFLLENBQUMsRUFBRTtRQUMxQixJQUFJLENBQUNBLEtBQUssQ0FBQ3NCLE1BQU0sR0FBRztJQUN4QjtJQUNBOztJQUVBLEdBQ0FvRixVQUFVQyxLQUFLLEVBQUU7UUFDYixJQUFJLElBQUksQ0FBQzFHLEtBQUssSUFBSTBHLE1BQU0xRyxLQUFLLElBQUksSUFBSSxDQUFDRCxLQUFLLENBQUNzQixNQUFNLElBQUlxRixNQUFNM0csS0FBSyxDQUFDc0IsTUFBTSxFQUNwRSxPQUFPO1FBQ1gsSUFBSyxJQUFJVCxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDYixLQUFLLENBQUNzQixNQUFNLEVBQUVULEtBQUssRUFDeEMsSUFBSSxJQUFJLENBQUNiLEtBQUssQ0FBQ2EsRUFBRSxJQUFJOEYsTUFBTTNHLEtBQUssQ0FBQ2EsRUFBRSxFQUMvQixPQUFPO1FBQ2YsT0FBTztJQUNYO0lBQ0E7O0lBRUEsR0FDQSxJQUFJSSxTQUFTO1FBQUUsT0FBTyxJQUFJLENBQUNsQixDQUFDLENBQUNrQixNQUFNO0lBQUU7SUFDckM7OztJQUdBLEdBQ0EyRixlQUFlQyxTQUFTLEVBQUU7UUFBRSxPQUFPLElBQUksQ0FBQzlHLENBQUMsQ0FBQ2tCLE1BQU0sQ0FBQzZGLE9BQU8sQ0FBQ0MsS0FBSyxDQUFDRixVQUFVO0lBQUU7SUFDM0VoRCxhQUFhWCxJQUFJLEVBQUVuQyxLQUFLLEVBQUU7UUFDdEIsSUFBSSxJQUFJLENBQUNSLFVBQVUsRUFDZixJQUFJLENBQUM4RCxhQUFhLENBQUMsSUFBSSxDQUFDOUQsVUFBVSxDQUFDK0QsT0FBTyxDQUFDWixLQUFLLENBQUMsSUFBSSxDQUFDbkQsVUFBVSxDQUFDVyxPQUFPLEVBQUVnQyxNQUFNLElBQUksRUFBRSxJQUFJLENBQUNuRCxDQUFDLENBQUN5RSxNQUFNLENBQUNDLEtBQUssQ0FBQzFEO0lBQ2xIO0lBQ0FvQixjQUFjZSxJQUFJLEVBQUVuQyxLQUFLLEVBQUU7UUFDdkIsSUFBSSxJQUFJLENBQUNSLFVBQVUsRUFDZixJQUFJLENBQUM4RCxhQUFhLENBQUMsSUFBSSxDQUFDOUQsVUFBVSxDQUFDK0QsT0FBTyxDQUFDL0MsTUFBTSxDQUFDLElBQUksQ0FBQ2hCLFVBQVUsQ0FBQ1csT0FBTyxFQUFFZ0MsTUFBTSxJQUFJLEVBQUUsSUFBSSxDQUFDbkQsQ0FBQyxDQUFDeUUsTUFBTSxDQUFDQyxLQUFLLENBQUMxRDtJQUNuSDtJQUNBOztJQUVBLEdBQ0FpRyxjQUFjO1FBQ1YsSUFBSUMsT0FBTyxJQUFJLENBQUM1RyxNQUFNLENBQUNpQixNQUFNLEdBQUc7UUFDaEMsSUFBSTJGLE9BQU8sS0FBSyxJQUFJLENBQUM1RyxNQUFNLENBQUM0RyxLQUFLLElBQUksQ0FBQyxHQUNsQyxJQUFJLENBQUM1RyxNQUFNLENBQUNnQixJQUFJLENBQUMsSUFBSSxDQUFDZCxVQUFVLENBQUMyRyxJQUFJLEVBQUUsSUFBSSxDQUFDL0csR0FBRyxFQUFFLElBQUksQ0FBQ0EsR0FBRyxFQUFFLENBQUM7SUFDcEU7SUFDQTs7SUFFQSxHQUNBZ0gsZ0JBQWdCO1FBQ1osSUFBSUYsT0FBTyxJQUFJLENBQUM1RyxNQUFNLENBQUNpQixNQUFNLEdBQUc7UUFDaEMsSUFBSTJGLE9BQU8sS0FBSyxJQUFJLENBQUM1RyxNQUFNLENBQUM0RyxLQUFLLElBQUksQ0FBQyxHQUNsQyxJQUFJLENBQUM1RyxNQUFNLENBQUNnQixJQUFJLENBQUMsSUFBSSxDQUFDYixTQUFTLEVBQUUsSUFBSSxDQUFDTCxHQUFHLEVBQUUsSUFBSSxDQUFDQSxHQUFHLEVBQUUsQ0FBQztJQUM5RDtJQUNBa0UsY0FBY25ELE9BQU8sRUFBRTtRQUNuQixJQUFJQSxXQUFXLElBQUksQ0FBQ1gsVUFBVSxDQUFDVyxPQUFPLEVBQUU7WUFDcEMsSUFBSWtHLFFBQVEsSUFBSWpHLGFBQWEsSUFBSSxDQUFDWixVQUFVLENBQUMrRCxPQUFPLEVBQUVwRDtZQUN0RCxJQUFJa0csTUFBTUYsSUFBSSxJQUFJLElBQUksQ0FBQzNHLFVBQVUsQ0FBQzJHLElBQUksRUFDbEMsSUFBSSxDQUFDRixXQUFXO1lBQ3BCLElBQUksQ0FBQ3pHLFVBQVUsR0FBRzZHO1FBQ3RCO0lBQ0o7SUFDQTs7SUFFQSxHQUNBdkYsYUFBYXJCLFNBQVMsRUFBRTtRQUNwQixJQUFJQSxZQUFZLElBQUksQ0FBQ0EsU0FBUyxFQUFFO1lBQzVCLElBQUksQ0FBQzJHLGFBQWE7WUFDbEIsSUFBSSxDQUFDM0csU0FBUyxHQUFHQTtRQUNyQjtJQUNKO0lBQ0E7O0lBRUEsR0FDQTZHLFFBQVE7UUFDSixJQUFJLElBQUksQ0FBQzlHLFVBQVUsSUFBSSxJQUFJLENBQUNBLFVBQVUsQ0FBQytELE9BQU8sQ0FBQ2dELE1BQU0sRUFDakQsSUFBSSxDQUFDTixXQUFXO1FBQ3BCLElBQUksSUFBSSxDQUFDeEcsU0FBUyxHQUFHLEdBQ2pCLElBQUksQ0FBQzJHLGFBQWE7SUFDMUI7QUFDSjtBQUNBLE1BQU1oRztJQUNGckIsWUFBWXdFLE9BQU8sRUFBRXBELE9BQU8sQ0FBRTtRQUMxQixJQUFJLENBQUNvRCxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDcEQsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ2dHLElBQUksR0FBRzVDLFFBQVFnRCxNQUFNLEdBQUdoRCxRQUFRNEMsSUFBSSxDQUFDaEcsV0FBVztJQUN6RDtBQUNKO0FBQ0EscUVBQXFFO0FBQ3JFLGtCQUFrQjtBQUNsQixNQUFNK0Q7SUFDRm5GLFlBQVlpQixLQUFLLENBQUU7UUFDZixJQUFJLENBQUNBLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNkLEtBQUssR0FBR2MsTUFBTWQsS0FBSztRQUN4QixJQUFJLENBQUNELEtBQUssR0FBR2UsTUFBTWYsS0FBSztRQUN4QixJQUFJLENBQUNvQyxJQUFJLEdBQUcsSUFBSSxDQUFDcEMsS0FBSyxDQUFDc0IsTUFBTTtJQUNqQztJQUNBQyxPQUFPQyxNQUFNLEVBQUU7UUFDWCxJQUFJMEIsT0FBTzFCLFNBQVMsTUFBTSxvQkFBb0IsS0FBSUUsUUFBUUYsVUFBVSxHQUFHLDJCQUEyQjtRQUNsRyxJQUFJRSxTQUFTLEdBQUc7WUFDWixJQUFJLElBQUksQ0FBQzFCLEtBQUssSUFBSSxJQUFJLENBQUNlLEtBQUssQ0FBQ2YsS0FBSyxFQUM5QixJQUFJLENBQUNBLEtBQUssR0FBRyxJQUFJLENBQUNBLEtBQUssQ0FBQzRFLEtBQUs7WUFDakMsSUFBSSxDQUFDNUUsS0FBSyxDQUFDcUIsSUFBSSxDQUFDLElBQUksQ0FBQ3BCLEtBQUssRUFBRSxHQUFHO1lBQy9CLElBQUksQ0FBQ21DLElBQUksSUFBSTtRQUNqQixPQUNLO1lBQ0QsSUFBSSxDQUFDQSxJQUFJLElBQUksQ0FBQ1YsUUFBUSxLQUFLO1FBQy9CO1FBQ0EsSUFBSTZGLE9BQU8sSUFBSSxDQUFDeEcsS0FBSyxDQUFDaEIsQ0FBQyxDQUFDa0IsTUFBTSxDQUFDZSxPQUFPLENBQUMsSUFBSSxDQUFDaEMsS0FBSyxDQUFDLElBQUksQ0FBQ29DLElBQUksR0FBRyxFQUFFLEVBQUVjLE1BQU07UUFDeEUsSUFBSSxDQUFDakQsS0FBSyxHQUFHc0g7SUFDakI7QUFDSjtBQUNBLG9FQUFvRTtBQUNwRSx3REFBd0Q7QUFDeEQsTUFBTUM7SUFDRjFILFlBQVlFLEtBQUssRUFBRUcsR0FBRyxFQUFFb0QsS0FBSyxDQUFFO1FBQzNCLElBQUksQ0FBQ3ZELEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNHLEdBQUcsR0FBR0E7UUFDWCxJQUFJLENBQUNvRCxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDbEQsTUFBTSxHQUFHTCxNQUFNSyxNQUFNO1FBQzFCLElBQUksSUFBSSxDQUFDa0QsS0FBSyxJQUFJLEdBQ2QsSUFBSSxDQUFDa0UsU0FBUztJQUN0QjtJQUNBLE9BQU9DLE9BQU8xSCxLQUFLLEVBQUVHLE1BQU1ILE1BQU1NLFVBQVUsR0FBR04sTUFBTUssTUFBTSxDQUFDaUIsTUFBTSxFQUFFO1FBQy9ELE9BQU8sSUFBSWtHLGtCQUFrQnhILE9BQU9HLEtBQUtBLE1BQU1ILE1BQU1NLFVBQVU7SUFDbkU7SUFDQW1ILFlBQVk7UUFDUixJQUFJMUQsT0FBTyxJQUFJLENBQUMvRCxLQUFLLENBQUNTLE1BQU07UUFDNUIsSUFBSXNELFFBQVEsTUFBTTtZQUNkLElBQUksQ0FBQ1IsS0FBSyxHQUFHLElBQUksQ0FBQ3ZELEtBQUssQ0FBQ00sVUFBVSxHQUFHeUQsS0FBS3pELFVBQVU7WUFDcEQsSUFBSSxDQUFDTixLQUFLLEdBQUcrRDtZQUNiLElBQUksQ0FBQzFELE1BQU0sR0FBRzBELEtBQUsxRCxNQUFNO1FBQzdCO0lBQ0o7SUFDQSxJQUFJc0gsS0FBSztRQUFFLE9BQU8sSUFBSSxDQUFDdEgsTUFBTSxDQUFDLElBQUksQ0FBQ2tELEtBQUssR0FBRyxFQUFFO0lBQUU7SUFDL0MsSUFBSXhDLFFBQVE7UUFBRSxPQUFPLElBQUksQ0FBQ1YsTUFBTSxDQUFDLElBQUksQ0FBQ2tELEtBQUssR0FBRyxFQUFFO0lBQUU7SUFDbEQsSUFBSUosTUFBTTtRQUFFLE9BQU8sSUFBSSxDQUFDOUMsTUFBTSxDQUFDLElBQUksQ0FBQ2tELEtBQUssR0FBRyxFQUFFO0lBQUU7SUFDaEQsSUFBSWhCLE9BQU87UUFBRSxPQUFPLElBQUksQ0FBQ2xDLE1BQU0sQ0FBQyxJQUFJLENBQUNrRCxLQUFLLEdBQUcsRUFBRTtJQUFFO0lBQ2pEUSxPQUFPO1FBQ0gsSUFBSSxDQUFDUixLQUFLLElBQUk7UUFDZCxJQUFJLENBQUNwRCxHQUFHLElBQUk7UUFDWixJQUFJLElBQUksQ0FBQ29ELEtBQUssSUFBSSxHQUNkLElBQUksQ0FBQ2tFLFNBQVM7SUFDdEI7SUFDQUcsT0FBTztRQUNILE9BQU8sSUFBSUosa0JBQWtCLElBQUksQ0FBQ3hILEtBQUssRUFBRSxJQUFJLENBQUNHLEdBQUcsRUFBRSxJQUFJLENBQUNvRCxLQUFLO0lBQ2pFO0FBQ0o7QUFFQSxvRUFBb0U7QUFDcEUsWUFBWTtBQUNaLFNBQVNzRSxZQUFZQyxLQUFLLEVBQUVDLE9BQU9DLFdBQVc7SUFDMUMsSUFBSSxPQUFPRixTQUFTLFVBQ2hCLE9BQU9BO0lBQ1gsSUFBSUcsUUFBUTtJQUNaLElBQUssSUFBSTlILE1BQU0sR0FBRytILE1BQU0sR0FBRy9ILE1BQU0ySCxNQUFNeEcsTUFBTSxFQUFHO1FBQzVDLElBQUk2QyxRQUFRO1FBQ1osT0FBUztZQUNMLElBQUlKLE9BQU8rRCxNQUFNSyxVQUFVLENBQUNoSSxRQUFRaUksT0FBTztZQUMzQyxJQUFJckUsUUFBUSxJQUFJLHFCQUFxQixLQUFJO2dCQUNyQ0ksUUFBUSxNQUFNLGlCQUFpQjtnQkFDL0I7WUFDSjtZQUNBLElBQUlKLFFBQVEsR0FBRyxlQUFlLEtBQzFCQTtZQUNKLElBQUlBLFFBQVEsR0FBRyxlQUFlLEtBQzFCQTtZQUNKLElBQUlzRSxRQUFRdEUsT0FBTyxHQUFHLGdCQUFnQjtZQUN0QyxJQUFJc0UsU0FBUyxHQUFHLGVBQWUsS0FBSTtnQkFDL0JBLFNBQVMsR0FBRyxlQUFlO2dCQUMzQkQsT0FBTztZQUNYO1lBQ0FqRSxTQUFTa0U7WUFDVCxJQUFJRCxNQUNBO1lBQ0pqRSxTQUFTLEdBQUcsZUFBZTtRQUMvQjtRQUNBLElBQUk4RCxPQUNBQSxLQUFLLENBQUNDLE1BQU0sR0FBRy9EO2FBRWY4RCxRQUFRLElBQUlGLEtBQUs1RDtJQUN6QjtJQUNBLE9BQU84RDtBQUNYO0FBRUEsTUFBTUs7SUFDRnhJLGFBQWM7UUFDVixJQUFJLENBQUNpQixLQUFLLEdBQUcsQ0FBQztRQUNkLElBQUksQ0FBQ29ELEtBQUssR0FBRyxDQUFDO1FBQ2QsSUFBSSxDQUFDaEIsR0FBRyxHQUFHLENBQUM7UUFDWixJQUFJLENBQUNvRixRQUFRLEdBQUcsQ0FBQztRQUNqQixJQUFJLENBQUMvSCxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDZ0ksSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDdEgsT0FBTyxHQUFHO0lBQ25CO0FBQ0o7QUFDQSxNQUFNdUgsWUFBWSxJQUFJSDtBQUN0Qjs7Ozs7QUFLQSxHQUNBLE1BQU1JO0lBQ0Y7O0lBRUEsR0FDQTVJLFlBQ0E7O0lBRUEsR0FDQWdJLEtBQUssRUFDTDs7SUFFQSxHQUNBekYsTUFBTSxDQUFFO1FBQ0osSUFBSSxDQUFDeUYsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ3pGLE1BQU0sR0FBR0E7UUFDZDs7UUFFQSxHQUNBLElBQUksQ0FBQ3NHLEtBQUssR0FBRztRQUNiOztRQUVBLEdBQ0EsSUFBSSxDQUFDQyxRQUFRLEdBQUc7UUFDaEI7O1FBRUEsR0FDQSxJQUFJLENBQUNDLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ0MsU0FBUyxHQUFHO1FBQ2pCOzs7UUFHQSxHQUNBLElBQUksQ0FBQy9FLElBQUksR0FBRyxDQUFDO1FBQ2I7O1FBRUEsR0FDQSxJQUFJLENBQUNnRixLQUFLLEdBQUdOO1FBQ2IsSUFBSSxDQUFDTyxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDN0ksR0FBRyxHQUFHLElBQUksQ0FBQzhJLFFBQVEsR0FBRzVHLE1BQU0sQ0FBQyxFQUFFLENBQUNDLElBQUk7UUFDekMsSUFBSSxDQUFDNEcsS0FBSyxHQUFHN0csTUFBTSxDQUFDLEVBQUU7UUFDdEIsSUFBSSxDQUFDYyxHQUFHLEdBQUdkLE1BQU0sQ0FBQ0EsT0FBT2YsTUFBTSxHQUFHLEVBQUUsQ0FBQzZILEVBQUU7UUFDdkMsSUFBSSxDQUFDQyxRQUFRO0lBQ2pCO0lBQ0E7O0lBRUEsR0FDQUMsY0FBY0MsTUFBTSxFQUFFQyxLQUFLLEVBQUU7UUFDekIsSUFBSUwsUUFBUSxJQUFJLENBQUNBLEtBQUssRUFBRTNGLFFBQVEsSUFBSSxDQUFDeUYsVUFBVTtRQUMvQyxJQUFJN0ksTUFBTSxJQUFJLENBQUNBLEdBQUcsR0FBR21KO1FBQ3JCLE1BQU9uSixNQUFNK0ksTUFBTTVHLElBQUksQ0FBRTtZQUNyQixJQUFJLENBQUNpQixPQUNELE9BQU87WUFDWCxJQUFJUSxPQUFPLElBQUksQ0FBQzFCLE1BQU0sQ0FBQyxFQUFFa0IsTUFBTTtZQUMvQnBELE9BQU8rSSxNQUFNNUcsSUFBSSxHQUFHeUIsS0FBS29GLEVBQUU7WUFDM0JELFFBQVFuRjtRQUNaO1FBQ0EsTUFBT3dGLFFBQVEsSUFBSXBKLE1BQU0rSSxNQUFNQyxFQUFFLEdBQUdoSixPQUFPK0ksTUFBTUMsRUFBRSxDQUFFO1lBQ2pELElBQUk1RixTQUFTLElBQUksQ0FBQ2xCLE1BQU0sQ0FBQ2YsTUFBTSxHQUFHLEdBQzlCLE9BQU87WUFDWCxJQUFJeUMsT0FBTyxJQUFJLENBQUMxQixNQUFNLENBQUMsRUFBRWtCLE1BQU07WUFDL0JwRCxPQUFPNEQsS0FBS3pCLElBQUksR0FBRzRHLE1BQU1DLEVBQUU7WUFDM0JELFFBQVFuRjtRQUNaO1FBQ0EsT0FBTzVEO0lBQ1g7SUFDQTs7SUFFQSxHQUNBcUosUUFBUXJKLEdBQUcsRUFBRTtRQUNULElBQUlBLE9BQU8sSUFBSSxDQUFDK0ksS0FBSyxDQUFDNUcsSUFBSSxJQUFJbkMsTUFBTSxJQUFJLENBQUMrSSxLQUFLLENBQUNDLEVBQUUsRUFDN0MsT0FBT2hKO1FBQ1gsS0FBSyxJQUFJK0ksU0FBUyxJQUFJLENBQUM3RyxNQUFNLENBQ3pCLElBQUk2RyxNQUFNQyxFQUFFLEdBQUdoSixLQUNYLE9BQU9zSixLQUFLQyxHQUFHLENBQUN2SixLQUFLK0ksTUFBTTVHLElBQUk7UUFDdkMsT0FBTyxJQUFJLENBQUNhLEdBQUc7SUFDbkI7SUFDQTs7Ozs7Ozs7OztJQVVBLEdBQ0F3RyxLQUFLTCxNQUFNLEVBQUU7UUFDVCxJQUFJTSxNQUFNLElBQUksQ0FBQ2hCLFFBQVEsR0FBR1UsUUFBUW5KLEtBQUt1RjtRQUN2QyxJQUFJa0UsT0FBTyxLQUFLQSxNQUFNLElBQUksQ0FBQ2pCLEtBQUssQ0FBQ3JILE1BQU0sRUFBRTtZQUNyQ25CLE1BQU0sSUFBSSxDQUFDQSxHQUFHLEdBQUdtSjtZQUNqQjVELFNBQVMsSUFBSSxDQUFDaUQsS0FBSyxDQUFDUixVQUFVLENBQUN5QjtRQUNuQyxPQUNLO1lBQ0QsSUFBSUMsV0FBVyxJQUFJLENBQUNSLGFBQWEsQ0FBQ0MsUUFBUTtZQUMxQyxJQUFJTyxZQUFZLE1BQ1osT0FBTyxDQUFDO1lBQ1oxSixNQUFNMEo7WUFDTixJQUFJMUosT0FBTyxJQUFJLENBQUMySSxTQUFTLElBQUkzSSxNQUFNLElBQUksQ0FBQzJJLFNBQVMsR0FBRyxJQUFJLENBQUNELE1BQU0sQ0FBQ3ZILE1BQU0sRUFBRTtnQkFDcEVvRSxTQUFTLElBQUksQ0FBQ21ELE1BQU0sQ0FBQ1YsVUFBVSxDQUFDaEksTUFBTSxJQUFJLENBQUMySSxTQUFTO1lBQ3hELE9BQ0s7Z0JBQ0QsSUFBSWpJLElBQUksSUFBSSxDQUFDbUksVUFBVSxFQUFFRSxRQUFRLElBQUksQ0FBQ0EsS0FBSztnQkFDM0MsTUFBT0EsTUFBTUMsRUFBRSxJQUFJaEosSUFDZitJLFFBQVEsSUFBSSxDQUFDN0csTUFBTSxDQUFDLEVBQUV4QixFQUFFO2dCQUM1QixJQUFJLENBQUNnSSxNQUFNLEdBQUcsSUFBSSxDQUFDZixLQUFLLENBQUNhLEtBQUssQ0FBQyxJQUFJLENBQUNHLFNBQVMsR0FBRzNJO2dCQUNoRCxJQUFJQSxNQUFNLElBQUksQ0FBQzBJLE1BQU0sQ0FBQ3ZILE1BQU0sR0FBRzRILE1BQU1DLEVBQUUsRUFDbkMsSUFBSSxDQUFDTixNQUFNLEdBQUcsSUFBSSxDQUFDQSxNQUFNLENBQUNqRSxLQUFLLENBQUMsR0FBR3NFLE1BQU1DLEVBQUUsR0FBR2hKO2dCQUNsRHVGLFNBQVMsSUFBSSxDQUFDbUQsTUFBTSxDQUFDVixVQUFVLENBQUM7WUFDcEM7UUFDSjtRQUNBLElBQUloSSxPQUFPLElBQUksQ0FBQzRJLEtBQUssQ0FBQ3ZJLFNBQVMsRUFDM0IsSUFBSSxDQUFDdUksS0FBSyxDQUFDdkksU0FBUyxHQUFHTCxNQUFNO1FBQ2pDLE9BQU91RjtJQUNYO0lBQ0E7Ozs7SUFJQSxHQUNBb0UsWUFBWWYsS0FBSyxFQUFFZ0IsWUFBWSxDQUFDLEVBQUU7UUFDOUIsSUFBSTVHLE1BQU00RyxZQUFZLElBQUksQ0FBQ1YsYUFBYSxDQUFDVSxXQUFXLENBQUMsS0FBSyxJQUFJLENBQUM1SixHQUFHO1FBQ2xFLElBQUlnRCxPQUFPLFFBQVFBLE1BQU0sSUFBSSxDQUFDNEYsS0FBSyxDQUFDaEksS0FBSyxFQUNyQyxNQUFNLElBQUlpSixXQUFXO1FBQ3pCLElBQUksQ0FBQ2pCLEtBQUssQ0FBQzVFLEtBQUssR0FBRzRFO1FBQ25CLElBQUksQ0FBQ0EsS0FBSyxDQUFDNUYsR0FBRyxHQUFHQTtJQUNyQjtJQUNBOztJQUVBLEdBQ0E4RyxjQUFjbEIsS0FBSyxFQUFFbUIsTUFBTSxFQUFFO1FBQ3pCLElBQUksQ0FBQ25CLEtBQUssQ0FBQzVFLEtBQUssR0FBRzRFO1FBQ25CLElBQUksQ0FBQ0EsS0FBSyxDQUFDNUYsR0FBRyxHQUFHK0c7SUFDckI7SUFDQUMsV0FBVztRQUNQLElBQUksSUFBSSxDQUFDaEssR0FBRyxJQUFJLElBQUksQ0FBQzJJLFNBQVMsSUFBSSxJQUFJLENBQUMzSSxHQUFHLEdBQUcsSUFBSSxDQUFDMkksU0FBUyxHQUFHLElBQUksQ0FBQ0QsTUFBTSxDQUFDdkgsTUFBTSxFQUFFO1lBQzlFLElBQUksRUFBRXFILEtBQUssRUFBRU0sUUFBUSxFQUFFLEdBQUcsSUFBSTtZQUM5QixJQUFJLENBQUNOLEtBQUssR0FBRyxJQUFJLENBQUNFLE1BQU07WUFDeEIsSUFBSSxDQUFDSSxRQUFRLEdBQUcsSUFBSSxDQUFDSCxTQUFTO1lBQzlCLElBQUksQ0FBQ0QsTUFBTSxHQUFHRjtZQUNkLElBQUksQ0FBQ0csU0FBUyxHQUFHRztZQUNqQixJQUFJLENBQUNMLFFBQVEsR0FBRyxJQUFJLENBQUN6SSxHQUFHLEdBQUcsSUFBSSxDQUFDOEksUUFBUTtRQUM1QyxPQUNLO1lBQ0QsSUFBSSxDQUFDSixNQUFNLEdBQUcsSUFBSSxDQUFDRixLQUFLO1lBQ3hCLElBQUksQ0FBQ0csU0FBUyxHQUFHLElBQUksQ0FBQ0csUUFBUTtZQUM5QixJQUFJbUIsWUFBWSxJQUFJLENBQUN0QyxLQUFLLENBQUNhLEtBQUssQ0FBQyxJQUFJLENBQUN4SSxHQUFHO1lBQ3pDLElBQUlnRCxNQUFNLElBQUksQ0FBQ2hELEdBQUcsR0FBR2lLLFVBQVU5SSxNQUFNO1lBQ3JDLElBQUksQ0FBQ3FILEtBQUssR0FBR3hGLE1BQU0sSUFBSSxDQUFDK0YsS0FBSyxDQUFDQyxFQUFFLEdBQUdpQixVQUFVeEYsS0FBSyxDQUFDLEdBQUcsSUFBSSxDQUFDc0UsS0FBSyxDQUFDQyxFQUFFLEdBQUcsSUFBSSxDQUFDaEosR0FBRyxJQUFJaUs7WUFDbEYsSUFBSSxDQUFDbkIsUUFBUSxHQUFHLElBQUksQ0FBQzlJLEdBQUc7WUFDeEIsSUFBSSxDQUFDeUksUUFBUSxHQUFHO1FBQ3BCO0lBQ0o7SUFDQVEsV0FBVztRQUNQLElBQUksSUFBSSxDQUFDUixRQUFRLElBQUksSUFBSSxDQUFDRCxLQUFLLENBQUNySCxNQUFNLEVBQUU7WUFDcEMsSUFBSSxDQUFDNkksUUFBUTtZQUNiLElBQUksSUFBSSxDQUFDdkIsUUFBUSxJQUFJLElBQUksQ0FBQ0QsS0FBSyxDQUFDckgsTUFBTSxFQUNsQyxPQUFPLElBQUksQ0FBQ3lDLElBQUksR0FBRyxDQUFDO1FBQzVCO1FBQ0EsT0FBTyxJQUFJLENBQUNBLElBQUksR0FBRyxJQUFJLENBQUM0RSxLQUFLLENBQUNSLFVBQVUsQ0FBQyxJQUFJLENBQUNTLFFBQVE7SUFDMUQ7SUFDQTs7O0lBR0EsR0FDQXlCLFFBQVFDLElBQUksQ0FBQyxFQUFFO1FBQ1gsSUFBSSxDQUFDMUIsUUFBUSxJQUFJMEI7UUFDakIsTUFBTyxJQUFJLENBQUNuSyxHQUFHLEdBQUdtSyxLQUFLLElBQUksQ0FBQ3BCLEtBQUssQ0FBQ0MsRUFBRSxDQUFFO1lBQ2xDLElBQUksSUFBSSxDQUFDSCxVQUFVLElBQUksSUFBSSxDQUFDM0csTUFBTSxDQUFDZixNQUFNLEdBQUcsR0FDeEMsT0FBTyxJQUFJLENBQUNpSixPQUFPO1lBQ3ZCRCxLQUFLLElBQUksQ0FBQ3BCLEtBQUssQ0FBQ0MsRUFBRSxHQUFHLElBQUksQ0FBQ2hKLEdBQUc7WUFDN0IsSUFBSSxDQUFDK0ksS0FBSyxHQUFHLElBQUksQ0FBQzdHLE1BQU0sQ0FBQyxFQUFFLElBQUksQ0FBQzJHLFVBQVUsQ0FBQztZQUMzQyxJQUFJLENBQUM3SSxHQUFHLEdBQUcsSUFBSSxDQUFDK0ksS0FBSyxDQUFDNUcsSUFBSTtRQUM5QjtRQUNBLElBQUksQ0FBQ25DLEdBQUcsSUFBSW1LO1FBQ1osSUFBSSxJQUFJLENBQUNuSyxHQUFHLElBQUksSUFBSSxDQUFDNEksS0FBSyxDQUFDdkksU0FBUyxFQUNoQyxJQUFJLENBQUN1SSxLQUFLLENBQUN2SSxTQUFTLEdBQUcsSUFBSSxDQUFDTCxHQUFHLEdBQUc7UUFDdEMsT0FBTyxJQUFJLENBQUNpSixRQUFRO0lBQ3hCO0lBQ0FtQixVQUFVO1FBQ04sSUFBSSxDQUFDcEssR0FBRyxHQUFHLElBQUksQ0FBQzhJLFFBQVEsR0FBRyxJQUFJLENBQUM5RixHQUFHO1FBQ25DLElBQUksQ0FBQytGLEtBQUssR0FBRyxJQUFJLENBQUM3RyxNQUFNLENBQUMsSUFBSSxDQUFDMkcsVUFBVSxHQUFHLElBQUksQ0FBQzNHLE1BQU0sQ0FBQ2YsTUFBTSxHQUFHLEVBQUU7UUFDbEUsSUFBSSxDQUFDcUgsS0FBSyxHQUFHO1FBQ2IsT0FBTyxJQUFJLENBQUM1RSxJQUFJLEdBQUcsQ0FBQztJQUN4QjtJQUNBOztJQUVBLEdBQ0FVLE1BQU10RSxHQUFHLEVBQUU0SSxLQUFLLEVBQUU7UUFDZCxJQUFJQSxPQUFPO1lBQ1AsSUFBSSxDQUFDQSxLQUFLLEdBQUdBO1lBQ2JBLE1BQU1oSSxLQUFLLEdBQUdaO1lBQ2Q0SSxNQUFNdkksU0FBUyxHQUFHTCxNQUFNO1lBQ3hCNEksTUFBTTVFLEtBQUssR0FBRzRFLE1BQU1SLFFBQVEsR0FBRyxDQUFDO1FBQ3BDLE9BQ0s7WUFDRCxJQUFJLENBQUNRLEtBQUssR0FBR047UUFDakI7UUFDQSxJQUFJLElBQUksQ0FBQ3RJLEdBQUcsSUFBSUEsS0FBSztZQUNqQixJQUFJLENBQUNBLEdBQUcsR0FBR0E7WUFDWCxJQUFJQSxPQUFPLElBQUksQ0FBQ2dELEdBQUcsRUFBRTtnQkFDakIsSUFBSSxDQUFDb0gsT0FBTztnQkFDWixPQUFPLElBQUk7WUFDZjtZQUNBLE1BQU9wSyxNQUFNLElBQUksQ0FBQytJLEtBQUssQ0FBQzVHLElBQUksQ0FDeEIsSUFBSSxDQUFDNEcsS0FBSyxHQUFHLElBQUksQ0FBQzdHLE1BQU0sQ0FBQyxFQUFFLElBQUksQ0FBQzJHLFVBQVUsQ0FBQztZQUMvQyxNQUFPN0ksT0FBTyxJQUFJLENBQUMrSSxLQUFLLENBQUNDLEVBQUUsQ0FDdkIsSUFBSSxDQUFDRCxLQUFLLEdBQUcsSUFBSSxDQUFDN0csTUFBTSxDQUFDLEVBQUUsSUFBSSxDQUFDMkcsVUFBVSxDQUFDO1lBQy9DLElBQUk3SSxPQUFPLElBQUksQ0FBQzhJLFFBQVEsSUFBSTlJLE1BQU0sSUFBSSxDQUFDOEksUUFBUSxHQUFHLElBQUksQ0FBQ04sS0FBSyxDQUFDckgsTUFBTSxFQUFFO2dCQUNqRSxJQUFJLENBQUNzSCxRQUFRLEdBQUd6SSxNQUFNLElBQUksQ0FBQzhJLFFBQVE7WUFDdkMsT0FDSztnQkFDRCxJQUFJLENBQUNOLEtBQUssR0FBRztnQkFDYixJQUFJLENBQUNDLFFBQVEsR0FBRztZQUNwQjtZQUNBLElBQUksQ0FBQ1EsUUFBUTtRQUNqQjtRQUNBLE9BQU8sSUFBSTtJQUNmO0lBQ0E7O0lBRUEsR0FDQW9CLEtBQUtsSSxJQUFJLEVBQUU2RyxFQUFFLEVBQUU7UUFDWCxJQUFJN0csUUFBUSxJQUFJLENBQUMyRyxRQUFRLElBQUlFLE1BQU0sSUFBSSxDQUFDRixRQUFRLEdBQUcsSUFBSSxDQUFDTixLQUFLLENBQUNySCxNQUFNLEVBQ2hFLE9BQU8sSUFBSSxDQUFDcUgsS0FBSyxDQUFDL0QsS0FBSyxDQUFDdEMsT0FBTyxJQUFJLENBQUMyRyxRQUFRLEVBQUVFLEtBQUssSUFBSSxDQUFDRixRQUFRO1FBQ3BFLElBQUkzRyxRQUFRLElBQUksQ0FBQ3dHLFNBQVMsSUFBSUssTUFBTSxJQUFJLENBQUNMLFNBQVMsR0FBRyxJQUFJLENBQUNELE1BQU0sQ0FBQ3ZILE1BQU0sRUFDbkUsT0FBTyxJQUFJLENBQUN1SCxNQUFNLENBQUNqRSxLQUFLLENBQUN0QyxPQUFPLElBQUksQ0FBQ3dHLFNBQVMsRUFBRUssS0FBSyxJQUFJLENBQUNMLFNBQVM7UUFDdkUsSUFBSXhHLFFBQVEsSUFBSSxDQUFDNEcsS0FBSyxDQUFDNUcsSUFBSSxJQUFJNkcsTUFBTSxJQUFJLENBQUNELEtBQUssQ0FBQ0MsRUFBRSxFQUM5QyxPQUFPLElBQUksQ0FBQ3JCLEtBQUssQ0FBQzBDLElBQUksQ0FBQ2xJLE1BQU02RztRQUNqQyxJQUFJekQsU0FBUztRQUNiLEtBQUssSUFBSStFLEtBQUssSUFBSSxDQUFDcEksTUFBTSxDQUFFO1lBQ3ZCLElBQUlvSSxFQUFFbkksSUFBSSxJQUFJNkcsSUFDVjtZQUNKLElBQUlzQixFQUFFdEIsRUFBRSxHQUFHN0csTUFDUG9ELFVBQVUsSUFBSSxDQUFDb0MsS0FBSyxDQUFDMEMsSUFBSSxDQUFDZixLQUFLQyxHQUFHLENBQUNlLEVBQUVuSSxJQUFJLEVBQUVBLE9BQU9tSCxLQUFLaUIsR0FBRyxDQUFDRCxFQUFFdEIsRUFBRSxFQUFFQTtRQUN6RTtRQUNBLE9BQU96RDtJQUNYO0FBQ0o7QUFDQTs7QUFFQSxHQUNBLE1BQU1pRjtJQUNGN0ssWUFBWTBHLElBQUksRUFBRW1CLEVBQUUsQ0FBRTtRQUNsQixJQUFJLENBQUNuQixJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDbUIsRUFBRSxHQUFHQTtJQUNkO0lBQ0FvQixNQUFNakIsS0FBSyxFQUFFOUgsS0FBSyxFQUFFO1FBQ2hCLElBQUksRUFBRWlCLE1BQU0sRUFBRSxHQUFHakIsTUFBTUQsQ0FBQztRQUN4QjZLLFVBQVUsSUFBSSxDQUFDcEUsSUFBSSxFQUFFc0IsT0FBTzlILE9BQU8sSUFBSSxDQUFDMkgsRUFBRSxFQUFFMUcsT0FBT3VGLElBQUksRUFBRXZGLE9BQU80SixjQUFjO0lBQ2xGO0FBQ0o7QUFDQUYsV0FBV0csU0FBUyxDQUFDQyxVQUFVLEdBQUdKLFdBQVdHLFNBQVMsQ0FBQ0UsUUFBUSxHQUFHTCxXQUFXRyxTQUFTLENBQUNHLE1BQU0sR0FBRztBQUNoRzs7QUFFQSxHQUNBLE1BQU1DO0lBQ0ZwTCxZQUFZMEcsSUFBSSxFQUFFMkUsU0FBUyxFQUFFQyxTQUFTLENBQUU7UUFDcEMsSUFBSSxDQUFDRCxTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ0MsU0FBUyxHQUFHQTtRQUNqQixJQUFJLENBQUM1RSxJQUFJLEdBQUcsT0FBT0EsUUFBUSxXQUFXcUIsWUFBWXJCLFFBQVFBO0lBQzlEO0lBQ0F1QyxNQUFNakIsS0FBSyxFQUFFOUgsS0FBSyxFQUFFO1FBQ2hCLElBQUllLFFBQVErRyxNQUFNM0gsR0FBRyxFQUFFa0wsVUFBVTtRQUNqQyxPQUFTO1lBQ0wsSUFBSUMsUUFBUXhELE1BQU0vRCxJQUFJLEdBQUcsR0FBR3dILFVBQVV6RCxNQUFNdUIsYUFBYSxDQUFDLEdBQUc7WUFDN0R1QixVQUFVLElBQUksQ0FBQ3BFLElBQUksRUFBRXNCLE9BQU85SCxPQUFPLEdBQUcsSUFBSSxDQUFDd0csSUFBSSxFQUFFLElBQUksQ0FBQzJFLFNBQVM7WUFDL0QsSUFBSXJELE1BQU1pQixLQUFLLENBQUM1RSxLQUFLLEdBQUcsQ0FBQyxHQUNyQjtZQUNKLElBQUksSUFBSSxDQUFDaUgsU0FBUyxJQUFJLE1BQ2xCO1lBQ0osSUFBSSxDQUFDRSxPQUNERDtZQUNKLElBQUlFLFdBQVcsTUFDWDtZQUNKekQsTUFBTXJELEtBQUssQ0FBQzhHLFNBQVN6RCxNQUFNaUIsS0FBSztRQUNwQztRQUNBLElBQUlzQyxTQUFTO1lBQ1R2RCxNQUFNckQsS0FBSyxDQUFDMUQsT0FBTytHLE1BQU1pQixLQUFLO1lBQzlCakIsTUFBTWdDLFdBQVcsQ0FBQyxJQUFJLENBQUNzQixTQUFTLEVBQUVDO1FBQ3RDO0lBQ0o7QUFDSjtBQUNBSCxnQkFBZ0JKLFNBQVMsQ0FBQ0MsVUFBVSxHQUFHSixXQUFXRyxTQUFTLENBQUNFLFFBQVEsR0FBR0wsV0FBV0csU0FBUyxDQUFDRyxNQUFNLEdBQUc7QUFDckc7OztBQUdBLEdBQ0EsTUFBTU87SUFDRjs7Ozs7O0lBTUEsR0FDQTFMLFlBQ0E7O0lBRUEsR0FDQWlKLEtBQUssRUFBRTBDLFVBQVUsQ0FBQyxDQUFDLENBQUU7UUFDakIsSUFBSSxDQUFDMUMsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ2dDLFVBQVUsR0FBRyxDQUFDLENBQUNVLFFBQVFWLFVBQVU7UUFDdEMsSUFBSSxDQUFDQyxRQUFRLEdBQUcsQ0FBQyxDQUFDUyxRQUFRVCxRQUFRO1FBQ2xDLElBQUksQ0FBQ0MsTUFBTSxHQUFHLENBQUMsQ0FBQ1EsUUFBUVIsTUFBTTtJQUNsQztBQUNKO0FBQ0EsbUVBQW1FO0FBQ25FLFNBQVM7QUFDVCxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLG1FQUFtRTtBQUNuRSxxREFBcUQ7QUFDckQsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxZQUFZO0FBQ1osRUFBRTtBQUNGLGdEQUFnRDtBQUNoRCxFQUFFO0FBQ0YsMkRBQTJEO0FBQzNELEVBQUU7QUFDRixtRUFBbUU7QUFDbkUsd0RBQXdEO0FBQ3hELEVBQUU7QUFDRixrRUFBa0U7QUFDbEUsb0VBQW9FO0FBQ3BFLHNEQUFzRDtBQUN0RCxTQUFTTCxVQUFVcEUsSUFBSSxFQUFFc0IsS0FBSyxFQUFFOUgsS0FBSyxFQUFFMEwsS0FBSyxFQUFFUCxTQUFTLEVBQUVRLFVBQVU7SUFDL0QsSUFBSTFMLFFBQVEsR0FBRzJMLFlBQVksS0FBS0YsT0FBTyxFQUFFNUUsT0FBTyxFQUFFLEdBQUc5RyxNQUFNRCxDQUFDLENBQUNrQixNQUFNO0lBQ25Fd0MsTUFBTSxPQUFTO1FBQ1gsSUFBSSxDQUFDbUksWUFBWXBGLElBQUksQ0FBQ3ZHLE1BQU0sS0FBSyxHQUM3QjtRQUNKLElBQUk0TCxTQUFTckYsSUFBSSxDQUFDdkcsUUFBUSxFQUFFO1FBQzVCLG9FQUFvRTtRQUNwRSxvREFBb0Q7UUFDcEQsb0NBQW9DO1FBQ3BDLElBQUssSUFBSVksSUFBSVosUUFBUSxHQUFHWSxJQUFJZ0wsUUFBUWhMLEtBQUssRUFDckMsSUFBSSxDQUFDMkYsSUFBSSxDQUFDM0YsSUFBSSxFQUFFLEdBQUcrSyxTQUFRLElBQUssR0FBRztZQUMvQixJQUFJMUksT0FBT3NELElBQUksQ0FBQzNGLEVBQUU7WUFDbEIsSUFBSWlHLFFBQVFnRixNQUFNLENBQUM1SSxTQUNkNEUsQ0FBQUEsTUFBTWlCLEtBQUssQ0FBQzVFLEtBQUssSUFBSSxDQUFDLEtBQUsyRCxNQUFNaUIsS0FBSyxDQUFDNUUsS0FBSyxJQUFJakIsUUFDN0M2SSxVQUFVN0ksTUFBTTRFLE1BQU1pQixLQUFLLENBQUM1RSxLQUFLLEVBQUVnSCxXQUFXUSxXQUFVLEdBQUk7Z0JBQ2hFN0QsTUFBTWdDLFdBQVcsQ0FBQzVHO2dCQUNsQjtZQUNKO1FBQ0o7UUFDSixJQUFJYSxPQUFPK0QsTUFBTS9ELElBQUksRUFBRWlJLE1BQU0sR0FBR0MsT0FBT3pGLElBQUksQ0FBQ3ZHLFFBQVEsRUFBRTtRQUN0RCx1QkFBdUI7UUFDdkIsSUFBSTZILE1BQU0vRCxJQUFJLEdBQUcsS0FBS2tJLE9BQU9ELE9BQU94RixJQUFJLENBQUNxRixTQUFTSSxPQUFPLElBQUksRUFBRSxJQUFJLE1BQU0sV0FBVyxLQUFJO1lBQ3BGaE0sUUFBUXVHLElBQUksQ0FBQ3FGLFNBQVNJLE9BQU8sSUFBSSxFQUFFO1lBQ25DLFNBQVN4STtRQUNiO1FBQ0EsMENBQTBDO1FBQzFDLE1BQU91SSxNQUFNQyxNQUFPO1lBQ2hCLElBQUlDLE1BQU0sTUFBT0QsUUFBUztZQUMxQixJQUFJMUksUUFBUXNJLFNBQVNLLE1BQU9BLENBQUFBLE9BQU87WUFDbkMsSUFBSTVKLE9BQU9rRSxJQUFJLENBQUNqRCxNQUFNLEVBQUU0RixLQUFLM0MsSUFBSSxDQUFDakQsUUFBUSxFQUFFLElBQUk7WUFDaEQsSUFBSVEsT0FBT3pCLE1BQ1AySixPQUFPQztpQkFDTixJQUFJbkksUUFBUW9GLElBQ2I2QyxNQUFNRSxNQUFNO2lCQUNYO2dCQUNEak0sUUFBUXVHLElBQUksQ0FBQ2pELFFBQVEsRUFBRTtnQkFDdkJ1RSxNQUFNdUMsT0FBTztnQkFDYixTQUFTNUc7WUFDYjtRQUNKO1FBQ0E7SUFDSjtBQUNKO0FBQ0EsU0FBUzBJLFdBQVczRixJQUFJLEVBQUV6RixLQUFLLEVBQUVtQyxJQUFJO0lBQ2pDLElBQUssSUFBSXJDLElBQUlFLE9BQU9nRCxNQUFNLENBQUNBLE9BQU95QyxJQUFJLENBQUMzRixFQUFFLEtBQUssTUFBTSxXQUFXLEtBQUlBLElBQy9ELElBQUlrRCxRQUFRYixNQUNSLE9BQU9yQyxJQUFJRTtJQUNuQixPQUFPLENBQUM7QUFDWjtBQUNBLFNBQVNnTCxVQUFVaEQsS0FBSyxFQUFFcUQsSUFBSSxFQUFFQyxTQUFTLEVBQUVDLFdBQVc7SUFDbEQsSUFBSUMsUUFBUUosV0FBV0UsV0FBV0MsYUFBYUY7SUFDL0MsT0FBT0csUUFBUSxLQUFLSixXQUFXRSxXQUFXQyxhQUFhdkQsU0FBU3dEO0FBQ3BFO0FBRUEsc0RBQXNEO0FBQ3RELE1BQU1DLFVBQVUsT0FBT0MsV0FBVyxlQUFlQSxRQUFRQyxHQUFHLElBQUksWUFBWUMsSUFBSSxDQUFDRixRQUFRQyxHQUFHLENBQUNFLEdBQUc7QUFDaEcsSUFBSUMsV0FBVztBQUNmLFNBQVNDLE1BQU1DLElBQUksRUFBRTVNLEdBQUcsRUFBRTZNLElBQUk7SUFDMUIsSUFBSUMsU0FBU0YsS0FBS0UsTUFBTSxDQUFDck4sbURBQVFBLENBQUNzTixnQkFBZ0I7SUFDbERELE9BQU9FLE1BQU0sQ0FBQ2hOO0lBQ2QsT0FBUztRQUNMLElBQUksQ0FBRTZNLENBQUFBLE9BQU8sSUFBSUMsT0FBT0csV0FBVyxDQUFDak4sT0FBTzhNLE9BQU9JLFVBQVUsQ0FBQ2xOLElBQUcsR0FDNUQsT0FBUztZQUNMLElBQUksQ0FBQzZNLE9BQU8sSUFBSUMsT0FBTzlELEVBQUUsR0FBR2hKLE1BQU04TSxPQUFPM0ssSUFBSSxHQUFHbkMsR0FBRSxLQUFNLENBQUM4TSxPQUFPdEwsSUFBSSxDQUFDMkwsT0FBTyxFQUN4RSxPQUFPTixPQUFPLElBQUl2RCxLQUFLQyxHQUFHLENBQUMsR0FBR0QsS0FBS2lCLEdBQUcsQ0FBQ3VDLE9BQU85RCxFQUFFLEdBQUcsR0FBR2hKLE1BQU0sR0FBRyxvQkFBb0IsUUFDN0VzSixLQUFLaUIsR0FBRyxDQUFDcUMsS0FBS3pMLE1BQU0sRUFBRW1JLEtBQUtDLEdBQUcsQ0FBQ3VELE9BQU8zSyxJQUFJLEdBQUcsR0FBR25DLE1BQU0sR0FBRyxvQkFBb0I7WUFDdkYsSUFBSTZNLE9BQU8sSUFBSUMsT0FBT00sV0FBVyxLQUFLTixPQUFPTyxXQUFXLElBQ3BEO1lBQ0osSUFBSSxDQUFDUCxPQUFPeE0sTUFBTSxJQUNkLE9BQU91TSxPQUFPLElBQUksSUFBSUQsS0FBS3pMLE1BQU07UUFDekM7SUFDUjtBQUNKO0FBQ0EsTUFBTW1NO0lBQ0YzTixZQUFZNE4sU0FBUyxFQUFFbEwsT0FBTyxDQUFFO1FBQzVCLElBQUksQ0FBQ2tMLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDbEwsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQzNCLENBQUMsR0FBRztRQUNULElBQUksQ0FBQzhNLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNDLFFBQVEsR0FBRyxDQUFDO1FBQ2pCLElBQUksQ0FBQ0MsTUFBTSxHQUFHLENBQUM7UUFDZixJQUFJLENBQUNDLEtBQUssR0FBRyxFQUFFO1FBQ2YsSUFBSSxDQUFDL00sS0FBSyxHQUFHLEVBQUU7UUFDZixJQUFJLENBQUN3QyxLQUFLLEdBQUcsRUFBRTtRQUNmLElBQUksQ0FBQ3dLLFlBQVk7SUFDckI7SUFDQUEsZUFBZTtRQUNYLElBQUlDLEtBQUssSUFBSSxDQUFDTCxRQUFRLEdBQUcsSUFBSSxDQUFDOU0sQ0FBQyxJQUFJLElBQUksQ0FBQzZNLFNBQVMsQ0FBQ3BNLE1BQU0sR0FBRyxPQUFPLElBQUksQ0FBQ29NLFNBQVMsQ0FBQyxJQUFJLENBQUM3TSxDQUFDLEdBQUc7UUFDMUYsSUFBSW1OLElBQUk7WUFDSixJQUFJLENBQUNKLFFBQVEsR0FBR0ksR0FBR0MsU0FBUyxHQUFHbkIsTUFBTWtCLEdBQUdqQixJQUFJLEVBQUVpQixHQUFHMUwsSUFBSSxHQUFHMEwsR0FBRzFFLE1BQU0sRUFBRSxLQUFLMEUsR0FBRzFFLE1BQU0sR0FBRzBFLEdBQUcxTCxJQUFJO1lBQzNGLElBQUksQ0FBQ3VMLE1BQU0sR0FBR0csR0FBR0UsT0FBTyxHQUFHcEIsTUFBTWtCLEdBQUdqQixJQUFJLEVBQUVpQixHQUFHN0UsRUFBRSxHQUFHNkUsR0FBRzFFLE1BQU0sRUFBRSxDQUFDLEtBQUswRSxHQUFHMUUsTUFBTSxHQUFHMEUsR0FBRzdFLEVBQUU7WUFDcEYsTUFBTyxJQUFJLENBQUMyRSxLQUFLLENBQUN4TSxNQUFNLENBQUU7Z0JBQ3RCLElBQUksQ0FBQ3dNLEtBQUssQ0FBQzdLLEdBQUc7Z0JBQ2QsSUFBSSxDQUFDbEMsS0FBSyxDQUFDa0MsR0FBRztnQkFDZCxJQUFJLENBQUNNLEtBQUssQ0FBQ04sR0FBRztZQUNsQjtZQUNBLElBQUksQ0FBQzZLLEtBQUssQ0FBQ3pNLElBQUksQ0FBQzJNLEdBQUdqQixJQUFJO1lBQ3ZCLElBQUksQ0FBQ2hNLEtBQUssQ0FBQ00sSUFBSSxDQUFDLENBQUMyTSxHQUFHMUUsTUFBTTtZQUMxQixJQUFJLENBQUMvRixLQUFLLENBQUNsQyxJQUFJLENBQUM7WUFDaEIsSUFBSSxDQUFDMkMsU0FBUyxHQUFHLElBQUksQ0FBQzRKLFFBQVE7UUFDbEMsT0FDSztZQUNELElBQUksQ0FBQzVKLFNBQVMsR0FBRztRQUNyQjtJQUNKO0lBQ0EsOERBQThEO0lBQzlEbUssT0FBT2hPLEdBQUcsRUFBRTtRQUNSLElBQUlBLE1BQU0sSUFBSSxDQUFDNkQsU0FBUyxFQUNwQixPQUFPO1FBQ1gsTUFBTyxJQUFJLENBQUMySixRQUFRLElBQUksSUFBSSxDQUFDRSxNQUFNLElBQUkxTixJQUNuQyxJQUFJLENBQUM0TixZQUFZO1FBQ3JCLElBQUksQ0FBQyxJQUFJLENBQUNKLFFBQVEsRUFDZCxPQUFPO1FBQ1gsT0FBUztZQUNMLElBQUkxRyxPQUFPLElBQUksQ0FBQzZHLEtBQUssQ0FBQ3hNLE1BQU0sR0FBRztZQUMvQixJQUFJMkYsT0FBTyxHQUFHO2dCQUNWLElBQUksQ0FBQzhHLFlBQVk7Z0JBQ2pCLE9BQU87WUFDWDtZQUNBLElBQUl6SyxNQUFNLElBQUksQ0FBQ3dLLEtBQUssQ0FBQzdHLEtBQUssRUFBRTFELFFBQVEsSUFBSSxDQUFDQSxLQUFLLENBQUMwRCxLQUFLO1lBQ3BELElBQUkxRCxTQUFTRCxJQUFJOEssUUFBUSxDQUFDOU0sTUFBTSxFQUFFO2dCQUM5QixJQUFJLENBQUN3TSxLQUFLLENBQUM3SyxHQUFHO2dCQUNkLElBQUksQ0FBQ2xDLEtBQUssQ0FBQ2tDLEdBQUc7Z0JBQ2QsSUFBSSxDQUFDTSxLQUFLLENBQUNOLEdBQUc7Z0JBQ2Q7WUFDSjtZQUNBLElBQUljLE9BQU9ULElBQUk4SyxRQUFRLENBQUM3SyxNQUFNO1lBQzlCLElBQUl4QyxRQUFRLElBQUksQ0FBQ0EsS0FBSyxDQUFDa0csS0FBSyxHQUFHM0QsSUFBSStLLFNBQVMsQ0FBQzlLLE1BQU07WUFDbkQsSUFBSXhDLFFBQVFaLEtBQUs7Z0JBQ2IsSUFBSSxDQUFDNkQsU0FBUyxHQUFHakQ7Z0JBQ2pCLE9BQU87WUFDWDtZQUNBLElBQUlnRCxnQkFBZ0JwRSwrQ0FBSUEsRUFBRTtnQkFDdEIsSUFBSW9CLFNBQVNaLEtBQUs7b0JBQ2QsSUFBSVksUUFBUSxJQUFJLENBQUM2TSxRQUFRLEVBQ3JCLE9BQU87b0JBQ1gsSUFBSXpLLE1BQU1wQyxRQUFRZ0QsS0FBS3pDLE1BQU07b0JBQzdCLElBQUk2QixPQUFPLElBQUksQ0FBQzBLLE1BQU0sRUFBRTt3QkFDcEIsSUFBSXJOLFlBQVl1RCxLQUFLdUssSUFBSSxDQUFDL08sbURBQVFBLENBQUNpQixTQUFTO3dCQUM1QyxJQUFJLENBQUNBLGFBQWEyQyxNQUFNM0MsWUFBWSxJQUFJLENBQUNtTixRQUFRLENBQUN4RSxFQUFFLEVBQ2hELE9BQU9wRjtvQkFDZjtnQkFDSjtnQkFDQSxJQUFJLENBQUNSLEtBQUssQ0FBQzBELEtBQUs7Z0JBQ2hCLElBQUlsRyxRQUFRZ0QsS0FBS3pDLE1BQU0sSUFBSW1JLEtBQUtDLEdBQUcsQ0FBQyxJQUFJLENBQUNrRSxRQUFRLEVBQUV6TixNQUFNO29CQUNyRCxJQUFJLENBQUMyTixLQUFLLENBQUN6TSxJQUFJLENBQUMwQztvQkFDaEIsSUFBSSxDQUFDaEQsS0FBSyxDQUFDTSxJQUFJLENBQUNOO29CQUNoQixJQUFJLENBQUN3QyxLQUFLLENBQUNsQyxJQUFJLENBQUM7Z0JBQ3BCO1lBQ0osT0FDSztnQkFDRCxJQUFJLENBQUNrQyxLQUFLLENBQUMwRCxLQUFLO2dCQUNoQixJQUFJLENBQUNqRCxTQUFTLEdBQUdqRCxRQUFRZ0QsS0FBS3pDLE1BQU07WUFDeEM7UUFDSjtJQUNKO0FBQ0o7QUFDQSxNQUFNaU47SUFDRnpPLFlBQVltQixNQUFNLEVBQUV1RCxNQUFNLENBQUU7UUFDeEIsSUFBSSxDQUFDQSxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDZ0ssTUFBTSxHQUFHLEVBQUU7UUFDaEIsSUFBSSxDQUFDQyxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDQyxPQUFPLEdBQUcsRUFBRTtRQUNqQixJQUFJLENBQUNGLE1BQU0sR0FBR3ZOLE9BQU8wTixVQUFVLENBQUNDLEdBQUcsQ0FBQ2hPLENBQUFBLElBQUssSUFBSTBIO0lBQ2pEO0lBQ0F1RyxXQUFXN08sS0FBSyxFQUFFO1FBQ2QsSUFBSThPLGNBQWM7UUFDbEIsSUFBSUMsT0FBTztRQUNYLElBQUksRUFBRTlOLE1BQU0sRUFBRSxHQUFHakIsTUFBTUQsQ0FBQyxFQUFFLEVBQUU0TyxVQUFVLEVBQUUsR0FBRzFOO1FBQzNDLElBQUl1SCxPQUFPdkgsT0FBT2lFLFNBQVMsQ0FBQ2xGLE1BQU1DLEtBQUssRUFBRSxFQUFFLDRCQUE0QjtRQUN2RSxJQUFJaUIsVUFBVWxCLE1BQU1PLFVBQVUsR0FBR1AsTUFBTU8sVUFBVSxDQUFDMkcsSUFBSSxHQUFHO1FBQ3pELElBQUkxRyxZQUFZO1FBQ2hCLElBQUssSUFBSUssSUFBSSxHQUFHQSxJQUFJOE4sV0FBV3JOLE1BQU0sRUFBRVQsSUFBSztZQUN4QyxJQUFJLENBQUMsS0FBTUEsSUFBSzJILElBQUcsS0FBTSxHQUNyQjtZQUNKLElBQUl3RyxZQUFZTCxVQUFVLENBQUM5TixFQUFFLEVBQUVrSSxRQUFRLElBQUksQ0FBQ3lGLE1BQU0sQ0FBQzNOLEVBQUU7WUFDckQsSUFBSWtPLFFBQVEsQ0FBQ0MsVUFBVWhFLFFBQVEsRUFDM0I7WUFDSixJQUFJZ0UsVUFBVWpFLFVBQVUsSUFBSWhDLE1BQU1oSSxLQUFLLElBQUlmLE1BQU1HLEdBQUcsSUFBSTRJLE1BQU1QLElBQUksSUFBSUEsUUFBUU8sTUFBTTdILE9BQU8sSUFBSUEsU0FBUztnQkFDcEcsSUFBSSxDQUFDK04saUJBQWlCLENBQUNsRyxPQUFPaUcsV0FBV2hQO2dCQUN6QytJLE1BQU1QLElBQUksR0FBR0E7Z0JBQ2JPLE1BQU03SCxPQUFPLEdBQUdBO1lBQ3BCO1lBQ0EsSUFBSTZILE1BQU12SSxTQUFTLEdBQUd1SSxNQUFNNUYsR0FBRyxHQUFHLEdBQUcsb0JBQW9CLEtBQ3JEM0MsWUFBWWlKLEtBQUtDLEdBQUcsQ0FBQ1gsTUFBTXZJLFNBQVMsRUFBRUE7WUFDMUMsSUFBSXVJLE1BQU01RSxLQUFLLElBQUksRUFBRSxZQUFZLEtBQUk7Z0JBQ2pDLElBQUkrSyxhQUFhSjtnQkFDakIsSUFBSS9GLE1BQU1SLFFBQVEsR0FBRyxDQUFDLEdBQ2xCdUcsY0FBYyxJQUFJLENBQUNLLFVBQVUsQ0FBQ25QLE9BQU8rSSxNQUFNUixRQUFRLEVBQUVRLE1BQU01RixHQUFHLEVBQUUyTDtnQkFDcEVBLGNBQWMsSUFBSSxDQUFDSyxVQUFVLENBQUNuUCxPQUFPK0ksTUFBTTVFLEtBQUssRUFBRTRFLE1BQU01RixHQUFHLEVBQUUyTDtnQkFDN0QsSUFBSSxDQUFDRSxVQUFVL0QsTUFBTSxFQUFFO29CQUNuQjhELE9BQU9oRztvQkFDUCxJQUFJK0YsY0FBY0ksWUFDZDtnQkFDUjtZQUNKO1FBQ0o7UUFDQSxNQUFPLElBQUksQ0FBQ1IsT0FBTyxDQUFDcE4sTUFBTSxHQUFHd04sWUFDekIsSUFBSSxDQUFDSixPQUFPLENBQUN6TCxHQUFHO1FBQ3BCLElBQUl6QyxXQUNBUixNQUFNNkIsWUFBWSxDQUFDckI7UUFDdkIsSUFBSSxDQUFDdU8sUUFBUS9PLE1BQU1HLEdBQUcsSUFBSSxJQUFJLENBQUNxRSxNQUFNLENBQUNyQixHQUFHLEVBQUU7WUFDdkM0TCxPQUFPLElBQUl6RztZQUNYeUcsS0FBSzVLLEtBQUssR0FBR25FLE1BQU1ELENBQUMsQ0FBQ2tCLE1BQU0sQ0FBQ21PLE9BQU87WUFDbkNMLEtBQUtoTyxLQUFLLEdBQUdnTyxLQUFLNUwsR0FBRyxHQUFHbkQsTUFBTUcsR0FBRztZQUNqQzJPLGNBQWMsSUFBSSxDQUFDSyxVQUFVLENBQUNuUCxPQUFPK08sS0FBSzVLLEtBQUssRUFBRTRLLEtBQUs1TCxHQUFHLEVBQUUyTDtRQUMvRDtRQUNBLElBQUksQ0FBQ0wsU0FBUyxHQUFHTTtRQUNqQixPQUFPLElBQUksQ0FBQ0wsT0FBTztJQUN2QjtJQUNBVyxhQUFhclAsS0FBSyxFQUFFO1FBQ2hCLElBQUksSUFBSSxDQUFDeU8sU0FBUyxFQUNkLE9BQU8sSUFBSSxDQUFDQSxTQUFTO1FBQ3pCLElBQUlNLE9BQU8sSUFBSXpHLGFBQWEsRUFBRW5JLEdBQUcsRUFBRUosQ0FBQyxFQUFFLEdBQUdDO1FBQ3pDK08sS0FBS2hPLEtBQUssR0FBR1o7UUFDYjRPLEtBQUs1TCxHQUFHLEdBQUdzRyxLQUFLaUIsR0FBRyxDQUFDdkssTUFBTSxHQUFHSixFQUFFeUUsTUFBTSxDQUFDckIsR0FBRztRQUN6QzRMLEtBQUs1SyxLQUFLLEdBQUdoRSxPQUFPSixFQUFFeUUsTUFBTSxDQUFDckIsR0FBRyxHQUFHcEQsRUFBRWtCLE1BQU0sQ0FBQ21PLE9BQU8sR0FBRyxFQUFFLFlBQVk7UUFDcEUsT0FBT0w7SUFDWDtJQUNBRSxrQkFBa0JsRyxLQUFLLEVBQUVpRyxTQUFTLEVBQUVoUCxLQUFLLEVBQUU7UUFDdkMsSUFBSWUsUUFBUSxJQUFJLENBQUN5RCxNQUFNLENBQUNnRixPQUFPLENBQUN4SixNQUFNRyxHQUFHO1FBQ3pDNk8sVUFBVWpHLEtBQUssQ0FBQyxJQUFJLENBQUN2RSxNQUFNLENBQUNDLEtBQUssQ0FBQzFELE9BQU9nSSxRQUFRL0k7UUFDakQsSUFBSStJLE1BQU01RSxLQUFLLEdBQUcsQ0FBQyxHQUFHO1lBQ2xCLElBQUksRUFBRWxELE1BQU0sRUFBRSxHQUFHakIsTUFBTUQsQ0FBQztZQUN4QixJQUFLLElBQUljLElBQUksR0FBR0EsSUFBSUksT0FBT3FPLFdBQVcsQ0FBQ2hPLE1BQU0sRUFBRVQsSUFDM0MsSUFBSUksT0FBT3FPLFdBQVcsQ0FBQ3pPLEVBQUUsSUFBSWtJLE1BQU01RSxLQUFLLEVBQUU7Z0JBQ3RDLElBQUl1QixTQUFTekUsT0FBT3NPLFlBQVksQ0FBQzFPLEVBQUUsQ0FBQyxJQUFJLENBQUMyRCxNQUFNLENBQUNnRyxJQUFJLENBQUN6QixNQUFNaEksS0FBSyxFQUFFZ0ksTUFBTTVGLEdBQUcsR0FBR25EO2dCQUM5RSxJQUFJMEYsVUFBVSxLQUFLMUYsTUFBTUQsQ0FBQyxDQUFDa0IsTUFBTSxDQUFDNkYsT0FBTyxDQUFDZ0YsTUFBTSxDQUFDcEcsVUFBVSxJQUFJO29CQUMzRCxJQUFJLENBQUNBLFNBQVMsTUFBTSxFQUFFLHlCQUF5QixLQUMzQ3FELE1BQU01RSxLQUFLLEdBQUd1QixVQUFVO3lCQUV4QnFELE1BQU1SLFFBQVEsR0FBRzdDLFVBQVU7b0JBQy9CO2dCQUNKO1lBQ0o7UUFDUixPQUNLO1lBQ0RxRCxNQUFNNUUsS0FBSyxHQUFHLEVBQUUsWUFBWTtZQUM1QjRFLE1BQU01RixHQUFHLEdBQUcsSUFBSSxDQUFDcUIsTUFBTSxDQUFDZ0YsT0FBTyxDQUFDekksUUFBUTtRQUM1QztJQUNKO0lBQ0F5TyxVQUFVaE8sTUFBTSxFQUFFdUgsS0FBSyxFQUFFNUYsR0FBRyxFQUFFSSxLQUFLLEVBQUU7UUFDakMsOEJBQThCO1FBQzlCLElBQUssSUFBSTFDLElBQUksR0FBR0EsSUFBSTBDLE9BQU8xQyxLQUFLLEVBQzVCLElBQUksSUFBSSxDQUFDNk4sT0FBTyxDQUFDN04sRUFBRSxJQUFJVyxRQUNuQixPQUFPK0I7UUFDZixJQUFJLENBQUNtTCxPQUFPLENBQUNuTCxRQUFRLEdBQUcvQjtRQUN4QixJQUFJLENBQUNrTixPQUFPLENBQUNuTCxRQUFRLEdBQUd3RjtRQUN4QixJQUFJLENBQUMyRixPQUFPLENBQUNuTCxRQUFRLEdBQUdKO1FBQ3hCLE9BQU9JO0lBQ1g7SUFDQTRMLFdBQVduUCxLQUFLLEVBQUUrSSxLQUFLLEVBQUU1RixHQUFHLEVBQUVJLEtBQUssRUFBRTtRQUNqQyxJQUFJLEVBQUV0RCxLQUFLLEVBQUUsR0FBR0QsT0FBTyxFQUFFaUIsTUFBTSxFQUFFLEdBQUdqQixNQUFNRCxDQUFDLEVBQUUsRUFBRXlHLElBQUksRUFBRSxHQUFHdkY7UUFDeEQsSUFBSyxJQUFJd08sTUFBTSxHQUFHQSxNQUFNLEdBQUdBLE1BQU87WUFDOUIsSUFBSyxJQUFJNU8sSUFBSUksT0FBT2lFLFNBQVMsQ0FBQ2pGLE9BQU93UCxNQUFNLEVBQUUsbUJBQW1CLE1BQUssRUFBRSxzQkFBc0IsT0FBTTVPLEtBQUssRUFBRztnQkFDdkcsSUFBSTJGLElBQUksQ0FBQzNGLEVBQUUsSUFBSSxNQUFNLFdBQVcsS0FBSTtvQkFDaEMsSUFBSTJGLElBQUksQ0FBQzNGLElBQUksRUFBRSxJQUFJLEVBQUUsWUFBWSxLQUFJO3dCQUNqQ0EsSUFBSTZPLEtBQUtsSixNQUFNM0YsSUFBSTtvQkFDdkIsT0FDSzt3QkFDRCxJQUFJMEMsU0FBUyxLQUFLaUQsSUFBSSxDQUFDM0YsSUFBSSxFQUFFLElBQUksRUFBRSxhQUFhLEtBQzVDMEMsUUFBUSxJQUFJLENBQUNpTSxTQUFTLENBQUNFLEtBQUtsSixNQUFNM0YsSUFBSSxJQUFJa0ksT0FBTzVGLEtBQUtJO3dCQUMxRDtvQkFDSjtnQkFDSjtnQkFDQSxJQUFJaUQsSUFBSSxDQUFDM0YsRUFBRSxJQUFJa0ksT0FDWHhGLFFBQVEsSUFBSSxDQUFDaU0sU0FBUyxDQUFDRSxLQUFLbEosTUFBTTNGLElBQUksSUFBSWtJLE9BQU81RixLQUFLSTtZQUM5RDtRQUNKO1FBQ0EsT0FBT0E7SUFDWDtBQUNKO0FBQ0EsTUFBTW9NO0lBQ0Y3UCxZQUFZbUIsTUFBTSxFQUFFNkcsS0FBSyxFQUFFNEYsU0FBUyxFQUFFckwsTUFBTSxDQUFFO1FBQzFDLElBQUksQ0FBQ3BCLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUM2RyxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDekYsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ3VOLFVBQVUsR0FBRztRQUNsQixJQUFJLENBQUNDLFdBQVcsR0FBRyxRQUFRLDJDQUEyQztRQUN0RSxJQUFJLENBQUNDLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUMxTCxNQUFNLEdBQUcsRUFBRTtRQUNoQixJQUFJLENBQUMyTCxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDcE4scUJBQXFCLEdBQUcsQ0FBQztRQUM5QixJQUFJLENBQUNFLG9CQUFvQixHQUFHO1FBQzVCLElBQUksQ0FBQ0QsaUJBQWlCLEdBQUc7UUFDekIsSUFBSSxDQUFDNEIsTUFBTSxHQUFHLElBQUlrRSxZQUFZWixPQUFPekY7UUFDckMsSUFBSSxDQUFDbU0sTUFBTSxHQUFHLElBQUlELFdBQVd0TixRQUFRLElBQUksQ0FBQ3VELE1BQU07UUFDaEQsSUFBSSxDQUFDd0wsT0FBTyxHQUFHL08sT0FBT3FDLEdBQUcsQ0FBQyxFQUFFO1FBQzVCLElBQUksRUFBRWhCLElBQUksRUFBRSxHQUFHRCxNQUFNLENBQUMsRUFBRTtRQUN4QixJQUFJLENBQUM0TixNQUFNLEdBQUc7WUFBQ3BRLE1BQU1rQixLQUFLLENBQUMsSUFBSSxFQUFFRSxPQUFPcUMsR0FBRyxDQUFDLEVBQUUsRUFBRWhCO1NBQU07UUFDdEQsSUFBSSxDQUFDb0wsU0FBUyxHQUFHQSxVQUFVcE0sTUFBTSxJQUFJLElBQUksQ0FBQ2tELE1BQU0sQ0FBQ3JCLEdBQUcsR0FBR2IsT0FBT3JCLE9BQU9pUCxZQUFZLEdBQUcsSUFDOUUsSUFBSXpDLGVBQWVDLFdBQVd6TSxPQUFPdUIsT0FBTyxJQUFJO0lBQzFEO0lBQ0EsSUFBSTJOLFlBQVk7UUFDWixPQUFPLElBQUksQ0FBQ0wsV0FBVztJQUMzQjtJQUNBLGlFQUFpRTtJQUNqRSxrRUFBa0U7SUFDbEUsa0VBQWtFO0lBQ2xFLEVBQUU7SUFDRixtRUFBbUU7SUFDbkUsMEJBQTBCO0lBQzFCekYsVUFBVTtRQUNOLElBQUk0RixTQUFTLElBQUksQ0FBQ0EsTUFBTSxFQUFFOVAsTUFBTSxJQUFJLENBQUMyUCxXQUFXO1FBQ2hELHNDQUFzQztRQUN0QyxJQUFJTSxZQUFZLElBQUksQ0FBQ0gsTUFBTSxHQUFHLEVBQUU7UUFDaEMsSUFBSUksU0FBU0M7UUFDYiwrREFBK0Q7UUFDL0QsK0RBQStEO1FBQy9ELHFEQUFxRDtRQUNyRCw2REFBNkQ7UUFDN0QsaUVBQWlFO1FBQ2pFLHVEQUF1RDtRQUN2RCxvREFBb0Q7UUFDcEQsSUFBSSxJQUFJLENBQUMxTixpQkFBaUIsR0FBRyxJQUFJLHdDQUF3QyxPQUFNcU4sT0FBTzNPLE1BQU0sSUFBSSxHQUFHO1lBQy9GLElBQUksQ0FBQ2lFLEVBQUUsR0FBRzBLO1lBQ1YsTUFBTzFLLEVBQUVJLFdBQVcsTUFBTUosRUFBRXZGLEtBQUssQ0FBQ3NCLE1BQU0sSUFBSWlFLEVBQUV2RixLQUFLLENBQUN1RixFQUFFdkYsS0FBSyxDQUFDc0IsTUFBTSxHQUFHLEVBQUUsSUFBSSxJQUFJLENBQUNxQixxQkFBcUIsQ0FBRSxDQUFFO1lBQ3pHLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUcsSUFBSSxDQUFDQyxvQkFBb0IsR0FBRztRQUN6RDtRQUNBLDREQUE0RDtRQUM1RCw0REFBNEQ7UUFDNUQsaUNBQWlDO1FBQ2pDLElBQUssSUFBSWhDLElBQUksR0FBR0EsSUFBSW9QLE9BQU8zTyxNQUFNLEVBQUVULElBQUs7WUFDcEMsSUFBSWIsUUFBUWlRLE1BQU0sQ0FBQ3BQLEVBQUU7WUFDckIsT0FBUztnQkFDTCxJQUFJLENBQUMyTixNQUFNLENBQUNDLFNBQVMsR0FBRztnQkFDeEIsSUFBSXpPLE1BQU1HLEdBQUcsR0FBR0EsS0FBSztvQkFDakJpUSxVQUFVL08sSUFBSSxDQUFDckI7Z0JBQ25CLE9BQ0ssSUFBSSxJQUFJLENBQUN1USxZQUFZLENBQUN2USxPQUFPb1EsV0FBV0gsU0FBUztvQkFDbEQ7Z0JBQ0osT0FDSztvQkFDRCxJQUFJLENBQUNJLFNBQVM7d0JBQ1ZBLFVBQVUsRUFBRTt3QkFDWkMsZ0JBQWdCLEVBQUU7b0JBQ3RCO29CQUNBRCxRQUFRaFAsSUFBSSxDQUFDckI7b0JBQ2IsSUFBSXdRLE1BQU0sSUFBSSxDQUFDaEMsTUFBTSxDQUFDYSxZQUFZLENBQUNyUDtvQkFDbkNzUSxjQUFjalAsSUFBSSxDQUFDbVAsSUFBSXJNLEtBQUssRUFBRXFNLElBQUlyTixHQUFHO2dCQUN6QztnQkFDQTtZQUNKO1FBQ0o7UUFDQSxJQUFJLENBQUNpTixVQUFVOU8sTUFBTSxFQUFFO1lBQ25CLElBQUltUCxXQUFXSixXQUFXSyxhQUFhTDtZQUN2QyxJQUFJSSxVQUFVO2dCQUNWLElBQUlqRSxTQUNBbUUsUUFBUUMsR0FBRyxDQUFDLGlCQUFpQixJQUFJLENBQUNDLE9BQU8sQ0FBQ0o7Z0JBQzlDLE9BQU8sSUFBSSxDQUFDSyxXQUFXLENBQUNMO1lBQzVCO1lBQ0EsSUFBSSxJQUFJLENBQUN4UCxNQUFNLENBQUNxRyxNQUFNLEVBQUU7Z0JBQ3BCLElBQUlrRixXQUFXNkQsU0FDWE0sUUFBUUMsR0FBRyxDQUFDLHNCQUF1QixLQUFJLENBQUNwQyxNQUFNLENBQUNDLFNBQVMsR0FBRyxJQUFJLENBQUN4TixNQUFNLENBQUM4UCxPQUFPLENBQUMsSUFBSSxDQUFDdkMsTUFBTSxDQUFDQyxTQUFTLENBQUN0SyxLQUFLLElBQUksTUFBSztnQkFDdkgsTUFBTSxJQUFJNk0sWUFBWSxpQkFBaUI3UTtZQUMzQztZQUNBLElBQUksQ0FBQyxJQUFJLENBQUN5UCxVQUFVLEVBQ2hCLElBQUksQ0FBQ0EsVUFBVSxHQUFHLEVBQUUsZ0JBQWdCO1FBQzVDO1FBQ0EsSUFBSSxJQUFJLENBQUNBLFVBQVUsSUFBSVMsU0FBUztZQUM1QixJQUFJSSxXQUFXLElBQUksQ0FBQ1YsU0FBUyxJQUFJLFFBQVFNLE9BQU8sQ0FBQyxFQUFFLENBQUNsUSxHQUFHLEdBQUcsSUFBSSxDQUFDNFAsU0FBUyxHQUFHTSxPQUFPLENBQUMsRUFBRSxHQUMvRSxJQUFJLENBQUNZLFdBQVcsQ0FBQ1osU0FBU0MsZUFBZUY7WUFDL0MsSUFBSUssVUFBVTtnQkFDVixJQUFJakUsU0FDQW1FLFFBQVFDLEdBQUcsQ0FBQyxrQkFBa0IsSUFBSSxDQUFDQyxPQUFPLENBQUNKO2dCQUMvQyxPQUFPLElBQUksQ0FBQ0ssV0FBVyxDQUFDTCxTQUFTbkssUUFBUTtZQUM3QztRQUNKO1FBQ0EsSUFBSSxJQUFJLENBQUNzSixVQUFVLEVBQUU7WUFDakIsSUFBSXNCLGVBQWUsSUFBSSxDQUFDdEIsVUFBVSxJQUFJLElBQUksSUFBSSxJQUFJLENBQUNBLFVBQVUsR0FBRyxFQUFFLDJCQUEyQjtZQUM3RixJQUFJUSxVQUFVOU8sTUFBTSxHQUFHNFAsY0FBYztnQkFDakNkLFVBQVVlLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNQSxFQUFFalIsS0FBSyxHQUFHZ1IsRUFBRWhSLEtBQUs7Z0JBQzFDLE1BQU9nUSxVQUFVOU8sTUFBTSxHQUFHNFAsYUFDdEJkLFVBQVVuTixHQUFHO1lBQ3JCO1lBQ0EsSUFBSW1OLFVBQVU1SyxJQUFJLENBQUNELENBQUFBLElBQUtBLEVBQUVyRixTQUFTLEdBQUdDLE1BQ2xDLElBQUksQ0FBQ3lQLFVBQVU7UUFDdkIsT0FDSyxJQUFJUSxVQUFVOU8sTUFBTSxHQUFHLEdBQUc7WUFDM0IsNkRBQTZEO1lBQzdELGdFQUFnRTtZQUNoRSx3REFBd0Q7WUFDeERnUSxPQUFPLElBQUssSUFBSXpRLElBQUksR0FBR0EsSUFBSXVQLFVBQVU5TyxNQUFNLEdBQUcsR0FBR1QsSUFBSztnQkFDbEQsSUFBSWIsUUFBUW9RLFNBQVMsQ0FBQ3ZQLEVBQUU7Z0JBQ3hCLElBQUssSUFBSTBRLElBQUkxUSxJQUFJLEdBQUcwUSxJQUFJbkIsVUFBVTlPLE1BQU0sRUFBRWlRLElBQUs7b0JBQzNDLElBQUk1SyxRQUFReUosU0FBUyxDQUFDbUIsRUFBRTtvQkFDeEIsSUFBSXZSLE1BQU0wRyxTQUFTLENBQUNDLFVBQ2hCM0csTUFBTUssTUFBTSxDQUFDaUIsTUFBTSxHQUFHLElBQUksNEJBQTRCLE9BQU1xRixNQUFNdEcsTUFBTSxDQUFDaUIsTUFBTSxHQUFHLElBQUksNEJBQTRCLEtBQUk7d0JBQ3RILElBQUksQ0FBQyxNQUFPbEIsS0FBSyxHQUFHdUcsTUFBTXZHLEtBQUssSUFBTUosTUFBTUssTUFBTSxDQUFDaUIsTUFBTSxHQUFHcUYsTUFBTXRHLE1BQU0sQ0FBQ2lCLE1BQU0sSUFBSyxHQUFHOzRCQUNsRjhPLFVBQVVvQixNQUFNLENBQUNELEtBQUs7d0JBQzFCLE9BQ0s7NEJBQ0RuQixVQUFVb0IsTUFBTSxDQUFDM1EsS0FBSzs0QkFDdEIsU0FBU3lRO3dCQUNiO29CQUNKO2dCQUNKO1lBQ0o7WUFDQSxJQUFJbEIsVUFBVTlPLE1BQU0sR0FBRyxHQUFHLHFCQUFxQixLQUMzQzhPLFVBQVVvQixNQUFNLENBQUMsR0FBRyxxQkFBcUIsS0FBSXBCLFVBQVU5TyxNQUFNLEdBQUcsR0FBRyxxQkFBcUI7UUFDaEc7UUFDQSxJQUFJLENBQUN3TyxXQUFXLEdBQUdNLFNBQVMsQ0FBQyxFQUFFLENBQUNqUSxHQUFHO1FBQ25DLElBQUssSUFBSVUsSUFBSSxHQUFHQSxJQUFJdVAsVUFBVTlPLE1BQU0sRUFBRVQsSUFDbEMsSUFBSXVQLFNBQVMsQ0FBQ3ZQLEVBQUUsQ0FBQ1YsR0FBRyxHQUFHLElBQUksQ0FBQzJQLFdBQVcsRUFDbkMsSUFBSSxDQUFDQSxXQUFXLEdBQUdNLFNBQVMsQ0FBQ3ZQLEVBQUUsQ0FBQ1YsR0FBRztRQUMzQyxPQUFPO0lBQ1g7SUFDQXNSLE9BQU90UixHQUFHLEVBQUU7UUFDUixJQUFJLElBQUksQ0FBQzRQLFNBQVMsSUFBSSxRQUFRLElBQUksQ0FBQ0EsU0FBUyxHQUFHNVAsS0FDM0MsTUFBTSxJQUFJNkosV0FBVztRQUN6QixJQUFJLENBQUMrRixTQUFTLEdBQUc1UDtJQUNyQjtJQUNBLGdFQUFnRTtJQUNoRSw4REFBOEQ7SUFDOUQsb0VBQW9FO0lBQ3BFLDREQUE0RDtJQUM1RG9RLGFBQWF2USxLQUFLLEVBQUVpUSxNQUFNLEVBQUV2TCxLQUFLLEVBQUU7UUFDL0IsSUFBSTNELFFBQVFmLE1BQU1HLEdBQUcsRUFBRSxFQUFFYyxNQUFNLEVBQUUsR0FBRyxJQUFJO1FBQ3hDLElBQUltQixPQUFPb0ssVUFBVSxJQUFJLENBQUNxRSxPQUFPLENBQUM3USxTQUFTLFNBQVM7UUFDcEQsSUFBSSxJQUFJLENBQUMrUCxTQUFTLElBQUksUUFBUWhQLFFBQVEsSUFBSSxDQUFDZ1AsU0FBUyxFQUNoRCxPQUFPL1AsTUFBTTJGLFdBQVcsS0FBSzNGLFFBQVE7UUFDekMsSUFBSSxJQUFJLENBQUMwTixTQUFTLEVBQUU7WUFDaEIsSUFBSWdFLFdBQVcxUixNQUFNTyxVQUFVLElBQUlQLE1BQU1PLFVBQVUsQ0FBQytELE9BQU8sQ0FBQ2dELE1BQU0sRUFBRXFLLFNBQVNELFdBQVcxUixNQUFNTyxVQUFVLENBQUMyRyxJQUFJLEdBQUc7WUFDaEgsSUFBSyxJQUFJMEssU0FBUyxJQUFJLENBQUNsRSxTQUFTLENBQUNTLE1BQU0sQ0FBQ3BOLFFBQVE2USxRQUFTO2dCQUNyRCxJQUFJQyxRQUFRLElBQUksQ0FBQzVRLE1BQU0sQ0FBQ3VCLE9BQU8sQ0FBQ0MsS0FBSyxDQUFDbVAsT0FBT2pRLElBQUksQ0FBQ2dHLEVBQUUsQ0FBQyxJQUFJaUssT0FBT2pRLElBQUksR0FBR1YsT0FBT2UsT0FBTyxDQUFDaEMsTUFBTUMsS0FBSyxFQUFFMlIsT0FBT2pRLElBQUksQ0FBQ2dHLEVBQUUsSUFBSSxDQUFDO2dCQUN0SCxJQUFJa0ssUUFBUSxDQUFDLEtBQUtELE9BQU90USxNQUFNLElBQUssRUFBQ29RLFlBQVksQ0FBQ0UsT0FBT3RELElBQUksQ0FBQy9PLG1EQUFRQSxDQUFDdVMsV0FBVyxLQUFLLE1BQU1ILE1BQUssR0FBSTtvQkFDbEczUixNQUFNa0UsT0FBTyxDQUFDME4sUUFBUUM7b0JBQ3RCLElBQUlyRixTQUNBbUUsUUFBUUMsR0FBRyxDQUFDeE8sT0FBTyxJQUFJLENBQUN5TyxPQUFPLENBQUM3USxTQUFTLENBQUMsZUFBZSxFQUFFaUIsT0FBTzhQLE9BQU8sQ0FBQ2EsT0FBT2pRLElBQUksQ0FBQ2dHLEVBQUUsRUFBRSxDQUFDLENBQUM7b0JBQ2hHLE9BQU87Z0JBQ1g7Z0JBQ0EsSUFBSSxDQUFFaUssQ0FBQUEsa0JBQWtCalMsK0NBQUcsS0FBTWlTLE9BQU94RCxRQUFRLENBQUM5TSxNQUFNLElBQUksS0FBS3NRLE9BQU92RCxTQUFTLENBQUMsRUFBRSxHQUFHLEdBQ2xGO2dCQUNKLElBQUkwRCxRQUFRSCxPQUFPeEQsUUFBUSxDQUFDLEVBQUU7Z0JBQzlCLElBQUkyRCxpQkFBaUJwUywrQ0FBSUEsSUFBSWlTLE9BQU92RCxTQUFTLENBQUMsRUFBRSxJQUFJLEdBQ2hEdUQsU0FBU0c7cUJBRVQ7WUFDUjtRQUNKO1FBQ0EsSUFBSUMsZ0JBQWdCL1EsT0FBT2lFLFNBQVMsQ0FBQ2xGLE1BQU1DLEtBQUssRUFBRSxFQUFFLDRCQUE0QjtRQUNoRixJQUFJK1IsZ0JBQWdCLEdBQUc7WUFDbkJoUyxNQUFNdUIsTUFBTSxDQUFDeVE7WUFDYixJQUFJeEYsU0FDQW1FLFFBQVFDLEdBQUcsQ0FBQ3hPLE9BQU8sSUFBSSxDQUFDeU8sT0FBTyxDQUFDN1EsU0FBUyxDQUFDLG9CQUFvQixFQUFFaUIsT0FBTzhQLE9BQU8sQ0FBQ2lCLGdCQUFnQixNQUFNLG9CQUFvQixLQUFJLENBQUMsQ0FBQztZQUNuSSxPQUFPO1FBQ1g7UUFDQSxJQUFJaFMsTUFBTUEsS0FBSyxDQUFDc0IsTUFBTSxJQUFJLEtBQUssZ0JBQWdCLEtBQUk7WUFDL0MsTUFBT3RCLE1BQU1BLEtBQUssQ0FBQ3NCLE1BQU0sR0FBRyxLQUFLLGFBQWEsT0FBTXRCLE1BQU0yRixXQUFXLEdBQUksQ0FBRTtRQUMvRTtRQUNBLElBQUkrSSxVQUFVLElBQUksQ0FBQ0YsTUFBTSxDQUFDSyxVQUFVLENBQUM3TztRQUNyQyxJQUFLLElBQUlhLElBQUksR0FBR0EsSUFBSTZOLFFBQVFwTixNQUFNLEVBQUc7WUFDakMsSUFBSUUsU0FBU2tOLE9BQU8sQ0FBQzdOLElBQUksRUFBRXFDLE9BQU93TCxPQUFPLENBQUM3TixJQUFJLEVBQUVzQyxNQUFNdUwsT0FBTyxDQUFDN04sSUFBSTtZQUNsRSxJQUFJb0csT0FBT3BHLEtBQUs2TixRQUFRcE4sTUFBTSxJQUFJLENBQUNvRDtZQUNuQyxJQUFJdU4sYUFBYWhMLE9BQU9qSCxRQUFRQSxNQUFNMEUsS0FBSztZQUMzQyxJQUFJcUssT0FBTyxJQUFJLENBQUNQLE1BQU0sQ0FBQ0MsU0FBUztZQUNoQ3dELFdBQVduTyxLQUFLLENBQUN0QyxRQUFRMEIsTUFBTTZMLE9BQU9BLEtBQUtoTyxLQUFLLEdBQUdrUixXQUFXOVIsR0FBRyxFQUFFZ0Q7WUFDbkUsSUFBSXFKLFNBQ0FtRSxRQUFRQyxHQUFHLENBQUN4TyxPQUFPLElBQUksQ0FBQ3lPLE9BQU8sQ0FBQ29CLGNBQWMsQ0FBQyxNQUFNLEVBQUUsQ0FBQ3pRLFNBQVMsTUFBTSxxQkFBcUIsR0FBdkIsS0FBOEIsSUFBSSxVQUNqRyxDQUFDLFVBQVUsRUFBRVAsT0FBTzhQLE9BQU8sQ0FBQ3ZQLFNBQVMsTUFBTSxvQkFBb0IsS0FBSSxDQUFDLENBQUMsS0FBSyxFQUFFUCxPQUFPOFAsT0FBTyxDQUFDN04sTUFBTSxHQUFHLEVBQUVuQyxNQUFNLEVBQUVrUixjQUFjalMsUUFBUSxLQUFLLFVBQVUsQ0FBQyxDQUFDO1lBQy9KLElBQUlpSCxNQUNBLE9BQU87aUJBQ04sSUFBSWdMLFdBQVc5UixHQUFHLEdBQUdZLE9BQ3RCa1AsT0FBTzVPLElBQUksQ0FBQzRRO2lCQUVadk4sTUFBTXJELElBQUksQ0FBQzRRO1FBQ25CO1FBQ0EsT0FBTztJQUNYO0lBQ0Esa0VBQWtFO0lBQ2xFLGdFQUFnRTtJQUNoRSw2Q0FBNkM7SUFDN0NDLGFBQWFsUyxLQUFLLEVBQUVvUSxTQUFTLEVBQUU7UUFDM0IsSUFBSWpRLE1BQU1ILE1BQU1HLEdBQUc7UUFDbkIsT0FBUztZQUNMLElBQUksQ0FBQyxJQUFJLENBQUNvUSxZQUFZLENBQUN2USxPQUFPLE1BQU0sT0FDaEMsT0FBTztZQUNYLElBQUlBLE1BQU1HLEdBQUcsR0FBR0EsS0FBSztnQkFDakJnUyxlQUFlblMsT0FBT29RO2dCQUN0QixPQUFPO1lBQ1g7UUFDSjtJQUNKO0lBQ0FhLFlBQVloQixNQUFNLEVBQUV6QixNQUFNLEVBQUU0QixTQUFTLEVBQUU7UUFDbkMsSUFBSUssV0FBVyxNQUFNMkIsWUFBWTtRQUNqQyxJQUFLLElBQUl2UixJQUFJLEdBQUdBLElBQUlvUCxPQUFPM08sTUFBTSxFQUFFVCxJQUFLO1lBQ3BDLElBQUliLFFBQVFpUSxNQUFNLENBQUNwUCxFQUFFLEVBQUVrSSxRQUFReUYsTUFBTSxDQUFDM04sS0FBSyxFQUFFLEVBQUV3UixXQUFXN0QsTUFBTSxDQUFDLENBQUMzTixLQUFLLEtBQUssRUFBRTtZQUM5RSxJQUFJdUIsT0FBT29LLFVBQVUsSUFBSSxDQUFDcUUsT0FBTyxDQUFDN1EsU0FBUyxTQUFTO1lBQ3BELElBQUlBLE1BQU11RyxPQUFPLEVBQUU7Z0JBQ2YsSUFBSTZMLFdBQ0E7Z0JBQ0pBLFlBQVk7Z0JBQ1pwUyxNQUFNeUcsT0FBTztnQkFDYixJQUFJK0YsU0FDQW1FLFFBQVFDLEdBQUcsQ0FBQ3hPLE9BQU8sSUFBSSxDQUFDeU8sT0FBTyxDQUFDN1EsU0FBUztnQkFDN0MsSUFBSXNTLE9BQU8sSUFBSSxDQUFDSixZQUFZLENBQUNsUyxPQUFPb1E7Z0JBQ3BDLElBQUlrQyxNQUNBO1lBQ1I7WUFDQSxJQUFJQyxRQUFRdlMsTUFBTTBFLEtBQUssSUFBSThOLFlBQVlwUTtZQUN2QyxJQUFLLElBQUltUCxJQUFJLEdBQUdnQixNQUFNNU0sV0FBVyxNQUFNNEwsSUFBSSxHQUFHLHdCQUF3QixLQUFJQSxJQUFLO2dCQUMzRSxJQUFJL0UsU0FDQW1FLFFBQVFDLEdBQUcsQ0FBQzRCLFlBQVksSUFBSSxDQUFDM0IsT0FBTyxDQUFDMEIsU0FBUztnQkFDbEQsSUFBSUQsT0FBTyxJQUFJLENBQUNKLFlBQVksQ0FBQ0ssT0FBT25DO2dCQUNwQyxJQUFJa0MsTUFDQTtnQkFDSixJQUFJOUYsU0FDQWdHLFlBQVksSUFBSSxDQUFDM0IsT0FBTyxDQUFDMEIsU0FBUztZQUMxQztZQUNBLEtBQUssSUFBSUUsVUFBVXpTLE1BQU1vRixlQUFlLENBQUMyRCxPQUFRO2dCQUM3QyxJQUFJeUQsU0FDQW1FLFFBQVFDLEdBQUcsQ0FBQ3hPLE9BQU8sSUFBSSxDQUFDeU8sT0FBTyxDQUFDNEIsVUFBVTtnQkFDOUMsSUFBSSxDQUFDUCxZQUFZLENBQUNPLFFBQVFyQztZQUM5QjtZQUNBLElBQUksSUFBSSxDQUFDNUwsTUFBTSxDQUFDckIsR0FBRyxHQUFHbkQsTUFBTUcsR0FBRyxFQUFFO2dCQUM3QixJQUFJa1MsWUFBWXJTLE1BQU1HLEdBQUcsRUFBRTtvQkFDdkJrUztvQkFDQXRKLFFBQVEsRUFBRSxZQUFZO2dCQUMxQjtnQkFDQS9JLE1BQU02RSxlQUFlLENBQUNrRSxPQUFPc0o7Z0JBQzdCLElBQUk3RixTQUNBbUUsUUFBUUMsR0FBRyxDQUFDeE8sT0FBTyxJQUFJLENBQUN5TyxPQUFPLENBQUM3USxTQUFTLENBQUMscUJBQXFCLEVBQUUsSUFBSSxDQUFDaUIsTUFBTSxDQUFDOFAsT0FBTyxDQUFDaEksT0FBTyxDQUFDLENBQUM7Z0JBQ2xHb0osZUFBZW5TLE9BQU9vUTtZQUMxQixPQUNLLElBQUksQ0FBQ0ssWUFBWUEsU0FBU3JRLEtBQUssR0FBR0osTUFBTUksS0FBSyxFQUFFO2dCQUNoRHFRLFdBQVd6UTtZQUNmO1FBQ0o7UUFDQSxPQUFPeVE7SUFDWDtJQUNBLCtDQUErQztJQUMvQ0ssWUFBWTlRLEtBQUssRUFBRTtRQUNmQSxNQUFNcUgsS0FBSztRQUNYLE9BQU8xSCwrQ0FBSUEsQ0FBQytTLEtBQUssQ0FBQztZQUFFclMsUUFBUW1ILGtCQUFrQkUsTUFBTSxDQUFDMUg7WUFDakR3QyxTQUFTLElBQUksQ0FBQ3ZCLE1BQU0sQ0FBQ3VCLE9BQU87WUFDNUJtUSxPQUFPLElBQUksQ0FBQzNDLE9BQU87WUFDbkI0QyxpQkFBaUIsSUFBSSxDQUFDM1IsTUFBTSxDQUFDaVAsWUFBWTtZQUN6QzlMLFFBQVEsSUFBSSxDQUFDQSxNQUFNO1lBQ25CckQsT0FBTyxJQUFJLENBQUNzQixNQUFNLENBQUMsRUFBRSxDQUFDQyxJQUFJO1lBQzFCaEIsUUFBUXRCLE1BQU1HLEdBQUcsR0FBRyxJQUFJLENBQUNrQyxNQUFNLENBQUMsRUFBRSxDQUFDQyxJQUFJO1lBQ3ZDdVEsZUFBZSxJQUFJLENBQUM1UixNQUFNLENBQUNnQixhQUFhO1FBQUM7SUFDakQ7SUFDQTRPLFFBQVE3USxLQUFLLEVBQUU7UUFDWCxJQUFJMkgsS0FBSyxDQUFDa0YsWUFBYUEsQ0FBQUEsV0FBVyxJQUFJaUcsT0FBTSxDQUFDLEVBQUdDLEdBQUcsQ0FBQy9TO1FBQ3BELElBQUksQ0FBQzJILElBQ0RrRixTQUFTNEMsR0FBRyxDQUFDelAsT0FBTzJILEtBQUtxTCxPQUFPQyxhQUFhLENBQUMsSUFBSSxDQUFDcEQsV0FBVztRQUNsRSxPQUFPbEksS0FBSzNIO0lBQ2hCO0FBQ0o7QUFDQSxTQUFTbVMsZUFBZW5TLEtBQUssRUFBRW9RLFNBQVM7SUFDcEMsSUFBSyxJQUFJdlAsSUFBSSxHQUFHQSxJQUFJdVAsVUFBVTlPLE1BQU0sRUFBRVQsSUFBSztRQUN2QyxJQUFJOEYsUUFBUXlKLFNBQVMsQ0FBQ3ZQLEVBQUU7UUFDeEIsSUFBSThGLE1BQU14RyxHQUFHLElBQUlILE1BQU1HLEdBQUcsSUFBSXdHLE1BQU1ELFNBQVMsQ0FBQzFHLFFBQVE7WUFDbEQsSUFBSW9RLFNBQVMsQ0FBQ3ZQLEVBQUUsQ0FBQ1QsS0FBSyxHQUFHSixNQUFNSSxLQUFLLEVBQ2hDZ1EsU0FBUyxDQUFDdlAsRUFBRSxHQUFHYjtZQUNuQjtRQUNKO0lBQ0o7SUFDQW9RLFVBQVUvTyxJQUFJLENBQUNyQjtBQUNuQjtBQUNBLE1BQU1rVDtJQUNGcFQsWUFBWXFULE1BQU0sRUFBRXBNLEtBQUssRUFBRXFNLFFBQVEsQ0FBRTtRQUNqQyxJQUFJLENBQUNELE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNwTSxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDcU0sUUFBUSxHQUFHQTtJQUNwQjtJQUNBdEgsT0FBTzVJLElBQUksRUFBRTtRQUFFLE9BQU8sQ0FBQyxJQUFJLENBQUNrUSxRQUFRLElBQUksSUFBSSxDQUFDQSxRQUFRLENBQUNsUSxLQUFLLElBQUk7SUFBRztBQUN0RTtBQUNBLE1BQU15RSxLQUFLMEwsQ0FBQUEsSUFBS0E7QUFDaEI7Ozs7Ozs7Ozs7O0FBV0EsR0FDQSxNQUFNQztJQUNGOztJQUVBLEdBQ0F4VCxZQUFZeVQsSUFBSSxDQUFFO1FBQ2QsSUFBSSxDQUFDeFMsS0FBSyxHQUFHd1MsS0FBS3hTLEtBQUs7UUFDdkIsSUFBSSxDQUFDMkMsS0FBSyxHQUFHNlAsS0FBSzdQLEtBQUssSUFBSWlFO1FBQzNCLElBQUksQ0FBQ3BHLE1BQU0sR0FBR2dTLEtBQUtoUyxNQUFNLElBQUlvRztRQUM3QixJQUFJLENBQUNwRCxLQUFLLEdBQUdnUCxLQUFLaFAsS0FBSyxJQUFJb0Q7UUFDM0IsSUFBSSxDQUFDVCxJQUFJLEdBQUdxTSxLQUFLck0sSUFBSSxJQUFLLEtBQU07UUFDaEMsSUFBSSxDQUFDSSxNQUFNLEdBQUdpTSxLQUFLak0sTUFBTSxLQUFLO0lBQ2xDO0FBQ0o7QUFDQTs7OztBQUlBLEdBQ0EsTUFBTWtNLGlCQUFpQmxVLGlEQUFNQTtJQUN6Qjs7SUFFQSxHQUNBUSxZQUFZeVQsSUFBSSxDQUFFO1FBQ2QsS0FBSztRQUNMOztRQUVBLEdBQ0EsSUFBSSxDQUFDRSxRQUFRLEdBQUcsRUFBRTtRQUNsQixJQUFJRixLQUFLRyxPQUFPLElBQUksR0FBRyxnQkFBZ0IsS0FDbkMsTUFBTSxJQUFJMUosV0FBVyxDQUFDLGdCQUFnQixFQUFFdUosS0FBS0csT0FBTyxDQUFDLGlDQUFpQyxFQUFFLEdBQUcsZ0JBQWdCLElBQUcsQ0FBQyxDQUFDO1FBQ3BILElBQUlDLFlBQVlKLEtBQUtJLFNBQVMsQ0FBQ2pQLEtBQUssQ0FBQztRQUNyQyxJQUFJLENBQUN6QyxhQUFhLEdBQUcwUixVQUFVclMsTUFBTTtRQUNyQyxJQUFLLElBQUlULElBQUksR0FBR0EsSUFBSTBTLEtBQUtLLGVBQWUsRUFBRS9TLElBQ3RDOFMsVUFBVXRTLElBQUksQ0FBQztRQUNuQixJQUFJd1MsV0FBV0MsT0FBT0MsSUFBSSxDQUFDUixLQUFLUyxRQUFRLEVBQUVwRixHQUFHLENBQUNuRSxDQUFBQSxJQUFLOEksS0FBS1MsUUFBUSxDQUFDdkosRUFBRSxDQUFDLEVBQUU7UUFDdEUsSUFBSXdKLFlBQVksRUFBRTtRQUNsQixJQUFLLElBQUlwVCxJQUFJLEdBQUdBLElBQUk4UyxVQUFVclMsTUFBTSxFQUFFVCxJQUNsQ29ULFVBQVU1UyxJQUFJLENBQUMsRUFBRTtRQUNyQixTQUFTNlMsUUFBUUMsTUFBTSxFQUFFN0YsSUFBSSxFQUFFbkssS0FBSztZQUNoQzhQLFNBQVMsQ0FBQ0UsT0FBTyxDQUFDOVMsSUFBSSxDQUFDO2dCQUFDaU47Z0JBQU1BLEtBQUs4RixXQUFXLENBQUNwQixPQUFPN087YUFBUTtRQUNsRTtRQUNBLElBQUlvUCxLQUFLVSxTQUFTLEVBQ2QsS0FBSyxJQUFJSSxZQUFZZCxLQUFLVSxTQUFTLENBQUU7WUFDakMsSUFBSTNGLE9BQU8rRixRQUFRLENBQUMsRUFBRTtZQUN0QixJQUFJLE9BQU8vRixRQUFRLFVBQ2ZBLE9BQU8vTyxtREFBUSxDQUFDK08sS0FBSztZQUN6QixJQUFLLElBQUl6TixJQUFJLEdBQUdBLElBQUl3VCxTQUFTL1MsTUFBTSxFQUFHO2dCQUNsQyxJQUFJeUMsT0FBT3NRLFFBQVEsQ0FBQ3hULElBQUk7Z0JBQ3hCLElBQUlrRCxRQUFRLEdBQUc7b0JBQ1htUSxRQUFRblEsTUFBTXVLLE1BQU0rRixRQUFRLENBQUN4VCxJQUFJO2dCQUNyQyxPQUNLO29CQUNELElBQUlzRCxRQUFRa1EsUUFBUSxDQUFDeFQsSUFBSSxDQUFDa0QsS0FBSztvQkFDL0IsSUFBSyxJQUFJd04sSUFBSSxDQUFDeE4sTUFBTXdOLElBQUksR0FBR0EsSUFDdkIyQyxRQUFRRyxRQUFRLENBQUN4VCxJQUFJLEVBQUV5TixNQUFNbks7b0JBQ2pDdEQ7Z0JBQ0o7WUFDSjtRQUNKO1FBQ0osSUFBSSxDQUFDMkIsT0FBTyxHQUFHLElBQUloRCxrREFBT0EsQ0FBQ21VLFVBQVUvRSxHQUFHLENBQUMsQ0FBQzBGLE1BQU16VCxJQUFNcEIsbURBQVFBLENBQUM4VSxNQUFNLENBQUM7Z0JBQ2xFRCxNQUFNelQsS0FBSyxJQUFJLENBQUNvQixhQUFhLEdBQUd1UyxZQUFZRjtnQkFDNUMzTSxJQUFJOUc7Z0JBQ0o0VCxPQUFPUixTQUFTLENBQUNwVCxFQUFFO2dCQUNuQnlDLEtBQUt1USxTQUFTYSxPQUFPLENBQUM3VCxLQUFLLENBQUM7Z0JBQzVCOFQsT0FBTzlULEtBQUs7Z0JBQ1p3SyxTQUFTa0ksS0FBS3FCLFlBQVksSUFBSXJCLEtBQUtxQixZQUFZLENBQUNGLE9BQU8sQ0FBQzdULEtBQUssQ0FBQztZQUNsRTtRQUNBLElBQUkwUyxLQUFLc0IsV0FBVyxFQUNoQixJQUFJLENBQUNyUyxPQUFPLEdBQUcsSUFBSSxDQUFDQSxPQUFPLENBQUN5SSxNQUFNLElBQUlzSSxLQUFLc0IsV0FBVztRQUMxRCxJQUFJLENBQUN2TixNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUM0SSxZQUFZLEdBQUd4USw4REFBbUJBO1FBQ3ZDLElBQUlvVixhQUFhak4sWUFBWTBMLEtBQUt3QixTQUFTO1FBQzNDLElBQUksQ0FBQzdULE9BQU8sR0FBR3FTLEtBQUtyUyxPQUFPO1FBQzNCLElBQUksQ0FBQzhULGdCQUFnQixHQUFHekIsS0FBS2pFLFdBQVcsSUFBSSxFQUFFO1FBQzlDLElBQUksQ0FBQ0EsV0FBVyxHQUFHLElBQUl0SCxZQUFZLElBQUksQ0FBQ2dOLGdCQUFnQixDQUFDMVQsTUFBTTtRQUMvRCxJQUFLLElBQUlULElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNtVSxnQkFBZ0IsQ0FBQzFULE1BQU0sRUFBRVQsSUFDOUMsSUFBSSxDQUFDeU8sV0FBVyxDQUFDek8sRUFBRSxHQUFHLElBQUksQ0FBQ21VLGdCQUFnQixDQUFDblUsRUFBRSxDQUFDcUMsSUFBSTtRQUN2RCxJQUFJLENBQUNxTSxZQUFZLEdBQUcsSUFBSSxDQUFDeUYsZ0JBQWdCLENBQUNwRyxHQUFHLENBQUNxRztRQUM5QyxJQUFJLENBQUNDLE1BQU0sR0FBR3JOLFlBQVkwTCxLQUFLMkIsTUFBTSxFQUFFQztRQUN2QyxJQUFJLENBQUMzTyxJQUFJLEdBQUdxQixZQUFZMEwsS0FBSzZCLFNBQVM7UUFDdEMsSUFBSSxDQUFDN04sSUFBSSxHQUFHTSxZQUFZMEwsS0FBS2hNLElBQUk7UUFDakMsSUFBSSxDQUFDOE4sT0FBTyxHQUFHOUIsS0FBSzhCLE9BQU87UUFDM0IsSUFBSSxDQUFDMUcsVUFBVSxHQUFHNEUsS0FBSzVFLFVBQVUsQ0FBQ0MsR0FBRyxDQUFDekssQ0FBQUEsUUFBUyxPQUFPQSxTQUFTLFdBQVcsSUFBSXdHLFdBQVdtSyxZQUFZM1EsU0FBU0E7UUFDOUcsSUFBSSxDQUFDNlAsUUFBUSxHQUFHVCxLQUFLUyxRQUFRO1FBQzdCLElBQUksQ0FBQ3NCLFFBQVEsR0FBRy9CLEtBQUsrQixRQUFRLElBQUksQ0FBQztRQUNsQyxJQUFJLENBQUNDLGtCQUFrQixHQUFHaEMsS0FBS2dDLGtCQUFrQixJQUFJO1FBQ3JELElBQUksQ0FBQzFLLGNBQWMsR0FBRzBJLEtBQUtpQyxTQUFTO1FBQ3BDLElBQUksQ0FBQ0MsU0FBUyxHQUFHbEMsS0FBS2tDLFNBQVMsSUFBSTtRQUNuQyxJQUFJLENBQUM3UixPQUFPLEdBQUcsSUFBSSxDQUFDcEIsT0FBTyxDQUFDQyxLQUFLLENBQUNuQixNQUFNLEdBQUc7UUFDM0MsSUFBSSxDQUFDd0YsT0FBTyxHQUFHLElBQUksQ0FBQzRPLFlBQVk7UUFDaEMsSUFBSSxDQUFDcFMsR0FBRyxHQUFHLElBQUksQ0FBQzBRLFFBQVEsQ0FBQ0YsT0FBT0MsSUFBSSxDQUFDLElBQUksQ0FBQ0MsUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDO0lBQzNEO0lBQ0EyQixZQUFZN04sS0FBSyxFQUFFNEYsU0FBUyxFQUFFckwsTUFBTSxFQUFFO1FBQ2xDLElBQUl1VCxRQUFRLElBQUlqRyxNQUFNLElBQUksRUFBRTdILE9BQU80RixXQUFXckw7UUFDOUMsS0FBSyxJQUFJd1QsS0FBSyxJQUFJLENBQUNwQyxRQUFRLENBQ3ZCbUMsUUFBUUMsRUFBRUQsT0FBTzlOLE9BQU80RixXQUFXckw7UUFDdkMsT0FBT3VUO0lBQ1g7SUFDQTs7SUFFQSxHQUNBNVQsUUFBUS9CLEtBQUssRUFBRWlELElBQUksRUFBRTRTLFFBQVEsS0FBSyxFQUFFO1FBQ2hDLElBQUlDLFFBQVEsSUFBSSxDQUFDeE8sSUFBSTtRQUNyQixJQUFJckUsUUFBUTZTLEtBQUssQ0FBQyxFQUFFLEVBQ2hCLE9BQU8sQ0FBQztRQUNaLElBQUssSUFBSTVWLE1BQU00VixLQUFLLENBQUM3UyxPQUFPLEVBQUUsR0FBSTtZQUM5QixJQUFJOFMsV0FBV0QsS0FBSyxDQUFDNVYsTUFBTSxFQUFFOEcsT0FBTytPLFdBQVc7WUFDL0MsSUFBSW5RLFNBQVNrUSxLQUFLLENBQUM1VixNQUFNO1lBQ3pCLElBQUk4RyxRQUFRNk8sT0FDUixPQUFPalE7WUFDWCxJQUFLLElBQUkxQyxNQUFNaEQsTUFBTzZWLENBQUFBLFlBQVksSUFBSTdWLE1BQU1nRCxLQUFLaEQsTUFDN0MsSUFBSTRWLEtBQUssQ0FBQzVWLElBQUksSUFBSUYsT0FDZCxPQUFPNEY7WUFDZixJQUFJb0IsTUFDQSxPQUFPLENBQUM7UUFDaEI7SUFDSjtJQUNBOztJQUVBLEdBQ0E5QixVQUFVbEYsS0FBSyxFQUFFZ1csUUFBUSxFQUFFO1FBQ3ZCLElBQUl6UCxPQUFPLElBQUksQ0FBQ0EsSUFBSTtRQUNwQixJQUFLLElBQUlpSixNQUFNLEdBQUdBLE1BQU0sR0FBR0EsTUFBTztZQUM5QixJQUFLLElBQUk1TyxJQUFJLElBQUksQ0FBQ3FFLFNBQVMsQ0FBQ2pGLE9BQU93UCxNQUFNLEVBQUUsbUJBQW1CLE1BQUssRUFBRSxzQkFBc0IsTUFBSzFMLE9BQU9sRCxLQUFLLEVBQUc7Z0JBQzNHLElBQUksQ0FBQ2tELE9BQU95QyxJQUFJLENBQUMzRixFQUFFLEtBQUssTUFBTSxXQUFXLEtBQUk7b0JBQ3pDLElBQUkyRixJQUFJLENBQUMzRixJQUFJLEVBQUUsSUFBSSxFQUFFLFlBQVksS0FDN0JrRCxPQUFPeUMsSUFBSSxDQUFDM0YsSUFBSTZPLEtBQUtsSixNQUFNM0YsSUFBSSxHQUFHO3lCQUNqQyxJQUFJMkYsSUFBSSxDQUFDM0YsSUFBSSxFQUFFLElBQUksRUFBRSxhQUFhLEtBQ25DLE9BQU82TyxLQUFLbEosTUFBTTNGLElBQUk7eUJBRXRCO2dCQUNSO2dCQUNBLElBQUlrRCxRQUFRa1MsWUFBWWxTLFFBQVEsRUFBRSxZQUFZLEtBQzFDLE9BQU8yTCxLQUFLbEosTUFBTTNGLElBQUk7WUFDOUI7UUFDSjtRQUNBLE9BQU87SUFDWDtJQUNBOztJQUVBLEdBQ0FxRSxVQUFVakYsS0FBSyxFQUFFaVcsSUFBSSxFQUFFO1FBQ25CLE9BQU8sSUFBSSxDQUFDaEIsTUFBTSxDQUFDLFFBQVMsRUFBRSxtQkFBbUIsTUFBTWdCLEtBQUs7SUFDaEU7SUFDQTs7SUFFQSxHQUNBblQsVUFBVTlDLEtBQUssRUFBRWtXLElBQUksRUFBRTtRQUNuQixPQUFPLENBQUMsSUFBSSxDQUFDalIsU0FBUyxDQUFDakYsT0FBTyxFQUFFLG9CQUFvQixPQUFNa1csSUFBRyxJQUFLO0lBQ3RFO0lBQ0E7O0lBRUEsR0FDQXZRLFlBQVkzRixLQUFLLEVBQUV1QixNQUFNLEVBQUU7UUFDdkIsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDMkUsVUFBVSxDQUFDbEcsT0FBT21SLENBQUFBLElBQUtBLEtBQUs1UCxTQUFTLE9BQU87SUFDOUQ7SUFDQTs7SUFFQSxHQUNBMkUsV0FBV2xHLEtBQUssRUFBRXVCLE1BQU0sRUFBRTtRQUN0QixJQUFJNFUsUUFBUSxJQUFJLENBQUNsUixTQUFTLENBQUNqRixPQUFPLEVBQUUsNEJBQTRCO1FBQ2hFLElBQUl5RixTQUFTMFEsUUFBUTVVLE9BQU80VSxTQUFTNUI7UUFDckMsSUFBSyxJQUFJM1QsSUFBSSxJQUFJLENBQUNxRSxTQUFTLENBQUNqRixPQUFPLEVBQUUsc0JBQXNCLE1BQUt5RixVQUFVLE1BQU03RSxLQUFLLEVBQUc7WUFDcEYsSUFBSSxJQUFJLENBQUMyRixJQUFJLENBQUMzRixFQUFFLElBQUksTUFBTSxXQUFXLEtBQUk7Z0JBQ3JDLElBQUksSUFBSSxDQUFDMkYsSUFBSSxDQUFDM0YsSUFBSSxFQUFFLElBQUksRUFBRSxZQUFZLEtBQ2xDQSxJQUFJNk8sS0FBSyxJQUFJLENBQUNsSixJQUFJLEVBQUUzRixJQUFJO3FCQUV4QjtZQUNSO1lBQ0E2RSxTQUFTbEUsT0FBT2tPLEtBQUssSUFBSSxDQUFDbEosSUFBSSxFQUFFM0YsSUFBSTtRQUN4QztRQUNBLE9BQU82RTtJQUNYO0lBQ0E7OztJQUdBLEdBQ0FMLFdBQVdwRixLQUFLLEVBQUU7UUFDZCxJQUFJeUYsU0FBUyxFQUFFO1FBQ2YsSUFBSyxJQUFJN0UsSUFBSSxJQUFJLENBQUNxRSxTQUFTLENBQUNqRixPQUFPLEVBQUUsc0JBQXNCLE9BQU1ZLEtBQUssRUFBRztZQUNyRSxJQUFJLElBQUksQ0FBQzJGLElBQUksQ0FBQzNGLEVBQUUsSUFBSSxNQUFNLFdBQVcsS0FBSTtnQkFDckMsSUFBSSxJQUFJLENBQUMyRixJQUFJLENBQUMzRixJQUFJLEVBQUUsSUFBSSxFQUFFLFlBQVksS0FDbENBLElBQUk2TyxLQUFLLElBQUksQ0FBQ2xKLElBQUksRUFBRTNGLElBQUk7cUJBRXhCO1lBQ1I7WUFDQSxJQUFJLENBQUMsSUFBSSxDQUFDMkYsSUFBSSxDQUFDM0YsSUFBSSxFQUFFLEdBQUksTUFBTSxxQkFBcUIsT0FBTSxFQUFFLEtBQU0sR0FBRztnQkFDakUsSUFBSXNELFFBQVEsSUFBSSxDQUFDcUMsSUFBSSxDQUFDM0YsSUFBSSxFQUFFO2dCQUM1QixJQUFJLENBQUM2RSxPQUFPRixJQUFJLENBQUMsQ0FBQ0MsR0FBRzVFLElBQU0sSUFBSyxLQUFNNEUsS0FBS3RCLFFBQ3ZDdUIsT0FBT3JFLElBQUksQ0FBQyxJQUFJLENBQUNtRixJQUFJLENBQUMzRixFQUFFLEVBQUVzRDtZQUNsQztRQUNKO1FBQ0EsT0FBT3VCO0lBQ1g7SUFDQTs7OztJQUlBLEdBQ0EyUSxVQUFVQyxNQUFNLEVBQUU7UUFDZCw4REFBOEQ7UUFDOUQsc0NBQXNDO1FBQ3RDLElBQUlDLE9BQU96QyxPQUFPMEMsTUFBTSxDQUFDMUMsT0FBT3BNLE1BQU0sQ0FBQzhMLFNBQVMxSSxTQUFTLEdBQUcsSUFBSTtRQUNoRSxJQUFJd0wsT0FBTzdCLEtBQUssRUFDWjhCLEtBQUsvVCxPQUFPLEdBQUcsSUFBSSxDQUFDQSxPQUFPLENBQUN5SSxNQUFNLElBQUlxTCxPQUFPN0IsS0FBSztRQUN0RCxJQUFJNkIsT0FBT2hULEdBQUcsRUFBRTtZQUNaLElBQUltVCxPQUFPLElBQUksQ0FBQ3pDLFFBQVEsQ0FBQ3NDLE9BQU9oVCxHQUFHLENBQUM7WUFDcEMsSUFBSSxDQUFDbVQsTUFDRCxNQUFNLElBQUl6TSxXQUFXLENBQUMsc0JBQXNCLEVBQUVzTSxPQUFPaFQsR0FBRyxDQUFDLENBQUM7WUFDOURpVCxLQUFLalQsR0FBRyxHQUFHbVQ7UUFDZjtRQUNBLElBQUlILE9BQU8zSCxVQUFVLEVBQ2pCNEgsS0FBSzVILFVBQVUsR0FBRyxJQUFJLENBQUNBLFVBQVUsQ0FBQ0MsR0FBRyxDQUFDOEgsQ0FBQUE7WUFDbEMsSUFBSXJRLFFBQVFpUSxPQUFPM0gsVUFBVSxDQUFDZ0ksSUFBSSxDQUFDbE0sQ0FBQUEsSUFBS0EsRUFBRW5JLElBQUksSUFBSW9VO1lBQ2xELE9BQU9yUSxRQUFRQSxNQUFNOEMsRUFBRSxHQUFHdU47UUFDOUI7UUFDSixJQUFJSixPQUFPL0csWUFBWSxFQUFFO1lBQ3JCZ0gsS0FBS2hILFlBQVksR0FBRyxJQUFJLENBQUNBLFlBQVksQ0FBQzNLLEtBQUs7WUFDM0MyUixLQUFLdkIsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDQSxnQkFBZ0IsQ0FBQ3BHLEdBQUcsQ0FBQyxDQUFDckosR0FBRzFFO2dCQUNsRCxJQUFJd0YsUUFBUWlRLE9BQU8vRyxZQUFZLENBQUNvSCxJQUFJLENBQUNsTSxDQUFBQSxJQUFLQSxFQUFFbkksSUFBSSxJQUFJaUQsRUFBRXFSLFFBQVE7Z0JBQzlELElBQUksQ0FBQ3ZRLE9BQ0QsT0FBT2Q7Z0JBQ1gsSUFBSWdPLE9BQU9PLE9BQU8wQyxNQUFNLENBQUMxQyxPQUFPMEMsTUFBTSxDQUFDLENBQUMsR0FBR2pSLElBQUk7b0JBQUVxUixVQUFVdlEsTUFBTThDLEVBQUU7Z0JBQUM7Z0JBQ3BFb04sS0FBS2hILFlBQVksQ0FBQzFPLEVBQUUsR0FBR29VLGVBQWUxQjtnQkFDdEMsT0FBT0E7WUFDWDtRQUNKO1FBQ0EsSUFBSStDLE9BQU9PLGNBQWMsRUFDckJOLEtBQUtyVixPQUFPLEdBQUdvVixPQUFPTyxjQUFjO1FBQ3hDLElBQUlQLE9BQU94UCxPQUFPLEVBQ2R5UCxLQUFLelAsT0FBTyxHQUFHLElBQUksQ0FBQzRPLFlBQVksQ0FBQ1ksT0FBT3hQLE9BQU87UUFDbkQsSUFBSXdQLE9BQU9oUCxNQUFNLElBQUksTUFDakJpUCxLQUFLalAsTUFBTSxHQUFHZ1AsT0FBT2hQLE1BQU07UUFDL0IsSUFBSWdQLE9BQU9RLElBQUksRUFDWFAsS0FBSzlDLFFBQVEsR0FBRzhDLEtBQUs5QyxRQUFRLENBQUMzUyxNQUFNLENBQUN3VixPQUFPUSxJQUFJO1FBQ3BELElBQUlSLE9BQU9wRyxZQUFZLElBQUksTUFDdkJxRyxLQUFLckcsWUFBWSxHQUFHb0csT0FBT3BHLFlBQVk7UUFDM0MsT0FBT3FHO0lBQ1g7SUFDQTs7O0lBR0EsR0FDQVEsY0FBYztRQUNWLE9BQU8sSUFBSSxDQUFDdEQsUUFBUSxDQUFDblMsTUFBTSxHQUFHO0lBQ2xDO0lBQ0E7Ozs7O0lBS0EsR0FDQXlQLFFBQVE3TixJQUFJLEVBQUU7UUFDVixPQUFPLElBQUksQ0FBQ3VTLFNBQVMsR0FBRyxJQUFJLENBQUNBLFNBQVMsQ0FBQ3ZTLEtBQUssR0FBRzhQLE9BQU85UCxRQUFRLElBQUksQ0FBQ1UsT0FBTyxJQUFJLElBQUksQ0FBQ3BCLE9BQU8sQ0FBQ0MsS0FBSyxDQUFDUyxLQUFLLENBQUNvUixJQUFJLElBQUlwUjtJQUNuSDtJQUNBOzs7SUFHQSxHQUNBLElBQUlrTSxVQUFVO1FBQUUsT0FBTyxJQUFJLENBQUN4TCxPQUFPLEdBQUc7SUFBRztJQUN6Qzs7SUFFQSxHQUNBLElBQUlvVCxVQUFVO1FBQUUsT0FBTyxJQUFJLENBQUN4VSxPQUFPLENBQUNDLEtBQUssQ0FBQyxJQUFJLENBQUNhLEdBQUcsQ0FBQyxFQUFFLENBQUM7SUFBRTtJQUN4RDs7SUFFQSxHQUNBdkIsa0JBQWtCbUIsSUFBSSxFQUFFO1FBQ3BCLElBQUkrVCxPQUFPLElBQUksQ0FBQzFCLGtCQUFrQjtRQUNsQyxPQUFPMEIsUUFBUSxPQUFPLElBQUlBLElBQUksQ0FBQy9ULEtBQUssSUFBSTtJQUM1QztJQUNBOztJQUVBLEdBQ0F3UyxhQUFhNU8sT0FBTyxFQUFFO1FBQ2xCLElBQUlvUSxTQUFTcEQsT0FBT0MsSUFBSSxDQUFDLElBQUksQ0FBQ3VCLFFBQVEsR0FBR3ZPLFFBQVFtUSxPQUFPdEksR0FBRyxDQUFDLElBQU07UUFDbEUsSUFBSTlILFNBQ0EsS0FBSyxJQUFJcVEsUUFBUXJRLFFBQVFwQyxLQUFLLENBQUMsS0FBTTtZQUNqQyxJQUFJaUQsS0FBS3VQLE9BQU94QyxPQUFPLENBQUN5QztZQUN4QixJQUFJeFAsTUFBTSxHQUNOWixLQUFLLENBQUNZLEdBQUcsR0FBRztRQUNwQjtRQUNKLElBQUl5TCxXQUFXO1FBQ2YsSUFBSyxJQUFJdlMsSUFBSSxHQUFHQSxJQUFJcVcsT0FBTzVWLE1BQU0sRUFBRVQsSUFDL0IsSUFBSSxDQUFDa0csS0FBSyxDQUFDbEcsRUFBRSxFQUFFO1lBQ1gsSUFBSyxJQUFJMFEsSUFBSSxJQUFJLENBQUMrRCxRQUFRLENBQUM0QixNQUFNLENBQUNyVyxFQUFFLENBQUMsRUFBRThHLElBQUksQ0FBQ0EsS0FBSyxJQUFJLENBQUNuQixJQUFJLENBQUMrSyxJQUFJLEtBQUssTUFBTSxXQUFXLEtBQ2pGLENBQUM2QixZQUFhQSxDQUFBQSxXQUFXLElBQUlnRSxXQUFXLElBQUksQ0FBQy9CLE9BQU8sR0FBRyxFQUFDLENBQUMsQ0FBRSxDQUFDMU4sR0FBRyxHQUFHO1FBQzFFO1FBQ0osT0FBTyxJQUFJdUwsUUFBUXBNLFNBQVNDLE9BQU9xTTtJQUN2QztJQUNBOzs7SUFHQSxHQUNBLE9BQU9nQixZQUFZYixJQUFJLEVBQUU7UUFDckIsT0FBTyxJQUFJQyxTQUFTRDtJQUN4QjtBQUNKO0FBQ0EsU0FBUzdELEtBQUtsSixJQUFJLEVBQUU3QixHQUFHO0lBQUksT0FBTzZCLElBQUksQ0FBQzdCLElBQUksR0FBSTZCLElBQUksQ0FBQzdCLE1BQU0sRUFBRSxJQUFJO0FBQUs7QUFDckUsU0FBUytMLGFBQWFULE1BQU07SUFDeEIsSUFBSTNLLE9BQU87SUFDWCxLQUFLLElBQUl0RixTQUFTaVEsT0FBUTtRQUN0QixJQUFJSSxVQUFVclEsTUFBTUQsQ0FBQyxDQUFDZ1EsU0FBUztRQUMvQixJQUFJLENBQUMvUCxNQUFNRyxHQUFHLElBQUlILE1BQU1ELENBQUMsQ0FBQ3lFLE1BQU0sQ0FBQ3JCLEdBQUcsSUFBSWtOLFdBQVcsUUFBUXJRLE1BQU1HLEdBQUcsR0FBR2tRLE9BQU0sS0FDekVyUSxNQUFNRCxDQUFDLENBQUNrQixNQUFNLENBQUM4QixTQUFTLENBQUMvQyxNQUFNQyxLQUFLLEVBQUUsRUFBRSx1QkFBdUIsUUFDOUQsRUFBQ3FGLFFBQVFBLEtBQUtsRixLQUFLLEdBQUdKLE1BQU1JLEtBQUssR0FDbENrRixPQUFPdEY7SUFDZjtJQUNBLE9BQU9zRjtBQUNYO0FBQ0EsU0FBUzJQLGVBQWUxQixJQUFJO0lBQ3hCLElBQUlBLEtBQUtxRCxRQUFRLEVBQUU7UUFDZixJQUFJcE8sT0FBTytLLEtBQUt0SSxNQUFNLEdBQUcsRUFBRSxxQkFBcUIsTUFBSyxFQUFFLHlCQUF5QjtRQUNoRixPQUFPLENBQUM5RyxPQUFPbkUsUUFBVSxLQUFNNFcsUUFBUSxDQUFDelMsT0FBT25FLFVBQVUsSUFBS3dJO0lBQ2xFO0lBQ0EsT0FBTytLLEtBQUtSLEdBQUc7QUFDbkI7QUFFNEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lcmEtcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL0BsZXplci9sci9kaXN0L2luZGV4LmpzP2RkMGIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGFyc2VyLCBOb2RlUHJvcCwgTm9kZVNldCwgTm9kZVR5cGUsIERlZmF1bHRCdWZmZXJMZW5ndGgsIFRyZWUsIEl0ZXJNb2RlIH0gZnJvbSAnQGxlemVyL2NvbW1vbic7XG5cbi8qKlxuQSBwYXJzZSBzdGFjay4gVGhlc2UgYXJlIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgcGFyc2VyIHRvIHRyYWNrXG5wYXJzaW5nIHByb2dyZXNzLiBUaGV5IGFsc28gcHJvdmlkZSBzb21lIHByb3BlcnRpZXMgYW5kIG1ldGhvZHNcbnRoYXQgZXh0ZXJuYWwgY29kZSBzdWNoIGFzIGEgdG9rZW5pemVyIGNhbiB1c2UgdG8gZ2V0IGluZm9ybWF0aW9uXG5hYm91dCB0aGUgcGFyc2Ugc3RhdGUuXG4qL1xuY2xhc3MgU3RhY2sge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHBhcnNlIHRoYXQgdGhpcyBzdGFjayBpcyBwYXJ0IG9mIEBpbnRlcm5hbFxuICAgICovXG4gICAgcCwgXG4gICAgLyoqXG4gICAgSG9sZHMgc3RhdGUsIGlucHV0IHBvcywgYnVmZmVyIGluZGV4IHRyaXBsZXRzIGZvciBhbGwgYnV0IHRoZVxuICAgIHRvcCBzdGF0ZSBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YWNrLCBcbiAgICAvKipcbiAgICBUaGUgY3VycmVudCBwYXJzZSBzdGF0ZSBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRlLCBcbiAgICAvLyBUaGUgcG9zaXRpb24gYXQgd2hpY2ggdGhlIG5leHQgcmVkdWNlIHNob3VsZCB0YWtlIHBsYWNlLiBUaGlzXG4gICAgLy8gY2FuIGJlIGxlc3MgdGhhbiBgdGhpcy5wb3NgIHdoZW4gc2tpcHBlZCBleHByZXNzaW9ucyBoYXZlIGJlZW5cbiAgICAvLyBhZGRlZCB0byB0aGUgc3RhY2sgKHdoaWNoIHNob3VsZCBiZSBtb3ZlZCBvdXRzaWRlIG9mIHRoZSBuZXh0XG4gICAgLy8gcmVkdWN0aW9uKVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVkdWNlUG9zLCBcbiAgICAvKipcbiAgICBUaGUgaW5wdXQgcG9zaXRpb24gdXAgdG8gd2hpY2ggdGhpcyBzdGFjayBoYXMgcGFyc2VkLlxuICAgICovXG4gICAgcG9zLCBcbiAgICAvKipcbiAgICBUaGUgZHluYW1pYyBzY29yZSBvZiB0aGUgc3RhY2ssIGluY2x1ZGluZyBkeW5hbWljIHByZWNlZGVuY2VcbiAgICBhbmQgZXJyb3ItcmVjb3ZlcnkgcGVuYWx0aWVzXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzY29yZSwgXG4gICAgLy8gVGhlIG91dHB1dCBidWZmZXIuIEhvbGRzICh0eXBlLCBzdGFydCwgZW5kLCBzaXplKSBxdWFkc1xuICAgIC8vIHJlcHJlc2VudGluZyBub2RlcyBjcmVhdGVkIGJ5IHRoZSBwYXJzZXIsIHdoZXJlIGBzaXplYCBpc1xuICAgIC8vIGFtb3VudCBvZiBidWZmZXIgYXJyYXkgZW50cmllcyBjb3ZlcmVkIGJ5IHRoaXMgbm9kZS5cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGJ1ZmZlciwgXG4gICAgLy8gVGhlIGJhc2Ugb2Zmc2V0IG9mIHRoZSBidWZmZXIuIFdoZW4gc3RhY2tzIGFyZSBzcGxpdCwgdGhlIHNwbGl0XG4gICAgLy8gaW5zdGFuY2Ugc2hhcmVkIHRoZSBidWZmZXIgaGlzdG9yeSB3aXRoIGl0cyBwYXJlbnQgdXAgdG9cbiAgICAvLyBgYnVmZmVyQmFzZWAsIHdoaWNoIGlzIHRoZSBhYnNvbHV0ZSBvZmZzZXQgKGluY2x1ZGluZyB0aGVcbiAgICAvLyBvZmZzZXQgb2YgcHJldmlvdXMgc3BsaXRzKSBpbnRvIHRoZSBidWZmZXIgYXQgd2hpY2ggdGhpcyBzdGFja1xuICAgIC8vIHN0YXJ0cyB3cml0aW5nLlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYnVmZmVyQmFzZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjdXJDb250ZXh0LCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGxvb2tBaGVhZCA9IDAsIFxuICAgIC8vIEEgcGFyZW50IHN0YWNrIGZyb20gd2hpY2ggdGhpcyB3YXMgc3BsaXQgb2ZmLCBpZiBhbnkuIFRoaXMgaXNcbiAgICAvLyBzZXQgdXAgc28gdGhhdCBpdCBhbHdheXMgcG9pbnRzIHRvIGEgc3RhY2sgdGhhdCBoYXMgc29tZVxuICAgIC8vIGFkZGl0aW9uYWwgYnVmZmVyIGNvbnRlbnQsIG5ldmVyIHRvIGEgc3RhY2sgd2l0aCBhbiBlcXVhbFxuICAgIC8vIGBidWZmZXJCYXNlYC5cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHBhcmVudCkge1xuICAgICAgICB0aGlzLnAgPSBwO1xuICAgICAgICB0aGlzLnN0YWNrID0gc3RhY2s7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5yZWR1Y2VQb3MgPSByZWR1Y2VQb3M7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLnNjb3JlID0gc2NvcmU7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmJ1ZmZlckJhc2UgPSBidWZmZXJCYXNlO1xuICAgICAgICB0aGlzLmN1ckNvbnRleHQgPSBjdXJDb250ZXh0O1xuICAgICAgICB0aGlzLmxvb2tBaGVhZCA9IGxvb2tBaGVhZDtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgWyR7dGhpcy5zdGFjay5maWx0ZXIoKF8sIGkpID0+IGkgJSAzID09IDApLmNvbmNhdCh0aGlzLnN0YXRlKX1dQCR7dGhpcy5wb3N9JHt0aGlzLnNjb3JlID8gXCIhXCIgKyB0aGlzLnNjb3JlIDogXCJcIn1gO1xuICAgIH1cbiAgICAvLyBTdGFydCBhbiBlbXB0eSBzdGFja1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIHN0YXJ0KHAsIHN0YXRlLCBwb3MgPSAwKSB7XG4gICAgICAgIGxldCBjeCA9IHAucGFyc2VyLmNvbnRleHQ7XG4gICAgICAgIHJldHVybiBuZXcgU3RhY2socCwgW10sIHN0YXRlLCBwb3MsIHBvcywgMCwgW10sIDAsIGN4ID8gbmV3IFN0YWNrQ29udGV4dChjeCwgY3guc3RhcnQpIDogbnVsbCwgMCwgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBzdGFjaydzIGN1cnJlbnQgW2NvbnRleHRdKCNsci5Db250ZXh0VHJhY2tlcikgdmFsdWUsIGlmXG4gICAgYW55LiBJdHMgdHlwZSB3aWxsIGRlcGVuZCBvbiB0aGUgY29udGV4dCB0cmFja2VyJ3MgdHlwZVxuICAgIHBhcmFtZXRlciwgb3IgaXQgd2lsbCBiZSBgbnVsbGAgaWYgdGhlcmUgaXMgbm8gY29udGV4dFxuICAgIHRyYWNrZXIuXG4gICAgKi9cbiAgICBnZXQgY29udGV4dCgpIHsgcmV0dXJuIHRoaXMuY3VyQ29udGV4dCA/IHRoaXMuY3VyQ29udGV4dC5jb250ZXh0IDogbnVsbDsgfVxuICAgIC8vIFB1c2ggYSBzdGF0ZSBvbnRvIHRoZSBzdGFjaywgdHJhY2tpbmcgaXRzIHN0YXJ0IHBvc2l0aW9uIGFzIHdlbGxcbiAgICAvLyBhcyB0aGUgYnVmZmVyIGJhc2UgYXQgdGhhdCBwb2ludC5cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHB1c2hTdGF0ZShzdGF0ZSwgc3RhcnQpIHtcbiAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMuc3RhdGUsIHN0YXJ0LCB0aGlzLmJ1ZmZlckJhc2UgKyB0aGlzLmJ1ZmZlci5sZW5ndGgpO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgfVxuICAgIC8vIEFwcGx5IGEgcmVkdWNlIGFjdGlvblxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVkdWNlKGFjdGlvbikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBkZXB0aCA9IGFjdGlvbiA+PiAxOSAvKiBBY3Rpb24uUmVkdWNlRGVwdGhTaGlmdCAqLywgdHlwZSA9IGFjdGlvbiAmIDY1NTM1IC8qIEFjdGlvbi5WYWx1ZU1hc2sgKi87XG4gICAgICAgIGxldCB7IHBhcnNlciB9ID0gdGhpcy5wO1xuICAgICAgICBsZXQgbG9va2FoZWFkUmVjb3JkID0gdGhpcy5yZWR1Y2VQb3MgPCB0aGlzLnBvcyAtIDI1IC8qIExvb2thaGVhZC5NYXJnaW4gKi87XG4gICAgICAgIGlmIChsb29rYWhlYWRSZWNvcmQpXG4gICAgICAgICAgICB0aGlzLnNldExvb2tBaGVhZCh0aGlzLnBvcyk7XG4gICAgICAgIGxldCBkUHJlYyA9IHBhcnNlci5keW5hbWljUHJlY2VkZW5jZSh0eXBlKTtcbiAgICAgICAgaWYgKGRQcmVjKVxuICAgICAgICAgICAgdGhpcy5zY29yZSArPSBkUHJlYztcbiAgICAgICAgaWYgKGRlcHRoID09IDApIHtcbiAgICAgICAgICAgIHRoaXMucHVzaFN0YXRlKHBhcnNlci5nZXRHb3RvKHRoaXMuc3RhdGUsIHR5cGUsIHRydWUpLCB0aGlzLnJlZHVjZVBvcyk7XG4gICAgICAgICAgICAvLyBaZXJvLWRlcHRoIHJlZHVjdGlvbnMgYXJlIGEgc3BlY2lhbCBjYXNl4oCUdGhleSBhZGQgc3R1ZmYgdG9cbiAgICAgICAgICAgIC8vIHRoZSBzdGFjayB3aXRob3V0IHBvcHBpbmcgYW55dGhpbmcgb2ZmLlxuICAgICAgICAgICAgaWYgKHR5cGUgPCBwYXJzZXIubWluUmVwZWF0VGVybSlcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JlTm9kZSh0eXBlLCB0aGlzLnJlZHVjZVBvcywgdGhpcy5yZWR1Y2VQb3MsIGxvb2thaGVhZFJlY29yZCA/IDggOiA0LCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMucmVkdWNlQ29udGV4dCh0eXBlLCB0aGlzLnJlZHVjZVBvcyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluZCB0aGUgYmFzZSBpbmRleCBpbnRvIGB0aGlzLnN0YWNrYCwgY29udGVudCBhZnRlciB3aGljaCB3aWxsXG4gICAgICAgIC8vIGJlIGRyb3BwZWQuIE5vdGUgdGhhdCB3aXRoIGBTdGF5RmxhZ2AgcmVkdWN0aW9ucyB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIGNvbnN1bWUgdHdvIGV4dHJhIGZyYW1lcyAodGhlIGR1bW15IHBhcmVudCBub2RlIGZvciB0aGUgc2tpcHBlZFxuICAgICAgICAvLyBleHByZXNzaW9uIGFuZCB0aGUgc3RhdGUgdGhhdCB3ZSdsbCBiZSBzdGF5aW5nIGluLCB3aGljaCBzaG91bGRcbiAgICAgICAgLy8gYmUgbW92ZWQgdG8gYHRoaXMuc3RhdGVgKS5cbiAgICAgICAgbGV0IGJhc2UgPSB0aGlzLnN0YWNrLmxlbmd0aCAtICgoZGVwdGggLSAxKSAqIDMpIC0gKGFjdGlvbiAmIDI2MjE0NCAvKiBBY3Rpb24uU3RheUZsYWcgKi8gPyA2IDogMCk7XG4gICAgICAgIGxldCBzdGFydCA9IGJhc2UgPyB0aGlzLnN0YWNrW2Jhc2UgLSAyXSA6IHRoaXMucC5yYW5nZXNbMF0uZnJvbSwgc2l6ZSA9IHRoaXMucmVkdWNlUG9zIC0gc3RhcnQ7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBrbHVkZ2UgdG8gdHJ5IGFuZCBkZXRlY3Qgb3Zlcmx5IGRlZXAgbGVmdC1hc3NvY2lhdGl2ZVxuICAgICAgICAvLyB0cmVlcywgd2hpY2ggd2lsbCBub3QgaW5jcmVhc2UgdGhlIHBhcnNlIHN0YWNrIGRlcHRoIGFuZCB0aHVzXG4gICAgICAgIC8vIHdvbid0IGJlIGNhdWdodCBieSB0aGUgcmVndWxhciBzdGFjay1kZXB0aCBsaW1pdCBjaGVjay5cbiAgICAgICAgaWYgKHNpemUgPj0gMjAwMCAvKiBSZWNvdmVyLk1pbkJpZ1JlZHVjdGlvbiAqLyAmJiAhKChfYSA9IHRoaXMucC5wYXJzZXIubm9kZVNldC50eXBlc1t0eXBlXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzQW5vbnltb3VzKSkge1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID09IHRoaXMucC5sYXN0QmlnUmVkdWN0aW9uU3RhcnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnAuYmlnUmVkdWN0aW9uQ291bnQrKztcbiAgICAgICAgICAgICAgICB0aGlzLnAubGFzdEJpZ1JlZHVjdGlvblNpemUgPSBzaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5wLmxhc3RCaWdSZWR1Y3Rpb25TaXplIDwgc2l6ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucC5iaWdSZWR1Y3Rpb25Db3VudCA9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5wLmxhc3RCaWdSZWR1Y3Rpb25TdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIHRoaXMucC5sYXN0QmlnUmVkdWN0aW9uU2l6ZSA9IHNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJ1ZmZlckJhc2UgPSBiYXNlID8gdGhpcy5zdGFja1tiYXNlIC0gMV0gOiAwLCBjb3VudCA9IHRoaXMuYnVmZmVyQmFzZSArIHRoaXMuYnVmZmVyLmxlbmd0aCAtIGJ1ZmZlckJhc2U7XG4gICAgICAgIC8vIFN0b3JlIG5vcm1hbCB0ZXJtcyBvciBgUiAtPiBSIFJgIHJlcGVhdCByZWR1Y3Rpb25zXG4gICAgICAgIGlmICh0eXBlIDwgcGFyc2VyLm1pblJlcGVhdFRlcm0gfHwgKGFjdGlvbiAmIDEzMTA3MiAvKiBBY3Rpb24uUmVwZWF0RmxhZyAqLykpIHtcbiAgICAgICAgICAgIGxldCBwb3MgPSBwYXJzZXIuc3RhdGVGbGFnKHRoaXMuc3RhdGUsIDEgLyogU3RhdGVGbGFnLlNraXBwZWQgKi8pID8gdGhpcy5wb3MgOiB0aGlzLnJlZHVjZVBvcztcbiAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKHR5cGUsIHN0YXJ0LCBwb3MsIGNvdW50ICsgNCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGlvbiAmIDI2MjE0NCAvKiBBY3Rpb24uU3RheUZsYWcgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnN0YWNrW2Jhc2VdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGJhc2VTdGF0ZUlEID0gdGhpcy5zdGFja1tiYXNlIC0gM107XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gcGFyc2VyLmdldEdvdG8oYmFzZVN0YXRlSUQsIHR5cGUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLnN0YWNrLmxlbmd0aCA+IGJhc2UpXG4gICAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICB0aGlzLnJlZHVjZUNvbnRleHQodHlwZSwgc3RhcnQpO1xuICAgIH1cbiAgICAvLyBTaGlmdCBhIHZhbHVlIGludG8gdGhlIGJ1ZmZlclxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RvcmVOb2RlKHRlcm0sIHN0YXJ0LCBlbmQsIHNpemUgPSA0LCBtdXN0U2luayA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0ZXJtID09IDAgLyogVGVybS5FcnIgKi8gJiZcbiAgICAgICAgICAgICghdGhpcy5zdGFjay5sZW5ndGggfHwgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdIDwgdGhpcy5idWZmZXIubGVuZ3RoICsgdGhpcy5idWZmZXJCYXNlKSkge1xuICAgICAgICAgICAgLy8gVHJ5IHRvIG9taXQvbWVyZ2UgYWRqYWNlbnQgZXJyb3Igbm9kZXNcbiAgICAgICAgICAgIGxldCBjdXIgPSB0aGlzLCB0b3AgPSB0aGlzLmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodG9wID09IDAgJiYgY3VyLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHRvcCA9IGN1ci5idWZmZXJCYXNlIC0gY3VyLnBhcmVudC5idWZmZXJCYXNlO1xuICAgICAgICAgICAgICAgIGN1ciA9IGN1ci5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9wID4gMCAmJiBjdXIuYnVmZmVyW3RvcCAtIDRdID09IDAgLyogVGVybS5FcnIgKi8gJiYgY3VyLmJ1ZmZlclt0b3AgLSAxXSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID09IGVuZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChjdXIuYnVmZmVyW3RvcCAtIDJdID49IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGN1ci5idWZmZXJbdG9wIC0gMl0gPSBlbmQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtdXN0U2luayB8fCB0aGlzLnBvcyA9PSBlbmQpIHsgLy8gU2ltcGxlIGNhc2UsIGp1c3QgYXBwZW5kXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHRlcm0sIHN0YXJ0LCBlbmQsIHNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBUaGVyZSBtYXkgYmUgc2tpcHBlZCBub2RlcyB0aGF0IGhhdmUgdG8gYmUgbW92ZWQgZm9yd2FyZFxuICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gMCAmJiB0aGlzLmJ1ZmZlcltpbmRleCAtIDRdICE9IDAgLyogVGVybS5FcnIgKi8pIHtcbiAgICAgICAgICAgICAgICBsZXQgbXVzdE1vdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzY2FuID0gaW5kZXg7IHNjYW4gPiAwICYmIHRoaXMuYnVmZmVyW3NjYW4gLSAyXSA+IGVuZDsgc2NhbiAtPSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmJ1ZmZlcltzY2FuIC0gMV0gPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXVzdE1vdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG11c3RNb3ZlKVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaW5kZXggPiAwICYmIHRoaXMuYnVmZmVyW2luZGV4IC0gMl0gPiBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgdGhpcyByZWNvcmQgZm9yd2FyZFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXhdID0gdGhpcy5idWZmZXJbaW5kZXggLSA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgMV0gPSB0aGlzLmJ1ZmZlcltpbmRleCAtIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAyXSA9IHRoaXMuYnVmZmVyW2luZGV4IC0gMl07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDNdID0gdGhpcy5idWZmZXJbaW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4IC09IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2l6ZSA+IDQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZSAtPSA0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleF0gPSB0ZXJtO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAxXSA9IHN0YXJ0O1xuICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAyXSA9IGVuZDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgM10gPSBzaXplO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEFwcGx5IGEgc2hpZnQgYWN0aW9uXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzaGlmdChhY3Rpb24sIHR5cGUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKGFjdGlvbiAmIDEzMTA3MiAvKiBBY3Rpb24uR290b0ZsYWcgKi8pIHtcbiAgICAgICAgICAgIHRoaXMucHVzaFN0YXRlKGFjdGlvbiAmIDY1NTM1IC8qIEFjdGlvbi5WYWx1ZU1hc2sgKi8sIHRoaXMucG9zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYWN0aW9uICYgMjYyMTQ0IC8qIEFjdGlvbi5TdGF5RmxhZyAqLykgPT0gMCkgeyAvLyBSZWd1bGFyIHNoaWZ0XG4gICAgICAgICAgICBsZXQgbmV4dFN0YXRlID0gYWN0aW9uLCB7IHBhcnNlciB9ID0gdGhpcy5wO1xuICAgICAgICAgICAgaWYgKGVuZCA+IHRoaXMucG9zIHx8IHR5cGUgPD0gcGFyc2VyLm1heE5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IGVuZDtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlci5zdGF0ZUZsYWcobmV4dFN0YXRlLCAxIC8qIFN0YXRlRmxhZy5Ta2lwcGVkICovKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWR1Y2VQb3MgPSBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnB1c2hTdGF0ZShuZXh0U3RhdGUsIHN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuc2hpZnRDb250ZXh0KHR5cGUsIHN0YXJ0KTtcbiAgICAgICAgICAgIGlmICh0eXBlIDw9IHBhcnNlci5tYXhOb2RlKVxuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2godHlwZSwgc3RhcnQsIGVuZCwgNCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIFNoaWZ0LWFuZC1zdGF5LCB3aGljaCBtZWFucyB0aGlzIGlzIGEgc2tpcHBlZCB0b2tlblxuICAgICAgICAgICAgdGhpcy5wb3MgPSBlbmQ7XG4gICAgICAgICAgICB0aGlzLnNoaWZ0Q29udGV4dCh0eXBlLCBzdGFydCk7XG4gICAgICAgICAgICBpZiAodHlwZSA8PSB0aGlzLnAucGFyc2VyLm1heE5vZGUpXG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaCh0eXBlLCBzdGFydCwgZW5kLCA0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBcHBseSBhbiBhY3Rpb25cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGFwcGx5KGFjdGlvbiwgbmV4dCwgbmV4dFN0YXJ0LCBuZXh0RW5kKSB7XG4gICAgICAgIGlmIChhY3Rpb24gJiA2NTUzNiAvKiBBY3Rpb24uUmVkdWNlRmxhZyAqLylcbiAgICAgICAgICAgIHRoaXMucmVkdWNlKGFjdGlvbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuc2hpZnQoYWN0aW9uLCBuZXh0LCBuZXh0U3RhcnQsIG5leHRFbmQpO1xuICAgIH1cbiAgICAvLyBBZGQgYSBwcmVidWlsdCAocmV1c2VkKSBub2RlIGludG8gdGhlIGJ1ZmZlci5cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHVzZU5vZGUodmFsdWUsIG5leHQpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5wLnJldXNlZC5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IHRoaXMucC5yZXVzZWRbaW5kZXhdICE9IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnAucmV1c2VkLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnBvcztcbiAgICAgICAgdGhpcy5yZWR1Y2VQb3MgPSB0aGlzLnBvcyA9IHN0YXJ0ICsgdmFsdWUubGVuZ3RoO1xuICAgICAgICB0aGlzLnB1c2hTdGF0ZShuZXh0LCBzdGFydCk7XG4gICAgICAgIHRoaXMuYnVmZmVyLnB1c2goaW5kZXgsIHN0YXJ0LCB0aGlzLnJlZHVjZVBvcywgLTEgLyogc2l6ZSA9PSAtMSBtZWFucyB0aGlzIGlzIGEgcmV1c2VkIHZhbHVlICovKTtcbiAgICAgICAgaWYgKHRoaXMuY3VyQ29udGV4dClcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29udGV4dCh0aGlzLmN1ckNvbnRleHQudHJhY2tlci5yZXVzZSh0aGlzLmN1ckNvbnRleHQuY29udGV4dCwgdmFsdWUsIHRoaXMsIHRoaXMucC5zdHJlYW0ucmVzZXQodGhpcy5wb3MgLSB2YWx1ZS5sZW5ndGgpKSk7XG4gICAgfVxuICAgIC8vIFNwbGl0IHRoZSBzdGFjay4gRHVlIHRvIHRoZSBidWZmZXIgc2hhcmluZyBhbmQgdGhlIGZhY3RcbiAgICAvLyB0aGF0IGB0aGlzLnN0YWNrYCB0ZW5kcyB0byBzdGF5IHF1aXRlIHNoYWxsb3csIHRoaXMgaXNuJ3QgdmVyeVxuICAgIC8vIGV4cGVuc2l2ZS5cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNwbGl0KCkge1xuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcztcbiAgICAgICAgbGV0IG9mZiA9IHBhcmVudC5idWZmZXIubGVuZ3RoO1xuICAgICAgICAvLyBCZWNhdXNlIHRoZSB0b3Agb2YgdGhlIGJ1ZmZlciAoYWZ0ZXIgdGhpcy5wb3MpIG1heSBiZSBtdXRhdGVkXG4gICAgICAgIC8vIHRvIHJlb3JkZXIgcmVkdWN0aW9ucyBhbmQgc2tpcHBlZCB0b2tlbnMsIGFuZCBzaGFyZWQgYnVmZmVyc1xuICAgICAgICAvLyBzaG91bGQgYmUgaW1tdXRhYmxlLCB0aGlzIGNvcGllcyBhbnkgb3V0c3RhbmRpbmcgc2tpcHBlZCB0b2tlbnNcbiAgICAgICAgLy8gdG8gdGhlIG5ldyBidWZmZXIsIGFuZCBwdXRzIHRoZSBiYXNlIHBvaW50ZXIgYmVmb3JlIHRoZW0uXG4gICAgICAgIHdoaWxlIChvZmYgPiAwICYmIHBhcmVudC5idWZmZXJbb2ZmIC0gMl0gPiBwYXJlbnQucmVkdWNlUG9zKVxuICAgICAgICAgICAgb2ZmIC09IDQ7XG4gICAgICAgIGxldCBidWZmZXIgPSBwYXJlbnQuYnVmZmVyLnNsaWNlKG9mZiksIGJhc2UgPSBwYXJlbnQuYnVmZmVyQmFzZSArIG9mZjtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHBhcmVudCBwb2ludHMgdG8gYW4gYWN0dWFsIHBhcmVudCB3aXRoIGNvbnRlbnQsIGlmIHRoZXJlIGlzIHN1Y2ggYSBwYXJlbnQuXG4gICAgICAgIHdoaWxlIChwYXJlbnQgJiYgYmFzZSA9PSBwYXJlbnQuYnVmZmVyQmFzZSlcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgIHJldHVybiBuZXcgU3RhY2sodGhpcy5wLCB0aGlzLnN0YWNrLnNsaWNlKCksIHRoaXMuc3RhdGUsIHRoaXMucmVkdWNlUG9zLCB0aGlzLnBvcywgdGhpcy5zY29yZSwgYnVmZmVyLCBiYXNlLCB0aGlzLmN1ckNvbnRleHQsIHRoaXMubG9va0FoZWFkLCBwYXJlbnQpO1xuICAgIH1cbiAgICAvLyBUcnkgdG8gcmVjb3ZlciBmcm9tIGFuIGVycm9yIGJ5ICdkZWxldGluZycgKGlnbm9yaW5nKSBvbmUgdG9rZW4uXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZWNvdmVyQnlEZWxldGUobmV4dCwgbmV4dEVuZCkge1xuICAgICAgICBsZXQgaXNOb2RlID0gbmV4dCA8PSB0aGlzLnAucGFyc2VyLm1heE5vZGU7XG4gICAgICAgIGlmIChpc05vZGUpXG4gICAgICAgICAgICB0aGlzLnN0b3JlTm9kZShuZXh0LCB0aGlzLnBvcywgbmV4dEVuZCwgNCk7XG4gICAgICAgIHRoaXMuc3RvcmVOb2RlKDAgLyogVGVybS5FcnIgKi8sIHRoaXMucG9zLCBuZXh0RW5kLCBpc05vZGUgPyA4IDogNCk7XG4gICAgICAgIHRoaXMucG9zID0gdGhpcy5yZWR1Y2VQb3MgPSBuZXh0RW5kO1xuICAgICAgICB0aGlzLnNjb3JlIC09IDE5MCAvKiBSZWNvdmVyLkRlbGV0ZSAqLztcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hlY2sgaWYgdGhlIGdpdmVuIHRlcm0gd291bGQgYmUgYWJsZSB0byBiZSBzaGlmdGVkIChvcHRpb25hbGx5XG4gICAgYWZ0ZXIgc29tZSByZWR1Y3Rpb25zKSBvbiB0aGlzIHN0YWNrLiBUaGlzIGNhbiBiZSB1c2VmdWwgZm9yXG4gICAgZXh0ZXJuYWwgdG9rZW5pemVycyB0aGF0IHdhbnQgdG8gbWFrZSBzdXJlIHRoZXkgb25seSBwcm92aWRlIGFcbiAgICBnaXZlbiB0b2tlbiB3aGVuIGl0IGFwcGxpZXMuXG4gICAgKi9cbiAgICBjYW5TaGlmdCh0ZXJtKSB7XG4gICAgICAgIGZvciAobGV0IHNpbSA9IG5ldyBTaW11bGF0ZWRTdGFjayh0aGlzKTs7KSB7XG4gICAgICAgICAgICBsZXQgYWN0aW9uID0gdGhpcy5wLnBhcnNlci5zdGF0ZVNsb3Qoc2ltLnN0YXRlLCA0IC8qIFBhcnNlU3RhdGUuRGVmYXVsdFJlZHVjZSAqLykgfHwgdGhpcy5wLnBhcnNlci5oYXNBY3Rpb24oc2ltLnN0YXRlLCB0ZXJtKTtcbiAgICAgICAgICAgIGlmIChhY3Rpb24gPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoKGFjdGlvbiAmIDY1NTM2IC8qIEFjdGlvbi5SZWR1Y2VGbGFnICovKSA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgc2ltLnJlZHVjZShhY3Rpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEFwcGx5IHVwIHRvIFJlY292ZXIuTWF4TmV4dCByZWNvdmVyeSBhY3Rpb25zIHRoYXQgY29uY2VwdHVhbGx5XG4gICAgLy8gaW5zZXJ0cyBzb21lIG1pc3NpbmcgdG9rZW4gb3IgcnVsZS5cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlY292ZXJCeUluc2VydChuZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA+PSAzMDAgLyogUmVjb3Zlci5NYXhJbnNlcnRTdGFja0RlcHRoICovKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBsZXQgbmV4dFN0YXRlcyA9IHRoaXMucC5wYXJzZXIubmV4dFN0YXRlcyh0aGlzLnN0YXRlKTtcbiAgICAgICAgaWYgKG5leHRTdGF0ZXMubGVuZ3RoID4gNCAvKiBSZWNvdmVyLk1heE5leHQgKi8gPDwgMSB8fCB0aGlzLnN0YWNrLmxlbmd0aCA+PSAxMjAgLyogUmVjb3Zlci5EYW1wZW5JbnNlcnRTdGFja0RlcHRoICovKSB7XG4gICAgICAgICAgICBsZXQgYmVzdCA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHM7IGkgPCBuZXh0U3RhdGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgaWYgKChzID0gbmV4dFN0YXRlc1tpICsgMV0pICE9IHRoaXMuc3RhdGUgJiYgdGhpcy5wLnBhcnNlci5oYXNBY3Rpb24ocywgbmV4dCkpXG4gICAgICAgICAgICAgICAgICAgIGJlc3QucHVzaChuZXh0U3RhdGVzW2ldLCBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDEyMCAvKiBSZWNvdmVyLkRhbXBlbkluc2VydFN0YWNrRGVwdGggKi8pXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGJlc3QubGVuZ3RoIDwgNCAvKiBSZWNvdmVyLk1heE5leHQgKi8gPDwgMSAmJiBpIDwgbmV4dFN0YXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcyA9IG5leHRTdGF0ZXNbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWJlc3Quc29tZSgodiwgaSkgPT4gKGkgJiAxKSAmJiB2ID09IHMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdC5wdXNoKG5leHRTdGF0ZXNbaV0sIHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHRTdGF0ZXMgPSBiZXN0O1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXh0U3RhdGVzLmxlbmd0aCAmJiByZXN1bHQubGVuZ3RoIDwgNCAvKiBSZWNvdmVyLk1heE5leHQgKi87IGkgKz0gMikge1xuICAgICAgICAgICAgbGV0IHMgPSBuZXh0U3RhdGVzW2kgKyAxXTtcbiAgICAgICAgICAgIGlmIChzID09IHRoaXMuc3RhdGUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgc3RhY2sgPSB0aGlzLnNwbGl0KCk7XG4gICAgICAgICAgICBzdGFjay5wdXNoU3RhdGUocywgdGhpcy5wb3MpO1xuICAgICAgICAgICAgc3RhY2suc3RvcmVOb2RlKDAgLyogVGVybS5FcnIgKi8sIHN0YWNrLnBvcywgc3RhY2sucG9zLCA0LCB0cnVlKTtcbiAgICAgICAgICAgIHN0YWNrLnNoaWZ0Q29udGV4dChuZXh0U3RhdGVzW2ldLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICBzdGFjay5yZWR1Y2VQb3MgPSB0aGlzLnBvcztcbiAgICAgICAgICAgIHN0YWNrLnNjb3JlIC09IDIwMCAvKiBSZWNvdmVyLkluc2VydCAqLztcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBGb3JjZSBhIHJlZHVjZSwgaWYgcG9zc2libGUuIFJldHVybiBmYWxzZSBpZiB0aGF0IGNhbid0XG4gICAgLy8gYmUgZG9uZS5cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZvcmNlUmVkdWNlKCkge1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHRoaXMucDtcbiAgICAgICAgbGV0IHJlZHVjZSA9IHBhcnNlci5zdGF0ZVNsb3QodGhpcy5zdGF0ZSwgNSAvKiBQYXJzZVN0YXRlLkZvcmNlZFJlZHVjZSAqLyk7XG4gICAgICAgIGlmICgocmVkdWNlICYgNjU1MzYgLyogQWN0aW9uLlJlZHVjZUZsYWcgKi8pID09IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghcGFyc2VyLnZhbGlkQWN0aW9uKHRoaXMuc3RhdGUsIHJlZHVjZSkpIHtcbiAgICAgICAgICAgIGxldCBkZXB0aCA9IHJlZHVjZSA+PiAxOSAvKiBBY3Rpb24uUmVkdWNlRGVwdGhTaGlmdCAqLywgdGVybSA9IHJlZHVjZSAmIDY1NTM1IC8qIEFjdGlvbi5WYWx1ZU1hc2sgKi87XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gdGhpcy5zdGFjay5sZW5ndGggLSBkZXB0aCAqIDM7XG4gICAgICAgICAgICBpZiAodGFyZ2V0IDwgMCB8fCBwYXJzZXIuZ2V0R290byh0aGlzLnN0YWNrW3RhcmdldF0sIHRlcm0sIGZhbHNlKSA8IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgYmFja3VwID0gdGhpcy5maW5kRm9yY2VkUmVkdWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKGJhY2t1cCA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmVkdWNlID0gYmFja3VwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUoMCAvKiBUZXJtLkVyciAqLywgdGhpcy5wb3MsIHRoaXMucG9zLCA0LCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuc2NvcmUgLT0gMTAwIC8qIFJlY292ZXIuUmVkdWNlICovO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVkdWNlUG9zID0gdGhpcy5wb3M7XG4gICAgICAgIHRoaXMucmVkdWNlKHJlZHVjZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnkgdG8gc2NhbiB0aHJvdWdoIHRoZSBhdXRvbWF0b24gdG8gZmluZCBzb21lIGtpbmQgb2YgcmVkdWN0aW9uXG4gICAgdGhhdCBjYW4gYmUgYXBwbGllZC4gVXNlZCB3aGVuIHRoZSByZWd1bGFyIEZvcmNlZFJlZHVjZSBmaWVsZFxuICAgIGlzbid0IGEgdmFsaWQgYWN0aW9uLiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZpbmRGb3JjZWRSZWR1Y3Rpb24oKSB7XG4gICAgICAgIGxldCB7IHBhcnNlciB9ID0gdGhpcy5wLCBzZWVuID0gW107XG4gICAgICAgIGxldCBleHBsb3JlID0gKHN0YXRlLCBkZXB0aCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNlZW4uaW5jbHVkZXMoc3RhdGUpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHNlZW4ucHVzaChzdGF0ZSk7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VyLmFsbEFjdGlvbnMoc3RhdGUsIChhY3Rpb24pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uICYgKDI2MjE0NCAvKiBBY3Rpb24uU3RheUZsYWcgKi8gfCAxMzEwNzIgLyogQWN0aW9uLkdvdG9GbGFnICovKSkgO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFjdGlvbiAmIDY1NTM2IC8qIEFjdGlvbi5SZWR1Y2VGbGFnICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByRGVwdGggPSAoYWN0aW9uID4+IDE5IC8qIEFjdGlvbi5SZWR1Y2VEZXB0aFNoaWZ0ICovKSAtIGRlcHRoO1xuICAgICAgICAgICAgICAgICAgICBpZiAockRlcHRoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRlcm0gPSBhY3Rpb24gJiA2NTUzNSAvKiBBY3Rpb24uVmFsdWVNYXNrICovLCB0YXJnZXQgPSB0aGlzLnN0YWNrLmxlbmd0aCAtIHJEZXB0aCAqIDM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ID49IDAgJiYgcGFyc2VyLmdldEdvdG8odGhpcy5zdGFja1t0YXJnZXRdLCB0ZXJtLCBmYWxzZSkgPj0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHJEZXB0aCA8PCAxOSAvKiBBY3Rpb24uUmVkdWNlRGVwdGhTaGlmdCAqLykgfCA2NTUzNiAvKiBBY3Rpb24uUmVkdWNlRmxhZyAqLyB8IHRlcm07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGV4cGxvcmUoYWN0aW9uLCBkZXB0aCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGV4cGxvcmUodGhpcy5zdGF0ZSwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZm9yY2VBbGwoKSB7XG4gICAgICAgIHdoaWxlICghdGhpcy5wLnBhcnNlci5zdGF0ZUZsYWcodGhpcy5zdGF0ZSwgMiAvKiBTdGF0ZUZsYWcuQWNjZXB0aW5nICovKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZvcmNlUmVkdWNlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JlTm9kZSgwIC8qIFRlcm0uRXJyICovLCB0aGlzLnBvcywgdGhpcy5wb3MsIDQsIHRydWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayB3aGV0aGVyIHRoaXMgc3RhdGUgaGFzIG5vIGZ1cnRoZXIgYWN0aW9ucyAoYXNzdW1lZCB0byBiZSBhIGRpcmVjdCBkZXNjZW5kYW50IG9mIHRoZVxuICAgIHRvcCBzdGF0ZSwgc2luY2UgYW55IG90aGVyIHN0YXRlcyBtdXN0IGJlIGFibGUgdG8gY29udGludWVcbiAgICBzb21laG93KS4gQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgZGVhZEVuZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoICE9IDMpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCB7IHBhcnNlciB9ID0gdGhpcy5wO1xuICAgICAgICByZXR1cm4gcGFyc2VyLmRhdGFbcGFyc2VyLnN0YXRlU2xvdCh0aGlzLnN0YXRlLCAxIC8qIFBhcnNlU3RhdGUuQWN0aW9ucyAqLyldID09IDY1NTM1IC8qIFNlcS5FbmQgKi8gJiZcbiAgICAgICAgICAgICFwYXJzZXIuc3RhdGVTbG90KHRoaXMuc3RhdGUsIDQgLyogUGFyc2VTdGF0ZS5EZWZhdWx0UmVkdWNlICovKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVzdGFydCB0aGUgc3RhY2sgKHB1dCBpdCBiYWNrIGluIGl0cyBzdGFydCBzdGF0ZSkuIE9ubHkgc2FmZVxuICAgIHdoZW4gdGhpcy5zdGFjay5sZW5ndGggPT0gMyAoc3RhdGUgaXMgZGlyZWN0bHkgYmVsb3cgdGhlIHRvcFxuICAgIHN0YXRlKS4gQGludGVybmFsXG4gICAgKi9cbiAgICByZXN0YXJ0KCkge1xuICAgICAgICB0aGlzLnN0b3JlTm9kZSgwIC8qIFRlcm0uRXJyICovLCB0aGlzLnBvcywgdGhpcy5wb3MsIDQsIHRydWUpO1xuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5zdGFja1swXTtcbiAgICAgICAgdGhpcy5zdGFjay5sZW5ndGggPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNhbWVTdGF0ZShvdGhlcikge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPSBvdGhlci5zdGF0ZSB8fCB0aGlzLnN0YWNrLmxlbmd0aCAhPSBvdGhlci5zdGFjay5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGFjay5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YWNrW2ldICE9IG90aGVyLnN0YWNrW2ldKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgcGFyc2VyIHVzZWQgYnkgdGhpcyBzdGFjay5cbiAgICAqL1xuICAgIGdldCBwYXJzZXIoKSB7IHJldHVybiB0aGlzLnAucGFyc2VyOyB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIGEgZ2l2ZW4gZGlhbGVjdCAoYnkgbnVtZXJpYyBJRCwgYXMgZXhwb3J0ZWQgZnJvbVxuICAgIHRoZSB0ZXJtcyBmaWxlKSBpcyBlbmFibGVkLlxuICAgICovXG4gICAgZGlhbGVjdEVuYWJsZWQoZGlhbGVjdElEKSB7IHJldHVybiB0aGlzLnAucGFyc2VyLmRpYWxlY3QuZmxhZ3NbZGlhbGVjdElEXTsgfVxuICAgIHNoaWZ0Q29udGV4dCh0ZXJtLCBzdGFydCkge1xuICAgICAgICBpZiAodGhpcy5jdXJDb250ZXh0KVxuICAgICAgICAgICAgdGhpcy51cGRhdGVDb250ZXh0KHRoaXMuY3VyQ29udGV4dC50cmFja2VyLnNoaWZ0KHRoaXMuY3VyQ29udGV4dC5jb250ZXh0LCB0ZXJtLCB0aGlzLCB0aGlzLnAuc3RyZWFtLnJlc2V0KHN0YXJ0KSkpO1xuICAgIH1cbiAgICByZWR1Y2VDb250ZXh0KHRlcm0sIHN0YXJ0KSB7XG4gICAgICAgIGlmICh0aGlzLmN1ckNvbnRleHQpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbnRleHQodGhpcy5jdXJDb250ZXh0LnRyYWNrZXIucmVkdWNlKHRoaXMuY3VyQ29udGV4dC5jb250ZXh0LCB0ZXJtLCB0aGlzLCB0aGlzLnAuc3RyZWFtLnJlc2V0KHN0YXJ0KSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGVtaXRDb250ZXh0KCkge1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMuYnVmZmVyLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChsYXN0IDwgMCB8fCB0aGlzLmJ1ZmZlcltsYXN0XSAhPSAtMylcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2godGhpcy5jdXJDb250ZXh0Lmhhc2gsIHRoaXMucG9zLCB0aGlzLnBvcywgLTMpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGVtaXRMb29rQWhlYWQoKSB7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5idWZmZXIubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGxhc3QgPCAwIHx8IHRoaXMuYnVmZmVyW2xhc3RdICE9IC00KVxuICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaCh0aGlzLmxvb2tBaGVhZCwgdGhpcy5wb3MsIHRoaXMucG9zLCAtNCk7XG4gICAgfVxuICAgIHVwZGF0ZUNvbnRleHQoY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCAhPSB0aGlzLmN1ckNvbnRleHQuY29udGV4dCkge1xuICAgICAgICAgICAgbGV0IG5ld0N4ID0gbmV3IFN0YWNrQ29udGV4dCh0aGlzLmN1ckNvbnRleHQudHJhY2tlciwgY29udGV4dCk7XG4gICAgICAgICAgICBpZiAobmV3Q3guaGFzaCAhPSB0aGlzLmN1ckNvbnRleHQuaGFzaClcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXRDb250ZXh0KCk7XG4gICAgICAgICAgICB0aGlzLmN1ckNvbnRleHQgPSBuZXdDeDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNldExvb2tBaGVhZChsb29rQWhlYWQpIHtcbiAgICAgICAgaWYgKGxvb2tBaGVhZCA+IHRoaXMubG9va0FoZWFkKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXRMb29rQWhlYWQoKTtcbiAgICAgICAgICAgIHRoaXMubG9va0FoZWFkID0gbG9va0FoZWFkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1ckNvbnRleHQgJiYgdGhpcy5jdXJDb250ZXh0LnRyYWNrZXIuc3RyaWN0KVxuICAgICAgICAgICAgdGhpcy5lbWl0Q29udGV4dCgpO1xuICAgICAgICBpZiAodGhpcy5sb29rQWhlYWQgPiAwKVxuICAgICAgICAgICAgdGhpcy5lbWl0TG9va0FoZWFkKCk7XG4gICAgfVxufVxuY2xhc3MgU3RhY2tDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3Rvcih0cmFja2VyLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudHJhY2tlciA9IHRyYWNrZXI7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuaGFzaCA9IHRyYWNrZXIuc3RyaWN0ID8gdHJhY2tlci5oYXNoKGNvbnRleHQpIDogMDtcbiAgICB9XG59XG4vLyBVc2VkIHRvIGNoZWFwbHkgcnVuIHNvbWUgcmVkdWN0aW9ucyB0byBzY2FuIGFoZWFkIHdpdGhvdXQgbXV0YXRpbmdcbi8vIGFuIGVudGlyZSBzdGFja1xuY2xhc3MgU2ltdWxhdGVkU3RhY2sge1xuICAgIGNvbnN0cnVjdG9yKHN0YXJ0KSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXJ0LnN0YXRlO1xuICAgICAgICB0aGlzLnN0YWNrID0gc3RhcnQuc3RhY2s7XG4gICAgICAgIHRoaXMuYmFzZSA9IHRoaXMuc3RhY2subGVuZ3RoO1xuICAgIH1cbiAgICByZWR1Y2UoYWN0aW9uKSB7XG4gICAgICAgIGxldCB0ZXJtID0gYWN0aW9uICYgNjU1MzUgLyogQWN0aW9uLlZhbHVlTWFzayAqLywgZGVwdGggPSBhY3Rpb24gPj4gMTkgLyogQWN0aW9uLlJlZHVjZURlcHRoU2hpZnQgKi87XG4gICAgICAgIGlmIChkZXB0aCA9PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGFjayA9PSB0aGlzLnN0YXJ0LnN0YWNrKVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sgPSB0aGlzLnN0YWNrLnNsaWNlKCk7XG4gICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5zdGF0ZSwgMCwgMCk7XG4gICAgICAgICAgICB0aGlzLmJhc2UgKz0gMztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSAtPSAoZGVwdGggLSAxKSAqIDM7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGdvdG8gPSB0aGlzLnN0YXJ0LnAucGFyc2VyLmdldEdvdG8odGhpcy5zdGFja1t0aGlzLmJhc2UgLSAzXSwgdGVybSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBnb3RvO1xuICAgIH1cbn1cbi8vIFRoaXMgaXMgZ2l2ZW4gdG8gYFRyZWUuYnVpbGRgIHRvIGJ1aWxkIGEgYnVmZmVyLCBhbmQgZW5jYXBzdWxhdGVzXG4vLyB0aGUgcGFyZW50LXN0YWNrLXdhbGtpbmcgbmVjZXNzYXJ5IHRvIHJlYWQgdGhlIG5vZGVzLlxuY2xhc3MgU3RhY2tCdWZmZXJDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKHN0YWNrLCBwb3MsIGluZGV4KSB7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBzdGFjaztcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBzdGFjay5idWZmZXI7XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID09IDApXG4gICAgICAgICAgICB0aGlzLm1heWJlTmV4dCgpO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKHN0YWNrLCBwb3MgPSBzdGFjay5idWZmZXJCYXNlICsgc3RhY2suYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrQnVmZmVyQ3Vyc29yKHN0YWNrLCBwb3MsIHBvcyAtIHN0YWNrLmJ1ZmZlckJhc2UpO1xuICAgIH1cbiAgICBtYXliZU5leHQoKSB7XG4gICAgICAgIGxldCBuZXh0ID0gdGhpcy5zdGFjay5wYXJlbnQ7XG4gICAgICAgIGlmIChuZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSB0aGlzLnN0YWNrLmJ1ZmZlckJhc2UgLSBuZXh0LmJ1ZmZlckJhc2U7XG4gICAgICAgICAgICB0aGlzLnN0YWNrID0gbmV4dDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbmV4dC5idWZmZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGlkKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDRdOyB9XG4gICAgZ2V0IHN0YXJ0KCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDNdOyB9XG4gICAgZ2V0IGVuZCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAyXTsgfVxuICAgIGdldCBzaXplKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDFdOyB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgdGhpcy5pbmRleCAtPSA0O1xuICAgICAgICB0aGlzLnBvcyAtPSA0O1xuICAgICAgICBpZiAodGhpcy5pbmRleCA9PSAwKVxuICAgICAgICAgICAgdGhpcy5tYXliZU5leHQoKTtcbiAgICB9XG4gICAgZm9yaygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFja0J1ZmZlckN1cnNvcih0aGlzLnN0YWNrLCB0aGlzLnBvcywgdGhpcy5pbmRleCk7XG4gICAgfVxufVxuXG4vLyBTZWUgbGV6ZXItZ2VuZXJhdG9yL3NyYy9lbmNvZGUudHMgZm9yIGNvbW1lbnRzIGFib3V0IHRoZSBlbmNvZGluZ1xuLy8gdXNlZCBoZXJlXG5mdW5jdGlvbiBkZWNvZGVBcnJheShpbnB1dCwgVHlwZSA9IFVpbnQxNkFycmF5KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCAhPSBcInN0cmluZ1wiKVxuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgbGV0IGFycmF5ID0gbnVsbDtcbiAgICBmb3IgKGxldCBwb3MgPSAwLCBvdXQgPSAwOyBwb3MgPCBpbnB1dC5sZW5ndGg7KSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IDA7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdChwb3MrKyksIHN0b3AgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChuZXh0ID09IDEyNiAvKiBFbmNvZGUuQmlnVmFsQ29kZSAqLykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gNjU1MzUgLyogRW5jb2RlLkJpZ1ZhbCAqLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0ID49IDkyIC8qIEVuY29kZS5HYXAyICovKVxuICAgICAgICAgICAgICAgIG5leHQtLTtcbiAgICAgICAgICAgIGlmIChuZXh0ID49IDM0IC8qIEVuY29kZS5HYXAxICovKVxuICAgICAgICAgICAgICAgIG5leHQtLTtcbiAgICAgICAgICAgIGxldCBkaWdpdCA9IG5leHQgLSAzMiAvKiBFbmNvZGUuU3RhcnQgKi87XG4gICAgICAgICAgICBpZiAoZGlnaXQgPj0gNDYgLyogRW5jb2RlLkJhc2UgKi8pIHtcbiAgICAgICAgICAgICAgICBkaWdpdCAtPSA0NiAvKiBFbmNvZGUuQmFzZSAqLztcbiAgICAgICAgICAgICAgICBzdG9wID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlICs9IGRpZ2l0O1xuICAgICAgICAgICAgaWYgKHN0b3ApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB2YWx1ZSAqPSA0NiAvKiBFbmNvZGUuQmFzZSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJyYXkpXG4gICAgICAgICAgICBhcnJheVtvdXQrK10gPSB2YWx1ZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYXJyYXkgPSBuZXcgVHlwZSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cblxuY2xhc3MgQ2FjaGVkVG9rZW4ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gLTE7XG4gICAgICAgIHRoaXMudmFsdWUgPSAtMTtcbiAgICAgICAgdGhpcy5lbmQgPSAtMTtcbiAgICAgICAgdGhpcy5leHRlbmRlZCA9IC0xO1xuICAgICAgICB0aGlzLmxvb2tBaGVhZCA9IDA7XG4gICAgICAgIHRoaXMubWFzayA9IDA7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IDA7XG4gICAgfVxufVxuY29uc3QgbnVsbFRva2VuID0gbmV3IENhY2hlZFRva2VuO1xuLyoqXG5bVG9rZW5pemVyc10oI2xyLkV4dGVybmFsVG9rZW5pemVyKSBpbnRlcmFjdCB3aXRoIHRoZSBpbnB1dFxudGhyb3VnaCB0aGlzIGludGVyZmFjZS4gSXQgcHJlc2VudHMgdGhlIGlucHV0IGFzIGEgc3RyZWFtIG9mXG5jaGFyYWN0ZXJzLCB0cmFja2luZyBsb29rYWhlYWQgYW5kIGhpZGluZyB0aGUgY29tcGxleGl0eSBvZlxuW3Jhbmdlc10oI2NvbW1vbi5QYXJzZXIucGFyc2VecmFuZ2VzKSBmcm9tIHRva2VuaXplciBjb2RlLlxuKi9cbmNsYXNzIElucHV0U3RyZWFtIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaW5wdXQsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmFuZ2VzKSB7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaHVuayA9IFwiXCI7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaHVua09mZiA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICBCYWNrdXAgY2h1bmtcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaHVuazIgPSBcIlwiO1xuICAgICAgICB0aGlzLmNodW5rMlBvcyA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgY2hhcmFjdGVyIGNvZGUgb2YgdGhlIG5leHQgY29kZSB1bml0IGluIHRoZSBpbnB1dCwgb3IgLTFcbiAgICAgICAgd2hlbiB0aGUgc3RyZWFtIGlzIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0LlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLm5leHQgPSAtMTtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnRva2VuID0gbnVsbFRva2VuO1xuICAgICAgICB0aGlzLnJhbmdlSW5kZXggPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IHRoaXMuY2h1bmtQb3MgPSByYW5nZXNbMF0uZnJvbTtcbiAgICAgICAgdGhpcy5yYW5nZSA9IHJhbmdlc1swXTtcbiAgICAgICAgdGhpcy5lbmQgPSByYW5nZXNbcmFuZ2VzLmxlbmd0aCAtIDFdLnRvO1xuICAgICAgICB0aGlzLnJlYWROZXh0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVzb2x2ZU9mZnNldChvZmZzZXQsIGFzc29jKSB7XG4gICAgICAgIGxldCByYW5nZSA9IHRoaXMucmFuZ2UsIGluZGV4ID0gdGhpcy5yYW5nZUluZGV4O1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5wb3MgKyBvZmZzZXQ7XG4gICAgICAgIHdoaWxlIChwb3MgPCByYW5nZS5mcm9tKSB7XG4gICAgICAgICAgICBpZiAoIWluZGV4KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLnJhbmdlc1stLWluZGV4XTtcbiAgICAgICAgICAgIHBvcyAtPSByYW5nZS5mcm9tIC0gbmV4dC50bztcbiAgICAgICAgICAgIHJhbmdlID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoYXNzb2MgPCAwID8gcG9zID4gcmFuZ2UudG8gOiBwb3MgPj0gcmFuZ2UudG8pIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSB0aGlzLnJhbmdlcy5sZW5ndGggLSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLnJhbmdlc1srK2luZGV4XTtcbiAgICAgICAgICAgIHBvcyArPSBuZXh0LmZyb20gLSByYW5nZS50bztcbiAgICAgICAgICAgIHJhbmdlID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNsaXBQb3MocG9zKSB7XG4gICAgICAgIGlmIChwb3MgPj0gdGhpcy5yYW5nZS5mcm9tICYmIHBvcyA8IHRoaXMucmFuZ2UudG8pXG4gICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICBmb3IgKGxldCByYW5nZSBvZiB0aGlzLnJhbmdlcylcbiAgICAgICAgICAgIGlmIChyYW5nZS50byA+IHBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgocG9zLCByYW5nZS5mcm9tKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kO1xuICAgIH1cbiAgICAvKipcbiAgICBMb29rIGF0IGEgY29kZSB1bml0IG5lYXIgdGhlIHN0cmVhbSBwb3NpdGlvbi4gYC5wZWVrKDApYCBlcXVhbHNcbiAgICBgLm5leHRgLCBgLnBlZWsoLTEpYCBnaXZlcyB5b3UgdGhlIHByZXZpb3VzIGNoYXJhY3RlciwgYW5kIHNvXG4gICAgb24uXG4gICAgXG4gICAgTm90ZSB0aGF0IGxvb2tpbmcgYXJvdW5kIGR1cmluZyB0b2tlbml6aW5nIGNyZWF0ZXMgZGVwZW5kZW5jaWVzXG4gICAgb24gcG90ZW50aWFsbHkgZmFyLWF3YXkgY29udGVudCwgd2hpY2ggbWF5IHJlZHVjZSB0aGVcbiAgICBlZmZlY3RpdmVuZXNzIGluY3JlbWVudGFsIHBhcnNpbmfigJR3aGVuIGxvb2tpbmcgZm9yd2FyZOKAlG9yIGV2ZW5cbiAgICBjYXVzZSBpbnZhbGlkIHJlcGFyc2VzIHdoZW4gbG9va2luZyBiYWNrd2FyZCBtb3JlIHRoYW4gMjUgY29kZVxuICAgIHVuaXRzLCBzaW5jZSB0aGUgbGlicmFyeSBkb2VzIG5vdCB0cmFjayBsb29rYmVoaW5kLlxuICAgICovXG4gICAgcGVlayhvZmZzZXQpIHtcbiAgICAgICAgbGV0IGlkeCA9IHRoaXMuY2h1bmtPZmYgKyBvZmZzZXQsIHBvcywgcmVzdWx0O1xuICAgICAgICBpZiAoaWR4ID49IDAgJiYgaWR4IDwgdGhpcy5jaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgIHBvcyA9IHRoaXMucG9zICsgb2Zmc2V0O1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jaHVuay5jaGFyQ29kZUF0KGlkeCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgcmVzb2x2ZWQgPSB0aGlzLnJlc29sdmVPZmZzZXQob2Zmc2V0LCAxKTtcbiAgICAgICAgICAgIGlmIChyZXNvbHZlZCA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIHBvcyA9IHJlc29sdmVkO1xuICAgICAgICAgICAgaWYgKHBvcyA+PSB0aGlzLmNodW5rMlBvcyAmJiBwb3MgPCB0aGlzLmNodW5rMlBvcyArIHRoaXMuY2h1bmsyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY2h1bmsyLmNoYXJDb2RlQXQocG9zIC0gdGhpcy5jaHVuazJQb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSB0aGlzLnJhbmdlSW5kZXgsIHJhbmdlID0gdGhpcy5yYW5nZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAocmFuZ2UudG8gPD0gcG9zKVxuICAgICAgICAgICAgICAgICAgICByYW5nZSA9IHRoaXMucmFuZ2VzWysraV07XG4gICAgICAgICAgICAgICAgdGhpcy5jaHVuazIgPSB0aGlzLmlucHV0LmNodW5rKHRoaXMuY2h1bmsyUG9zID0gcG9zKTtcbiAgICAgICAgICAgICAgICBpZiAocG9zICsgdGhpcy5jaHVuazIubGVuZ3RoID4gcmFuZ2UudG8pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2h1bmsyID0gdGhpcy5jaHVuazIuc2xpY2UoMCwgcmFuZ2UudG8gLSBwb3MpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY2h1bmsyLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyA+PSB0aGlzLnRva2VuLmxvb2tBaGVhZClcbiAgICAgICAgICAgIHRoaXMudG9rZW4ubG9va0FoZWFkID0gcG9zICsgMTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgQWNjZXB0IGEgdG9rZW4uIEJ5IGRlZmF1bHQsIHRoZSBlbmQgb2YgdGhlIHRva2VuIGlzIHNldCB0byB0aGVcbiAgICBjdXJyZW50IHN0cmVhbSBwb3NpdGlvbiwgYnV0IHlvdSBjYW4gcGFzcyBhbiBvZmZzZXQgKHJlbGF0aXZlIHRvXG4gICAgdGhlIHN0cmVhbSBwb3NpdGlvbikgdG8gY2hhbmdlIHRoYXQuXG4gICAgKi9cbiAgICBhY2NlcHRUb2tlbih0b2tlbiwgZW5kT2Zmc2V0ID0gMCkge1xuICAgICAgICBsZXQgZW5kID0gZW5kT2Zmc2V0ID8gdGhpcy5yZXNvbHZlT2Zmc2V0KGVuZE9mZnNldCwgLTEpIDogdGhpcy5wb3M7XG4gICAgICAgIGlmIChlbmQgPT0gbnVsbCB8fCBlbmQgPCB0aGlzLnRva2VuLnN0YXJ0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUb2tlbiBlbmQgb3V0IG9mIGJvdW5kc1wiKTtcbiAgICAgICAgdGhpcy50b2tlbi52YWx1ZSA9IHRva2VuO1xuICAgICAgICB0aGlzLnRva2VuLmVuZCA9IGVuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgQWNjZXB0IGEgdG9rZW4gZW5kaW5nIGF0IGEgc3BlY2lmaWMgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBhY2NlcHRUb2tlblRvKHRva2VuLCBlbmRQb3MpIHtcbiAgICAgICAgdGhpcy50b2tlbi52YWx1ZSA9IHRva2VuO1xuICAgICAgICB0aGlzLnRva2VuLmVuZCA9IGVuZFBvcztcbiAgICB9XG4gICAgZ2V0Q2h1bmsoKSB7XG4gICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmNodW5rMlBvcyAmJiB0aGlzLnBvcyA8IHRoaXMuY2h1bmsyUG9zICsgdGhpcy5jaHVuazIubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgeyBjaHVuaywgY2h1bmtQb3MgfSA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmNodW5rID0gdGhpcy5jaHVuazI7XG4gICAgICAgICAgICB0aGlzLmNodW5rUG9zID0gdGhpcy5jaHVuazJQb3M7XG4gICAgICAgICAgICB0aGlzLmNodW5rMiA9IGNodW5rO1xuICAgICAgICAgICAgdGhpcy5jaHVuazJQb3MgPSBjaHVua1BvcztcbiAgICAgICAgICAgIHRoaXMuY2h1bmtPZmYgPSB0aGlzLnBvcyAtIHRoaXMuY2h1bmtQb3M7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNodW5rMiA9IHRoaXMuY2h1bms7XG4gICAgICAgICAgICB0aGlzLmNodW5rMlBvcyA9IHRoaXMuY2h1bmtQb3M7XG4gICAgICAgICAgICBsZXQgbmV4dENodW5rID0gdGhpcy5pbnB1dC5jaHVuayh0aGlzLnBvcyk7XG4gICAgICAgICAgICBsZXQgZW5kID0gdGhpcy5wb3MgKyBuZXh0Q2h1bmsubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5jaHVuayA9IGVuZCA+IHRoaXMucmFuZ2UudG8gPyBuZXh0Q2h1bmsuc2xpY2UoMCwgdGhpcy5yYW5nZS50byAtIHRoaXMucG9zKSA6IG5leHRDaHVuaztcbiAgICAgICAgICAgIHRoaXMuY2h1bmtQb3MgPSB0aGlzLnBvcztcbiAgICAgICAgICAgIHRoaXMuY2h1bmtPZmYgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlYWROZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5jaHVua09mZiA+PSB0aGlzLmNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5nZXRDaHVuaygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2h1bmtPZmYgPT0gdGhpcy5jaHVuay5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5leHQgPSB0aGlzLmNodW5rLmNoYXJDb2RlQXQodGhpcy5jaHVua09mZik7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgdGhlIHN0cmVhbSBmb3J3YXJkIE4gKGRlZmF1bHRzIHRvIDEpIGNvZGUgdW5pdHMuIFJldHVybnNcbiAgICB0aGUgbmV3IHZhbHVlIG9mIFtgbmV4dGBdKCNsci5JbnB1dFN0cmVhbS5uZXh0KS5cbiAgICAqL1xuICAgIGFkdmFuY2UobiA9IDEpIHtcbiAgICAgICAgdGhpcy5jaHVua09mZiArPSBuO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgKyBuID49IHRoaXMucmFuZ2UudG8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJhbmdlSW5kZXggPT0gdGhpcy5yYW5nZXMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXREb25lKCk7XG4gICAgICAgICAgICBuIC09IHRoaXMucmFuZ2UudG8gLSB0aGlzLnBvcztcbiAgICAgICAgICAgIHRoaXMucmFuZ2UgPSB0aGlzLnJhbmdlc1srK3RoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHRoaXMucmFuZ2UuZnJvbTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvcyArPSBuO1xuICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy50b2tlbi5sb29rQWhlYWQpXG4gICAgICAgICAgICB0aGlzLnRva2VuLmxvb2tBaGVhZCA9IHRoaXMucG9zICsgMTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZE5leHQoKTtcbiAgICB9XG4gICAgc2V0RG9uZSgpIHtcbiAgICAgICAgdGhpcy5wb3MgPSB0aGlzLmNodW5rUG9zID0gdGhpcy5lbmQ7XG4gICAgICAgIHRoaXMucmFuZ2UgPSB0aGlzLnJhbmdlc1t0aGlzLnJhbmdlSW5kZXggPSB0aGlzLnJhbmdlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgdGhpcy5jaHVuayA9IFwiXCI7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHQgPSAtMTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZXNldChwb3MsIHRva2VuKSB7XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgdG9rZW4uc3RhcnQgPSBwb3M7XG4gICAgICAgICAgICB0b2tlbi5sb29rQWhlYWQgPSBwb3MgKyAxO1xuICAgICAgICAgICAgdG9rZW4udmFsdWUgPSB0b2tlbi5leHRlbmRlZCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50b2tlbiA9IG51bGxUb2tlbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wb3MgIT0gcG9zKSB7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgICAgIGlmIChwb3MgPT0gdGhpcy5lbmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldERvbmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChwb3MgPCB0aGlzLnJhbmdlLmZyb20pXG4gICAgICAgICAgICAgICAgdGhpcy5yYW5nZSA9IHRoaXMucmFuZ2VzWy0tdGhpcy5yYW5nZUluZGV4XTtcbiAgICAgICAgICAgIHdoaWxlIChwb3MgPj0gdGhpcy5yYW5nZS50bylcbiAgICAgICAgICAgICAgICB0aGlzLnJhbmdlID0gdGhpcy5yYW5nZXNbKyt0aGlzLnJhbmdlSW5kZXhdO1xuICAgICAgICAgICAgaWYgKHBvcyA+PSB0aGlzLmNodW5rUG9zICYmIHBvcyA8IHRoaXMuY2h1bmtQb3MgKyB0aGlzLmNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2h1bmtPZmYgPSBwb3MgLSB0aGlzLmNodW5rUG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaHVuayA9IFwiXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5jaHVua09mZiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlYWROZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVhZChmcm9tLCB0bykge1xuICAgICAgICBpZiAoZnJvbSA+PSB0aGlzLmNodW5rUG9zICYmIHRvIDw9IHRoaXMuY2h1bmtQb3MgKyB0aGlzLmNodW5rLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNodW5rLnNsaWNlKGZyb20gLSB0aGlzLmNodW5rUG9zLCB0byAtIHRoaXMuY2h1bmtQb3MpO1xuICAgICAgICBpZiAoZnJvbSA+PSB0aGlzLmNodW5rMlBvcyAmJiB0byA8PSB0aGlzLmNodW5rMlBvcyArIHRoaXMuY2h1bmsyLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNodW5rMi5zbGljZShmcm9tIC0gdGhpcy5jaHVuazJQb3MsIHRvIC0gdGhpcy5jaHVuazJQb3MpO1xuICAgICAgICBpZiAoZnJvbSA+PSB0aGlzLnJhbmdlLmZyb20gJiYgdG8gPD0gdGhpcy5yYW5nZS50bylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlucHV0LnJlYWQoZnJvbSwgdG8pO1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgciBvZiB0aGlzLnJhbmdlcykge1xuICAgICAgICAgICAgaWYgKHIuZnJvbSA+PSB0bylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChyLnRvID4gZnJvbSlcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5pbnB1dC5yZWFkKE1hdGgubWF4KHIuZnJvbSwgZnJvbSksIE1hdGgubWluKHIudG8sIHRvKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vKipcbkBpbnRlcm5hbFxuKi9cbmNsYXNzIFRva2VuR3JvdXAge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEsIGlkKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICB9XG4gICAgdG9rZW4oaW5wdXQsIHN0YWNrKSB7XG4gICAgICAgIGxldCB7IHBhcnNlciB9ID0gc3RhY2sucDtcbiAgICAgICAgcmVhZFRva2VuKHRoaXMuZGF0YSwgaW5wdXQsIHN0YWNrLCB0aGlzLmlkLCBwYXJzZXIuZGF0YSwgcGFyc2VyLnRva2VuUHJlY1RhYmxlKTtcbiAgICB9XG59XG5Ub2tlbkdyb3VwLnByb3RvdHlwZS5jb250ZXh0dWFsID0gVG9rZW5Hcm91cC5wcm90b3R5cGUuZmFsbGJhY2sgPSBUb2tlbkdyb3VwLnByb3RvdHlwZS5leHRlbmQgPSBmYWxzZTtcbi8qKlxuQGhpZGVcbiovXG5jbGFzcyBMb2NhbFRva2VuR3JvdXAge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEsIHByZWNUYWJsZSwgZWxzZVRva2VuKSB7XG4gICAgICAgIHRoaXMucHJlY1RhYmxlID0gcHJlY1RhYmxlO1xuICAgICAgICB0aGlzLmVsc2VUb2tlbiA9IGVsc2VUb2tlbjtcbiAgICAgICAgdGhpcy5kYXRhID0gdHlwZW9mIGRhdGEgPT0gXCJzdHJpbmdcIiA/IGRlY29kZUFycmF5KGRhdGEpIDogZGF0YTtcbiAgICB9XG4gICAgdG9rZW4oaW5wdXQsIHN0YWNrKSB7XG4gICAgICAgIGxldCBzdGFydCA9IGlucHV0LnBvcywgc2tpcHBlZCA9IDA7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBhdEVvZiA9IGlucHV0Lm5leHQgPCAwLCBuZXh0UG9zID0gaW5wdXQucmVzb2x2ZU9mZnNldCgxLCAxKTtcbiAgICAgICAgICAgIHJlYWRUb2tlbih0aGlzLmRhdGEsIGlucHV0LCBzdGFjaywgMCwgdGhpcy5kYXRhLCB0aGlzLnByZWNUYWJsZSk7XG4gICAgICAgICAgICBpZiAoaW5wdXQudG9rZW4udmFsdWUgPiAtMSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmICh0aGlzLmVsc2VUb2tlbiA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICghYXRFb2YpXG4gICAgICAgICAgICAgICAgc2tpcHBlZCsrO1xuICAgICAgICAgICAgaWYgKG5leHRQb3MgPT0gbnVsbClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlucHV0LnJlc2V0KG5leHRQb3MsIGlucHV0LnRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2tpcHBlZCkge1xuICAgICAgICAgICAgaW5wdXQucmVzZXQoc3RhcnQsIGlucHV0LnRva2VuKTtcbiAgICAgICAgICAgIGlucHV0LmFjY2VwdFRva2VuKHRoaXMuZWxzZVRva2VuLCBza2lwcGVkKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbkxvY2FsVG9rZW5Hcm91cC5wcm90b3R5cGUuY29udGV4dHVhbCA9IFRva2VuR3JvdXAucHJvdG90eXBlLmZhbGxiYWNrID0gVG9rZW5Hcm91cC5wcm90b3R5cGUuZXh0ZW5kID0gZmFsc2U7XG4vKipcbmBAZXh0ZXJuYWwgdG9rZW5zYCBkZWNsYXJhdGlvbnMgaW4gdGhlIGdyYW1tYXIgc2hvdWxkIHJlc29sdmUgdG9cbmFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4qL1xuY2xhc3MgRXh0ZXJuYWxUb2tlbml6ZXIge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHRva2VuaXplci4gVGhlIGZpcnN0IGFyZ3VtZW50IGlzIHRoZSBmdW5jdGlvbiB0aGF0LFxuICAgIGdpdmVuIGFuIGlucHV0IHN0cmVhbSwgc2NhbnMgZm9yIHRoZSB0eXBlcyBvZiB0b2tlbnMgaXRcbiAgICByZWNvZ25pemVzIGF0IHRoZSBzdHJlYW0ncyBwb3NpdGlvbiwgYW5kIGNhbGxzXG4gICAgW2BhY2NlcHRUb2tlbmBdKCNsci5JbnB1dFN0cmVhbS5hY2NlcHRUb2tlbikgd2hlbiBpdCBmaW5kc1xuICAgIG9uZS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9rZW4sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgIHRoaXMuY29udGV4dHVhbCA9ICEhb3B0aW9ucy5jb250ZXh0dWFsO1xuICAgICAgICB0aGlzLmZhbGxiYWNrID0gISFvcHRpb25zLmZhbGxiYWNrO1xuICAgICAgICB0aGlzLmV4dGVuZCA9ICEhb3B0aW9ucy5leHRlbmQ7XG4gICAgfVxufVxuLy8gVG9rZW5pemVyIGRhdGEgaXMgc3RvcmVkIGEgYmlnIHVpbnQxNiBhcnJheSBjb250YWluaW5nLCBmb3IgZWFjaFxuLy8gc3RhdGU6XG4vL1xuLy8gIC0gQSBncm91cCBiaXRtYXNrLCBpbmRpY2F0aW5nIHdoYXQgdG9rZW4gZ3JvdXBzIGFyZSByZWFjaGFibGUgZnJvbVxuLy8gICAgdGhpcyBzdGF0ZSwgc28gdGhhdCBwYXRocyB0aGF0IGNhbiBvbmx5IGxlYWQgdG8gdG9rZW5zIG5vdCBpblxuLy8gICAgYW55IG9mIHRoZSBjdXJyZW50IGdyb3VwcyBjYW4gYmUgY3V0IG9mZiBlYXJseS5cbi8vXG4vLyAgLSBUaGUgcG9zaXRpb24gb2YgdGhlIGVuZCBvZiB0aGUgc3RhdGUncyBzZXF1ZW5jZSBvZiBhY2NlcHRpbmdcbi8vICAgIHRva2Vuc1xuLy9cbi8vICAtIFRoZSBudW1iZXIgb2Ygb3V0Z29pbmcgZWRnZXMgZm9yIHRoZSBzdGF0ZVxuLy9cbi8vICAtIFRoZSBhY2NlcHRpbmcgdG9rZW5zLCBhcyAodG9rZW4gaWQsIGdyb3VwIG1hc2spIHBhaXJzXG4vL1xuLy8gIC0gVGhlIG91dGdvaW5nIGVkZ2VzLCBhcyAoc3RhcnQgY2hhcmFjdGVyLCBlbmQgY2hhcmFjdGVyLCBzdGF0ZVxuLy8gICAgaW5kZXgpIHRyaXBsZXMsIHdpdGggZW5kIGNoYXJhY3RlciBiZWluZyBleGNsdXNpdmVcbi8vXG4vLyBUaGlzIGZ1bmN0aW9uIGludGVycHJldHMgdGhhdCBkYXRhLCBydW5uaW5nIHRocm91Z2ggYSBzdHJlYW0gYXNcbi8vIGxvbmcgYXMgbmV3IHN0YXRlcyB3aXRoIHRoZSBhIG1hdGNoaW5nIGdyb3VwIG1hc2sgY2FuIGJlIHJlYWNoZWQsXG4vLyBhbmQgdXBkYXRpbmcgYGlucHV0LnRva2VuYCB3aGVuIGl0IG1hdGNoZXMgYSB0b2tlbi5cbmZ1bmN0aW9uIHJlYWRUb2tlbihkYXRhLCBpbnB1dCwgc3RhY2ssIGdyb3VwLCBwcmVjVGFibGUsIHByZWNPZmZzZXQpIHtcbiAgICBsZXQgc3RhdGUgPSAwLCBncm91cE1hc2sgPSAxIDw8IGdyb3VwLCB7IGRpYWxlY3QgfSA9IHN0YWNrLnAucGFyc2VyO1xuICAgIHNjYW46IGZvciAoOzspIHtcbiAgICAgICAgaWYgKChncm91cE1hc2sgJiBkYXRhW3N0YXRlXSkgPT0gMClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBsZXQgYWNjRW5kID0gZGF0YVtzdGF0ZSArIDFdO1xuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoaXMgc3RhdGUgY2FuIGxlYWQgdG8gYSB0b2tlbiBpbiB0aGUgY3VycmVudCBncm91cFxuICAgICAgICAvLyBBY2NlcHQgdG9rZW5zIGluIHRoaXMgc3RhdGUsIHBvc3NpYmx5IG92ZXJ3cml0aW5nXG4gICAgICAgIC8vIGxvd2VyLXByZWNlZGVuY2UgLyBzaG9ydGVyIHRva2Vuc1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhdGUgKyAzOyBpIDwgYWNjRW5kOyBpICs9IDIpXG4gICAgICAgICAgICBpZiAoKGRhdGFbaSArIDFdICYgZ3JvdXBNYXNrKSA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgdGVybSA9IGRhdGFbaV07XG4gICAgICAgICAgICAgICAgaWYgKGRpYWxlY3QuYWxsb3dzKHRlcm0pICYmXG4gICAgICAgICAgICAgICAgICAgIChpbnB1dC50b2tlbi52YWx1ZSA9PSAtMSB8fCBpbnB1dC50b2tlbi52YWx1ZSA9PSB0ZXJtIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVycmlkZXModGVybSwgaW5wdXQudG9rZW4udmFsdWUsIHByZWNUYWJsZSwgcHJlY09mZnNldCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0LmFjY2VwdFRva2VuKHRlcm0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIGxldCBuZXh0ID0gaW5wdXQubmV4dCwgbG93ID0gMCwgaGlnaCA9IGRhdGFbc3RhdGUgKyAyXTtcbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciBFT0ZcbiAgICAgICAgaWYgKGlucHV0Lm5leHQgPCAwICYmIGhpZ2ggPiBsb3cgJiYgZGF0YVthY2NFbmQgKyBoaWdoICogMyAtIDNdID09IDY1NTM1IC8qIFNlcS5FbmQgKi8pIHtcbiAgICAgICAgICAgIHN0YXRlID0gZGF0YVthY2NFbmQgKyBoaWdoICogMyAtIDFdO1xuICAgICAgICAgICAgY29udGludWUgc2NhbjtcbiAgICAgICAgfVxuICAgICAgICAvLyBEbyBhIGJpbmFyeSBzZWFyY2ggb24gdGhlIHN0YXRlJ3MgZWRnZXNcbiAgICAgICAgZm9yICg7IGxvdyA8IGhpZ2g7KSB7XG4gICAgICAgICAgICBsZXQgbWlkID0gKGxvdyArIGhpZ2gpID4+IDE7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBhY2NFbmQgKyBtaWQgKyAobWlkIDw8IDEpO1xuICAgICAgICAgICAgbGV0IGZyb20gPSBkYXRhW2luZGV4XSwgdG8gPSBkYXRhW2luZGV4ICsgMV0gfHwgMHgxMDAwMDtcbiAgICAgICAgICAgIGlmIChuZXh0IDwgZnJvbSlcbiAgICAgICAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICAgICAgZWxzZSBpZiAobmV4dCA+PSB0bylcbiAgICAgICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBkYXRhW2luZGV4ICsgMl07XG4gICAgICAgICAgICAgICAgaW5wdXQuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlIHNjYW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZE9mZnNldChkYXRhLCBzdGFydCwgdGVybSkge1xuICAgIGZvciAobGV0IGkgPSBzdGFydCwgbmV4dDsgKG5leHQgPSBkYXRhW2ldKSAhPSA2NTUzNSAvKiBTZXEuRW5kICovOyBpKyspXG4gICAgICAgIGlmIChuZXh0ID09IHRlcm0pXG4gICAgICAgICAgICByZXR1cm4gaSAtIHN0YXJ0O1xuICAgIHJldHVybiAtMTtcbn1cbmZ1bmN0aW9uIG92ZXJyaWRlcyh0b2tlbiwgcHJldiwgdGFibGVEYXRhLCB0YWJsZU9mZnNldCkge1xuICAgIGxldCBpUHJldiA9IGZpbmRPZmZzZXQodGFibGVEYXRhLCB0YWJsZU9mZnNldCwgcHJldik7XG4gICAgcmV0dXJuIGlQcmV2IDwgMCB8fCBmaW5kT2Zmc2V0KHRhYmxlRGF0YSwgdGFibGVPZmZzZXQsIHRva2VuKSA8IGlQcmV2O1xufVxuXG4vLyBFbnZpcm9ubWVudCB2YXJpYWJsZSB1c2VkIHRvIGNvbnRyb2wgY29uc29sZSBvdXRwdXRcbmNvbnN0IHZlcmJvc2UgPSB0eXBlb2YgcHJvY2VzcyAhPSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52ICYmIC9cXGJwYXJzZVxcYi8udGVzdChwcm9jZXNzLmVudi5MT0cpO1xubGV0IHN0YWNrSURzID0gbnVsbDtcbmZ1bmN0aW9uIGN1dEF0KHRyZWUsIHBvcywgc2lkZSkge1xuICAgIGxldCBjdXJzb3IgPSB0cmVlLmN1cnNvcihJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKTtcbiAgICBjdXJzb3IubW92ZVRvKHBvcyk7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAoIShzaWRlIDwgMCA/IGN1cnNvci5jaGlsZEJlZm9yZShwb3MpIDogY3Vyc29yLmNoaWxkQWZ0ZXIocG9zKSkpXG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgaWYgKChzaWRlIDwgMCA/IGN1cnNvci50byA8IHBvcyA6IGN1cnNvci5mcm9tID4gcG9zKSAmJiAhY3Vyc29yLnR5cGUuaXNFcnJvcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZGUgPCAwID8gTWF0aC5tYXgoMCwgTWF0aC5taW4oY3Vyc29yLnRvIC0gMSwgcG9zIC0gMjUgLyogTG9va2FoZWFkLk1hcmdpbiAqLykpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IE1hdGgubWluKHRyZWUubGVuZ3RoLCBNYXRoLm1heChjdXJzb3IuZnJvbSArIDEsIHBvcyArIDI1IC8qIExvb2thaGVhZC5NYXJnaW4gKi8pKTtcbiAgICAgICAgICAgICAgICBpZiAoc2lkZSA8IDAgPyBjdXJzb3IucHJldlNpYmxpbmcoKSA6IGN1cnNvci5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnNvci5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZGUgPCAwID8gMCA6IHRyZWUubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIEZyYWdtZW50Q3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudHMsIG5vZGVTZXQpIHtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHM7XG4gICAgICAgIHRoaXMubm9kZVNldCA9IG5vZGVTZXQ7XG4gICAgICAgIHRoaXMuaSA9IDA7XG4gICAgICAgIHRoaXMuZnJhZ21lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLnNhZmVGcm9tID0gLTE7XG4gICAgICAgIHRoaXMuc2FmZVRvID0gLTE7XG4gICAgICAgIHRoaXMudHJlZXMgPSBbXTtcbiAgICAgICAgdGhpcy5zdGFydCA9IFtdO1xuICAgICAgICB0aGlzLmluZGV4ID0gW107XG4gICAgICAgIHRoaXMubmV4dEZyYWdtZW50KCk7XG4gICAgfVxuICAgIG5leHRGcmFnbWVudCgpIHtcbiAgICAgICAgbGV0IGZyID0gdGhpcy5mcmFnbWVudCA9IHRoaXMuaSA9PSB0aGlzLmZyYWdtZW50cy5sZW5ndGggPyBudWxsIDogdGhpcy5mcmFnbWVudHNbdGhpcy5pKytdO1xuICAgICAgICBpZiAoZnIpIHtcbiAgICAgICAgICAgIHRoaXMuc2FmZUZyb20gPSBmci5vcGVuU3RhcnQgPyBjdXRBdChmci50cmVlLCBmci5mcm9tICsgZnIub2Zmc2V0LCAxKSAtIGZyLm9mZnNldCA6IGZyLmZyb207XG4gICAgICAgICAgICB0aGlzLnNhZmVUbyA9IGZyLm9wZW5FbmQgPyBjdXRBdChmci50cmVlLCBmci50byArIGZyLm9mZnNldCwgLTEpIC0gZnIub2Zmc2V0IDogZnIudG87XG4gICAgICAgICAgICB3aGlsZSAodGhpcy50cmVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyZWVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleC5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJlZXMucHVzaChmci50cmVlKTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQucHVzaCgtZnIub2Zmc2V0KTtcbiAgICAgICAgICAgIHRoaXMuaW5kZXgucHVzaCgwKTtcbiAgICAgICAgICAgIHRoaXMubmV4dFN0YXJ0ID0gdGhpcy5zYWZlRnJvbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubmV4dFN0YXJ0ID0gMWU5O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGBwb3NgIG11c3QgYmUgPj0gYW55IHByZXZpb3VzbHkgZ2l2ZW4gYHBvc2AgZm9yIHRoaXMgY3Vyc29yXG4gICAgbm9kZUF0KHBvcykge1xuICAgICAgICBpZiAocG9zIDwgdGhpcy5uZXh0U3RhcnQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgd2hpbGUgKHRoaXMuZnJhZ21lbnQgJiYgdGhpcy5zYWZlVG8gPD0gcG9zKVxuICAgICAgICAgICAgdGhpcy5uZXh0RnJhZ21lbnQoKTtcbiAgICAgICAgaWYgKCF0aGlzLmZyYWdtZW50KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBsYXN0ID0gdGhpcy50cmVlcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgaWYgKGxhc3QgPCAwKSB7IC8vIEVuZCBvZiB0cmVlXG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0RnJhZ21lbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0b3AgPSB0aGlzLnRyZWVzW2xhc3RdLCBpbmRleCA9IHRoaXMuaW5kZXhbbGFzdF07XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gdG9wLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJlZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydC5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4LnBvcCgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG5leHQgPSB0b3AuY2hpbGRyZW5baW5kZXhdO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5zdGFydFtsYXN0XSArIHRvcC5wb3NpdGlvbnNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0U3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgVHJlZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCA9PSBwb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0IDwgdGhpcy5zYWZlRnJvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZW5kID0gc3RhcnQgKyBuZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZCA8PSB0aGlzLnNhZmVUbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxvb2tBaGVhZCA9IG5leHQucHJvcChOb2RlUHJvcC5sb29rQWhlYWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsb29rQWhlYWQgfHwgZW5kICsgbG9va0FoZWFkIDwgdGhpcy5mcmFnbWVudC50bylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4W2xhc3RdKys7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ICsgbmV4dC5sZW5ndGggPj0gTWF0aC5tYXgodGhpcy5zYWZlRnJvbSwgcG9zKSkgeyAvLyBFbnRlciB0aGlzIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmVlcy5wdXNoKG5leHQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0LnB1c2goc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4LnB1c2goMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleFtsYXN0XSsrO1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dFN0YXJ0ID0gc3RhcnQgKyBuZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFRva2VuQ2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgc3RyZWFtKSB7XG4gICAgICAgIHRoaXMuc3RyZWFtID0gc3RyZWFtO1xuICAgICAgICB0aGlzLnRva2VucyA9IFtdO1xuICAgICAgICB0aGlzLm1haW5Ub2tlbiA9IG51bGw7XG4gICAgICAgIHRoaXMuYWN0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLnRva2VucyA9IHBhcnNlci50b2tlbml6ZXJzLm1hcChfID0+IG5ldyBDYWNoZWRUb2tlbik7XG4gICAgfVxuICAgIGdldEFjdGlvbnMoc3RhY2spIHtcbiAgICAgICAgbGV0IGFjdGlvbkluZGV4ID0gMDtcbiAgICAgICAgbGV0IG1haW4gPSBudWxsO1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHN0YWNrLnAsIHsgdG9rZW5pemVycyB9ID0gcGFyc2VyO1xuICAgICAgICBsZXQgbWFzayA9IHBhcnNlci5zdGF0ZVNsb3Qoc3RhY2suc3RhdGUsIDMgLyogUGFyc2VTdGF0ZS5Ub2tlbml6ZXJNYXNrICovKTtcbiAgICAgICAgbGV0IGNvbnRleHQgPSBzdGFjay5jdXJDb250ZXh0ID8gc3RhY2suY3VyQ29udGV4dC5oYXNoIDogMDtcbiAgICAgICAgbGV0IGxvb2tBaGVhZCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5pemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCgoMSA8PCBpKSAmIG1hc2spID09IDApXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgdG9rZW5pemVyID0gdG9rZW5pemVyc1tpXSwgdG9rZW4gPSB0aGlzLnRva2Vuc1tpXTtcbiAgICAgICAgICAgIGlmIChtYWluICYmICF0b2tlbml6ZXIuZmFsbGJhY2spXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAodG9rZW5pemVyLmNvbnRleHR1YWwgfHwgdG9rZW4uc3RhcnQgIT0gc3RhY2sucG9zIHx8IHRva2VuLm1hc2sgIT0gbWFzayB8fCB0b2tlbi5jb250ZXh0ICE9IGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUNhY2hlZFRva2VuKHRva2VuLCB0b2tlbml6ZXIsIHN0YWNrKTtcbiAgICAgICAgICAgICAgICB0b2tlbi5tYXNrID0gbWFzaztcbiAgICAgICAgICAgICAgICB0b2tlbi5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b2tlbi5sb29rQWhlYWQgPiB0b2tlbi5lbmQgKyAyNSAvKiBMb29rYWhlYWQuTWFyZ2luICovKVxuICAgICAgICAgICAgICAgIGxvb2tBaGVhZCA9IE1hdGgubWF4KHRva2VuLmxvb2tBaGVhZCwgbG9va0FoZWFkKTtcbiAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSAhPSAwIC8qIFRlcm0uRXJyICovKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSBhY3Rpb25JbmRleDtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4uZXh0ZW5kZWQgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uSW5kZXggPSB0aGlzLmFkZEFjdGlvbnMoc3RhY2ssIHRva2VuLmV4dGVuZGVkLCB0b2tlbi5lbmQsIGFjdGlvbkluZGV4KTtcbiAgICAgICAgICAgICAgICBhY3Rpb25JbmRleCA9IHRoaXMuYWRkQWN0aW9ucyhzdGFjaywgdG9rZW4udmFsdWUsIHRva2VuLmVuZCwgYWN0aW9uSW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmICghdG9rZW5pemVyLmV4dGVuZCkge1xuICAgICAgICAgICAgICAgICAgICBtYWluID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb25JbmRleCA+IHN0YXJ0SW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMuYWN0aW9ucy5sZW5ndGggPiBhY3Rpb25JbmRleClcbiAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5wb3AoKTtcbiAgICAgICAgaWYgKGxvb2tBaGVhZClcbiAgICAgICAgICAgIHN0YWNrLnNldExvb2tBaGVhZChsb29rQWhlYWQpO1xuICAgICAgICBpZiAoIW1haW4gJiYgc3RhY2sucG9zID09IHRoaXMuc3RyZWFtLmVuZCkge1xuICAgICAgICAgICAgbWFpbiA9IG5ldyBDYWNoZWRUb2tlbjtcbiAgICAgICAgICAgIG1haW4udmFsdWUgPSBzdGFjay5wLnBhcnNlci5lb2ZUZXJtO1xuICAgICAgICAgICAgbWFpbi5zdGFydCA9IG1haW4uZW5kID0gc3RhY2sucG9zO1xuICAgICAgICAgICAgYWN0aW9uSW5kZXggPSB0aGlzLmFkZEFjdGlvbnMoc3RhY2ssIG1haW4udmFsdWUsIG1haW4uZW5kLCBhY3Rpb25JbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYWluVG9rZW4gPSBtYWluO1xuICAgICAgICByZXR1cm4gdGhpcy5hY3Rpb25zO1xuICAgIH1cbiAgICBnZXRNYWluVG9rZW4oc3RhY2spIHtcbiAgICAgICAgaWYgKHRoaXMubWFpblRva2VuKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFpblRva2VuO1xuICAgICAgICBsZXQgbWFpbiA9IG5ldyBDYWNoZWRUb2tlbiwgeyBwb3MsIHAgfSA9IHN0YWNrO1xuICAgICAgICBtYWluLnN0YXJ0ID0gcG9zO1xuICAgICAgICBtYWluLmVuZCA9IE1hdGgubWluKHBvcyArIDEsIHAuc3RyZWFtLmVuZCk7XG4gICAgICAgIG1haW4udmFsdWUgPSBwb3MgPT0gcC5zdHJlYW0uZW5kID8gcC5wYXJzZXIuZW9mVGVybSA6IDAgLyogVGVybS5FcnIgKi87XG4gICAgICAgIHJldHVybiBtYWluO1xuICAgIH1cbiAgICB1cGRhdGVDYWNoZWRUb2tlbih0b2tlbiwgdG9rZW5pemVyLCBzdGFjaykge1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnN0cmVhbS5jbGlwUG9zKHN0YWNrLnBvcyk7XG4gICAgICAgIHRva2VuaXplci50b2tlbih0aGlzLnN0cmVhbS5yZXNldChzdGFydCwgdG9rZW4pLCBzdGFjayk7XG4gICAgICAgIGlmICh0b2tlbi52YWx1ZSA+IC0xKSB7XG4gICAgICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHN0YWNrLnA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlci5zcGVjaWFsaXplZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VyLnNwZWNpYWxpemVkW2ldID09IHRva2VuLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBwYXJzZXIuc3BlY2lhbGl6ZXJzW2ldKHRoaXMuc3RyZWFtLnJlYWQodG9rZW4uc3RhcnQsIHRva2VuLmVuZCksIHN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA+PSAwICYmIHN0YWNrLnAucGFyc2VyLmRpYWxlY3QuYWxsb3dzKHJlc3VsdCA+PiAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChyZXN1bHQgJiAxKSA9PSAwIC8qIFNwZWNpYWxpemUuU3BlY2lhbGl6ZSAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi52YWx1ZSA9IHJlc3VsdCA+PiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLmV4dGVuZGVkID0gcmVzdWx0ID4+IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRva2VuLnZhbHVlID0gMCAvKiBUZXJtLkVyciAqLztcbiAgICAgICAgICAgIHRva2VuLmVuZCA9IHRoaXMuc3RyZWFtLmNsaXBQb3Moc3RhcnQgKyAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwdXRBY3Rpb24oYWN0aW9uLCB0b2tlbiwgZW5kLCBpbmRleCkge1xuICAgICAgICAvLyBEb24ndCBhZGQgZHVwbGljYXRlIGFjdGlvbnNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleDsgaSArPSAzKVxuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aW9uc1tpXSA9PSBhY3Rpb24pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB0aGlzLmFjdGlvbnNbaW5kZXgrK10gPSBhY3Rpb247XG4gICAgICAgIHRoaXMuYWN0aW9uc1tpbmRleCsrXSA9IHRva2VuO1xuICAgICAgICB0aGlzLmFjdGlvbnNbaW5kZXgrK10gPSBlbmQ7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gICAgYWRkQWN0aW9ucyhzdGFjaywgdG9rZW4sIGVuZCwgaW5kZXgpIHtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHN0YWNrLCB7IHBhcnNlciB9ID0gc3RhY2sucCwgeyBkYXRhIH0gPSBwYXJzZXI7XG4gICAgICAgIGZvciAobGV0IHNldCA9IDA7IHNldCA8IDI7IHNldCsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gcGFyc2VyLnN0YXRlU2xvdChzdGF0ZSwgc2V0ID8gMiAvKiBQYXJzZVN0YXRlLlNraXAgKi8gOiAxIC8qIFBhcnNlU3RhdGUuQWN0aW9ucyAqLyk7OyBpICs9IDMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVtpXSA9PSA2NTUzNSAvKiBTZXEuRW5kICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhW2kgKyAxXSA9PSAxIC8qIFNlcS5OZXh0ICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gcGFpcihkYXRhLCBpICsgMik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT0gMCAmJiBkYXRhW2kgKyAxXSA9PSAyIC8qIFNlcS5PdGhlciAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMucHV0QWN0aW9uKHBhaXIoZGF0YSwgaSArIDIpLCB0b2tlbiwgZW5kLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGF0YVtpXSA9PSB0b2tlbilcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLnB1dEFjdGlvbihwYWlyKGRhdGEsIGkgKyAxKSwgdG9rZW4sIGVuZCwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG59XG5jbGFzcyBQYXJzZSB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIHRoaXMucmVjb3ZlcmluZyA9IDA7XG4gICAgICAgIHRoaXMubmV4dFN0YWNrSUQgPSAweDI2NTQ7IC8vIOKZlCwg4pmVLCDimZYsIOKZlywg4pmYLCDimZksIOKZoCwg4pmhLCDimaIsIOKZoywg4pmkLCDimaUsIOKZpiwg4pmnXG4gICAgICAgIHRoaXMubWluU3RhY2tQb3MgPSAwO1xuICAgICAgICB0aGlzLnJldXNlZCA9IFtdO1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdEJpZ1JlZHVjdGlvblN0YXJ0ID0gLTE7XG4gICAgICAgIHRoaXMubGFzdEJpZ1JlZHVjdGlvblNpemUgPSAwO1xuICAgICAgICB0aGlzLmJpZ1JlZHVjdGlvbkNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBuZXcgSW5wdXRTdHJlYW0oaW5wdXQsIHJhbmdlcyk7XG4gICAgICAgIHRoaXMudG9rZW5zID0gbmV3IFRva2VuQ2FjaGUocGFyc2VyLCB0aGlzLnN0cmVhbSk7XG4gICAgICAgIHRoaXMudG9wVGVybSA9IHBhcnNlci50b3BbMV07XG4gICAgICAgIGxldCB7IGZyb20gfSA9IHJhbmdlc1swXTtcbiAgICAgICAgdGhpcy5zdGFja3MgPSBbU3RhY2suc3RhcnQodGhpcywgcGFyc2VyLnRvcFswXSwgZnJvbSldO1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cy5sZW5ndGggJiYgdGhpcy5zdHJlYW0uZW5kIC0gZnJvbSA+IHBhcnNlci5idWZmZXJMZW5ndGggKiA0XG4gICAgICAgICAgICA/IG5ldyBGcmFnbWVudEN1cnNvcihmcmFnbWVudHMsIHBhcnNlci5ub2RlU2V0KSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBwYXJzZWRQb3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pblN0YWNrUG9zO1xuICAgIH1cbiAgICAvLyBNb3ZlIHRoZSBwYXJzZXIgZm9yd2FyZC4gVGhpcyB3aWxsIHByb2Nlc3MgYWxsIHBhcnNlIHN0YWNrcyBhdFxuICAgIC8vIGB0aGlzLnBvc2AgYW5kIHRyeSB0byBhZHZhbmNlIHRoZW0gdG8gYSBmdXJ0aGVyIHBvc2l0aW9uLiBJZiBub1xuICAgIC8vIHN0YWNrIGZvciBzdWNoIGEgcG9zaXRpb24gaXMgZm91bmQsIGl0J2xsIHN0YXJ0IGVycm9yLXJlY292ZXJ5LlxuICAgIC8vXG4gICAgLy8gV2hlbiB0aGUgcGFyc2UgaXMgZmluaXNoZWQsIHRoaXMgd2lsbCByZXR1cm4gYSBzeW50YXggdHJlZS4gV2hlblxuICAgIC8vIG5vdCwgaXQgcmV0dXJucyBgbnVsbGAuXG4gICAgYWR2YW5jZSgpIHtcbiAgICAgICAgbGV0IHN0YWNrcyA9IHRoaXMuc3RhY2tzLCBwb3MgPSB0aGlzLm1pblN0YWNrUG9zO1xuICAgICAgICAvLyBUaGlzIHdpbGwgaG9sZCBzdGFja3MgYmV5b25kIGBwb3NgLlxuICAgICAgICBsZXQgbmV3U3RhY2tzID0gdGhpcy5zdGFja3MgPSBbXTtcbiAgICAgICAgbGV0IHN0b3BwZWQsIHN0b3BwZWRUb2tlbnM7XG4gICAgICAgIC8vIElmIGEgbGFyZ2UgYW1vdW50IG9mIHJlZHVjdGlvbnMgaGFwcGVuZWQgd2l0aCB0aGUgc2FtZSBzdGFydFxuICAgICAgICAvLyBwb3NpdGlvbiwgZm9yY2UgdGhlIHN0YWNrIG91dCBvZiB0aGF0IHByb2R1Y3Rpb24gaW4gb3JkZXIgdG9cbiAgICAgICAgLy8gYXZvaWQgY3JlYXRpbmcgYSB0cmVlIHRvbyBkZWVwIHRvIHJlY3Vyc2UgdGhyb3VnaC5cbiAgICAgICAgLy8gKFRoaXMgaXMgYW4gdWdseSBrbHVkZ2UsIGJlY2F1c2UgdW5mb3J0dW5hdGVseSB0aGVyZSBpcyBub1xuICAgICAgICAvLyBzdHJhaWdodGZvcndhcmQsIGNoZWFwIHdheSB0byBjaGVjayBmb3IgdGhpcyBoYXBwZW5pbmcsIGR1ZSB0b1xuICAgICAgICAvLyB0aGUgaGlzdG9yeSBvZiByZWR1Y3Rpb25zIG9ubHkgYmVpbmcgYXZhaWxhYmxlIGluIGFuXG4gICAgICAgIC8vIGV4cGVuc2l2ZS10by1hY2Nlc3MgZm9ybWF0IGluIHRoZSBzdGFjayBidWZmZXJzLilcbiAgICAgICAgaWYgKHRoaXMuYmlnUmVkdWN0aW9uQ291bnQgPiAzMDAgLyogUmVjLk1heExlZnRBc3NvY2lhdGl2ZVJlZHVjdGlvbkNvdW50ICovICYmIHN0YWNrcy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgbGV0IFtzXSA9IHN0YWNrcztcbiAgICAgICAgICAgIHdoaWxlIChzLmZvcmNlUmVkdWNlKCkgJiYgcy5zdGFjay5sZW5ndGggJiYgcy5zdGFja1tzLnN0YWNrLmxlbmd0aCAtIDJdID49IHRoaXMubGFzdEJpZ1JlZHVjdGlvblN0YXJ0KSB7IH1cbiAgICAgICAgICAgIHRoaXMuYmlnUmVkdWN0aW9uQ291bnQgPSB0aGlzLmxhc3RCaWdSZWR1Y3Rpb25TaXplID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBLZWVwIGFkdmFuY2luZyBhbnkgc3RhY2tzIGF0IGBwb3NgIHVudGlsIHRoZXkgZWl0aGVyIG1vdmVcbiAgICAgICAgLy8gZm9yd2FyZCBvciBjYW4ndCBiZSBhZHZhbmNlZC4gR2F0aGVyIHN0YWNrcyB0aGF0IGNhbid0IGJlXG4gICAgICAgIC8vIGFkdmFuY2VkIGZ1cnRoZXIgaW4gYHN0b3BwZWRgLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHN0YWNrID0gc3RhY2tzW2ldO1xuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIHRoaXMudG9rZW5zLm1haW5Ub2tlbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHN0YWNrLnBvcyA+IHBvcykge1xuICAgICAgICAgICAgICAgICAgICBuZXdTdGFja3MucHVzaChzdGFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuYWR2YW5jZVN0YWNrKHN0YWNrLCBuZXdTdGFja3MsIHN0YWNrcykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0b3BwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BwZWQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BwZWRUb2tlbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdG9wcGVkLnB1c2goc3RhY2spO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdG9rID0gdGhpcy50b2tlbnMuZ2V0TWFpblRva2VuKHN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgc3RvcHBlZFRva2Vucy5wdXNoKHRvay52YWx1ZSwgdG9rLmVuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbmV3U3RhY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGZpbmlzaGVkID0gc3RvcHBlZCAmJiBmaW5kRmluaXNoZWQoc3RvcHBlZCk7XG4gICAgICAgICAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJGaW5pc2ggd2l0aCBcIiArIHRoaXMuc3RhY2tJRChmaW5pc2hlZCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YWNrVG9UcmVlKGZpbmlzaGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnBhcnNlci5zdHJpY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSAmJiBzdG9wcGVkKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlN0dWNrIHdpdGggdG9rZW4gXCIgKyAodGhpcy50b2tlbnMubWFpblRva2VuID8gdGhpcy5wYXJzZXIuZ2V0TmFtZSh0aGlzLnRva2Vucy5tYWluVG9rZW4udmFsdWUpIDogXCJub25lXCIpKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJObyBwYXJzZSBhdCBcIiArIHBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVjb3ZlcmluZylcbiAgICAgICAgICAgICAgICB0aGlzLnJlY292ZXJpbmcgPSA1IC8qIFJlYy5EaXN0YW5jZSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWNvdmVyaW5nICYmIHN0b3BwZWQpIHtcbiAgICAgICAgICAgIGxldCBmaW5pc2hlZCA9IHRoaXMuc3RvcHBlZEF0ICE9IG51bGwgJiYgc3RvcHBlZFswXS5wb3MgPiB0aGlzLnN0b3BwZWRBdCA/IHN0b3BwZWRbMF1cbiAgICAgICAgICAgICAgICA6IHRoaXMucnVuUmVjb3Zlcnkoc3RvcHBlZCwgc3RvcHBlZFRva2VucywgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkZvcmNlLWZpbmlzaCBcIiArIHRoaXMuc3RhY2tJRChmaW5pc2hlZCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YWNrVG9UcmVlKGZpbmlzaGVkLmZvcmNlQWxsKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlY292ZXJpbmcpIHtcbiAgICAgICAgICAgIGxldCBtYXhSZW1haW5pbmcgPSB0aGlzLnJlY292ZXJpbmcgPT0gMSA/IDEgOiB0aGlzLnJlY292ZXJpbmcgKiAzIC8qIFJlYy5NYXhSZW1haW5pbmdQZXJTdGVwICovO1xuICAgICAgICAgICAgaWYgKG5ld1N0YWNrcy5sZW5ndGggPiBtYXhSZW1haW5pbmcpIHtcbiAgICAgICAgICAgICAgICBuZXdTdGFja3Muc29ydCgoYSwgYikgPT4gYi5zY29yZSAtIGEuc2NvcmUpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChuZXdTdGFja3MubGVuZ3RoID4gbWF4UmVtYWluaW5nKVxuICAgICAgICAgICAgICAgICAgICBuZXdTdGFja3MucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3U3RhY2tzLnNvbWUocyA9PiBzLnJlZHVjZVBvcyA+IHBvcykpXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvdmVyaW5nLS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV3U3RhY2tzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIC8vIFBydW5lIHN0YWNrcyB0aGF0IGFyZSBpbiB0aGUgc2FtZSBzdGF0ZSwgb3IgdGhhdCBoYXZlIGJlZW5cbiAgICAgICAgICAgIC8vIHJ1bm5pbmcgd2l0aG91dCBzcGxpdHRpbmcgZm9yIGEgd2hpbGUsIHRvIGF2b2lkIGdldHRpbmcgc3R1Y2tcbiAgICAgICAgICAgIC8vIHdpdGggbXVsdGlwbGUgc3VjY2Vzc2Z1bCBzdGFja3MgcnVubmluZyBlbmRsZXNzbHkgb24uXG4gICAgICAgICAgICBvdXRlcjogZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdTdGFja3MubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YWNrID0gbmV3U3RhY2tzW2ldO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IG5ld1N0YWNrcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb3RoZXIgPSBuZXdTdGFja3Nbal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5zYW1lU3RhdGUob3RoZXIpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5idWZmZXIubGVuZ3RoID4gNTAwIC8qIFJlYy5NaW5CdWZmZXJMZW5ndGhQcnVuZSAqLyAmJiBvdGhlci5idWZmZXIubGVuZ3RoID4gNTAwIC8qIFJlYy5NaW5CdWZmZXJMZW5ndGhQcnVuZSAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgoc3RhY2suc2NvcmUgLSBvdGhlci5zY29yZSkgfHwgKHN0YWNrLmJ1ZmZlci5sZW5ndGggLSBvdGhlci5idWZmZXIubGVuZ3RoKSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3RhY2tzLnNwbGljZShqLS0sIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3RhY2tzLnNwbGljZShpLS0sIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld1N0YWNrcy5sZW5ndGggPiAxMiAvKiBSZWMuTWF4U3RhY2tDb3VudCAqLylcbiAgICAgICAgICAgICAgICBuZXdTdGFja3Muc3BsaWNlKDEyIC8qIFJlYy5NYXhTdGFja0NvdW50ICovLCBuZXdTdGFja3MubGVuZ3RoIC0gMTIgLyogUmVjLk1heFN0YWNrQ291bnQgKi8pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWluU3RhY2tQb3MgPSBuZXdTdGFja3NbMF0ucG9zO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG5ld1N0YWNrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChuZXdTdGFja3NbaV0ucG9zIDwgdGhpcy5taW5TdGFja1BvcylcbiAgICAgICAgICAgICAgICB0aGlzLm1pblN0YWNrUG9zID0gbmV3U3RhY2tzW2ldLnBvcztcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHN0b3BBdChwb3MpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RvcHBlZEF0ICE9IG51bGwgJiYgdGhpcy5zdG9wcGVkQXQgPCBwb3MpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNhbid0IG1vdmUgc3RvcHBlZEF0IGZvcndhcmRcIik7XG4gICAgICAgIHRoaXMuc3RvcHBlZEF0ID0gcG9zO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIGFuIHVwZGF0ZWQgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gc3RhY2ssIG9yIG51bGwgaWYgdGhlXG4gICAgLy8gc3RhY2sgY2FuJ3QgYWR2YW5jZSBub3JtYWxseS4gV2hlbiBgc3BsaXRgIGFuZCBgc3RhY2tzYCBhcmVcbiAgICAvLyBnaXZlbiwgc3RhY2tzIHNwbGl0IG9mZiBieSBhbWJpZ3VvdXMgb3BlcmF0aW9ucyB3aWxsIGJlIHB1c2hlZCB0b1xuICAgIC8vIGBzcGxpdGAsIG9yIGFkZGVkIHRvIGBzdGFja3NgIGlmIHRoZXkgbW92ZSBgcG9zYCBmb3J3YXJkLlxuICAgIGFkdmFuY2VTdGFjayhzdGFjaywgc3RhY2tzLCBzcGxpdCkge1xuICAgICAgICBsZXQgc3RhcnQgPSBzdGFjay5wb3MsIHsgcGFyc2VyIH0gPSB0aGlzO1xuICAgICAgICBsZXQgYmFzZSA9IHZlcmJvc2UgPyB0aGlzLnN0YWNrSUQoc3RhY2spICsgXCIgLT4gXCIgOiBcIlwiO1xuICAgICAgICBpZiAodGhpcy5zdG9wcGVkQXQgIT0gbnVsbCAmJiBzdGFydCA+IHRoaXMuc3RvcHBlZEF0KVxuICAgICAgICAgICAgcmV0dXJuIHN0YWNrLmZvcmNlUmVkdWNlKCkgPyBzdGFjayA6IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmZyYWdtZW50cykge1xuICAgICAgICAgICAgbGV0IHN0cmljdEN4ID0gc3RhY2suY3VyQ29udGV4dCAmJiBzdGFjay5jdXJDb250ZXh0LnRyYWNrZXIuc3RyaWN0LCBjeEhhc2ggPSBzdHJpY3RDeCA/IHN0YWNrLmN1ckNvbnRleHQuaGFzaCA6IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBjYWNoZWQgPSB0aGlzLmZyYWdtZW50cy5ub2RlQXQoc3RhcnQpOyBjYWNoZWQ7KSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hdGNoID0gdGhpcy5wYXJzZXIubm9kZVNldC50eXBlc1tjYWNoZWQudHlwZS5pZF0gPT0gY2FjaGVkLnR5cGUgPyBwYXJzZXIuZ2V0R290byhzdGFjay5zdGF0ZSwgY2FjaGVkLnR5cGUuaWQpIDogLTE7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoID4gLTEgJiYgY2FjaGVkLmxlbmd0aCAmJiAoIXN0cmljdEN4IHx8IChjYWNoZWQucHJvcChOb2RlUHJvcC5jb250ZXh0SGFzaCkgfHwgMCkgPT0gY3hIYXNoKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGFjay51c2VOb2RlKGNhY2hlZCwgbWF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoc3RhY2spICsgYCAodmlhIHJldXNlIG9mICR7cGFyc2VyLmdldE5hbWUoY2FjaGVkLnR5cGUuaWQpfSlgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghKGNhY2hlZCBpbnN0YW5jZW9mIFRyZWUpIHx8IGNhY2hlZC5jaGlsZHJlbi5sZW5ndGggPT0gMCB8fCBjYWNoZWQucG9zaXRpb25zWzBdID4gMClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgbGV0IGlubmVyID0gY2FjaGVkLmNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgICAgIGlmIChpbm5lciBpbnN0YW5jZW9mIFRyZWUgJiYgY2FjaGVkLnBvc2l0aW9uc1swXSA9PSAwKVxuICAgICAgICAgICAgICAgICAgICBjYWNoZWQgPSBpbm5lcjtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBkZWZhdWx0UmVkdWNlID0gcGFyc2VyLnN0YXRlU2xvdChzdGFjay5zdGF0ZSwgNCAvKiBQYXJzZVN0YXRlLkRlZmF1bHRSZWR1Y2UgKi8pO1xuICAgICAgICBpZiAoZGVmYXVsdFJlZHVjZSA+IDApIHtcbiAgICAgICAgICAgIHN0YWNrLnJlZHVjZShkZWZhdWx0UmVkdWNlKTtcbiAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoc3RhY2spICsgYCAodmlhIGFsd2F5cy1yZWR1Y2UgJHtwYXJzZXIuZ2V0TmFtZShkZWZhdWx0UmVkdWNlICYgNjU1MzUgLyogQWN0aW9uLlZhbHVlTWFzayAqLyl9KWApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YWNrLnN0YWNrLmxlbmd0aCA+PSA4NDAwIC8qIFJlYy5DdXREZXB0aCAqLykge1xuICAgICAgICAgICAgd2hpbGUgKHN0YWNrLnN0YWNrLmxlbmd0aCA+IDYwMDAgLyogUmVjLkN1dFRvICovICYmIHN0YWNrLmZvcmNlUmVkdWNlKCkpIHsgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBhY3Rpb25zID0gdGhpcy50b2tlbnMuZ2V0QWN0aW9ucyhzdGFjayk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWN0aW9ucy5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgYWN0aW9uID0gYWN0aW9uc1tpKytdLCB0ZXJtID0gYWN0aW9uc1tpKytdLCBlbmQgPSBhY3Rpb25zW2krK107XG4gICAgICAgICAgICBsZXQgbGFzdCA9IGkgPT0gYWN0aW9ucy5sZW5ndGggfHwgIXNwbGl0O1xuICAgICAgICAgICAgbGV0IGxvY2FsU3RhY2sgPSBsYXN0ID8gc3RhY2sgOiBzdGFjay5zcGxpdCgpO1xuICAgICAgICAgICAgbGV0IG1haW4gPSB0aGlzLnRva2Vucy5tYWluVG9rZW47XG4gICAgICAgICAgICBsb2NhbFN0YWNrLmFwcGx5KGFjdGlvbiwgdGVybSwgbWFpbiA/IG1haW4uc3RhcnQgOiBsb2NhbFN0YWNrLnBvcywgZW5kKTtcbiAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQobG9jYWxTdGFjaykgKyBgICh2aWEgJHsoYWN0aW9uICYgNjU1MzYgLyogQWN0aW9uLlJlZHVjZUZsYWcgKi8pID09IDAgPyBcInNoaWZ0XCJcbiAgICAgICAgICAgICAgICAgICAgOiBgcmVkdWNlIG9mICR7cGFyc2VyLmdldE5hbWUoYWN0aW9uICYgNjU1MzUgLyogQWN0aW9uLlZhbHVlTWFzayAqLyl9YH0gZm9yICR7cGFyc2VyLmdldE5hbWUodGVybSl9IEAgJHtzdGFydH0ke2xvY2FsU3RhY2sgPT0gc3RhY2sgPyBcIlwiIDogXCIsIHNwbGl0XCJ9KWApO1xuICAgICAgICAgICAgaWYgKGxhc3QpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBlbHNlIGlmIChsb2NhbFN0YWNrLnBvcyA+IHN0YXJ0KVxuICAgICAgICAgICAgICAgIHN0YWNrcy5wdXNoKGxvY2FsU3RhY2spO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNwbGl0LnB1c2gobG9jYWxTdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBBZHZhbmNlIGEgZ2l2ZW4gc3RhY2sgZm9yd2FyZCBhcyBmYXIgYXMgaXQgd2lsbCBnby4gUmV0dXJucyB0aGVcbiAgICAvLyAocG9zc2libHkgdXBkYXRlZCkgc3RhY2sgaWYgaXQgZ290IHN0dWNrLCBvciBudWxsIGlmIGl0IG1vdmVkXG4gICAgLy8gZm9yd2FyZCBhbmQgd2FzIGdpdmVuIHRvIGBwdXNoU3RhY2tEZWR1cGAuXG4gICAgYWR2YW5jZUZ1bGx5KHN0YWNrLCBuZXdTdGFja3MpIHtcbiAgICAgICAgbGV0IHBvcyA9IHN0YWNrLnBvcztcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmFkdmFuY2VTdGFjayhzdGFjaywgbnVsbCwgbnVsbCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKHN0YWNrLnBvcyA+IHBvcykge1xuICAgICAgICAgICAgICAgIHB1c2hTdGFja0RlZHVwKHN0YWNrLCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJ1blJlY292ZXJ5KHN0YWNrcywgdG9rZW5zLCBuZXdTdGFja3MpIHtcbiAgICAgICAgbGV0IGZpbmlzaGVkID0gbnVsbCwgcmVzdGFydGVkID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RhY2sgPSBzdGFja3NbaV0sIHRva2VuID0gdG9rZW5zW2kgPDwgMV0sIHRva2VuRW5kID0gdG9rZW5zWyhpIDw8IDEpICsgMV07XG4gICAgICAgICAgICBsZXQgYmFzZSA9IHZlcmJvc2UgPyB0aGlzLnN0YWNrSUQoc3RhY2spICsgXCIgLT4gXCIgOiBcIlwiO1xuICAgICAgICAgICAgaWYgKHN0YWNrLmRlYWRFbmQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdGFydGVkKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICByZXN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YWNrLnJlc3RhcnQoKTtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChzdGFjaykgKyBcIiAocmVzdGFydGVkKVwiKTtcbiAgICAgICAgICAgICAgICBsZXQgZG9uZSA9IHRoaXMuYWR2YW5jZUZ1bGx5KHN0YWNrLCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmb3JjZSA9IHN0YWNrLnNwbGl0KCksIGZvcmNlQmFzZSA9IGJhc2U7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgZm9yY2UuZm9yY2VSZWR1Y2UoKSAmJiBqIDwgMTAgLyogUmVjLkZvcmNlUmVkdWNlTGltaXQgKi87IGorKykge1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhmb3JjZUJhc2UgKyB0aGlzLnN0YWNrSUQoZm9yY2UpICsgXCIgKHZpYSBmb3JjZS1yZWR1Y2UpXCIpO1xuICAgICAgICAgICAgICAgIGxldCBkb25lID0gdGhpcy5hZHZhbmNlRnVsbHkoZm9yY2UsIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBmb3JjZUJhc2UgPSB0aGlzLnN0YWNrSUQoZm9yY2UpICsgXCIgLT4gXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpbnNlcnQgb2Ygc3RhY2sucmVjb3ZlckJ5SW5zZXJ0KHRva2VuKSkge1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKGluc2VydCkgKyBcIiAodmlhIHJlY292ZXItaW5zZXJ0KVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2VGdWxseShpbnNlcnQsIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zdHJlYW0uZW5kID4gc3RhY2sucG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuRW5kID09IHN0YWNrLnBvcykge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbkVuZCsrO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IDAgLyogVGVybS5FcnIgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YWNrLnJlY292ZXJCeURlbGV0ZSh0b2tlbiwgdG9rZW5FbmQpO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKHN0YWNrKSArIGAgKHZpYSByZWNvdmVyLWRlbGV0ZSAke3RoaXMucGFyc2VyLmdldE5hbWUodG9rZW4pfSlgKTtcbiAgICAgICAgICAgICAgICBwdXNoU3RhY2tEZWR1cChzdGFjaywgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFmaW5pc2hlZCB8fCBmaW5pc2hlZC5zY29yZSA8IHN0YWNrLnNjb3JlKSB7XG4gICAgICAgICAgICAgICAgZmluaXNoZWQgPSBzdGFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmluaXNoZWQ7XG4gICAgfVxuICAgIC8vIENvbnZlcnQgdGhlIHN0YWNrJ3MgYnVmZmVyIHRvIGEgc3ludGF4IHRyZWUuXG4gICAgc3RhY2tUb1RyZWUoc3RhY2spIHtcbiAgICAgICAgc3RhY2suY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuIFRyZWUuYnVpbGQoeyBidWZmZXI6IFN0YWNrQnVmZmVyQ3Vyc29yLmNyZWF0ZShzdGFjayksXG4gICAgICAgICAgICBub2RlU2V0OiB0aGlzLnBhcnNlci5ub2RlU2V0LFxuICAgICAgICAgICAgdG9wSUQ6IHRoaXMudG9wVGVybSxcbiAgICAgICAgICAgIG1heEJ1ZmZlckxlbmd0aDogdGhpcy5wYXJzZXIuYnVmZmVyTGVuZ3RoLFxuICAgICAgICAgICAgcmV1c2VkOiB0aGlzLnJldXNlZCxcbiAgICAgICAgICAgIHN0YXJ0OiB0aGlzLnJhbmdlc1swXS5mcm9tLFxuICAgICAgICAgICAgbGVuZ3RoOiBzdGFjay5wb3MgLSB0aGlzLnJhbmdlc1swXS5mcm9tLFxuICAgICAgICAgICAgbWluUmVwZWF0VHlwZTogdGhpcy5wYXJzZXIubWluUmVwZWF0VGVybSB9KTtcbiAgICB9XG4gICAgc3RhY2tJRChzdGFjaykge1xuICAgICAgICBsZXQgaWQgPSAoc3RhY2tJRHMgfHwgKHN0YWNrSURzID0gbmV3IFdlYWtNYXApKS5nZXQoc3RhY2spO1xuICAgICAgICBpZiAoIWlkKVxuICAgICAgICAgICAgc3RhY2tJRHMuc2V0KHN0YWNrLCBpZCA9IFN0cmluZy5mcm9tQ29kZVBvaW50KHRoaXMubmV4dFN0YWNrSUQrKykpO1xuICAgICAgICByZXR1cm4gaWQgKyBzdGFjaztcbiAgICB9XG59XG5mdW5jdGlvbiBwdXNoU3RhY2tEZWR1cChzdGFjaywgbmV3U3RhY2tzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdTdGFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG90aGVyID0gbmV3U3RhY2tzW2ldO1xuICAgICAgICBpZiAob3RoZXIucG9zID09IHN0YWNrLnBvcyAmJiBvdGhlci5zYW1lU3RhdGUoc3RhY2spKSB7XG4gICAgICAgICAgICBpZiAobmV3U3RhY2tzW2ldLnNjb3JlIDwgc3RhY2suc2NvcmUpXG4gICAgICAgICAgICAgICAgbmV3U3RhY2tzW2ldID0gc3RhY2s7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV3U3RhY2tzLnB1c2goc3RhY2spO1xufVxuY2xhc3MgRGlhbGVjdCB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlLCBmbGFncywgZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGRpc2FibGVkO1xuICAgIH1cbiAgICBhbGxvd3ModGVybSkgeyByZXR1cm4gIXRoaXMuZGlzYWJsZWQgfHwgdGhpcy5kaXNhYmxlZFt0ZXJtXSA9PSAwOyB9XG59XG5jb25zdCBpZCA9IHggPT4geDtcbi8qKlxuQ29udGV4dCB0cmFja2VycyBhcmUgdXNlZCB0byB0cmFjayBzdGF0ZWZ1bCBjb250ZXh0IChzdWNoIGFzXG5pbmRlbnRhdGlvbiBpbiB0aGUgUHl0aG9uIGdyYW1tYXIsIG9yIHBhcmVudCBlbGVtZW50cyBpbiB0aGUgWE1MXG5ncmFtbWFyKSBuZWVkZWQgYnkgZXh0ZXJuYWwgdG9rZW5pemVycy4gWW91IGRlY2xhcmUgdGhlbSBpbiBhXG5ncmFtbWFyIGZpbGUgYXMgYEBjb250ZXh0IGV4cG9ydE5hbWUgZnJvbSBcIm1vZHVsZVwiYC5cblxuQ29udGV4dCB2YWx1ZXMgc2hvdWxkIGJlIGltbXV0YWJsZSwgYW5kIGNhbiBiZSB1cGRhdGVkIChyZXBsYWNlZClcbm9uIHNoaWZ0IG9yIHJlZHVjZSBhY3Rpb25zLlxuXG5UaGUgZXhwb3J0IHVzZWQgaW4gYSBgQGNvbnRleHRgIGRlY2xhcmF0aW9uIHNob3VsZCBiZSBvZiB0aGlzXG50eXBlLlxuKi9cbmNsYXNzIENvbnRleHRUcmFja2VyIHtcbiAgICAvKipcbiAgICBEZWZpbmUgYSBjb250ZXh0IHRyYWNrZXIuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzcGVjLnN0YXJ0O1xuICAgICAgICB0aGlzLnNoaWZ0ID0gc3BlYy5zaGlmdCB8fCBpZDtcbiAgICAgICAgdGhpcy5yZWR1Y2UgPSBzcGVjLnJlZHVjZSB8fCBpZDtcbiAgICAgICAgdGhpcy5yZXVzZSA9IHNwZWMucmV1c2UgfHwgaWQ7XG4gICAgICAgIHRoaXMuaGFzaCA9IHNwZWMuaGFzaCB8fCAoKCkgPT4gMCk7XG4gICAgICAgIHRoaXMuc3RyaWN0ID0gc3BlYy5zdHJpY3QgIT09IGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuSG9sZHMgdGhlIHBhcnNlIHRhYmxlcyBmb3IgYSBnaXZlbiBncmFtbWFyLCBhcyBnZW5lcmF0ZWQgYnlcbmBsZXplci1nZW5lcmF0b3JgLCBhbmQgcHJvdmlkZXMgW21ldGhvZHNdKCNjb21tb24uUGFyc2VyKSB0byBwYXJzZVxuY29udGVudCB3aXRoLlxuKi9cbmNsYXNzIExSUGFyc2VyIGV4dGVuZHMgUGFyc2VyIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLndyYXBwZXJzID0gW107XG4gICAgICAgIGlmIChzcGVjLnZlcnNpb24gIT0gMTQgLyogRmlsZS5WZXJzaW9uICovKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFBhcnNlciB2ZXJzaW9uICgke3NwZWMudmVyc2lvbn0pIGRvZXNuJ3QgbWF0Y2ggcnVudGltZSB2ZXJzaW9uICgkezE0IC8qIEZpbGUuVmVyc2lvbiAqL30pYCk7XG4gICAgICAgIGxldCBub2RlTmFtZXMgPSBzcGVjLm5vZGVOYW1lcy5zcGxpdChcIiBcIik7XG4gICAgICAgIHRoaXMubWluUmVwZWF0VGVybSA9IG5vZGVOYW1lcy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3BlYy5yZXBlYXROb2RlQ291bnQ7IGkrKylcbiAgICAgICAgICAgIG5vZGVOYW1lcy5wdXNoKFwiXCIpO1xuICAgICAgICBsZXQgdG9wVGVybXMgPSBPYmplY3Qua2V5cyhzcGVjLnRvcFJ1bGVzKS5tYXAociA9PiBzcGVjLnRvcFJ1bGVzW3JdWzFdKTtcbiAgICAgICAgbGV0IG5vZGVQcm9wcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVOYW1lcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIG5vZGVQcm9wcy5wdXNoKFtdKTtcbiAgICAgICAgZnVuY3Rpb24gc2V0UHJvcChub2RlSUQsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgICBub2RlUHJvcHNbbm9kZUlEXS5wdXNoKFtwcm9wLCBwcm9wLmRlc2VyaWFsaXplKFN0cmluZyh2YWx1ZSkpXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNwZWMubm9kZVByb3BzKVxuICAgICAgICAgICAgZm9yIChsZXQgcHJvcFNwZWMgb2Ygc3BlYy5ub2RlUHJvcHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJvcCA9IHByb3BTcGVjWzBdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICBwcm9wID0gTm9kZVByb3BbcHJvcF07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwcm9wU3BlYy5sZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gcHJvcFNwZWNbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0UHJvcChuZXh0LCBwcm9wLCBwcm9wU3BlY1tpKytdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHByb3BTcGVjW2kgKyAtbmV4dF07XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gLW5leHQ7IGogPiAwOyBqLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0UHJvcChwcm9wU3BlY1tpKytdLCBwcm9wLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIHRoaXMubm9kZVNldCA9IG5ldyBOb2RlU2V0KG5vZGVOYW1lcy5tYXAoKG5hbWUsIGkpID0+IE5vZGVUeXBlLmRlZmluZSh7XG4gICAgICAgICAgICBuYW1lOiBpID49IHRoaXMubWluUmVwZWF0VGVybSA/IHVuZGVmaW5lZCA6IG5hbWUsXG4gICAgICAgICAgICBpZDogaSxcbiAgICAgICAgICAgIHByb3BzOiBub2RlUHJvcHNbaV0sXG4gICAgICAgICAgICB0b3A6IHRvcFRlcm1zLmluZGV4T2YoaSkgPiAtMSxcbiAgICAgICAgICAgIGVycm9yOiBpID09IDAsXG4gICAgICAgICAgICBza2lwcGVkOiBzcGVjLnNraXBwZWROb2RlcyAmJiBzcGVjLnNraXBwZWROb2Rlcy5pbmRleE9mKGkpID4gLTFcbiAgICAgICAgfSkpKTtcbiAgICAgICAgaWYgKHNwZWMucHJvcFNvdXJjZXMpXG4gICAgICAgICAgICB0aGlzLm5vZGVTZXQgPSB0aGlzLm5vZGVTZXQuZXh0ZW5kKC4uLnNwZWMucHJvcFNvdXJjZXMpO1xuICAgICAgICB0aGlzLnN0cmljdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlckxlbmd0aCA9IERlZmF1bHRCdWZmZXJMZW5ndGg7XG4gICAgICAgIGxldCB0b2tlbkFycmF5ID0gZGVjb2RlQXJyYXkoc3BlYy50b2tlbkRhdGEpO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBzcGVjLmNvbnRleHQ7XG4gICAgICAgIHRoaXMuc3BlY2lhbGl6ZXJTcGVjcyA9IHNwZWMuc3BlY2lhbGl6ZWQgfHwgW107XG4gICAgICAgIHRoaXMuc3BlY2lhbGl6ZWQgPSBuZXcgVWludDE2QXJyYXkodGhpcy5zcGVjaWFsaXplclNwZWNzLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zcGVjaWFsaXplclNwZWNzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgdGhpcy5zcGVjaWFsaXplZFtpXSA9IHRoaXMuc3BlY2lhbGl6ZXJTcGVjc1tpXS50ZXJtO1xuICAgICAgICB0aGlzLnNwZWNpYWxpemVycyA9IHRoaXMuc3BlY2lhbGl6ZXJTcGVjcy5tYXAoZ2V0U3BlY2lhbGl6ZXIpO1xuICAgICAgICB0aGlzLnN0YXRlcyA9IGRlY29kZUFycmF5KHNwZWMuc3RhdGVzLCBVaW50MzJBcnJheSk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRlY29kZUFycmF5KHNwZWMuc3RhdGVEYXRhKTtcbiAgICAgICAgdGhpcy5nb3RvID0gZGVjb2RlQXJyYXkoc3BlYy5nb3RvKTtcbiAgICAgICAgdGhpcy5tYXhUZXJtID0gc3BlYy5tYXhUZXJtO1xuICAgICAgICB0aGlzLnRva2VuaXplcnMgPSBzcGVjLnRva2VuaXplcnMubWFwKHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiID8gbmV3IFRva2VuR3JvdXAodG9rZW5BcnJheSwgdmFsdWUpIDogdmFsdWUpO1xuICAgICAgICB0aGlzLnRvcFJ1bGVzID0gc3BlYy50b3BSdWxlcztcbiAgICAgICAgdGhpcy5kaWFsZWN0cyA9IHNwZWMuZGlhbGVjdHMgfHwge307XG4gICAgICAgIHRoaXMuZHluYW1pY1ByZWNlZGVuY2VzID0gc3BlYy5keW5hbWljUHJlY2VkZW5jZXMgfHwgbnVsbDtcbiAgICAgICAgdGhpcy50b2tlblByZWNUYWJsZSA9IHNwZWMudG9rZW5QcmVjO1xuICAgICAgICB0aGlzLnRlcm1OYW1lcyA9IHNwZWMudGVybU5hbWVzIHx8IG51bGw7XG4gICAgICAgIHRoaXMubWF4Tm9kZSA9IHRoaXMubm9kZVNldC50eXBlcy5sZW5ndGggLSAxO1xuICAgICAgICB0aGlzLmRpYWxlY3QgPSB0aGlzLnBhcnNlRGlhbGVjdCgpO1xuICAgICAgICB0aGlzLnRvcCA9IHRoaXMudG9wUnVsZXNbT2JqZWN0LmtleXModGhpcy50b3BSdWxlcylbMF1dO1xuICAgIH1cbiAgICBjcmVhdGVQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgbGV0IHBhcnNlID0gbmV3IFBhcnNlKHRoaXMsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcyk7XG4gICAgICAgIGZvciAobGV0IHcgb2YgdGhpcy53cmFwcGVycylcbiAgICAgICAgICAgIHBhcnNlID0gdyhwYXJzZSwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBnb3RvIHRhYmxlIGVudHJ5IEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0R290byhzdGF0ZSwgdGVybSwgbG9vc2UgPSBmYWxzZSkge1xuICAgICAgICBsZXQgdGFibGUgPSB0aGlzLmdvdG87XG4gICAgICAgIGlmICh0ZXJtID49IHRhYmxlWzBdKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSB0YWJsZVt0ZXJtICsgMV07Oykge1xuICAgICAgICAgICAgbGV0IGdyb3VwVGFnID0gdGFibGVbcG9zKytdLCBsYXN0ID0gZ3JvdXBUYWcgJiAxO1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IHRhYmxlW3BvcysrXTtcbiAgICAgICAgICAgIGlmIChsYXN0ICYmIGxvb3NlKVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgICBmb3IgKGxldCBlbmQgPSBwb3MgKyAoZ3JvdXBUYWcgPj4gMSk7IHBvcyA8IGVuZDsgcG9zKyspXG4gICAgICAgICAgICAgICAgaWYgKHRhYmxlW3Bvc10gPT0gc3RhdGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgICBpZiAobGFzdClcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQ2hlY2sgaWYgdGhpcyBzdGF0ZSBoYXMgYW4gYWN0aW9uIGZvciBhIGdpdmVuIHRlcm1pbmFsIEBpbnRlcm5hbFxuICAgICovXG4gICAgaGFzQWN0aW9uKHN0YXRlLCB0ZXJtaW5hbCkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgZm9yIChsZXQgc2V0ID0gMDsgc2V0IDwgMjsgc2V0KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnN0YXRlU2xvdChzdGF0ZSwgc2V0ID8gMiAvKiBQYXJzZVN0YXRlLlNraXAgKi8gOiAxIC8qIFBhcnNlU3RhdGUuQWN0aW9ucyAqLyksIG5leHQ7OyBpICs9IDMpIHtcbiAgICAgICAgICAgICAgICBpZiAoKG5leHQgPSBkYXRhW2ldKSA9PSA2NTUzNSAvKiBTZXEuRW5kICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhW2kgKyAxXSA9PSAxIC8qIFNlcS5OZXh0ICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGRhdGFbaSA9IHBhaXIoZGF0YSwgaSArIDIpXTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGF0YVtpICsgMV0gPT0gMiAvKiBTZXEuT3RoZXIgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFpcihkYXRhLCBpICsgMik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV4dCA9PSB0ZXJtaW5hbCB8fCBuZXh0ID09IDAgLyogVGVybS5FcnIgKi8pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYWlyKGRhdGEsIGkgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0ZVNsb3Qoc3RhdGUsIHNsb3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVzWyhzdGF0ZSAqIDYgLyogUGFyc2VTdGF0ZS5TaXplICovKSArIHNsb3RdO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRlRmxhZyhzdGF0ZSwgZmxhZykge1xuICAgICAgICByZXR1cm4gKHRoaXMuc3RhdGVTbG90KHN0YXRlLCAwIC8qIFBhcnNlU3RhdGUuRmxhZ3MgKi8pICYgZmxhZykgPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHZhbGlkQWN0aW9uKHN0YXRlLCBhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5hbGxBY3Rpb25zKHN0YXRlLCBhID0+IGEgPT0gYWN0aW9uID8gdHJ1ZSA6IG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGFsbEFjdGlvbnMoc3RhdGUsIGFjdGlvbikge1xuICAgICAgICBsZXQgZGVmbHQgPSB0aGlzLnN0YXRlU2xvdChzdGF0ZSwgNCAvKiBQYXJzZVN0YXRlLkRlZmF1bHRSZWR1Y2UgKi8pO1xuICAgICAgICBsZXQgcmVzdWx0ID0gZGVmbHQgPyBhY3Rpb24oZGVmbHQpIDogdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIDEgLyogUGFyc2VTdGF0ZS5BY3Rpb25zICovKTsgcmVzdWx0ID09IG51bGw7IGkgKz0gMykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVtpXSA9PSA2NTUzNSAvKiBTZXEuRW5kICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVtpICsgMV0gPT0gMSAvKiBTZXEuTmV4dCAqLylcbiAgICAgICAgICAgICAgICAgICAgaSA9IHBhaXIodGhpcy5kYXRhLCBpICsgMik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCA9IGFjdGlvbihwYWlyKHRoaXMuZGF0YSwgaSArIDEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHN0YXRlcyB0aGF0IGNhbiBmb2xsb3cgdGhpcyBvbmUgdGhyb3VnaCBzaGlmdCBhY3Rpb25zIG9yXG4gICAgZ290byBqdW1wcy4gQGludGVybmFsXG4gICAgKi9cbiAgICBuZXh0U3RhdGVzKHN0YXRlKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc3RhdGVTbG90KHN0YXRlLCAxIC8qIFBhcnNlU3RhdGUuQWN0aW9ucyAqLyk7OyBpICs9IDMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbaV0gPT0gNjU1MzUgLyogU2VxLkVuZCAqLykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbaSArIDFdID09IDEgLyogU2VxLk5leHQgKi8pXG4gICAgICAgICAgICAgICAgICAgIGkgPSBwYWlyKHRoaXMuZGF0YSwgaSArIDIpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHRoaXMuZGF0YVtpICsgMl0gJiAoNjU1MzYgLyogQWN0aW9uLlJlZHVjZUZsYWcgKi8gPj4gMTYpKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5kYXRhW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5zb21lKCh2LCBpKSA9PiAoaSAmIDEpICYmIHYgPT0gdmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmRhdGFbaV0sIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBDb25maWd1cmUgdGhlIHBhcnNlci4gUmV0dXJucyBhIG5ldyBwYXJzZXIgaW5zdGFuY2UgdGhhdCBoYXMgdGhlXG4gICAgZ2l2ZW4gc2V0dGluZ3MgbW9kaWZpZWQuIFNldHRpbmdzIG5vdCBwcm92aWRlZCBpbiBgY29uZmlnYCBhcmVcbiAgICBrZXB0IGZyb20gdGhlIG9yaWdpbmFsIHBhcnNlci5cbiAgICAqL1xuICAgIGNvbmZpZ3VyZShjb25maWcpIHtcbiAgICAgICAgLy8gSGlkZW91cyByZWZsZWN0aW9uLWJhc2VkIGtsdWRnZSB0byBtYWtlIGl0IGVhc3kgdG8gY3JlYXRlIGFcbiAgICAgICAgLy8gc2xpZ2h0bHkgbW9kaWZpZWQgY29weSBvZiBhIHBhcnNlci5cbiAgICAgICAgbGV0IGNvcHkgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUoTFJQYXJzZXIucHJvdG90eXBlKSwgdGhpcyk7XG4gICAgICAgIGlmIChjb25maWcucHJvcHMpXG4gICAgICAgICAgICBjb3B5Lm5vZGVTZXQgPSB0aGlzLm5vZGVTZXQuZXh0ZW5kKC4uLmNvbmZpZy5wcm9wcyk7XG4gICAgICAgIGlmIChjb25maWcudG9wKSB7XG4gICAgICAgICAgICBsZXQgaW5mbyA9IHRoaXMudG9wUnVsZXNbY29uZmlnLnRvcF07XG4gICAgICAgICAgICBpZiAoIWluZm8pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgdG9wIHJ1bGUgbmFtZSAke2NvbmZpZy50b3B9YCk7XG4gICAgICAgICAgICBjb3B5LnRvcCA9IGluZm87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy50b2tlbml6ZXJzKVxuICAgICAgICAgICAgY29weS50b2tlbml6ZXJzID0gdGhpcy50b2tlbml6ZXJzLm1hcCh0ID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBjb25maWcudG9rZW5pemVycy5maW5kKHIgPT4gci5mcm9tID09IHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZCA/IGZvdW5kLnRvIDogdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAoY29uZmlnLnNwZWNpYWxpemVycykge1xuICAgICAgICAgICAgY29weS5zcGVjaWFsaXplcnMgPSB0aGlzLnNwZWNpYWxpemVycy5zbGljZSgpO1xuICAgICAgICAgICAgY29weS5zcGVjaWFsaXplclNwZWNzID0gdGhpcy5zcGVjaWFsaXplclNwZWNzLm1hcCgocywgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGNvbmZpZy5zcGVjaWFsaXplcnMuZmluZChyID0+IHIuZnJvbSA9PSBzLmV4dGVybmFsKTtcbiAgICAgICAgICAgICAgICBpZiAoIWZvdW5kKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgICAgICAgICBsZXQgc3BlYyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcyksIHsgZXh0ZXJuYWw6IGZvdW5kLnRvIH0pO1xuICAgICAgICAgICAgICAgIGNvcHkuc3BlY2lhbGl6ZXJzW2ldID0gZ2V0U3BlY2lhbGl6ZXIoc3BlYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNwZWM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLmNvbnRleHRUcmFja2VyKVxuICAgICAgICAgICAgY29weS5jb250ZXh0ID0gY29uZmlnLmNvbnRleHRUcmFja2VyO1xuICAgICAgICBpZiAoY29uZmlnLmRpYWxlY3QpXG4gICAgICAgICAgICBjb3B5LmRpYWxlY3QgPSB0aGlzLnBhcnNlRGlhbGVjdChjb25maWcuZGlhbGVjdCk7XG4gICAgICAgIGlmIChjb25maWcuc3RyaWN0ICE9IG51bGwpXG4gICAgICAgICAgICBjb3B5LnN0cmljdCA9IGNvbmZpZy5zdHJpY3Q7XG4gICAgICAgIGlmIChjb25maWcud3JhcClcbiAgICAgICAgICAgIGNvcHkud3JhcHBlcnMgPSBjb3B5LndyYXBwZXJzLmNvbmNhdChjb25maWcud3JhcCk7XG4gICAgICAgIGlmIChjb25maWcuYnVmZmVyTGVuZ3RoICE9IG51bGwpXG4gICAgICAgICAgICBjb3B5LmJ1ZmZlckxlbmd0aCA9IGNvbmZpZy5idWZmZXJMZW5ndGg7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbiAgICAvKipcbiAgICBUZWxscyB5b3Ugd2hldGhlciBhbnkgW3BhcnNlIHdyYXBwZXJzXSgjbHIuUGFyc2VyQ29uZmlnLndyYXApXG4gICAgYXJlIHJlZ2lzdGVyZWQgZm9yIHRoaXMgcGFyc2VyLlxuICAgICovXG4gICAgaGFzV3JhcHBlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndyYXBwZXJzLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdGhlIG5hbWUgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4gdGVybS4gVGhpcyB3aWxsIG9ubHlcbiAgICB3b3JrIGZvciBhbGwgdGVybXMgd2hlbiB0aGUgcGFyc2VyIHdhcyBnZW5lcmF0ZWQgd2l0aCB0aGVcbiAgICBgLS1uYW1lc2Agb3B0aW9uLiBCeSBkZWZhdWx0LCBvbmx5IHRoZSBuYW1lcyBvZiB0YWdnZWQgdGVybXMgYXJlXG4gICAgc3RvcmVkLlxuICAgICovXG4gICAgZ2V0TmFtZSh0ZXJtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRlcm1OYW1lcyA/IHRoaXMudGVybU5hbWVzW3Rlcm1dIDogU3RyaW5nKHRlcm0gPD0gdGhpcy5tYXhOb2RlICYmIHRoaXMubm9kZVNldC50eXBlc1t0ZXJtXS5uYW1lIHx8IHRlcm0pO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZW9mIHRlcm0gaWQgaXMgYWx3YXlzIGFsbG9jYXRlZCBkaXJlY3RseSBhZnRlciB0aGUgbm9kZVxuICAgIHR5cGVzLiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBlb2ZUZXJtKCkgeyByZXR1cm4gdGhpcy5tYXhOb2RlICsgMTsgfVxuICAgIC8qKlxuICAgIFRoZSB0eXBlIG9mIHRvcCBub2RlIHByb2R1Y2VkIGJ5IHRoZSBwYXJzZXIuXG4gICAgKi9cbiAgICBnZXQgdG9wTm9kZSgpIHsgcmV0dXJuIHRoaXMubm9kZVNldC50eXBlc1t0aGlzLnRvcFsxXV07IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGR5bmFtaWNQcmVjZWRlbmNlKHRlcm0pIHtcbiAgICAgICAgbGV0IHByZWMgPSB0aGlzLmR5bmFtaWNQcmVjZWRlbmNlcztcbiAgICAgICAgcmV0dXJuIHByZWMgPT0gbnVsbCA/IDAgOiBwcmVjW3Rlcm1dIHx8IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcGFyc2VEaWFsZWN0KGRpYWxlY3QpIHtcbiAgICAgICAgbGV0IHZhbHVlcyA9IE9iamVjdC5rZXlzKHRoaXMuZGlhbGVjdHMpLCBmbGFncyA9IHZhbHVlcy5tYXAoKCkgPT4gZmFsc2UpO1xuICAgICAgICBpZiAoZGlhbGVjdClcbiAgICAgICAgICAgIGZvciAobGV0IHBhcnQgb2YgZGlhbGVjdC5zcGxpdChcIiBcIikpIHtcbiAgICAgICAgICAgICAgICBsZXQgaWQgPSB2YWx1ZXMuaW5kZXhPZihwYXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoaWQgPj0gMClcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3NbaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgbGV0IGRpc2FibGVkID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIWZsYWdzW2ldKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IHRoaXMuZGlhbGVjdHNbdmFsdWVzW2ldXSwgaWQ7IChpZCA9IHRoaXMuZGF0YVtqKytdKSAhPSA2NTUzNSAvKiBTZXEuRW5kICovOylcbiAgICAgICAgICAgICAgICAgICAgKGRpc2FibGVkIHx8IChkaXNhYmxlZCA9IG5ldyBVaW50OEFycmF5KHRoaXMubWF4VGVybSArIDEpKSlbaWRdID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBEaWFsZWN0KGRpYWxlY3QsIGZsYWdzLCBkaXNhYmxlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFVzZWQgYnkgdGhlIG91dHB1dCBvZiB0aGUgcGFyc2VyIGdlbmVyYXRvci4gTm90IGF2YWlsYWJsZSB0b1xuICAgIHVzZXIgY29kZS4gQGhpZGVcbiAgICAqL1xuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZShzcGVjKSB7XG4gICAgICAgIHJldHVybiBuZXcgTFJQYXJzZXIoc3BlYyk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFpcihkYXRhLCBvZmYpIHsgcmV0dXJuIGRhdGFbb2ZmXSB8IChkYXRhW29mZiArIDFdIDw8IDE2KTsgfVxuZnVuY3Rpb24gZmluZEZpbmlzaGVkKHN0YWNrcykge1xuICAgIGxldCBiZXN0ID0gbnVsbDtcbiAgICBmb3IgKGxldCBzdGFjayBvZiBzdGFja3MpIHtcbiAgICAgICAgbGV0IHN0b3BwZWQgPSBzdGFjay5wLnN0b3BwZWRBdDtcbiAgICAgICAgaWYgKChzdGFjay5wb3MgPT0gc3RhY2sucC5zdHJlYW0uZW5kIHx8IHN0b3BwZWQgIT0gbnVsbCAmJiBzdGFjay5wb3MgPiBzdG9wcGVkKSAmJlxuICAgICAgICAgICAgc3RhY2sucC5wYXJzZXIuc3RhdGVGbGFnKHN0YWNrLnN0YXRlLCAyIC8qIFN0YXRlRmxhZy5BY2NlcHRpbmcgKi8pICYmXG4gICAgICAgICAgICAoIWJlc3QgfHwgYmVzdC5zY29yZSA8IHN0YWNrLnNjb3JlKSlcbiAgICAgICAgICAgIGJlc3QgPSBzdGFjaztcbiAgICB9XG4gICAgcmV0dXJuIGJlc3Q7XG59XG5mdW5jdGlvbiBnZXRTcGVjaWFsaXplcihzcGVjKSB7XG4gICAgaWYgKHNwZWMuZXh0ZXJuYWwpIHtcbiAgICAgICAgbGV0IG1hc2sgPSBzcGVjLmV4dGVuZCA/IDEgLyogU3BlY2lhbGl6ZS5FeHRlbmQgKi8gOiAwIC8qIFNwZWNpYWxpemUuU3BlY2lhbGl6ZSAqLztcbiAgICAgICAgcmV0dXJuICh2YWx1ZSwgc3RhY2spID0+IChzcGVjLmV4dGVybmFsKHZhbHVlLCBzdGFjaykgPDwgMSkgfCBtYXNrO1xuICAgIH1cbiAgICByZXR1cm4gc3BlYy5nZXQ7XG59XG5cbmV4cG9ydCB7IENvbnRleHRUcmFja2VyLCBFeHRlcm5hbFRva2VuaXplciwgSW5wdXRTdHJlYW0sIExSUGFyc2VyLCBMb2NhbFRva2VuR3JvdXAsIFN0YWNrIH07XG4iXSwibmFtZXMiOlsiUGFyc2VyIiwiTm9kZVByb3AiLCJOb2RlU2V0IiwiTm9kZVR5cGUiLCJEZWZhdWx0QnVmZmVyTGVuZ3RoIiwiVHJlZSIsIkl0ZXJNb2RlIiwiU3RhY2siLCJjb25zdHJ1Y3RvciIsInAiLCJzdGFjayIsInN0YXRlIiwicmVkdWNlUG9zIiwicG9zIiwic2NvcmUiLCJidWZmZXIiLCJidWZmZXJCYXNlIiwiY3VyQ29udGV4dCIsImxvb2tBaGVhZCIsInBhcmVudCIsInRvU3RyaW5nIiwiZmlsdGVyIiwiXyIsImkiLCJjb25jYXQiLCJzdGFydCIsImN4IiwicGFyc2VyIiwiY29udGV4dCIsIlN0YWNrQ29udGV4dCIsInB1c2hTdGF0ZSIsInB1c2giLCJsZW5ndGgiLCJyZWR1Y2UiLCJhY3Rpb24iLCJfYSIsImRlcHRoIiwidHlwZSIsImxvb2thaGVhZFJlY29yZCIsInNldExvb2tBaGVhZCIsImRQcmVjIiwiZHluYW1pY1ByZWNlZGVuY2UiLCJnZXRHb3RvIiwibWluUmVwZWF0VGVybSIsInN0b3JlTm9kZSIsInJlZHVjZUNvbnRleHQiLCJiYXNlIiwicmFuZ2VzIiwiZnJvbSIsInNpemUiLCJub2RlU2V0IiwidHlwZXMiLCJpc0Fub255bW91cyIsImxhc3RCaWdSZWR1Y3Rpb25TdGFydCIsImJpZ1JlZHVjdGlvbkNvdW50IiwibGFzdEJpZ1JlZHVjdGlvblNpemUiLCJjb3VudCIsInN0YXRlRmxhZyIsImJhc2VTdGF0ZUlEIiwicG9wIiwidGVybSIsImVuZCIsIm11c3RTaW5rIiwiY3VyIiwidG9wIiwiaW5kZXgiLCJtdXN0TW92ZSIsInNjYW4iLCJzaGlmdCIsIm5leHRTdGF0ZSIsIm1heE5vZGUiLCJzaGlmdENvbnRleHQiLCJhcHBseSIsIm5leHQiLCJuZXh0U3RhcnQiLCJuZXh0RW5kIiwidXNlTm9kZSIsInZhbHVlIiwicmV1c2VkIiwidXBkYXRlQ29udGV4dCIsInRyYWNrZXIiLCJyZXVzZSIsInN0cmVhbSIsInJlc2V0Iiwic3BsaXQiLCJvZmYiLCJzbGljZSIsInJlY292ZXJCeURlbGV0ZSIsImlzTm9kZSIsImNhblNoaWZ0Iiwic2ltIiwiU2ltdWxhdGVkU3RhY2siLCJzdGF0ZVNsb3QiLCJoYXNBY3Rpb24iLCJyZWNvdmVyQnlJbnNlcnQiLCJuZXh0U3RhdGVzIiwiYmVzdCIsInMiLCJzb21lIiwidiIsInJlc3VsdCIsImZvcmNlUmVkdWNlIiwidmFsaWRBY3Rpb24iLCJ0YXJnZXQiLCJiYWNrdXAiLCJmaW5kRm9yY2VkUmVkdWN0aW9uIiwic2VlbiIsImV4cGxvcmUiLCJpbmNsdWRlcyIsImFsbEFjdGlvbnMiLCJyRGVwdGgiLCJmb3VuZCIsImZvcmNlQWxsIiwiZGVhZEVuZCIsImRhdGEiLCJyZXN0YXJ0Iiwic2FtZVN0YXRlIiwib3RoZXIiLCJkaWFsZWN0RW5hYmxlZCIsImRpYWxlY3RJRCIsImRpYWxlY3QiLCJmbGFncyIsImVtaXRDb250ZXh0IiwibGFzdCIsImhhc2giLCJlbWl0TG9va0FoZWFkIiwibmV3Q3giLCJjbG9zZSIsInN0cmljdCIsImdvdG8iLCJTdGFja0J1ZmZlckN1cnNvciIsIm1heWJlTmV4dCIsImNyZWF0ZSIsImlkIiwiZm9yayIsImRlY29kZUFycmF5IiwiaW5wdXQiLCJUeXBlIiwiVWludDE2QXJyYXkiLCJhcnJheSIsIm91dCIsImNoYXJDb2RlQXQiLCJzdG9wIiwiZGlnaXQiLCJDYWNoZWRUb2tlbiIsImV4dGVuZGVkIiwibWFzayIsIm51bGxUb2tlbiIsIklucHV0U3RyZWFtIiwiY2h1bmsiLCJjaHVua09mZiIsImNodW5rMiIsImNodW5rMlBvcyIsInRva2VuIiwicmFuZ2VJbmRleCIsImNodW5rUG9zIiwicmFuZ2UiLCJ0byIsInJlYWROZXh0IiwicmVzb2x2ZU9mZnNldCIsIm9mZnNldCIsImFzc29jIiwiY2xpcFBvcyIsIk1hdGgiLCJtYXgiLCJwZWVrIiwiaWR4IiwicmVzb2x2ZWQiLCJhY2NlcHRUb2tlbiIsImVuZE9mZnNldCIsIlJhbmdlRXJyb3IiLCJhY2NlcHRUb2tlblRvIiwiZW5kUG9zIiwiZ2V0Q2h1bmsiLCJuZXh0Q2h1bmsiLCJhZHZhbmNlIiwibiIsInNldERvbmUiLCJyZWFkIiwiciIsIm1pbiIsIlRva2VuR3JvdXAiLCJyZWFkVG9rZW4iLCJ0b2tlblByZWNUYWJsZSIsInByb3RvdHlwZSIsImNvbnRleHR1YWwiLCJmYWxsYmFjayIsImV4dGVuZCIsIkxvY2FsVG9rZW5Hcm91cCIsInByZWNUYWJsZSIsImVsc2VUb2tlbiIsInNraXBwZWQiLCJhdEVvZiIsIm5leHRQb3MiLCJFeHRlcm5hbFRva2VuaXplciIsIm9wdGlvbnMiLCJncm91cCIsInByZWNPZmZzZXQiLCJncm91cE1hc2siLCJhY2NFbmQiLCJhbGxvd3MiLCJvdmVycmlkZXMiLCJsb3ciLCJoaWdoIiwibWlkIiwiZmluZE9mZnNldCIsInByZXYiLCJ0YWJsZURhdGEiLCJ0YWJsZU9mZnNldCIsImlQcmV2IiwidmVyYm9zZSIsInByb2Nlc3MiLCJlbnYiLCJ0ZXN0IiwiTE9HIiwic3RhY2tJRHMiLCJjdXRBdCIsInRyZWUiLCJzaWRlIiwiY3Vyc29yIiwiSW5jbHVkZUFub255bW91cyIsIm1vdmVUbyIsImNoaWxkQmVmb3JlIiwiY2hpbGRBZnRlciIsImlzRXJyb3IiLCJwcmV2U2libGluZyIsIm5leHRTaWJsaW5nIiwiRnJhZ21lbnRDdXJzb3IiLCJmcmFnbWVudHMiLCJmcmFnbWVudCIsInNhZmVGcm9tIiwic2FmZVRvIiwidHJlZXMiLCJuZXh0RnJhZ21lbnQiLCJmciIsIm9wZW5TdGFydCIsIm9wZW5FbmQiLCJub2RlQXQiLCJjaGlsZHJlbiIsInBvc2l0aW9ucyIsInByb3AiLCJUb2tlbkNhY2hlIiwidG9rZW5zIiwibWFpblRva2VuIiwiYWN0aW9ucyIsInRva2VuaXplcnMiLCJtYXAiLCJnZXRBY3Rpb25zIiwiYWN0aW9uSW5kZXgiLCJtYWluIiwidG9rZW5pemVyIiwidXBkYXRlQ2FjaGVkVG9rZW4iLCJzdGFydEluZGV4IiwiYWRkQWN0aW9ucyIsImVvZlRlcm0iLCJnZXRNYWluVG9rZW4iLCJzcGVjaWFsaXplZCIsInNwZWNpYWxpemVycyIsInB1dEFjdGlvbiIsInNldCIsInBhaXIiLCJQYXJzZSIsInJlY292ZXJpbmciLCJuZXh0U3RhY2tJRCIsIm1pblN0YWNrUG9zIiwic3RvcHBlZEF0IiwidG9wVGVybSIsInN0YWNrcyIsImJ1ZmZlckxlbmd0aCIsInBhcnNlZFBvcyIsIm5ld1N0YWNrcyIsInN0b3BwZWQiLCJzdG9wcGVkVG9rZW5zIiwiYWR2YW5jZVN0YWNrIiwidG9rIiwiZmluaXNoZWQiLCJmaW5kRmluaXNoZWQiLCJjb25zb2xlIiwibG9nIiwic3RhY2tJRCIsInN0YWNrVG9UcmVlIiwiZ2V0TmFtZSIsIlN5bnRheEVycm9yIiwicnVuUmVjb3ZlcnkiLCJtYXhSZW1haW5pbmciLCJzb3J0IiwiYSIsImIiLCJvdXRlciIsImoiLCJzcGxpY2UiLCJzdG9wQXQiLCJzdHJpY3RDeCIsImN4SGFzaCIsImNhY2hlZCIsIm1hdGNoIiwiY29udGV4dEhhc2giLCJpbm5lciIsImRlZmF1bHRSZWR1Y2UiLCJsb2NhbFN0YWNrIiwiYWR2YW5jZUZ1bGx5IiwicHVzaFN0YWNrRGVkdXAiLCJyZXN0YXJ0ZWQiLCJ0b2tlbkVuZCIsImRvbmUiLCJmb3JjZSIsImZvcmNlQmFzZSIsImluc2VydCIsImJ1aWxkIiwidG9wSUQiLCJtYXhCdWZmZXJMZW5ndGgiLCJtaW5SZXBlYXRUeXBlIiwiV2Vha01hcCIsImdldCIsIlN0cmluZyIsImZyb21Db2RlUG9pbnQiLCJEaWFsZWN0Iiwic291cmNlIiwiZGlzYWJsZWQiLCJ4IiwiQ29udGV4dFRyYWNrZXIiLCJzcGVjIiwiTFJQYXJzZXIiLCJ3cmFwcGVycyIsInZlcnNpb24iLCJub2RlTmFtZXMiLCJyZXBlYXROb2RlQ291bnQiLCJ0b3BUZXJtcyIsIk9iamVjdCIsImtleXMiLCJ0b3BSdWxlcyIsIm5vZGVQcm9wcyIsInNldFByb3AiLCJub2RlSUQiLCJkZXNlcmlhbGl6ZSIsInByb3BTcGVjIiwibmFtZSIsImRlZmluZSIsInVuZGVmaW5lZCIsInByb3BzIiwiaW5kZXhPZiIsImVycm9yIiwic2tpcHBlZE5vZGVzIiwicHJvcFNvdXJjZXMiLCJ0b2tlbkFycmF5IiwidG9rZW5EYXRhIiwic3BlY2lhbGl6ZXJTcGVjcyIsImdldFNwZWNpYWxpemVyIiwic3RhdGVzIiwiVWludDMyQXJyYXkiLCJzdGF0ZURhdGEiLCJtYXhUZXJtIiwiZGlhbGVjdHMiLCJkeW5hbWljUHJlY2VkZW5jZXMiLCJ0b2tlblByZWMiLCJ0ZXJtTmFtZXMiLCJwYXJzZURpYWxlY3QiLCJjcmVhdGVQYXJzZSIsInBhcnNlIiwidyIsImxvb3NlIiwidGFibGUiLCJncm91cFRhZyIsInRlcm1pbmFsIiwic2xvdCIsImZsYWciLCJkZWZsdCIsImNvbmZpZ3VyZSIsImNvbmZpZyIsImNvcHkiLCJhc3NpZ24iLCJpbmZvIiwidCIsImZpbmQiLCJleHRlcm5hbCIsImNvbnRleHRUcmFja2VyIiwid3JhcCIsImhhc1dyYXBwZXJzIiwidG9wTm9kZSIsInByZWMiLCJ2YWx1ZXMiLCJwYXJ0IiwiVWludDhBcnJheSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lezer/lr/dist/index.js\n");

/***/ })

};
;