"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/slate";
exports.ids = ["vendor-chunks/slate"];
exports.modules = {

/***/ "(ssr)/./node_modules/slate/dist/index.es.js":
/*!*********************************************!*\
  !*** ./node_modules/slate/dist/index.es.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Editor: () => (/* binding */ Editor),\n/* harmony export */   Element: () => (/* binding */ Element),\n/* harmony export */   Location: () => (/* binding */ Location),\n/* harmony export */   Node: () => (/* binding */ Node),\n/* harmony export */   Operation: () => (/* binding */ Operation),\n/* harmony export */   Path: () => (/* binding */ Path),\n/* harmony export */   PathRef: () => (/* binding */ PathRef),\n/* harmony export */   Point: () => (/* binding */ Point),\n/* harmony export */   PointRef: () => (/* binding */ PointRef),\n/* harmony export */   Range: () => (/* binding */ Range),\n/* harmony export */   RangeRef: () => (/* binding */ RangeRef),\n/* harmony export */   Scrubber: () => (/* binding */ Scrubber),\n/* harmony export */   Span: () => (/* binding */ Span),\n/* harmony export */   Text: () => (/* binding */ Text),\n/* harmony export */   Transforms: () => (/* binding */ Transforms),\n/* harmony export */   above: () => (/* binding */ above),\n/* harmony export */   addMark: () => (/* binding */ addMark),\n/* harmony export */   after: () => (/* binding */ after),\n/* harmony export */   apply: () => (/* binding */ apply),\n/* harmony export */   before: () => (/* binding */ before),\n/* harmony export */   collapse: () => (/* binding */ collapse),\n/* harmony export */   createEditor: () => (/* binding */ createEditor),\n/* harmony export */   deleteBackward: () => (/* binding */ deleteBackward),\n/* harmony export */   deleteForward: () => (/* binding */ deleteForward),\n/* harmony export */   deleteFragment: () => (/* binding */ deleteFragment),\n/* harmony export */   deleteText: () => (/* binding */ deleteText),\n/* harmony export */   deselect: () => (/* binding */ deselect),\n/* harmony export */   edges: () => (/* binding */ edges),\n/* harmony export */   elementReadOnly: () => (/* binding */ elementReadOnly),\n/* harmony export */   end: () => (/* binding */ end),\n/* harmony export */   first: () => (/* binding */ first),\n/* harmony export */   fragment: () => (/* binding */ fragment),\n/* harmony export */   getDirtyPaths: () => (/* binding */ getDirtyPaths),\n/* harmony export */   getFragment: () => (/* binding */ getFragment),\n/* harmony export */   getVoid: () => (/* binding */ getVoid),\n/* harmony export */   hasBlocks: () => (/* binding */ hasBlocks),\n/* harmony export */   hasInlines: () => (/* binding */ hasInlines),\n/* harmony export */   hasPath: () => (/* binding */ hasPath),\n/* harmony export */   hasTexts: () => (/* binding */ hasTexts),\n/* harmony export */   insertBreak: () => (/* binding */ insertBreak),\n/* harmony export */   insertFragment: () => (/* binding */ insertFragment),\n/* harmony export */   insertNode: () => (/* binding */ insertNode),\n/* harmony export */   insertNodes: () => (/* binding */ insertNodes),\n/* harmony export */   insertSoftBreak: () => (/* binding */ insertSoftBreak),\n/* harmony export */   insertText: () => (/* binding */ insertText),\n/* harmony export */   isBlock: () => (/* binding */ isBlock),\n/* harmony export */   isEdge: () => (/* binding */ isEdge),\n/* harmony export */   isEditor: () => (/* binding */ isEditor),\n/* harmony export */   isEmpty: () => (/* binding */ isEmpty),\n/* harmony export */   isEnd: () => (/* binding */ isEnd),\n/* harmony export */   isNormalizing: () => (/* binding */ isNormalizing),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   isStart: () => (/* binding */ isStart),\n/* harmony export */   last: () => (/* binding */ last),\n/* harmony export */   leaf: () => (/* binding */ leaf),\n/* harmony export */   levels: () => (/* binding */ levels),\n/* harmony export */   liftNodes: () => (/* binding */ liftNodes),\n/* harmony export */   marks: () => (/* binding */ marks),\n/* harmony export */   mergeNodes: () => (/* binding */ mergeNodes),\n/* harmony export */   move: () => (/* binding */ move),\n/* harmony export */   moveNodes: () => (/* binding */ moveNodes),\n/* harmony export */   next: () => (/* binding */ next),\n/* harmony export */   node: () => (/* binding */ node),\n/* harmony export */   nodes: () => (/* binding */ nodes),\n/* harmony export */   normalize: () => (/* binding */ normalize),\n/* harmony export */   normalizeNode: () => (/* binding */ normalizeNode),\n/* harmony export */   parent: () => (/* binding */ parent),\n/* harmony export */   path: () => (/* binding */ path),\n/* harmony export */   pathRef: () => (/* binding */ pathRef),\n/* harmony export */   pathRefs: () => (/* binding */ pathRefs),\n/* harmony export */   point: () => (/* binding */ point),\n/* harmony export */   pointRef: () => (/* binding */ pointRef),\n/* harmony export */   pointRefs: () => (/* binding */ pointRefs),\n/* harmony export */   positions: () => (/* binding */ positions),\n/* harmony export */   previous: () => (/* binding */ previous),\n/* harmony export */   range: () => (/* binding */ range),\n/* harmony export */   rangeRef: () => (/* binding */ rangeRef),\n/* harmony export */   rangeRefs: () => (/* binding */ rangeRefs),\n/* harmony export */   removeMark: () => (/* binding */ removeMark),\n/* harmony export */   removeNodes: () => (/* binding */ removeNodes),\n/* harmony export */   select: () => (/* binding */ select),\n/* harmony export */   setNodes: () => (/* binding */ setNodes),\n/* harmony export */   setNormalizing: () => (/* binding */ setNormalizing),\n/* harmony export */   setPoint: () => (/* binding */ setPoint),\n/* harmony export */   setSelection: () => (/* binding */ setSelection),\n/* harmony export */   shouldMergeNodesRemovePrevNode: () => (/* binding */ shouldMergeNodesRemovePrevNode),\n/* harmony export */   shouldNormalize: () => (/* binding */ shouldNormalize),\n/* harmony export */   splitNodes: () => (/* binding */ splitNodes),\n/* harmony export */   start: () => (/* binding */ start),\n/* harmony export */   string: () => (/* binding */ string),\n/* harmony export */   unhangRange: () => (/* binding */ unhangRange),\n/* harmony export */   unsetNodes: () => (/* binding */ unsetNodes),\n/* harmony export */   unwrapNodes: () => (/* binding */ unwrapNodes),\n/* harmony export */   withoutNormalizing: () => (/* binding */ withoutNormalizing),\n/* harmony export */   wrapNodes: () => (/* binding */ wrapNodes)\n/* harmony export */ });\n/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! immer */ \"(ssr)/./node_modules/immer/dist/immer.mjs\");\n\n// eslint-disable-next-line no-redeclare\nvar PathRef = {\n    transform (ref, op) {\n        var { current, affinity } = ref;\n        if (current == null) {\n            return;\n        }\n        var path = Path.transform(current, op, {\n            affinity\n        });\n        ref.current = path;\n        if (path == null) {\n            ref.unref();\n        }\n    }\n};\n// eslint-disable-next-line no-redeclare\nvar PointRef = {\n    transform (ref, op) {\n        var { current, affinity } = ref;\n        if (current == null) {\n            return;\n        }\n        var point = Point.transform(current, op, {\n            affinity\n        });\n        ref.current = point;\n        if (point == null) {\n            ref.unref();\n        }\n    }\n};\n// eslint-disable-next-line no-redeclare\nvar RangeRef = {\n    transform (ref, op) {\n        var { current, affinity } = ref;\n        if (current == null) {\n            return;\n        }\n        var path = Range.transform(current, op, {\n            affinity\n        });\n        ref.current = path;\n        if (path == null) {\n            ref.unref();\n        }\n    }\n};\nvar DIRTY_PATHS = new WeakMap();\nvar DIRTY_PATH_KEYS = new WeakMap();\nvar FLUSHING = new WeakMap();\nvar NORMALIZING = new WeakMap();\nvar PATH_REFS = new WeakMap();\nvar POINT_REFS = new WeakMap();\nvar RANGE_REFS = new WeakMap();\n// eslint-disable-next-line no-redeclare\nvar Path = {\n    ancestors (path) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { reverse = false } = options;\n        var paths = Path.levels(path, options);\n        if (reverse) {\n            paths = paths.slice(1);\n        } else {\n            paths = paths.slice(0, -1);\n        }\n        return paths;\n    },\n    common (path, another) {\n        var common = [];\n        for(var i = 0; i < path.length && i < another.length; i++){\n            var av = path[i];\n            var bv = another[i];\n            if (av !== bv) {\n                break;\n            }\n            common.push(av);\n        }\n        return common;\n    },\n    compare (path, another) {\n        var min = Math.min(path.length, another.length);\n        for(var i = 0; i < min; i++){\n            if (path[i] < another[i]) return -1;\n            if (path[i] > another[i]) return 1;\n        }\n        return 0;\n    },\n    endsAfter (path, another) {\n        var i = path.length - 1;\n        var as = path.slice(0, i);\n        var bs = another.slice(0, i);\n        var av = path[i];\n        var bv = another[i];\n        return Path.equals(as, bs) && av > bv;\n    },\n    endsAt (path, another) {\n        var i = path.length;\n        var as = path.slice(0, i);\n        var bs = another.slice(0, i);\n        return Path.equals(as, bs);\n    },\n    endsBefore (path, another) {\n        var i = path.length - 1;\n        var as = path.slice(0, i);\n        var bs = another.slice(0, i);\n        var av = path[i];\n        var bv = another[i];\n        return Path.equals(as, bs) && av < bv;\n    },\n    equals (path, another) {\n        return path.length === another.length && path.every((n, i)=>n === another[i]);\n    },\n    hasPrevious (path) {\n        return path[path.length - 1] > 0;\n    },\n    isAfter (path, another) {\n        return Path.compare(path, another) === 1;\n    },\n    isAncestor (path, another) {\n        return path.length < another.length && Path.compare(path, another) === 0;\n    },\n    isBefore (path, another) {\n        return Path.compare(path, another) === -1;\n    },\n    isChild (path, another) {\n        return path.length === another.length + 1 && Path.compare(path, another) === 0;\n    },\n    isCommon (path, another) {\n        return path.length <= another.length && Path.compare(path, another) === 0;\n    },\n    isDescendant (path, another) {\n        return path.length > another.length && Path.compare(path, another) === 0;\n    },\n    isParent (path, another) {\n        return path.length + 1 === another.length && Path.compare(path, another) === 0;\n    },\n    isPath (value) {\n        return Array.isArray(value) && (value.length === 0 || typeof value[0] === \"number\");\n    },\n    isSibling (path, another) {\n        if (path.length !== another.length) {\n            return false;\n        }\n        var as = path.slice(0, -1);\n        var bs = another.slice(0, -1);\n        var al = path[path.length - 1];\n        var bl = another[another.length - 1];\n        return al !== bl && Path.equals(as, bs);\n    },\n    levels (path) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { reverse = false } = options;\n        var list = [];\n        for(var i = 0; i <= path.length; i++){\n            list.push(path.slice(0, i));\n        }\n        if (reverse) {\n            list.reverse();\n        }\n        return list;\n    },\n    next (path) {\n        if (path.length === 0) {\n            throw new Error(\"Cannot get the next path of a root path [\".concat(path, \"], because it has no next index.\"));\n        }\n        var last = path[path.length - 1];\n        return path.slice(0, -1).concat(last + 1);\n    },\n    operationCanTransformPath (operation) {\n        switch(operation.type){\n            case \"insert_node\":\n            case \"remove_node\":\n            case \"merge_node\":\n            case \"split_node\":\n            case \"move_node\":\n                return true;\n            default:\n                return false;\n        }\n    },\n    parent (path) {\n        if (path.length === 0) {\n            throw new Error(\"Cannot get the parent path of the root path [\".concat(path, \"].\"));\n        }\n        return path.slice(0, -1);\n    },\n    previous (path) {\n        if (path.length === 0) {\n            throw new Error(\"Cannot get the previous path of a root path [\".concat(path, \"], because it has no previous index.\"));\n        }\n        var last = path[path.length - 1];\n        if (last <= 0) {\n            throw new Error(\"Cannot get the previous path of a first child path [\".concat(path, \"] because it would result in a negative index.\"));\n        }\n        return path.slice(0, -1).concat(last - 1);\n    },\n    relative (path, ancestor) {\n        if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {\n            throw new Error(\"Cannot get the relative path of [\".concat(path, \"] inside ancestor [\").concat(ancestor, \"], because it is not above or equal to the path.\"));\n        }\n        return path.slice(ancestor.length);\n    },\n    transform (path, operation) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        if (!path) return null;\n        // PERF: use destructing instead of immer\n        var p = [\n            ...path\n        ];\n        var { affinity = \"forward\" } = options;\n        // PERF: Exit early if the operation is guaranteed not to have an effect.\n        if (path.length === 0) {\n            return p;\n        }\n        switch(operation.type){\n            case \"insert_node\":\n                {\n                    var { path: op } = operation;\n                    if (Path.equals(op, p) || Path.endsBefore(op, p) || Path.isAncestor(op, p)) {\n                        p[op.length - 1] += 1;\n                    }\n                    break;\n                }\n            case \"remove_node\":\n                {\n                    var { path: _op } = operation;\n                    if (Path.equals(_op, p) || Path.isAncestor(_op, p)) {\n                        return null;\n                    } else if (Path.endsBefore(_op, p)) {\n                        p[_op.length - 1] -= 1;\n                    }\n                    break;\n                }\n            case \"merge_node\":\n                {\n                    var { path: _op2, position } = operation;\n                    if (Path.equals(_op2, p) || Path.endsBefore(_op2, p)) {\n                        p[_op2.length - 1] -= 1;\n                    } else if (Path.isAncestor(_op2, p)) {\n                        p[_op2.length - 1] -= 1;\n                        p[_op2.length] += position;\n                    }\n                    break;\n                }\n            case \"split_node\":\n                {\n                    var { path: _op3, position: _position } = operation;\n                    if (Path.equals(_op3, p)) {\n                        if (affinity === \"forward\") {\n                            p[p.length - 1] += 1;\n                        } else if (affinity === \"backward\") ;\n                        else {\n                            return null;\n                        }\n                    } else if (Path.endsBefore(_op3, p)) {\n                        p[_op3.length - 1] += 1;\n                    } else if (Path.isAncestor(_op3, p) && path[_op3.length] >= _position) {\n                        p[_op3.length - 1] += 1;\n                        p[_op3.length] -= _position;\n                    }\n                    break;\n                }\n            case \"move_node\":\n                {\n                    var { path: _op4, newPath: onp } = operation;\n                    // If the old and new path are the same, it's a no-op.\n                    if (Path.equals(_op4, onp)) {\n                        return p;\n                    }\n                    if (Path.isAncestor(_op4, p) || Path.equals(_op4, p)) {\n                        var copy = onp.slice();\n                        if (Path.endsBefore(_op4, onp) && _op4.length < onp.length) {\n                            copy[_op4.length - 1] -= 1;\n                        }\n                        return copy.concat(p.slice(_op4.length));\n                    } else if (Path.isSibling(_op4, onp) && (Path.isAncestor(onp, p) || Path.equals(onp, p))) {\n                        if (Path.endsBefore(_op4, p)) {\n                            p[_op4.length - 1] -= 1;\n                        } else {\n                            p[_op4.length - 1] += 1;\n                        }\n                    } else if (Path.endsBefore(onp, p) || Path.equals(onp, p) || Path.isAncestor(onp, p)) {\n                        if (Path.endsBefore(_op4, p)) {\n                            p[_op4.length - 1] -= 1;\n                        }\n                        p[onp.length - 1] += 1;\n                    } else if (Path.endsBefore(_op4, p)) {\n                        if (Path.equals(onp, p)) {\n                            p[onp.length - 1] += 1;\n                        }\n                        p[_op4.length - 1] -= 1;\n                    }\n                    break;\n                }\n        }\n        return p;\n    }\n};\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _toPrimitive(input, hint) {\n    if (_typeof(input) !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n        var res = prim.call(input, hint || \"default\");\n        if (_typeof(res) !== \"object\") return res;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n}\nfunction _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, \"string\");\n    return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction ownKeys$e(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread$e(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys$e(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$e(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nvar insertChildren = function insertChildren(xs, index) {\n    for(var _len = arguments.length, newValues = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){\n        newValues[_key - 2] = arguments[_key];\n    }\n    return [\n        ...xs.slice(0, index),\n        ...newValues,\n        ...xs.slice(index)\n    ];\n};\nvar replaceChildren = function replaceChildren(xs, index, removeCount) {\n    for(var _len2 = arguments.length, newValues = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++){\n        newValues[_key2 - 3] = arguments[_key2];\n    }\n    return [\n        ...xs.slice(0, index),\n        ...newValues,\n        ...xs.slice(index + removeCount)\n    ];\n};\nvar removeChildren = replaceChildren;\n/**\n * Replace a descendant with a new node, replacing all ancestors\n */ var modifyDescendant = (editor, path, f)=>{\n    if (path.length === 0) {\n        throw new Error(\"Cannot modify the editor\");\n    }\n    var node = Node.get(editor, path);\n    var slicedPath = path.slice();\n    var modifiedNode = f(node);\n    while(slicedPath.length > 1){\n        var _index = slicedPath.pop();\n        var ancestorNode = Node.get(editor, slicedPath);\n        modifiedNode = _objectSpread$e(_objectSpread$e({}, ancestorNode), {}, {\n            children: replaceChildren(ancestorNode.children, _index, 1, modifiedNode)\n        });\n    }\n    var index = slicedPath.pop();\n    editor.children = replaceChildren(editor.children, index, 1, modifiedNode);\n};\n/**\n * Replace the children of a node, replacing all ancestors\n */ var modifyChildren = (editor, path, f)=>{\n    if (path.length === 0) {\n        editor.children = f(editor.children);\n    } else {\n        modifyDescendant(editor, path, (node)=>{\n            if (Text.isText(node)) {\n                throw new Error(\"Cannot get the element at path [\".concat(path, \"] because it refers to a leaf node: \").concat(Scrubber.stringify(node)));\n            }\n            return _objectSpread$e(_objectSpread$e({}, node), {}, {\n                children: f(node.children)\n            });\n        });\n    }\n};\n/**\n * Replace a leaf, replacing all ancestors\n */ var modifyLeaf = (editor, path, f)=>modifyDescendant(editor, path, (node)=>{\n        if (!Text.isText(node)) {\n            throw new Error(\"Cannot get the leaf node at path [\".concat(path, \"] because it refers to a non-leaf node: \").concat(Scrubber.stringify(node)));\n        }\n        return f(node);\n    });\n// eslint-disable-next-line no-redeclare\nvar GeneralTransforms = {\n    transform (editor, op) {\n        var transformSelection = false;\n        switch(op.type){\n            case \"insert_node\":\n                {\n                    var { path, node } = op;\n                    modifyChildren(editor, Path.parent(path), (children)=>{\n                        var index = path[path.length - 1];\n                        if (index > children.length) {\n                            throw new Error('Cannot apply an \"insert_node\" operation at path ['.concat(path, \"] because the destination is past the end of the node.\"));\n                        }\n                        return insertChildren(children, index, node);\n                    });\n                    transformSelection = true;\n                    break;\n                }\n            case \"insert_text\":\n                {\n                    var { path: _path, offset, text } = op;\n                    if (text.length === 0) break;\n                    modifyLeaf(editor, _path, (node)=>{\n                        var before = node.text.slice(0, offset);\n                        var after = node.text.slice(offset);\n                        return _objectSpread$e(_objectSpread$e({}, node), {}, {\n                            text: before + text + after\n                        });\n                    });\n                    transformSelection = true;\n                    break;\n                }\n            case \"merge_node\":\n                {\n                    var { path: _path2 } = op;\n                    var index = _path2[_path2.length - 1];\n                    var prevPath = Path.previous(_path2);\n                    var prevIndex = prevPath[prevPath.length - 1];\n                    modifyChildren(editor, Path.parent(_path2), (children)=>{\n                        var node = children[index];\n                        var prev = children[prevIndex];\n                        var newNode;\n                        if (Text.isText(node) && Text.isText(prev)) {\n                            newNode = _objectSpread$e(_objectSpread$e({}, prev), {}, {\n                                text: prev.text + node.text\n                            });\n                        } else if (!Text.isText(node) && !Text.isText(prev)) {\n                            newNode = _objectSpread$e(_objectSpread$e({}, prev), {}, {\n                                children: prev.children.concat(node.children)\n                            });\n                        } else {\n                            throw new Error('Cannot apply a \"merge_node\" operation at path ['.concat(_path2, \"] to nodes of different interfaces: \").concat(Scrubber.stringify(node), \" \").concat(Scrubber.stringify(prev)));\n                        }\n                        return replaceChildren(children, prevIndex, 2, newNode);\n                    });\n                    transformSelection = true;\n                    break;\n                }\n            case \"move_node\":\n                {\n                    var { path: _path3, newPath } = op;\n                    var _index2 = _path3[_path3.length - 1];\n                    if (Path.isAncestor(_path3, newPath)) {\n                        throw new Error(\"Cannot move a path [\".concat(_path3, \"] to new path [\").concat(newPath, \"] because the destination is inside itself.\"));\n                    }\n                    var _node = Node.get(editor, _path3);\n                    modifyChildren(editor, Path.parent(_path3), (children)=>removeChildren(children, _index2, 1));\n                    // This is tricky, but since the `path` and `newPath` both refer to\n                    // the same snapshot in time, there's a mismatch. After either\n                    // removing the original position, the second step's path can be out\n                    // of date. So instead of using the `op.newPath` directly, we\n                    // transform `op.path` to ascertain what the `newPath` would be after\n                    // the operation was applied.\n                    var truePath = Path.transform(_path3, op);\n                    var newIndex = truePath[truePath.length - 1];\n                    modifyChildren(editor, Path.parent(truePath), (children)=>insertChildren(children, newIndex, _node));\n                    transformSelection = true;\n                    break;\n                }\n            case \"remove_node\":\n                {\n                    var { path: _path4 } = op;\n                    var _index3 = _path4[_path4.length - 1];\n                    modifyChildren(editor, Path.parent(_path4), (children)=>removeChildren(children, _index3, 1));\n                    // Transform all the points in the value, but if the point was in the\n                    // node that was removed we need to update the range or remove it.\n                    if (editor.selection) {\n                        var selection = _objectSpread$e({}, editor.selection);\n                        for (var [point, key] of Range.points(selection)){\n                            var result = Point.transform(point, op);\n                            if (selection != null && result != null) {\n                                selection[key] = result;\n                            } else {\n                                var prev = void 0;\n                                var next = void 0;\n                                for (var [n, p] of Node.texts(editor)){\n                                    if (Path.compare(p, _path4) === -1) {\n                                        prev = [\n                                            n,\n                                            p\n                                        ];\n                                    } else {\n                                        next = [\n                                            n,\n                                            p\n                                        ];\n                                        break;\n                                    }\n                                }\n                                var preferNext = false;\n                                if (prev && next) {\n                                    if (Path.equals(next[1], _path4)) {\n                                        preferNext = !Path.hasPrevious(next[1]);\n                                    } else {\n                                        preferNext = Path.common(prev[1], _path4).length < Path.common(next[1], _path4).length;\n                                    }\n                                }\n                                if (prev && !preferNext) {\n                                    selection[key] = {\n                                        path: prev[1],\n                                        offset: prev[0].text.length\n                                    };\n                                } else if (next) {\n                                    selection[key] = {\n                                        path: next[1],\n                                        offset: 0\n                                    };\n                                } else {\n                                    selection = null;\n                                }\n                            }\n                        }\n                        editor.selection = selection;\n                    }\n                    break;\n                }\n            case \"remove_text\":\n                {\n                    var { path: _path5, offset: _offset, text: _text } = op;\n                    if (_text.length === 0) break;\n                    modifyLeaf(editor, _path5, (node)=>{\n                        var before = node.text.slice(0, _offset);\n                        var after = node.text.slice(_offset + _text.length);\n                        return _objectSpread$e(_objectSpread$e({}, node), {}, {\n                            text: before + after\n                        });\n                    });\n                    transformSelection = true;\n                    break;\n                }\n            case \"set_node\":\n                {\n                    var { path: _path6, properties, newProperties } = op;\n                    if (_path6.length === 0) {\n                        throw new Error(\"Cannot set properties on the root node!\");\n                    }\n                    modifyDescendant(editor, _path6, (node)=>{\n                        var newNode = _objectSpread$e({}, node);\n                        for(var _key3 in newProperties){\n                            if (_key3 === \"children\" || _key3 === \"text\") {\n                                throw new Error('Cannot set the \"'.concat(_key3, '\" property of nodes!'));\n                            }\n                            var value = newProperties[_key3];\n                            if (value == null) {\n                                delete newNode[_key3];\n                            } else {\n                                newNode[_key3] = value;\n                            }\n                        }\n                        // properties that were previously defined, but are now missing, must be deleted\n                        for(var _key4 in properties){\n                            if (!newProperties.hasOwnProperty(_key4)) {\n                                delete newNode[_key4];\n                            }\n                        }\n                        return newNode;\n                    });\n                    break;\n                }\n            case \"set_selection\":\n                {\n                    var { newProperties: _newProperties } = op;\n                    if (_newProperties == null) {\n                        editor.selection = null;\n                        break;\n                    }\n                    if (editor.selection == null) {\n                        if (!Range.isRange(_newProperties)) {\n                            throw new Error('Cannot apply an incomplete \"set_selection\" operation properties '.concat(Scrubber.stringify(_newProperties), \" when there is no current selection.\"));\n                        }\n                        editor.selection = _objectSpread$e({}, _newProperties);\n                        break;\n                    }\n                    var _selection = _objectSpread$e({}, editor.selection);\n                    for(var _key5 in _newProperties){\n                        var value = _newProperties[_key5];\n                        if (value == null) {\n                            if (_key5 === \"anchor\" || _key5 === \"focus\") {\n                                throw new Error('Cannot remove the \"'.concat(_key5, '\" selection property'));\n                            }\n                            delete _selection[_key5];\n                        } else {\n                            _selection[_key5] = value;\n                        }\n                    }\n                    editor.selection = _selection;\n                    break;\n                }\n            case \"split_node\":\n                {\n                    var { path: _path7, position, properties: _properties } = op;\n                    var _index4 = _path7[_path7.length - 1];\n                    if (_path7.length === 0) {\n                        throw new Error('Cannot apply a \"split_node\" operation at path ['.concat(_path7, \"] because the root node cannot be split.\"));\n                    }\n                    modifyChildren(editor, Path.parent(_path7), (children)=>{\n                        var node = children[_index4];\n                        var newNode;\n                        var nextNode;\n                        if (Text.isText(node)) {\n                            var before = node.text.slice(0, position);\n                            var after = node.text.slice(position);\n                            newNode = _objectSpread$e(_objectSpread$e({}, node), {}, {\n                                text: before\n                            });\n                            nextNode = _objectSpread$e(_objectSpread$e({}, _properties), {}, {\n                                text: after\n                            });\n                        } else {\n                            var _before = node.children.slice(0, position);\n                            var _after = node.children.slice(position);\n                            newNode = _objectSpread$e(_objectSpread$e({}, node), {}, {\n                                children: _before\n                            });\n                            nextNode = _objectSpread$e(_objectSpread$e({}, _properties), {}, {\n                                children: _after\n                            });\n                        }\n                        return replaceChildren(children, _index4, 1, newNode, nextNode);\n                    });\n                    transformSelection = true;\n                    break;\n                }\n        }\n        if (transformSelection && editor.selection) {\n            var _selection2 = _objectSpread$e({}, editor.selection);\n            for (var [_point, _key6] of Range.points(_selection2)){\n                _selection2[_key6] = Point.transform(_point, op);\n            }\n            editor.selection = _selection2;\n        }\n    }\n};\n// eslint-disable-next-line no-redeclare\nvar NodeTransforms = {\n    insertNodes (editor, nodes, options) {\n        editor.insertNodes(nodes, options);\n    },\n    liftNodes (editor, options) {\n        editor.liftNodes(options);\n    },\n    mergeNodes (editor, options) {\n        editor.mergeNodes(options);\n    },\n    moveNodes (editor, options) {\n        editor.moveNodes(options);\n    },\n    removeNodes (editor, options) {\n        editor.removeNodes(options);\n    },\n    setNodes (editor, props, options) {\n        editor.setNodes(props, options);\n    },\n    splitNodes (editor, options) {\n        editor.splitNodes(options);\n    },\n    unsetNodes (editor, props, options) {\n        editor.unsetNodes(props, options);\n    },\n    unwrapNodes (editor, options) {\n        editor.unwrapNodes(options);\n    },\n    wrapNodes (editor, element, options) {\n        editor.wrapNodes(element, options);\n    }\n};\n// eslint-disable-next-line no-redeclare\nvar SelectionTransforms = {\n    collapse (editor, options) {\n        editor.collapse(options);\n    },\n    deselect (editor) {\n        editor.deselect();\n    },\n    move (editor, options) {\n        editor.move(options);\n    },\n    select (editor, target) {\n        editor.select(target);\n    },\n    setPoint (editor, props, options) {\n        editor.setPoint(props, options);\n    },\n    setSelection (editor, props) {\n        editor.setSelection(props);\n    }\n};\nvar isObject = (value)=>typeof value === \"object\" && value !== null;\n/*\n  Custom deep equal comparison for Slate nodes.\n\n  We don't need general purpose deep equality;\n  Slate only supports plain values, Arrays, and nested objects.\n  Complex values nested inside Arrays are not supported.\n\n  Slate objects are designed to be serialised, so\n  missing keys are deliberately normalised to undefined.\n */ var isDeepEqual = (node, another)=>{\n    for(var key in node){\n        var a = node[key];\n        var b = another[key];\n        if (Array.isArray(a) && Array.isArray(b)) {\n            if (a.length !== b.length) return false;\n            for(var i = 0; i < a.length; i++){\n                if (a[i] !== b[i]) return false;\n            }\n        } else if (isObject(a) && isObject(b)) {\n            if (!isDeepEqual(a, b)) return false;\n        } else if (a !== b) {\n            return false;\n        }\n    }\n    /*\n    Deep object equality is only necessary in one direction; in the reverse direction\n    we are only looking for keys that are missing.\n    As above, undefined keys are normalised to missing.\n  */ for(var _key in another){\n        if (node[_key] === undefined && another[_key] !== undefined) {\n            return false;\n        }\n    }\n    return true;\n};\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nvar _excluded$4 = [\n    \"anchor\",\n    \"focus\"\n];\nfunction ownKeys$d(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread$d(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys$d(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$d(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\n// eslint-disable-next-line no-redeclare\nvar Range = {\n    edges (range) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { reverse = false } = options;\n        var { anchor, focus } = range;\n        return Range.isBackward(range) === reverse ? [\n            anchor,\n            focus\n        ] : [\n            focus,\n            anchor\n        ];\n    },\n    end (range) {\n        var [, end] = Range.edges(range);\n        return end;\n    },\n    equals (range, another) {\n        return Point.equals(range.anchor, another.anchor) && Point.equals(range.focus, another.focus);\n    },\n    surrounds (range, target) {\n        var intersectionRange = Range.intersection(range, target);\n        if (!intersectionRange) {\n            return false;\n        }\n        return Range.equals(intersectionRange, target);\n    },\n    includes (range, target) {\n        if (Range.isRange(target)) {\n            if (Range.includes(range, target.anchor) || Range.includes(range, target.focus)) {\n                return true;\n            }\n            var [rs, re] = Range.edges(range);\n            var [ts, te] = Range.edges(target);\n            return Point.isBefore(rs, ts) && Point.isAfter(re, te);\n        }\n        var [start, end] = Range.edges(range);\n        var isAfterStart = false;\n        var isBeforeEnd = false;\n        if (Point.isPoint(target)) {\n            isAfterStart = Point.compare(target, start) >= 0;\n            isBeforeEnd = Point.compare(target, end) <= 0;\n        } else {\n            isAfterStart = Path.compare(target, start.path) >= 0;\n            isBeforeEnd = Path.compare(target, end.path) <= 0;\n        }\n        return isAfterStart && isBeforeEnd;\n    },\n    intersection (range, another) {\n        var rest = _objectWithoutProperties(range, _excluded$4);\n        var [s1, e1] = Range.edges(range);\n        var [s2, e2] = Range.edges(another);\n        var start = Point.isBefore(s1, s2) ? s2 : s1;\n        var end = Point.isBefore(e1, e2) ? e1 : e2;\n        if (Point.isBefore(end, start)) {\n            return null;\n        } else {\n            return _objectSpread$d({\n                anchor: start,\n                focus: end\n            }, rest);\n        }\n    },\n    isBackward (range) {\n        var { anchor, focus } = range;\n        return Point.isAfter(anchor, focus);\n    },\n    isCollapsed (range) {\n        var { anchor, focus } = range;\n        return Point.equals(anchor, focus);\n    },\n    isExpanded (range) {\n        return !Range.isCollapsed(range);\n    },\n    isForward (range) {\n        return !Range.isBackward(range);\n    },\n    isRange (value) {\n        return isObject(value) && Point.isPoint(value.anchor) && Point.isPoint(value.focus);\n    },\n    *points (range) {\n        yield [\n            range.anchor,\n            \"anchor\"\n        ];\n        yield [\n            range.focus,\n            \"focus\"\n        ];\n    },\n    start (range) {\n        var [start] = Range.edges(range);\n        return start;\n    },\n    transform (range, op) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        if (range === null) {\n            return null;\n        }\n        var { affinity = \"inward\" } = options;\n        var affinityAnchor;\n        var affinityFocus;\n        if (affinity === \"inward\") {\n            // If the range is collapsed, make sure to use the same affinity to\n            // avoid the two points passing each other and expanding in the opposite\n            // direction\n            var isCollapsed = Range.isCollapsed(range);\n            if (Range.isForward(range)) {\n                affinityAnchor = \"forward\";\n                affinityFocus = isCollapsed ? affinityAnchor : \"backward\";\n            } else {\n                affinityAnchor = \"backward\";\n                affinityFocus = isCollapsed ? affinityAnchor : \"forward\";\n            }\n        } else if (affinity === \"outward\") {\n            if (Range.isForward(range)) {\n                affinityAnchor = \"backward\";\n                affinityFocus = \"forward\";\n            } else {\n                affinityAnchor = \"forward\";\n                affinityFocus = \"backward\";\n            }\n        } else {\n            affinityAnchor = affinity;\n            affinityFocus = affinity;\n        }\n        var anchor = Point.transform(range.anchor, op, {\n            affinity: affinityAnchor\n        });\n        var focus = Point.transform(range.focus, op, {\n            affinity: affinityFocus\n        });\n        if (!anchor || !focus) {\n            return null;\n        }\n        return {\n            anchor,\n            focus\n        };\n    }\n};\n/**\n * Shared the function with isElementType utility\n */ var isElement = function isElement(value) {\n    var { deep = false } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!isObject(value)) return false;\n    // PERF: No need to use the full Editor.isEditor here\n    var isEditor = typeof value.apply === \"function\";\n    if (isEditor) return false;\n    var isChildrenValid = deep ? Node.isNodeList(value.children) : Array.isArray(value.children);\n    return isChildrenValid;\n};\n// eslint-disable-next-line no-redeclare\nvar Element = {\n    isAncestor (value) {\n        var { deep = false } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return isObject(value) && Node.isNodeList(value.children, {\n            deep\n        });\n    },\n    isElement,\n    isElementList (value) {\n        var { deep = false } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return Array.isArray(value) && value.every((val)=>Element.isElement(val, {\n                deep\n            }));\n    },\n    isElementProps (props) {\n        return props.children !== undefined;\n    },\n    isElementType: function isElementType(value, elementVal) {\n        var elementKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"type\";\n        return isElement(value) && value[elementKey] === elementVal;\n    },\n    matches (element, props) {\n        for(var key in props){\n            if (key === \"children\") {\n                continue;\n            }\n            if (element[key] !== props[key]) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\nvar _excluded$3 = [\n    \"children\"\n], _excluded2$3 = [\n    \"text\"\n];\n// eslint-disable-next-line no-redeclare\nvar Node = {\n    ancestor (root, path) {\n        var node = Node.get(root, path);\n        if (Text.isText(node)) {\n            throw new Error(\"Cannot get the ancestor node at path [\".concat(path, \"] because it refers to a text node instead: \").concat(Scrubber.stringify(node)));\n        }\n        return node;\n    },\n    ancestors (root, path) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return function*() {\n            for (var p of Path.ancestors(path, options)){\n                var n = Node.ancestor(root, p);\n                var entry = [\n                    n,\n                    p\n                ];\n                yield entry;\n            }\n        }();\n    },\n    child (root, index) {\n        if (Text.isText(root)) {\n            throw new Error(\"Cannot get the child of a text node: \".concat(Scrubber.stringify(root)));\n        }\n        var c = root.children[index];\n        if (c == null) {\n            throw new Error(\"Cannot get child at index `\".concat(index, \"` in node: \").concat(Scrubber.stringify(root)));\n        }\n        return c;\n    },\n    children (root, path) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return function*() {\n            var { reverse = false } = options;\n            var ancestor = Node.ancestor(root, path);\n            var { children } = ancestor;\n            var index = reverse ? children.length - 1 : 0;\n            while(reverse ? index >= 0 : index < children.length){\n                var child = Node.child(ancestor, index);\n                var childPath = path.concat(index);\n                yield [\n                    child,\n                    childPath\n                ];\n                index = reverse ? index - 1 : index + 1;\n            }\n        }();\n    },\n    common (root, path, another) {\n        var p = Path.common(path, another);\n        var n = Node.get(root, p);\n        return [\n            n,\n            p\n        ];\n    },\n    descendant (root, path) {\n        var node = Node.get(root, path);\n        if (Editor.isEditor(node)) {\n            throw new Error(\"Cannot get the descendant node at path [\".concat(path, \"] because it refers to the root editor node instead: \").concat(Scrubber.stringify(node)));\n        }\n        return node;\n    },\n    descendants (root) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return function*() {\n            for (var [node, path] of Node.nodes(root, options)){\n                if (path.length !== 0) {\n                    // NOTE: we have to coerce here because checking the path's length does\n                    // guarantee that `node` is not a `Editor`, but TypeScript doesn't know.\n                    yield [\n                        node,\n                        path\n                    ];\n                }\n            }\n        }();\n    },\n    elements (root) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return function*() {\n            for (var [node, path] of Node.nodes(root, options)){\n                if (Element.isElement(node)) {\n                    yield [\n                        node,\n                        path\n                    ];\n                }\n            }\n        }();\n    },\n    extractProps (node) {\n        if (Element.isAncestor(node)) {\n            var properties = _objectWithoutProperties(node, _excluded$3);\n            return properties;\n        } else {\n            var properties = _objectWithoutProperties(node, _excluded2$3);\n            return properties;\n        }\n    },\n    first (root, path) {\n        var p = path.slice();\n        var n = Node.get(root, p);\n        while(n){\n            if (Text.isText(n) || n.children.length === 0) {\n                break;\n            } else {\n                n = n.children[0];\n                p.push(0);\n            }\n        }\n        return [\n            n,\n            p\n        ];\n    },\n    fragment (root, range) {\n        if (Text.isText(root)) {\n            throw new Error(\"Cannot get a fragment starting from a root text node: \".concat(Scrubber.stringify(root)));\n        }\n        var newRoot = (0,immer__WEBPACK_IMPORTED_MODULE_0__.produce)({\n            children: root.children\n        }, (r)=>{\n            var [start, end] = Range.edges(range);\n            var nodeEntries = Node.nodes(r, {\n                reverse: true,\n                pass: (_ref)=>{\n                    var [, path] = _ref;\n                    return !Range.includes(range, path);\n                }\n            });\n            for (var [, path] of nodeEntries){\n                if (!Range.includes(range, path)) {\n                    var parent = Node.parent(r, path);\n                    var index = path[path.length - 1];\n                    parent.children.splice(index, 1);\n                }\n                if (Path.equals(path, end.path)) {\n                    var leaf = Node.leaf(r, path);\n                    leaf.text = leaf.text.slice(0, end.offset);\n                }\n                if (Path.equals(path, start.path)) {\n                    var _leaf = Node.leaf(r, path);\n                    _leaf.text = _leaf.text.slice(start.offset);\n                }\n            }\n            if (Editor.isEditor(r)) {\n                r.selection = null;\n            }\n        });\n        return newRoot.children;\n    },\n    get (root, path) {\n        var node = Node.getIf(root, path);\n        if (node === undefined) {\n            throw new Error(\"Cannot find a descendant at path [\".concat(path, \"] in node: \").concat(Scrubber.stringify(root)));\n        }\n        return node;\n    },\n    getIf (root, path) {\n        var node = root;\n        for(var i = 0; i < path.length; i++){\n            var p = path[i];\n            if (Text.isText(node) || !node.children[p]) {\n                return;\n            }\n            node = node.children[p];\n        }\n        return node;\n    },\n    has (root, path) {\n        var node = root;\n        for(var i = 0; i < path.length; i++){\n            var p = path[i];\n            if (Text.isText(node) || !node.children[p]) {\n                return false;\n            }\n            node = node.children[p];\n        }\n        return true;\n    },\n    isNode (value) {\n        var { deep = false } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return Text.isText(value) || Element.isElement(value, {\n            deep\n        }) || Editor.isEditor(value, {\n            deep\n        });\n    },\n    isNodeList (value) {\n        var { deep = false } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return Array.isArray(value) && value.every((val)=>Node.isNode(val, {\n                deep\n            }));\n    },\n    last (root, path) {\n        var p = path.slice();\n        var n = Node.get(root, p);\n        while(n){\n            if (Text.isText(n) || n.children.length === 0) {\n                break;\n            } else {\n                var i = n.children.length - 1;\n                n = n.children[i];\n                p.push(i);\n            }\n        }\n        return [\n            n,\n            p\n        ];\n    },\n    leaf (root, path) {\n        var node = Node.get(root, path);\n        if (!Text.isText(node)) {\n            throw new Error(\"Cannot get the leaf node at path [\".concat(path, \"] because it refers to a non-leaf node: \").concat(Scrubber.stringify(node)));\n        }\n        return node;\n    },\n    levels (root, path) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return function*() {\n            for (var p of Path.levels(path, options)){\n                var n = Node.get(root, p);\n                yield [\n                    n,\n                    p\n                ];\n            }\n        }();\n    },\n    matches (node, props) {\n        return Element.isElement(node) && Element.isElementProps(props) && Element.matches(node, props) || Text.isText(node) && Text.isTextProps(props) && Text.matches(node, props);\n    },\n    nodes (root) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return function*() {\n            var { pass, reverse = false } = options;\n            var { from = [], to } = options;\n            var visited = new Set();\n            var p = [];\n            var n = root;\n            while(true){\n                if (to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to))) {\n                    break;\n                }\n                if (!visited.has(n)) {\n                    yield [\n                        n,\n                        p\n                    ];\n                }\n                // If we're allowed to go downward and we haven't descended yet, do.\n                if (!visited.has(n) && !Text.isText(n) && n.children.length !== 0 && (pass == null || pass([\n                    n,\n                    p\n                ]) === false)) {\n                    visited.add(n);\n                    var nextIndex = reverse ? n.children.length - 1 : 0;\n                    if (Path.isAncestor(p, from)) {\n                        nextIndex = from[p.length];\n                    }\n                    p = p.concat(nextIndex);\n                    n = Node.get(root, p);\n                    continue;\n                }\n                // If we're at the root and we can't go down, we're done.\n                if (p.length === 0) {\n                    break;\n                }\n                // If we're going forward...\n                if (!reverse) {\n                    var newPath = Path.next(p);\n                    if (Node.has(root, newPath)) {\n                        p = newPath;\n                        n = Node.get(root, p);\n                        continue;\n                    }\n                }\n                // If we're going backward...\n                if (reverse && p[p.length - 1] !== 0) {\n                    var _newPath = Path.previous(p);\n                    p = _newPath;\n                    n = Node.get(root, p);\n                    continue;\n                }\n                // Otherwise we're going upward...\n                p = Path.parent(p);\n                n = Node.get(root, p);\n                visited.add(n);\n            }\n        }();\n    },\n    parent (root, path) {\n        var parentPath = Path.parent(path);\n        var p = Node.get(root, parentPath);\n        if (Text.isText(p)) {\n            throw new Error(\"Cannot get the parent of path [\".concat(path, \"] because it does not exist in the root.\"));\n        }\n        return p;\n    },\n    string (node) {\n        if (Text.isText(node)) {\n            return node.text;\n        } else {\n            return node.children.map(Node.string).join(\"\");\n        }\n    },\n    texts (root) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return function*() {\n            for (var [node, path] of Node.nodes(root, options)){\n                if (Text.isText(node)) {\n                    yield [\n                        node,\n                        path\n                    ];\n                }\n            }\n        }();\n    }\n};\nfunction ownKeys$c(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread$c(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys$c(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$c(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\n// eslint-disable-next-line no-redeclare\nvar Operation = {\n    isNodeOperation (value) {\n        return Operation.isOperation(value) && value.type.endsWith(\"_node\");\n    },\n    isOperation (value) {\n        if (!isObject(value)) {\n            return false;\n        }\n        switch(value.type){\n            case \"insert_node\":\n                return Path.isPath(value.path) && Node.isNode(value.node);\n            case \"insert_text\":\n                return typeof value.offset === \"number\" && typeof value.text === \"string\" && Path.isPath(value.path);\n            case \"merge_node\":\n                return typeof value.position === \"number\" && Path.isPath(value.path) && isObject(value.properties);\n            case \"move_node\":\n                return Path.isPath(value.path) && Path.isPath(value.newPath);\n            case \"remove_node\":\n                return Path.isPath(value.path) && Node.isNode(value.node);\n            case \"remove_text\":\n                return typeof value.offset === \"number\" && typeof value.text === \"string\" && Path.isPath(value.path);\n            case \"set_node\":\n                return Path.isPath(value.path) && isObject(value.properties) && isObject(value.newProperties);\n            case \"set_selection\":\n                return value.properties === null && Range.isRange(value.newProperties) || value.newProperties === null && Range.isRange(value.properties) || isObject(value.properties) && isObject(value.newProperties);\n            case \"split_node\":\n                return Path.isPath(value.path) && typeof value.position === \"number\" && isObject(value.properties);\n            default:\n                return false;\n        }\n    },\n    isOperationList (value) {\n        return Array.isArray(value) && value.every((val)=>Operation.isOperation(val));\n    },\n    isSelectionOperation (value) {\n        return Operation.isOperation(value) && value.type.endsWith(\"_selection\");\n    },\n    isTextOperation (value) {\n        return Operation.isOperation(value) && value.type.endsWith(\"_text\");\n    },\n    inverse (op) {\n        switch(op.type){\n            case \"insert_node\":\n                {\n                    return _objectSpread$c(_objectSpread$c({}, op), {}, {\n                        type: \"remove_node\"\n                    });\n                }\n            case \"insert_text\":\n                {\n                    return _objectSpread$c(_objectSpread$c({}, op), {}, {\n                        type: \"remove_text\"\n                    });\n                }\n            case \"merge_node\":\n                {\n                    return _objectSpread$c(_objectSpread$c({}, op), {}, {\n                        type: \"split_node\",\n                        path: Path.previous(op.path)\n                    });\n                }\n            case \"move_node\":\n                {\n                    var { newPath, path } = op;\n                    // PERF: in this case the move operation is a no-op anyways.\n                    if (Path.equals(newPath, path)) {\n                        return op;\n                    }\n                    // If the move happens completely within a single parent the path and\n                    // newPath are stable with respect to each other.\n                    if (Path.isSibling(path, newPath)) {\n                        return _objectSpread$c(_objectSpread$c({}, op), {}, {\n                            path: newPath,\n                            newPath: path\n                        });\n                    }\n                    // If the move does not happen within a single parent it is possible\n                    // for the move to impact the true path to the location where the node\n                    // was removed from and where it was inserted. We have to adjust for this\n                    // and find the original path. We can accomplish this (only in non-sibling)\n                    // moves by looking at the impact of the move operation on the node\n                    // after the original move path.\n                    var inversePath = Path.transform(path, op);\n                    var inverseNewPath = Path.transform(Path.next(path), op);\n                    return _objectSpread$c(_objectSpread$c({}, op), {}, {\n                        path: inversePath,\n                        newPath: inverseNewPath\n                    });\n                }\n            case \"remove_node\":\n                {\n                    return _objectSpread$c(_objectSpread$c({}, op), {}, {\n                        type: \"insert_node\"\n                    });\n                }\n            case \"remove_text\":\n                {\n                    return _objectSpread$c(_objectSpread$c({}, op), {}, {\n                        type: \"insert_text\"\n                    });\n                }\n            case \"set_node\":\n                {\n                    var { properties, newProperties } = op;\n                    return _objectSpread$c(_objectSpread$c({}, op), {}, {\n                        properties: newProperties,\n                        newProperties: properties\n                    });\n                }\n            case \"set_selection\":\n                {\n                    var { properties: _properties, newProperties: _newProperties } = op;\n                    if (_properties == null) {\n                        return _objectSpread$c(_objectSpread$c({}, op), {}, {\n                            properties: _newProperties,\n                            newProperties: null\n                        });\n                    } else if (_newProperties == null) {\n                        return _objectSpread$c(_objectSpread$c({}, op), {}, {\n                            properties: null,\n                            newProperties: _properties\n                        });\n                    } else {\n                        return _objectSpread$c(_objectSpread$c({}, op), {}, {\n                            properties: _newProperties,\n                            newProperties: _properties\n                        });\n                    }\n                }\n            case \"split_node\":\n                {\n                    return _objectSpread$c(_objectSpread$c({}, op), {}, {\n                        type: \"merge_node\",\n                        path: Path.next(op.path)\n                    });\n                }\n        }\n    }\n};\nvar isEditor = function isEditor(value) {\n    var { deep = false } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!isObject(value)) {\n        return false;\n    }\n    var isEditor = typeof value.addMark === \"function\" && typeof value.apply === \"function\" && typeof value.deleteFragment === \"function\" && typeof value.insertBreak === \"function\" && typeof value.insertSoftBreak === \"function\" && typeof value.insertFragment === \"function\" && typeof value.insertNode === \"function\" && typeof value.insertText === \"function\" && typeof value.isElementReadOnly === \"function\" && typeof value.isInline === \"function\" && typeof value.isSelectable === \"function\" && typeof value.isVoid === \"function\" && typeof value.normalizeNode === \"function\" && typeof value.onChange === \"function\" && typeof value.removeMark === \"function\" && typeof value.getDirtyPaths === \"function\" && (value.marks === null || isObject(value.marks)) && (value.selection === null || Range.isRange(value.selection)) && (!deep || Node.isNodeList(value.children)) && Operation.isOperationList(value.operations);\n    return isEditor;\n};\n// eslint-disable-next-line no-redeclare\nvar Editor = {\n    above (editor, options) {\n        return editor.above(options);\n    },\n    addMark (editor, key, value) {\n        editor.addMark(key, value);\n    },\n    after (editor, at, options) {\n        return editor.after(at, options);\n    },\n    before (editor, at, options) {\n        return editor.before(at, options);\n    },\n    deleteBackward (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { unit = \"character\" } = options;\n        editor.deleteBackward(unit);\n    },\n    deleteForward (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { unit = \"character\" } = options;\n        editor.deleteForward(unit);\n    },\n    deleteFragment (editor, options) {\n        editor.deleteFragment(options);\n    },\n    edges (editor, at) {\n        return editor.edges(at);\n    },\n    elementReadOnly (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return editor.elementReadOnly(options);\n    },\n    end (editor, at) {\n        return editor.end(at);\n    },\n    first (editor, at) {\n        return editor.first(at);\n    },\n    fragment (editor, at) {\n        return editor.fragment(at);\n    },\n    hasBlocks (editor, element) {\n        return editor.hasBlocks(element);\n    },\n    hasInlines (editor, element) {\n        return editor.hasInlines(element);\n    },\n    hasPath (editor, path) {\n        return editor.hasPath(path);\n    },\n    hasTexts (editor, element) {\n        return editor.hasTexts(element);\n    },\n    insertBreak (editor) {\n        editor.insertBreak();\n    },\n    insertFragment (editor, fragment, options) {\n        editor.insertFragment(fragment, options);\n    },\n    insertNode (editor, node) {\n        editor.insertNode(node);\n    },\n    insertSoftBreak (editor) {\n        editor.insertSoftBreak();\n    },\n    insertText (editor, text) {\n        editor.insertText(text);\n    },\n    isBlock (editor, value) {\n        return editor.isBlock(value);\n    },\n    isEdge (editor, point, at) {\n        return editor.isEdge(point, at);\n    },\n    isEditor (value) {\n        return isEditor(value);\n    },\n    isElementReadOnly (editor, element) {\n        return editor.isElementReadOnly(element);\n    },\n    isEmpty (editor, element) {\n        return editor.isEmpty(element);\n    },\n    isEnd (editor, point, at) {\n        return editor.isEnd(point, at);\n    },\n    isInline (editor, value) {\n        return editor.isInline(value);\n    },\n    isNormalizing (editor) {\n        return editor.isNormalizing();\n    },\n    isSelectable (editor, value) {\n        return editor.isSelectable(value);\n    },\n    isStart (editor, point, at) {\n        return editor.isStart(point, at);\n    },\n    isVoid (editor, value) {\n        return editor.isVoid(value);\n    },\n    last (editor, at) {\n        return editor.last(at);\n    },\n    leaf (editor, at, options) {\n        return editor.leaf(at, options);\n    },\n    levels (editor, options) {\n        return editor.levels(options);\n    },\n    marks (editor) {\n        return editor.getMarks();\n    },\n    next (editor, options) {\n        return editor.next(options);\n    },\n    node (editor, at, options) {\n        return editor.node(at, options);\n    },\n    nodes (editor, options) {\n        return editor.nodes(options);\n    },\n    normalize (editor, options) {\n        editor.normalize(options);\n    },\n    parent (editor, at, options) {\n        return editor.parent(at, options);\n    },\n    path (editor, at, options) {\n        return editor.path(at, options);\n    },\n    pathRef (editor, path, options) {\n        return editor.pathRef(path, options);\n    },\n    pathRefs (editor) {\n        return editor.pathRefs();\n    },\n    point (editor, at, options) {\n        return editor.point(at, options);\n    },\n    pointRef (editor, point, options) {\n        return editor.pointRef(point, options);\n    },\n    pointRefs (editor) {\n        return editor.pointRefs();\n    },\n    positions (editor, options) {\n        return editor.positions(options);\n    },\n    previous (editor, options) {\n        return editor.previous(options);\n    },\n    range (editor, at, to) {\n        return editor.range(at, to);\n    },\n    rangeRef (editor, range, options) {\n        return editor.rangeRef(range, options);\n    },\n    rangeRefs (editor) {\n        return editor.rangeRefs();\n    },\n    removeMark (editor, key) {\n        editor.removeMark(key);\n    },\n    setNormalizing (editor, isNormalizing) {\n        editor.setNormalizing(isNormalizing);\n    },\n    start (editor, at) {\n        return editor.start(at);\n    },\n    string (editor, at, options) {\n        return editor.string(at, options);\n    },\n    unhangRange (editor, range, options) {\n        return editor.unhangRange(range, options);\n    },\n    void (editor, options) {\n        return editor.void(options);\n    },\n    withoutNormalizing (editor, fn) {\n        editor.withoutNormalizing(fn);\n    },\n    shouldMergeNodesRemovePrevNode: (editor, prevNode, curNode)=>{\n        return editor.shouldMergeNodesRemovePrevNode(prevNode, curNode);\n    }\n};\n// eslint-disable-next-line no-redeclare\nvar Location = {\n    isLocation (value) {\n        return Path.isPath(value) || Point.isPoint(value) || Range.isRange(value);\n    }\n};\n// eslint-disable-next-line no-redeclare\nvar Span = {\n    isSpan (value) {\n        return Array.isArray(value) && value.length === 2 && value.every(Path.isPath);\n    }\n};\nfunction ownKeys$b(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread$b(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys$b(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$b(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\n// eslint-disable-next-line no-redeclare\nvar Point = {\n    compare (point, another) {\n        var result = Path.compare(point.path, another.path);\n        if (result === 0) {\n            if (point.offset < another.offset) return -1;\n            if (point.offset > another.offset) return 1;\n            return 0;\n        }\n        return result;\n    },\n    isAfter (point, another) {\n        return Point.compare(point, another) === 1;\n    },\n    isBefore (point, another) {\n        return Point.compare(point, another) === -1;\n    },\n    equals (point, another) {\n        // PERF: ensure the offsets are equal first since they are cheaper to check.\n        return point.offset === another.offset && Path.equals(point.path, another.path);\n    },\n    isPoint (value) {\n        return isObject(value) && typeof value.offset === \"number\" && Path.isPath(value.path);\n    },\n    transform (point, op) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        if (point === null) {\n            return null;\n        }\n        var { affinity = \"forward\" } = options;\n        var { path, offset } = point;\n        switch(op.type){\n            case \"insert_node\":\n            case \"move_node\":\n                {\n                    path = Path.transform(path, op, options);\n                    break;\n                }\n            case \"insert_text\":\n                {\n                    if (Path.equals(op.path, path) && (op.offset < offset || op.offset === offset && affinity === \"forward\")) {\n                        offset += op.text.length;\n                    }\n                    break;\n                }\n            case \"merge_node\":\n                {\n                    if (Path.equals(op.path, path)) {\n                        offset += op.position;\n                    }\n                    path = Path.transform(path, op, options);\n                    break;\n                }\n            case \"remove_text\":\n                {\n                    if (Path.equals(op.path, path) && op.offset <= offset) {\n                        offset -= Math.min(offset - op.offset, op.text.length);\n                    }\n                    break;\n                }\n            case \"remove_node\":\n                {\n                    if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {\n                        return null;\n                    }\n                    path = Path.transform(path, op, options);\n                    break;\n                }\n            case \"split_node\":\n                {\n                    if (Path.equals(op.path, path)) {\n                        if (op.position === offset && affinity == null) {\n                            return null;\n                        } else if (op.position < offset || op.position === offset && affinity === \"forward\") {\n                            offset -= op.position;\n                            path = Path.transform(path, op, _objectSpread$b(_objectSpread$b({}, options), {}, {\n                                affinity: \"forward\"\n                            }));\n                        }\n                    } else {\n                        path = Path.transform(path, op, options);\n                    }\n                    break;\n                }\n            default:\n                return point;\n        }\n        return {\n            path,\n            offset\n        };\n    }\n};\nvar _scrubber = undefined;\n/**\n * This interface implements a stringify() function, which is used by Slate\n * internally when generating exceptions containing end user data. Developers\n * using Slate may call Scrubber.setScrubber() to alter the behavior of this\n * stringify() function.\n *\n * For example, to prevent the cleartext logging of 'text' fields within Nodes:\n *\n *    import { Scrubber } from 'slate';\n *    Scrubber.setScrubber((key, val) => {\n *      if (key === 'text') return '...scrubbed...'\n *      return val\n *    });\n *\n */ // eslint-disable-next-line no-redeclare\nvar Scrubber = {\n    setScrubber (scrubber) {\n        _scrubber = scrubber;\n    },\n    stringify (value) {\n        return JSON.stringify(value, _scrubber);\n    }\n};\nvar _excluded$2 = [\n    \"text\"\n], _excluded2$2 = [\n    \"anchor\",\n    \"focus\",\n    \"merge\"\n];\nfunction ownKeys$a(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread$a(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys$a(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$a(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\n// eslint-disable-next-line no-redeclare\nvar Text = {\n    equals (text, another) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var { loose = false } = options;\n        function omitText(obj) {\n            var rest = _objectWithoutProperties(obj, _excluded$2);\n            return rest;\n        }\n        return isDeepEqual(loose ? omitText(text) : text, loose ? omitText(another) : another);\n    },\n    isText (value) {\n        return isObject(value) && typeof value.text === \"string\";\n    },\n    isTextList (value) {\n        return Array.isArray(value) && value.every((val)=>Text.isText(val));\n    },\n    isTextProps (props) {\n        return props.text !== undefined;\n    },\n    matches (text, props) {\n        for(var key in props){\n            if (key === \"text\") {\n                continue;\n            }\n            if (!text.hasOwnProperty(key) || text[key] !== props[key]) {\n                return false;\n            }\n        }\n        return true;\n    },\n    decorations (node, decorations) {\n        var leaves = [\n            {\n                leaf: _objectSpread$a({}, node)\n            }\n        ];\n        for (var dec of decorations){\n            var { anchor, focus, merge: mergeDecoration } = dec, rest = _objectWithoutProperties(dec, _excluded2$2);\n            var [start, end] = Range.edges(dec);\n            var next = [];\n            var leafEnd = 0;\n            var decorationStart = start.offset;\n            var decorationEnd = end.offset;\n            var merge = mergeDecoration !== null && mergeDecoration !== void 0 ? mergeDecoration : Object.assign;\n            for (var { leaf } of leaves){\n                var { length } = leaf.text;\n                var leafStart = leafEnd;\n                leafEnd += length;\n                // If the range encompasses the entire leaf, add the range.\n                if (decorationStart <= leafStart && leafEnd <= decorationEnd) {\n                    merge(leaf, rest);\n                    next.push({\n                        leaf\n                    });\n                    continue;\n                }\n                // If the range expanded and match the leaf, or starts after, or ends before it, continue.\n                if (decorationStart !== decorationEnd && (decorationStart === leafEnd || decorationEnd === leafStart) || decorationStart > leafEnd || decorationEnd < leafStart || decorationEnd === leafStart && leafStart !== 0) {\n                    next.push({\n                        leaf\n                    });\n                    continue;\n                }\n                // Otherwise we need to split the leaf, at the start, end, or both,\n                // and add the range to the middle intersecting section. Do the end\n                // split first since we don't need to update the offset that way.\n                var middle = leaf;\n                var before = void 0;\n                var after = void 0;\n                if (decorationEnd < leafEnd) {\n                    var off = decorationEnd - leafStart;\n                    after = {\n                        leaf: _objectSpread$a(_objectSpread$a({}, middle), {}, {\n                            text: middle.text.slice(off)\n                        })\n                    };\n                    middle = _objectSpread$a(_objectSpread$a({}, middle), {}, {\n                        text: middle.text.slice(0, off)\n                    });\n                }\n                if (decorationStart > leafStart) {\n                    var _off = decorationStart - leafStart;\n                    before = {\n                        leaf: _objectSpread$a(_objectSpread$a({}, middle), {}, {\n                            text: middle.text.slice(0, _off)\n                        })\n                    };\n                    middle = _objectSpread$a(_objectSpread$a({}, middle), {}, {\n                        text: middle.text.slice(_off)\n                    });\n                }\n                merge(middle, rest);\n                if (before) {\n                    next.push(before);\n                }\n                next.push({\n                    leaf: middle\n                });\n                if (after) {\n                    next.push(after);\n                }\n            }\n            leaves = next;\n        }\n        if (leaves.length > 1) {\n            var currentOffset = 0;\n            for (var [index, item] of leaves.entries()){\n                var _start = currentOffset;\n                var _end = _start + item.leaf.text.length;\n                var position = {\n                    start: _start,\n                    end: _end\n                };\n                if (index === 0) position.isFirst = true;\n                if (index === leaves.length - 1) position.isLast = true;\n                item.position = position;\n                currentOffset = _end;\n            }\n        }\n        return leaves;\n    }\n};\n/**\n * Get the default location to insert content into the editor.\n * By default, use the selection as the target location. But if there is\n * no selection, insert at the end of the document since that is such a\n * common use case when inserting from a non-selected state.\n */ var getDefaultInsertLocation = (editor)=>{\n    if (editor.selection) {\n        return editor.selection;\n    } else if (editor.children.length > 0) {\n        return Editor.end(editor, []);\n    } else {\n        return [\n            0\n        ];\n    }\n};\nvar matchPath = (editor, path)=>{\n    var [node] = Editor.node(editor, path);\n    return (n)=>n === node;\n};\n// Character (grapheme cluster) boundaries are determined according to\n// the default grapheme cluster boundary specification, extended grapheme clusters variant[1].\n//\n// References:\n//\n// [1] https://www.unicode.org/reports/tr29/#Default_Grapheme_Cluster_Table\n// [2] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakProperty.txt\n// [3] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.html\n// [4] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.txt\n/**\n * Get the distance to the end of the first character in a string of text.\n */ var getCharacterDistance = function getCharacterDistance(str) {\n    var isRTL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var isLTR = !isRTL;\n    var codepoints = isRTL ? codepointsIteratorRTL(str) : str;\n    var left = CodepointType.None;\n    var right = CodepointType.None;\n    var distance = 0;\n    // Evaluation of these conditions are deferred.\n    var gb11 = null; // Is GB11 applicable?\n    var gb12Or13 = null; // Is GB12 or GB13 applicable?\n    for (var char of codepoints){\n        var code = char.codePointAt(0);\n        if (!code) break;\n        var type = getCodepointType(char, code);\n        [left, right] = isLTR ? [\n            right,\n            type\n        ] : [\n            type,\n            left\n        ];\n        if (intersects(left, CodepointType.ZWJ) && intersects(right, CodepointType.ExtPict)) {\n            if (isLTR) {\n                gb11 = endsWithEmojiZWJ(str.substring(0, distance));\n            } else {\n                gb11 = endsWithEmojiZWJ(str.substring(0, str.length - distance));\n            }\n            if (!gb11) break;\n        }\n        if (intersects(left, CodepointType.RI) && intersects(right, CodepointType.RI)) {\n            if (gb12Or13 !== null) {\n                gb12Or13 = !gb12Or13;\n            } else {\n                if (isLTR) {\n                    gb12Or13 = true;\n                } else {\n                    gb12Or13 = endsWithOddNumberOfRIs(str.substring(0, str.length - distance));\n                }\n            }\n            if (!gb12Or13) break;\n        }\n        if (left !== CodepointType.None && right !== CodepointType.None && isBoundaryPair(left, right)) {\n            break;\n        }\n        distance += char.length;\n    }\n    return distance || 1;\n};\nvar SPACE = /\\s/;\nvar PUNCTUATION = /[\\u002B\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/;\nvar CHAMELEON = /['\\u2018\\u2019]/;\n/**\n * Get the distance to the end of the first word in a string of text.\n */ var getWordDistance = function getWordDistance(text) {\n    var isRTL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var dist = 0;\n    var started = false;\n    while(text.length > 0){\n        var charDist = getCharacterDistance(text, isRTL);\n        var [char, remaining] = splitByCharacterDistance(text, charDist, isRTL);\n        if (isWordCharacter(char, remaining, isRTL)) {\n            started = true;\n            dist += charDist;\n        } else if (!started) {\n            dist += charDist;\n        } else {\n            break;\n        }\n        text = remaining;\n    }\n    return dist;\n};\n/**\n * Split a string in two parts at a given distance starting from the end when\n * `isRTL` is set to `true`.\n */ var splitByCharacterDistance = (str, dist, isRTL)=>{\n    if (isRTL) {\n        var at = str.length - dist;\n        return [\n            str.slice(at, str.length),\n            str.slice(0, at)\n        ];\n    }\n    return [\n        str.slice(0, dist),\n        str.slice(dist)\n    ];\n};\n/**\n * Check if a character is a word character. The `remaining` argument is used\n * because sometimes you must read subsequent characters to truly determine it.\n */ var isWordCharacter = function isWordCharacter(char, remaining) {\n    var isRTL = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (SPACE.test(char)) {\n        return false;\n    }\n    // Chameleons count as word characters as long as they're in a word, so\n    // recurse to see if the next one is a word character or not.\n    if (CHAMELEON.test(char)) {\n        var charDist = getCharacterDistance(remaining, isRTL);\n        var [nextChar, nextRemaining] = splitByCharacterDistance(remaining, charDist, isRTL);\n        if (isWordCharacter(nextChar, nextRemaining, isRTL)) {\n            return true;\n        }\n    }\n    if (PUNCTUATION.test(char)) {\n        return false;\n    }\n    return true;\n};\n/**\n * Iterate on codepoints from right to left.\n */ var codepointsIteratorRTL = function* codepointsIteratorRTL(str) {\n    var end = str.length - 1;\n    for(var i = 0; i < str.length; i++){\n        var char1 = str.charAt(end - i);\n        if (isLowSurrogate(char1.charCodeAt(0))) {\n            var char2 = str.charAt(end - i - 1);\n            if (isHighSurrogate(char2.charCodeAt(0))) {\n                yield char2 + char1;\n                i++;\n                continue;\n            }\n        }\n        yield char1;\n    }\n};\n/**\n * Is `charCode` a high surrogate.\n *\n * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates\n */ var isHighSurrogate = (charCode)=>{\n    return charCode >= 0xd800 && charCode <= 0xdbff;\n};\n/**\n * Is `charCode` a low surrogate.\n *\n * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates\n */ var isLowSurrogate = (charCode)=>{\n    return charCode >= 0xdc00 && charCode <= 0xdfff;\n};\nvar CodepointType;\n(function(CodepointType) {\n    CodepointType[CodepointType[\"None\"] = 0] = \"None\";\n    CodepointType[CodepointType[\"Extend\"] = 1] = \"Extend\";\n    CodepointType[CodepointType[\"ZWJ\"] = 2] = \"ZWJ\";\n    CodepointType[CodepointType[\"RI\"] = 4] = \"RI\";\n    CodepointType[CodepointType[\"Prepend\"] = 8] = \"Prepend\";\n    CodepointType[CodepointType[\"SpacingMark\"] = 16] = \"SpacingMark\";\n    CodepointType[CodepointType[\"L\"] = 32] = \"L\";\n    CodepointType[CodepointType[\"V\"] = 64] = \"V\";\n    CodepointType[CodepointType[\"T\"] = 128] = \"T\";\n    CodepointType[CodepointType[\"LV\"] = 256] = \"LV\";\n    CodepointType[CodepointType[\"LVT\"] = 512] = \"LVT\";\n    CodepointType[CodepointType[\"ExtPict\"] = 1024] = \"ExtPict\";\n    CodepointType[CodepointType[\"Any\"] = 2048] = \"Any\";\n})(CodepointType || (CodepointType = {}));\nvar reExtend = /^(?:[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u0898-\\u089F\\u08CA-\\u08E1\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09BE\\u09C1-\\u09C4\\u09CD\\u09D7\\u09E2\\u09E3\\u09FE\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01\\u0B3C\\u0B3E\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE\\u0BC0\\u0BCD\\u0BD7\\u0C00\\u0C04\\u0C3C\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC2\\u0CC6\\u0CCC\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D00\\u0D01\\u0D3B\\u0D3C\\u0D3E\\u0D41-\\u0D44\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D81\\u0DCA\\u0DCF\\u0DD2-\\u0DD4\\u0DD6\\u0DDF\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECE\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732\\u1733\\u1752\\u1753\\u1772\\u1773\\u17B4\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u180F\\u1885\\u1886\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1ACE\\u1B00-\\u1B03\\u1B34-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DFF\\u200C\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA82C\\uA8C4\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9BD\\uA9E5\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEC\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFF9E\\uFF9F]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD803[\\uDD24-\\uDD27\\uDEAB\\uDEAC\\uDEFD-\\uDEFF\\uDF46-\\uDF50\\uDF82-\\uDF85]|\\uD804[\\uDC01\\uDC38-\\uDC46\\uDC70\\uDC73\\uDC74\\uDC7F-\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDCC2\\uDD00-\\uDD02\\uDD27-\\uDD2B\\uDD2D-\\uDD34\\uDD73\\uDD80\\uDD81\\uDDB6-\\uDDBE\\uDDC9-\\uDDCC\\uDDCF\\uDE2F-\\uDE31\\uDE34\\uDE36\\uDE37\\uDE3E\\uDE41\\uDEDF\\uDEE3-\\uDEEA\\uDF00\\uDF01\\uDF3B\\uDF3C\\uDF3E\\uDF40\\uDF57\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC38-\\uDC3F\\uDC42-\\uDC44\\uDC46\\uDC5E\\uDCB0\\uDCB3-\\uDCB8\\uDCBA\\uDCBD\\uDCBF\\uDCC0\\uDCC2\\uDCC3\\uDDAF\\uDDB2-\\uDDB5\\uDDBC\\uDDBD\\uDDBF\\uDDC0\\uDDDC\\uDDDD\\uDE33-\\uDE3A\\uDE3D\\uDE3F\\uDE40\\uDEAB\\uDEAD\\uDEB0-\\uDEB5\\uDEB7\\uDF1D-\\uDF1F\\uDF22-\\uDF25\\uDF27-\\uDF2B]|\\uD806[\\uDC2F-\\uDC37\\uDC39\\uDC3A\\uDD30\\uDD3B\\uDD3C\\uDD3E\\uDD43\\uDDD4-\\uDDD7\\uDDDA\\uDDDB\\uDDE0\\uDE01-\\uDE0A\\uDE33-\\uDE38\\uDE3B-\\uDE3E\\uDE47\\uDE51-\\uDE56\\uDE59-\\uDE5B\\uDE8A-\\uDE96\\uDE98\\uDE99]|\\uD807[\\uDC30-\\uDC36\\uDC38-\\uDC3D\\uDC3F\\uDC92-\\uDCA7\\uDCAA-\\uDCB0\\uDCB2\\uDCB3\\uDCB5\\uDCB6\\uDD31-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD45\\uDD47\\uDD90\\uDD91\\uDD95\\uDD97\\uDEF3\\uDEF4\\uDF00\\uDF01\\uDF36-\\uDF3A\\uDF40\\uDF42]|\\uD80D[\\uDC40\\uDC47-\\uDC55]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF4F\\uDF8F-\\uDF92\\uDFE4]|\\uD82F[\\uDC9D\\uDC9E]|\\uD833[\\uDF00-\\uDF2D\\uDF30-\\uDF46]|\\uD834[\\uDD65\\uDD67-\\uDD69\\uDD6E-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDC8F\\uDD30-\\uDD36\\uDEAE\\uDEEC-\\uDEEF]|\\uD839[\\uDCEC-\\uDCEF]|\\uD83A[\\uDCD0-\\uDCD6\\uDD44-\\uDD4A]|\\uD83C[\\uDFFB-\\uDFFF]|\\uDB40[\\uDC20-\\uDC7F\\uDD00-\\uDDEF])$/;\nvar rePrepend = /^(?:[\\u0600-\\u0605\\u06DD\\u070F\\u0890\\u0891\\u08E2\\u0D4E]|\\uD804[\\uDCBD\\uDCCD\\uDDC2\\uDDC3]|\\uD806[\\uDD3F\\uDD41\\uDE3A\\uDE84-\\uDE89]|\\uD807\\uDD46)$/;\nvar reSpacingMark = /^(?:[\\u0903\\u093B\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u094F\\u0982\\u0983\\u09BF\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0\\u0CC1\\u0CC3\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0D02\\u0D03\\u0D3F\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D82\\u0D83\\u0DD0\\u0DD1\\u0DD8-\\u0DDE\\u0DF2\\u0DF3\\u0E33\\u0EB3\\u0F3E\\u0F3F\\u0F7F\\u1031\\u103B\\u103C\\u1056\\u1057\\u1084\\u1715\\u1734\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u1A19\\u1A1A\\u1A55\\u1A57\\u1A6D-\\u1A72\\u1B04\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1BE7\\u1BEA-\\u1BEC\\u1BEE\\u1BF2\\u1BF3\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF7\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BE-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAAEB\\uAAEE\\uAAEF\\uAAF5\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]|\\uD804[\\uDC00\\uDC02\\uDC82\\uDCB0-\\uDCB2\\uDCB7\\uDCB8\\uDD2C\\uDD45\\uDD46\\uDD82\\uDDB3-\\uDDB5\\uDDBF\\uDDC0\\uDDCE\\uDE2C-\\uDE2E\\uDE32\\uDE33\\uDE35\\uDEE0-\\uDEE2\\uDF02\\uDF03\\uDF3F\\uDF41-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF62\\uDF63]|\\uD805[\\uDC35-\\uDC37\\uDC40\\uDC41\\uDC45\\uDCB1\\uDCB2\\uDCB9\\uDCBB\\uDCBC\\uDCBE\\uDCC1\\uDDB0\\uDDB1\\uDDB8-\\uDDBB\\uDDBE\\uDE30-\\uDE32\\uDE3B\\uDE3C\\uDE3E\\uDEAC\\uDEAE\\uDEAF\\uDEB6\\uDF26]|\\uD806[\\uDC2C-\\uDC2E\\uDC38\\uDD31-\\uDD35\\uDD37\\uDD38\\uDD3D\\uDD40\\uDD42\\uDDD1-\\uDDD3\\uDDDC-\\uDDDF\\uDDE4\\uDE39\\uDE57\\uDE58\\uDE97]|\\uD807[\\uDC2F\\uDC3E\\uDCA9\\uDCB1\\uDCB4\\uDD8A-\\uDD8E\\uDD93\\uDD94\\uDD96\\uDEF5\\uDEF6]|\\uD81B[\\uDF51-\\uDF87\\uDFF0\\uDFF1]|\\uD834[\\uDD66\\uDD6D])$/;\nvar reL = /^[\\u1100-\\u115F\\uA960-\\uA97C]$/;\nvar reV = /^[\\u1160-\\u11A7\\uD7B0-\\uD7C6]$/;\nvar reT = /^[\\u11A8-\\u11FF\\uD7CB-\\uD7FB]$/;\nvar reLV = /^[\\uAC00\\uAC1C\\uAC38\\uAC54\\uAC70\\uAC8C\\uACA8\\uACC4\\uACE0\\uACFC\\uAD18\\uAD34\\uAD50\\uAD6C\\uAD88\\uADA4\\uADC0\\uADDC\\uADF8\\uAE14\\uAE30\\uAE4C\\uAE68\\uAE84\\uAEA0\\uAEBC\\uAED8\\uAEF4\\uAF10\\uAF2C\\uAF48\\uAF64\\uAF80\\uAF9C\\uAFB8\\uAFD4\\uAFF0\\uB00C\\uB028\\uB044\\uB060\\uB07C\\uB098\\uB0B4\\uB0D0\\uB0EC\\uB108\\uB124\\uB140\\uB15C\\uB178\\uB194\\uB1B0\\uB1CC\\uB1E8\\uB204\\uB220\\uB23C\\uB258\\uB274\\uB290\\uB2AC\\uB2C8\\uB2E4\\uB300\\uB31C\\uB338\\uB354\\uB370\\uB38C\\uB3A8\\uB3C4\\uB3E0\\uB3FC\\uB418\\uB434\\uB450\\uB46C\\uB488\\uB4A4\\uB4C0\\uB4DC\\uB4F8\\uB514\\uB530\\uB54C\\uB568\\uB584\\uB5A0\\uB5BC\\uB5D8\\uB5F4\\uB610\\uB62C\\uB648\\uB664\\uB680\\uB69C\\uB6B8\\uB6D4\\uB6F0\\uB70C\\uB728\\uB744\\uB760\\uB77C\\uB798\\uB7B4\\uB7D0\\uB7EC\\uB808\\uB824\\uB840\\uB85C\\uB878\\uB894\\uB8B0\\uB8CC\\uB8E8\\uB904\\uB920\\uB93C\\uB958\\uB974\\uB990\\uB9AC\\uB9C8\\uB9E4\\uBA00\\uBA1C\\uBA38\\uBA54\\uBA70\\uBA8C\\uBAA8\\uBAC4\\uBAE0\\uBAFC\\uBB18\\uBB34\\uBB50\\uBB6C\\uBB88\\uBBA4\\uBBC0\\uBBDC\\uBBF8\\uBC14\\uBC30\\uBC4C\\uBC68\\uBC84\\uBCA0\\uBCBC\\uBCD8\\uBCF4\\uBD10\\uBD2C\\uBD48\\uBD64\\uBD80\\uBD9C\\uBDB8\\uBDD4\\uBDF0\\uBE0C\\uBE28\\uBE44\\uBE60\\uBE7C\\uBE98\\uBEB4\\uBED0\\uBEEC\\uBF08\\uBF24\\uBF40\\uBF5C\\uBF78\\uBF94\\uBFB0\\uBFCC\\uBFE8\\uC004\\uC020\\uC03C\\uC058\\uC074\\uC090\\uC0AC\\uC0C8\\uC0E4\\uC100\\uC11C\\uC138\\uC154\\uC170\\uC18C\\uC1A8\\uC1C4\\uC1E0\\uC1FC\\uC218\\uC234\\uC250\\uC26C\\uC288\\uC2A4\\uC2C0\\uC2DC\\uC2F8\\uC314\\uC330\\uC34C\\uC368\\uC384\\uC3A0\\uC3BC\\uC3D8\\uC3F4\\uC410\\uC42C\\uC448\\uC464\\uC480\\uC49C\\uC4B8\\uC4D4\\uC4F0\\uC50C\\uC528\\uC544\\uC560\\uC57C\\uC598\\uC5B4\\uC5D0\\uC5EC\\uC608\\uC624\\uC640\\uC65C\\uC678\\uC694\\uC6B0\\uC6CC\\uC6E8\\uC704\\uC720\\uC73C\\uC758\\uC774\\uC790\\uC7AC\\uC7C8\\uC7E4\\uC800\\uC81C\\uC838\\uC854\\uC870\\uC88C\\uC8A8\\uC8C4\\uC8E0\\uC8FC\\uC918\\uC934\\uC950\\uC96C\\uC988\\uC9A4\\uC9C0\\uC9DC\\uC9F8\\uCA14\\uCA30\\uCA4C\\uCA68\\uCA84\\uCAA0\\uCABC\\uCAD8\\uCAF4\\uCB10\\uCB2C\\uCB48\\uCB64\\uCB80\\uCB9C\\uCBB8\\uCBD4\\uCBF0\\uCC0C\\uCC28\\uCC44\\uCC60\\uCC7C\\uCC98\\uCCB4\\uCCD0\\uCCEC\\uCD08\\uCD24\\uCD40\\uCD5C\\uCD78\\uCD94\\uCDB0\\uCDCC\\uCDE8\\uCE04\\uCE20\\uCE3C\\uCE58\\uCE74\\uCE90\\uCEAC\\uCEC8\\uCEE4\\uCF00\\uCF1C\\uCF38\\uCF54\\uCF70\\uCF8C\\uCFA8\\uCFC4\\uCFE0\\uCFFC\\uD018\\uD034\\uD050\\uD06C\\uD088\\uD0A4\\uD0C0\\uD0DC\\uD0F8\\uD114\\uD130\\uD14C\\uD168\\uD184\\uD1A0\\uD1BC\\uD1D8\\uD1F4\\uD210\\uD22C\\uD248\\uD264\\uD280\\uD29C\\uD2B8\\uD2D4\\uD2F0\\uD30C\\uD328\\uD344\\uD360\\uD37C\\uD398\\uD3B4\\uD3D0\\uD3EC\\uD408\\uD424\\uD440\\uD45C\\uD478\\uD494\\uD4B0\\uD4CC\\uD4E8\\uD504\\uD520\\uD53C\\uD558\\uD574\\uD590\\uD5AC\\uD5C8\\uD5E4\\uD600\\uD61C\\uD638\\uD654\\uD670\\uD68C\\uD6A8\\uD6C4\\uD6E0\\uD6FC\\uD718\\uD734\\uD750\\uD76C\\uD788]$/;\nvar reLVT = /^[\\uAC01-\\uAC1B\\uAC1D-\\uAC37\\uAC39-\\uAC53\\uAC55-\\uAC6F\\uAC71-\\uAC8B\\uAC8D-\\uACA7\\uACA9-\\uACC3\\uACC5-\\uACDF\\uACE1-\\uACFB\\uACFD-\\uAD17\\uAD19-\\uAD33\\uAD35-\\uAD4F\\uAD51-\\uAD6B\\uAD6D-\\uAD87\\uAD89-\\uADA3\\uADA5-\\uADBF\\uADC1-\\uADDB\\uADDD-\\uADF7\\uADF9-\\uAE13\\uAE15-\\uAE2F\\uAE31-\\uAE4B\\uAE4D-\\uAE67\\uAE69-\\uAE83\\uAE85-\\uAE9F\\uAEA1-\\uAEBB\\uAEBD-\\uAED7\\uAED9-\\uAEF3\\uAEF5-\\uAF0F\\uAF11-\\uAF2B\\uAF2D-\\uAF47\\uAF49-\\uAF63\\uAF65-\\uAF7F\\uAF81-\\uAF9B\\uAF9D-\\uAFB7\\uAFB9-\\uAFD3\\uAFD5-\\uAFEF\\uAFF1-\\uB00B\\uB00D-\\uB027\\uB029-\\uB043\\uB045-\\uB05F\\uB061-\\uB07B\\uB07D-\\uB097\\uB099-\\uB0B3\\uB0B5-\\uB0CF\\uB0D1-\\uB0EB\\uB0ED-\\uB107\\uB109-\\uB123\\uB125-\\uB13F\\uB141-\\uB15B\\uB15D-\\uB177\\uB179-\\uB193\\uB195-\\uB1AF\\uB1B1-\\uB1CB\\uB1CD-\\uB1E7\\uB1E9-\\uB203\\uB205-\\uB21F\\uB221-\\uB23B\\uB23D-\\uB257\\uB259-\\uB273\\uB275-\\uB28F\\uB291-\\uB2AB\\uB2AD-\\uB2C7\\uB2C9-\\uB2E3\\uB2E5-\\uB2FF\\uB301-\\uB31B\\uB31D-\\uB337\\uB339-\\uB353\\uB355-\\uB36F\\uB371-\\uB38B\\uB38D-\\uB3A7\\uB3A9-\\uB3C3\\uB3C5-\\uB3DF\\uB3E1-\\uB3FB\\uB3FD-\\uB417\\uB419-\\uB433\\uB435-\\uB44F\\uB451-\\uB46B\\uB46D-\\uB487\\uB489-\\uB4A3\\uB4A5-\\uB4BF\\uB4C1-\\uB4DB\\uB4DD-\\uB4F7\\uB4F9-\\uB513\\uB515-\\uB52F\\uB531-\\uB54B\\uB54D-\\uB567\\uB569-\\uB583\\uB585-\\uB59F\\uB5A1-\\uB5BB\\uB5BD-\\uB5D7\\uB5D9-\\uB5F3\\uB5F5-\\uB60F\\uB611-\\uB62B\\uB62D-\\uB647\\uB649-\\uB663\\uB665-\\uB67F\\uB681-\\uB69B\\uB69D-\\uB6B7\\uB6B9-\\uB6D3\\uB6D5-\\uB6EF\\uB6F1-\\uB70B\\uB70D-\\uB727\\uB729-\\uB743\\uB745-\\uB75F\\uB761-\\uB77B\\uB77D-\\uB797\\uB799-\\uB7B3\\uB7B5-\\uB7CF\\uB7D1-\\uB7EB\\uB7ED-\\uB807\\uB809-\\uB823\\uB825-\\uB83F\\uB841-\\uB85B\\uB85D-\\uB877\\uB879-\\uB893\\uB895-\\uB8AF\\uB8B1-\\uB8CB\\uB8CD-\\uB8E7\\uB8E9-\\uB903\\uB905-\\uB91F\\uB921-\\uB93B\\uB93D-\\uB957\\uB959-\\uB973\\uB975-\\uB98F\\uB991-\\uB9AB\\uB9AD-\\uB9C7\\uB9C9-\\uB9E3\\uB9E5-\\uB9FF\\uBA01-\\uBA1B\\uBA1D-\\uBA37\\uBA39-\\uBA53\\uBA55-\\uBA6F\\uBA71-\\uBA8B\\uBA8D-\\uBAA7\\uBAA9-\\uBAC3\\uBAC5-\\uBADF\\uBAE1-\\uBAFB\\uBAFD-\\uBB17\\uBB19-\\uBB33\\uBB35-\\uBB4F\\uBB51-\\uBB6B\\uBB6D-\\uBB87\\uBB89-\\uBBA3\\uBBA5-\\uBBBF\\uBBC1-\\uBBDB\\uBBDD-\\uBBF7\\uBBF9-\\uBC13\\uBC15-\\uBC2F\\uBC31-\\uBC4B\\uBC4D-\\uBC67\\uBC69-\\uBC83\\uBC85-\\uBC9F\\uBCA1-\\uBCBB\\uBCBD-\\uBCD7\\uBCD9-\\uBCF3\\uBCF5-\\uBD0F\\uBD11-\\uBD2B\\uBD2D-\\uBD47\\uBD49-\\uBD63\\uBD65-\\uBD7F\\uBD81-\\uBD9B\\uBD9D-\\uBDB7\\uBDB9-\\uBDD3\\uBDD5-\\uBDEF\\uBDF1-\\uBE0B\\uBE0D-\\uBE27\\uBE29-\\uBE43\\uBE45-\\uBE5F\\uBE61-\\uBE7B\\uBE7D-\\uBE97\\uBE99-\\uBEB3\\uBEB5-\\uBECF\\uBED1-\\uBEEB\\uBEED-\\uBF07\\uBF09-\\uBF23\\uBF25-\\uBF3F\\uBF41-\\uBF5B\\uBF5D-\\uBF77\\uBF79-\\uBF93\\uBF95-\\uBFAF\\uBFB1-\\uBFCB\\uBFCD-\\uBFE7\\uBFE9-\\uC003\\uC005-\\uC01F\\uC021-\\uC03B\\uC03D-\\uC057\\uC059-\\uC073\\uC075-\\uC08F\\uC091-\\uC0AB\\uC0AD-\\uC0C7\\uC0C9-\\uC0E3\\uC0E5-\\uC0FF\\uC101-\\uC11B\\uC11D-\\uC137\\uC139-\\uC153\\uC155-\\uC16F\\uC171-\\uC18B\\uC18D-\\uC1A7\\uC1A9-\\uC1C3\\uC1C5-\\uC1DF\\uC1E1-\\uC1FB\\uC1FD-\\uC217\\uC219-\\uC233\\uC235-\\uC24F\\uC251-\\uC26B\\uC26D-\\uC287\\uC289-\\uC2A3\\uC2A5-\\uC2BF\\uC2C1-\\uC2DB\\uC2DD-\\uC2F7\\uC2F9-\\uC313\\uC315-\\uC32F\\uC331-\\uC34B\\uC34D-\\uC367\\uC369-\\uC383\\uC385-\\uC39F\\uC3A1-\\uC3BB\\uC3BD-\\uC3D7\\uC3D9-\\uC3F3\\uC3F5-\\uC40F\\uC411-\\uC42B\\uC42D-\\uC447\\uC449-\\uC463\\uC465-\\uC47F\\uC481-\\uC49B\\uC49D-\\uC4B7\\uC4B9-\\uC4D3\\uC4D5-\\uC4EF\\uC4F1-\\uC50B\\uC50D-\\uC527\\uC529-\\uC543\\uC545-\\uC55F\\uC561-\\uC57B\\uC57D-\\uC597\\uC599-\\uC5B3\\uC5B5-\\uC5CF\\uC5D1-\\uC5EB\\uC5ED-\\uC607\\uC609-\\uC623\\uC625-\\uC63F\\uC641-\\uC65B\\uC65D-\\uC677\\uC679-\\uC693\\uC695-\\uC6AF\\uC6B1-\\uC6CB\\uC6CD-\\uC6E7\\uC6E9-\\uC703\\uC705-\\uC71F\\uC721-\\uC73B\\uC73D-\\uC757\\uC759-\\uC773\\uC775-\\uC78F\\uC791-\\uC7AB\\uC7AD-\\uC7C7\\uC7C9-\\uC7E3\\uC7E5-\\uC7FF\\uC801-\\uC81B\\uC81D-\\uC837\\uC839-\\uC853\\uC855-\\uC86F\\uC871-\\uC88B\\uC88D-\\uC8A7\\uC8A9-\\uC8C3\\uC8C5-\\uC8DF\\uC8E1-\\uC8FB\\uC8FD-\\uC917\\uC919-\\uC933\\uC935-\\uC94F\\uC951-\\uC96B\\uC96D-\\uC987\\uC989-\\uC9A3\\uC9A5-\\uC9BF\\uC9C1-\\uC9DB\\uC9DD-\\uC9F7\\uC9F9-\\uCA13\\uCA15-\\uCA2F\\uCA31-\\uCA4B\\uCA4D-\\uCA67\\uCA69-\\uCA83\\uCA85-\\uCA9F\\uCAA1-\\uCABB\\uCABD-\\uCAD7\\uCAD9-\\uCAF3\\uCAF5-\\uCB0F\\uCB11-\\uCB2B\\uCB2D-\\uCB47\\uCB49-\\uCB63\\uCB65-\\uCB7F\\uCB81-\\uCB9B\\uCB9D-\\uCBB7\\uCBB9-\\uCBD3\\uCBD5-\\uCBEF\\uCBF1-\\uCC0B\\uCC0D-\\uCC27\\uCC29-\\uCC43\\uCC45-\\uCC5F\\uCC61-\\uCC7B\\uCC7D-\\uCC97\\uCC99-\\uCCB3\\uCCB5-\\uCCCF\\uCCD1-\\uCCEB\\uCCED-\\uCD07\\uCD09-\\uCD23\\uCD25-\\uCD3F\\uCD41-\\uCD5B\\uCD5D-\\uCD77\\uCD79-\\uCD93\\uCD95-\\uCDAF\\uCDB1-\\uCDCB\\uCDCD-\\uCDE7\\uCDE9-\\uCE03\\uCE05-\\uCE1F\\uCE21-\\uCE3B\\uCE3D-\\uCE57\\uCE59-\\uCE73\\uCE75-\\uCE8F\\uCE91-\\uCEAB\\uCEAD-\\uCEC7\\uCEC9-\\uCEE3\\uCEE5-\\uCEFF\\uCF01-\\uCF1B\\uCF1D-\\uCF37\\uCF39-\\uCF53\\uCF55-\\uCF6F\\uCF71-\\uCF8B\\uCF8D-\\uCFA7\\uCFA9-\\uCFC3\\uCFC5-\\uCFDF\\uCFE1-\\uCFFB\\uCFFD-\\uD017\\uD019-\\uD033\\uD035-\\uD04F\\uD051-\\uD06B\\uD06D-\\uD087\\uD089-\\uD0A3\\uD0A5-\\uD0BF\\uD0C1-\\uD0DB\\uD0DD-\\uD0F7\\uD0F9-\\uD113\\uD115-\\uD12F\\uD131-\\uD14B\\uD14D-\\uD167\\uD169-\\uD183\\uD185-\\uD19F\\uD1A1-\\uD1BB\\uD1BD-\\uD1D7\\uD1D9-\\uD1F3\\uD1F5-\\uD20F\\uD211-\\uD22B\\uD22D-\\uD247\\uD249-\\uD263\\uD265-\\uD27F\\uD281-\\uD29B\\uD29D-\\uD2B7\\uD2B9-\\uD2D3\\uD2D5-\\uD2EF\\uD2F1-\\uD30B\\uD30D-\\uD327\\uD329-\\uD343\\uD345-\\uD35F\\uD361-\\uD37B\\uD37D-\\uD397\\uD399-\\uD3B3\\uD3B5-\\uD3CF\\uD3D1-\\uD3EB\\uD3ED-\\uD407\\uD409-\\uD423\\uD425-\\uD43F\\uD441-\\uD45B\\uD45D-\\uD477\\uD479-\\uD493\\uD495-\\uD4AF\\uD4B1-\\uD4CB\\uD4CD-\\uD4E7\\uD4E9-\\uD503\\uD505-\\uD51F\\uD521-\\uD53B\\uD53D-\\uD557\\uD559-\\uD573\\uD575-\\uD58F\\uD591-\\uD5AB\\uD5AD-\\uD5C7\\uD5C9-\\uD5E3\\uD5E5-\\uD5FF\\uD601-\\uD61B\\uD61D-\\uD637\\uD639-\\uD653\\uD655-\\uD66F\\uD671-\\uD68B\\uD68D-\\uD6A7\\uD6A9-\\uD6C3\\uD6C5-\\uD6DF\\uD6E1-\\uD6FB\\uD6FD-\\uD717\\uD719-\\uD733\\uD735-\\uD74F\\uD751-\\uD76B\\uD76D-\\uD787\\uD789-\\uD7A3]$/;\nvar reExtPict = /^(?:[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u2388\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2605\\u2607-\\u2612\\u2614-\\u2685\\u2690-\\u2705\\u2708-\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763-\\u2767\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC00-\\uDCFF\\uDD0D-\\uDD0F\\uDD2F\\uDD6C-\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDAD-\\uDDE5\\uDE01-\\uDE0F\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE3C-\\uDE3F\\uDE49-\\uDFFA]|\\uD83D[\\uDC00-\\uDD3D\\uDD46-\\uDE4F\\uDE80-\\uDEFF\\uDF74-\\uDF7F\\uDFD5-\\uDFFF]|\\uD83E[\\uDC0C-\\uDC0F\\uDC48-\\uDC4F\\uDC5A-\\uDC5F\\uDC88-\\uDC8F\\uDCAE-\\uDCFF\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDEFF]|\\uD83F[\\uDC00-\\uDFFD])$/;\nvar getCodepointType = (char, code)=>{\n    var type = CodepointType.Any;\n    if (char.search(reExtend) !== -1) {\n        type |= CodepointType.Extend;\n    }\n    if (code === 0x200d) {\n        type |= CodepointType.ZWJ;\n    }\n    if (code >= 0x1f1e6 && code <= 0x1f1ff) {\n        type |= CodepointType.RI;\n    }\n    if (char.search(rePrepend) !== -1) {\n        type |= CodepointType.Prepend;\n    }\n    if (char.search(reSpacingMark) !== -1) {\n        type |= CodepointType.SpacingMark;\n    }\n    if (char.search(reL) !== -1) {\n        type |= CodepointType.L;\n    }\n    if (char.search(reV) !== -1) {\n        type |= CodepointType.V;\n    }\n    if (char.search(reT) !== -1) {\n        type |= CodepointType.T;\n    }\n    if (char.search(reLV) !== -1) {\n        type |= CodepointType.LV;\n    }\n    if (char.search(reLVT) !== -1) {\n        type |= CodepointType.LVT;\n    }\n    if (char.search(reExtPict) !== -1) {\n        type |= CodepointType.ExtPict;\n    }\n    return type;\n};\nfunction intersects(x, y) {\n    return (x & y) !== 0;\n}\nvar NonBoundaryPairs = [\n    // GB6\n    [\n        CodepointType.L,\n        CodepointType.L | CodepointType.V | CodepointType.LV | CodepointType.LVT\n    ],\n    // GB7\n    [\n        CodepointType.LV | CodepointType.V,\n        CodepointType.V | CodepointType.T\n    ],\n    // GB8\n    [\n        CodepointType.LVT | CodepointType.T,\n        CodepointType.T\n    ],\n    // GB9\n    [\n        CodepointType.Any,\n        CodepointType.Extend | CodepointType.ZWJ\n    ],\n    // GB9a\n    [\n        CodepointType.Any,\n        CodepointType.SpacingMark\n    ],\n    // GB9b\n    [\n        CodepointType.Prepend,\n        CodepointType.Any\n    ],\n    // GB11\n    [\n        CodepointType.ZWJ,\n        CodepointType.ExtPict\n    ],\n    // GB12 and GB13\n    [\n        CodepointType.RI,\n        CodepointType.RI\n    ]\n];\nfunction isBoundaryPair(left, right) {\n    return NonBoundaryPairs.findIndex((r)=>intersects(left, r[0]) && intersects(right, r[1])) === -1;\n}\nvar endingEmojiZWJ = /(?:[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u2388\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2605\\u2607-\\u2612\\u2614-\\u2685\\u2690-\\u2705\\u2708-\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763-\\u2767\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC00-\\uDCFF\\uDD0D-\\uDD0F\\uDD2F\\uDD6C-\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDAD-\\uDDE5\\uDE01-\\uDE0F\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE3C-\\uDE3F\\uDE49-\\uDFFA]|\\uD83D[\\uDC00-\\uDD3D\\uDD46-\\uDE4F\\uDE80-\\uDEFF\\uDF74-\\uDF7F\\uDFD5-\\uDFFF]|\\uD83E[\\uDC0C-\\uDC0F\\uDC48-\\uDC4F\\uDC5A-\\uDC5F\\uDC88-\\uDC8F\\uDCAE-\\uDCFF\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDEFF]|\\uD83F[\\uDC00-\\uDFFD])(?:[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u0898-\\u089F\\u08CA-\\u08E1\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09BE\\u09C1-\\u09C4\\u09CD\\u09D7\\u09E2\\u09E3\\u09FE\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01\\u0B3C\\u0B3E\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE\\u0BC0\\u0BCD\\u0BD7\\u0C00\\u0C04\\u0C3C\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC2\\u0CC6\\u0CCC\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D00\\u0D01\\u0D3B\\u0D3C\\u0D3E\\u0D41-\\u0D44\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D81\\u0DCA\\u0DCF\\u0DD2-\\u0DD4\\u0DD6\\u0DDF\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECE\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732\\u1733\\u1752\\u1753\\u1772\\u1773\\u17B4\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u180F\\u1885\\u1886\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1ACE\\u1B00-\\u1B03\\u1B34-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DFF\\u200C\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA82C\\uA8C4\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9BD\\uA9E5\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEC\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFF9E\\uFF9F]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD803[\\uDD24-\\uDD27\\uDEAB\\uDEAC\\uDEFD-\\uDEFF\\uDF46-\\uDF50\\uDF82-\\uDF85]|\\uD804[\\uDC01\\uDC38-\\uDC46\\uDC70\\uDC73\\uDC74\\uDC7F-\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDCC2\\uDD00-\\uDD02\\uDD27-\\uDD2B\\uDD2D-\\uDD34\\uDD73\\uDD80\\uDD81\\uDDB6-\\uDDBE\\uDDC9-\\uDDCC\\uDDCF\\uDE2F-\\uDE31\\uDE34\\uDE36\\uDE37\\uDE3E\\uDE41\\uDEDF\\uDEE3-\\uDEEA\\uDF00\\uDF01\\uDF3B\\uDF3C\\uDF3E\\uDF40\\uDF57\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC38-\\uDC3F\\uDC42-\\uDC44\\uDC46\\uDC5E\\uDCB0\\uDCB3-\\uDCB8\\uDCBA\\uDCBD\\uDCBF\\uDCC0\\uDCC2\\uDCC3\\uDDAF\\uDDB2-\\uDDB5\\uDDBC\\uDDBD\\uDDBF\\uDDC0\\uDDDC\\uDDDD\\uDE33-\\uDE3A\\uDE3D\\uDE3F\\uDE40\\uDEAB\\uDEAD\\uDEB0-\\uDEB5\\uDEB7\\uDF1D-\\uDF1F\\uDF22-\\uDF25\\uDF27-\\uDF2B]|\\uD806[\\uDC2F-\\uDC37\\uDC39\\uDC3A\\uDD30\\uDD3B\\uDD3C\\uDD3E\\uDD43\\uDDD4-\\uDDD7\\uDDDA\\uDDDB\\uDDE0\\uDE01-\\uDE0A\\uDE33-\\uDE38\\uDE3B-\\uDE3E\\uDE47\\uDE51-\\uDE56\\uDE59-\\uDE5B\\uDE8A-\\uDE96\\uDE98\\uDE99]|\\uD807[\\uDC30-\\uDC36\\uDC38-\\uDC3D\\uDC3F\\uDC92-\\uDCA7\\uDCAA-\\uDCB0\\uDCB2\\uDCB3\\uDCB5\\uDCB6\\uDD31-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD45\\uDD47\\uDD90\\uDD91\\uDD95\\uDD97\\uDEF3\\uDEF4\\uDF00\\uDF01\\uDF36-\\uDF3A\\uDF40\\uDF42]|\\uD80D[\\uDC40\\uDC47-\\uDC55]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF4F\\uDF8F-\\uDF92\\uDFE4]|\\uD82F[\\uDC9D\\uDC9E]|\\uD833[\\uDF00-\\uDF2D\\uDF30-\\uDF46]|\\uD834[\\uDD65\\uDD67-\\uDD69\\uDD6E-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDC8F\\uDD30-\\uDD36\\uDEAE\\uDEEC-\\uDEEF]|\\uD839[\\uDCEC-\\uDCEF]|\\uD83A[\\uDCD0-\\uDCD6\\uDD44-\\uDD4A]|\\uD83C[\\uDFFB-\\uDFFF]|\\uDB40[\\uDC20-\\uDC7F\\uDD00-\\uDDEF])*\\u200D$/;\nvar endsWithEmojiZWJ = (str)=>{\n    return str.search(endingEmojiZWJ) !== -1;\n};\nvar endingRIs = /(?:\\uD83C[\\uDDE6-\\uDDFF])+$/g;\nvar endsWithOddNumberOfRIs = (str)=>{\n    var match = str.match(endingRIs);\n    if (match === null) {\n        return false;\n    } else {\n        // A RI is represented by a surrogate pair.\n        var numRIs = match[0].length / 2;\n        return numRIs % 2 === 1;\n    }\n};\n// eslint-disable-next-line no-redeclare\nvar TextTransforms = {\n    delete (editor, options) {\n        editor.delete(options);\n    },\n    insertFragment (editor, fragment, options) {\n        editor.insertFragment(fragment, options);\n    },\n    insertText (editor, text) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        Editor.withoutNormalizing(editor, ()=>{\n            var { voids = false } = options;\n            var { at = getDefaultInsertLocation(editor) } = options;\n            if (Path.isPath(at)) {\n                at = Editor.range(editor, at);\n            }\n            if (Range.isRange(at)) {\n                if (Range.isCollapsed(at)) {\n                    at = at.anchor;\n                } else {\n                    var end = Range.end(at);\n                    if (!voids && Editor.void(editor, {\n                        at: end\n                    })) {\n                        return;\n                    }\n                    var start = Range.start(at);\n                    var startRef = Editor.pointRef(editor, start);\n                    var endRef = Editor.pointRef(editor, end);\n                    Transforms.delete(editor, {\n                        at,\n                        voids\n                    });\n                    var startPoint = startRef.unref();\n                    var endPoint = endRef.unref();\n                    at = startPoint || endPoint;\n                    Transforms.setSelection(editor, {\n                        anchor: at,\n                        focus: at\n                    });\n                }\n            }\n            if (!voids && Editor.void(editor, {\n                at\n            }) || Editor.elementReadOnly(editor, {\n                at\n            })) {\n                return;\n            }\n            var { path, offset } = at;\n            if (text.length > 0) editor.apply({\n                type: \"insert_text\",\n                path,\n                offset,\n                text\n            });\n        });\n    }\n};\nfunction ownKeys$9(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread$9(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys$9(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$9(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nvar Transforms = _objectSpread$9(_objectSpread$9(_objectSpread$9(_objectSpread$9({}, GeneralTransforms), NodeTransforms), SelectionTransforms), TextTransforms);\n// perf\nvar BATCHING_DIRTY_PATHS = new WeakMap();\nvar isBatchingDirtyPaths = (editor)=>{\n    return BATCHING_DIRTY_PATHS.get(editor) || false;\n};\nvar batchDirtyPaths = (editor, fn, update)=>{\n    var value = BATCHING_DIRTY_PATHS.get(editor) || false;\n    BATCHING_DIRTY_PATHS.set(editor, true);\n    try {\n        fn();\n        update();\n    } finally{\n        BATCHING_DIRTY_PATHS.set(editor, value);\n    }\n};\n/**\n * update editor dirty paths\n *\n * @param newDirtyPaths: Path[]; new dirty paths\n * @param transform: (p: Path) => Path | null; how to transform existing dirty paths\n */ function updateDirtyPaths(editor, newDirtyPaths, transform) {\n    var oldDirtyPaths = DIRTY_PATHS.get(editor) || [];\n    var oldDirtyPathKeys = DIRTY_PATH_KEYS.get(editor) || new Set();\n    var dirtyPaths;\n    var dirtyPathKeys;\n    var add = (path)=>{\n        if (path) {\n            var key = path.join(\",\");\n            if (!dirtyPathKeys.has(key)) {\n                dirtyPathKeys.add(key);\n                dirtyPaths.push(path);\n            }\n        }\n    };\n    if (transform) {\n        dirtyPaths = [];\n        dirtyPathKeys = new Set();\n        for (var path of oldDirtyPaths){\n            var newPath = transform(path);\n            add(newPath);\n        }\n    } else {\n        dirtyPaths = oldDirtyPaths;\n        dirtyPathKeys = oldDirtyPathKeys;\n    }\n    for (var _path of newDirtyPaths){\n        add(_path);\n    }\n    DIRTY_PATHS.set(editor, dirtyPaths);\n    DIRTY_PATH_KEYS.set(editor, dirtyPathKeys);\n}\nvar apply = (editor, op)=>{\n    for (var ref of Editor.pathRefs(editor)){\n        PathRef.transform(ref, op);\n    }\n    for (var _ref of Editor.pointRefs(editor)){\n        PointRef.transform(_ref, op);\n    }\n    for (var _ref2 of Editor.rangeRefs(editor)){\n        RangeRef.transform(_ref2, op);\n    }\n    // update dirty paths\n    if (!isBatchingDirtyPaths(editor)) {\n        var transform = Path.operationCanTransformPath(op) ? (p)=>Path.transform(p, op) : undefined;\n        updateDirtyPaths(editor, editor.getDirtyPaths(op), transform);\n    }\n    Transforms.transform(editor, op);\n    editor.operations.push(op);\n    Editor.normalize(editor, {\n        operation: op\n    });\n    // Clear any formats applied to the cursor if the selection changes.\n    if (op.type === \"set_selection\") {\n        editor.marks = null;\n    }\n    if (!FLUSHING.get(editor)) {\n        FLUSHING.set(editor, true);\n        Promise.resolve().then(()=>{\n            FLUSHING.set(editor, false);\n            editor.onChange({\n                operation: op\n            });\n            editor.operations = [];\n        });\n    }\n};\n/**\n * Get the \"dirty\" paths generated from an operation.\n */ var getDirtyPaths = (editor, op)=>{\n    switch(op.type){\n        case \"insert_text\":\n        case \"remove_text\":\n        case \"set_node\":\n            {\n                var { path } = op;\n                return Path.levels(path);\n            }\n        case \"insert_node\":\n            {\n                var { node, path: _path } = op;\n                var levels = Path.levels(_path);\n                var descendants = Text.isText(node) ? [] : Array.from(Node.nodes(node), (_ref)=>{\n                    var [, p] = _ref;\n                    return _path.concat(p);\n                });\n                return [\n                    ...levels,\n                    ...descendants\n                ];\n            }\n        case \"merge_node\":\n            {\n                var { path: _path2 } = op;\n                var ancestors = Path.ancestors(_path2);\n                var previousPath = Path.previous(_path2);\n                return [\n                    ...ancestors,\n                    previousPath\n                ];\n            }\n        case \"move_node\":\n            {\n                var { path: _path3, newPath } = op;\n                if (Path.equals(_path3, newPath)) {\n                    return [];\n                }\n                var oldAncestors = [];\n                var newAncestors = [];\n                for (var ancestor of Path.ancestors(_path3)){\n                    var p = Path.transform(ancestor, op);\n                    oldAncestors.push(p);\n                }\n                for (var _ancestor of Path.ancestors(newPath)){\n                    var _p = Path.transform(_ancestor, op);\n                    newAncestors.push(_p);\n                }\n                var newParent = newAncestors[newAncestors.length - 1];\n                var newIndex = newPath[newPath.length - 1];\n                var resultPath = newParent.concat(newIndex);\n                return [\n                    ...oldAncestors,\n                    ...newAncestors,\n                    resultPath\n                ];\n            }\n        case \"remove_node\":\n            {\n                var { path: _path4 } = op;\n                var _ancestors = Path.ancestors(_path4);\n                return [\n                    ..._ancestors\n                ];\n            }\n        case \"split_node\":\n            {\n                var { path: _path5 } = op;\n                var _levels = Path.levels(_path5);\n                var nextPath = Path.next(_path5);\n                return [\n                    ..._levels,\n                    nextPath\n                ];\n            }\n        default:\n            {\n                return [];\n            }\n    }\n};\nvar getFragment = (editor)=>{\n    var { selection } = editor;\n    if (selection) {\n        return Node.fragment(editor, selection);\n    }\n    return [];\n};\nvar normalizeNode = (editor, entry, options)=>{\n    var [node, path] = entry;\n    // There are no core normalizations for text nodes.\n    if (Text.isText(node)) {\n        return;\n    }\n    // Ensure that block and inline nodes have at least one text child.\n    if (Element.isElement(node) && node.children.length === 0) {\n        var child = {\n            text: \"\"\n        };\n        Transforms.insertNodes(editor, child, {\n            at: path.concat(0),\n            voids: true\n        });\n        return;\n    }\n    // Determine whether the node should have block or inline children.\n    var shouldHaveInlines = Editor.isEditor(node) ? false : Element.isElement(node) && (editor.isInline(node) || node.children.length === 0 || Text.isText(node.children[0]) || editor.isInline(node.children[0]));\n    // Since we'll be applying operations while iterating, keep track of an\n    // index that accounts for any added/removed nodes.\n    var n = 0;\n    for(var i = 0; i < node.children.length; i++, n++){\n        var currentNode = Node.get(editor, path);\n        if (Text.isText(currentNode)) continue;\n        var _child = currentNode.children[n];\n        var prev = currentNode.children[n - 1];\n        var isLast = i === node.children.length - 1;\n        var isInlineOrText = Text.isText(_child) || Element.isElement(_child) && editor.isInline(_child);\n        // Only allow block nodes in the top-level children and parent blocks\n        // that only contain block nodes. Similarly, only allow inline nodes in\n        // other inline nodes, or parent blocks that only contain inlines and\n        // text.\n        if (isInlineOrText !== shouldHaveInlines) {\n            if (isInlineOrText) {\n                if (options !== null && options !== void 0 && options.fallbackElement) {\n                    Transforms.wrapNodes(editor, options.fallbackElement(), {\n                        at: path.concat(n),\n                        voids: true\n                    });\n                } else {\n                    Transforms.removeNodes(editor, {\n                        at: path.concat(n),\n                        voids: true\n                    });\n                }\n            } else {\n                Transforms.unwrapNodes(editor, {\n                    at: path.concat(n),\n                    voids: true\n                });\n            }\n            n--;\n        } else if (Element.isElement(_child)) {\n            // Ensure that inline nodes are surrounded by text nodes.\n            if (editor.isInline(_child)) {\n                if (prev == null || !Text.isText(prev)) {\n                    var newChild = {\n                        text: \"\"\n                    };\n                    Transforms.insertNodes(editor, newChild, {\n                        at: path.concat(n),\n                        voids: true\n                    });\n                    n++;\n                } else if (isLast) {\n                    var _newChild = {\n                        text: \"\"\n                    };\n                    Transforms.insertNodes(editor, _newChild, {\n                        at: path.concat(n + 1),\n                        voids: true\n                    });\n                    n++;\n                }\n            }\n        } else {\n            // If the child is not a text node, and doesn't have a `children` field,\n            // then we have an invalid node that will upset slate.\n            //\n            // eg: `{ type: 'some_node' }`.\n            //\n            // To prevent slate from breaking, we can add the `children` field,\n            // and now that it is valid, we can to many more operations easily,\n            // such as extend normalizers to fix erronous structure.\n            if (!Text.isText(_child) && !(\"children\" in _child)) {\n                var elementChild = _child;\n                elementChild.children = [];\n            }\n            // Merge adjacent text nodes that are empty or match.\n            if (prev != null && Text.isText(prev)) {\n                if (Text.equals(_child, prev, {\n                    loose: true\n                })) {\n                    Transforms.mergeNodes(editor, {\n                        at: path.concat(n),\n                        voids: true\n                    });\n                    n--;\n                } else if (prev.text === \"\") {\n                    Transforms.removeNodes(editor, {\n                        at: path.concat(n - 1),\n                        voids: true\n                    });\n                    n--;\n                } else if (_child.text === \"\") {\n                    Transforms.removeNodes(editor, {\n                        at: path.concat(n),\n                        voids: true\n                    });\n                    n--;\n                }\n            }\n        }\n    }\n};\nvar shouldNormalize = (editor, _ref)=>{\n    var { iteration, initialDirtyPathsLength } = _ref;\n    var maxIterations = initialDirtyPathsLength * 42; // HACK: better way?\n    if (iteration > maxIterations) {\n        throw new Error(\"Could not completely normalize the editor after \".concat(maxIterations, \" iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\"));\n    }\n    return true;\n};\nvar above = function above(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var { voids = false, mode = \"lowest\", at = editor.selection, match } = options;\n    if (!at) {\n        return;\n    }\n    var path = Editor.path(editor, at);\n    // If `at` is a Range that spans mulitple nodes, `path` will be their common ancestor.\n    // Otherwise `path` will be a text node and/or the same as `at`, in which cases we want to start with its parent.\n    if (!Range.isRange(at) || Path.equals(at.focus.path, at.anchor.path)) {\n        if (path.length === 0) return;\n        path = Path.parent(path);\n    }\n    var reverse = mode === \"lowest\";\n    var [firstMatch] = Editor.levels(editor, {\n        at: path,\n        voids,\n        match,\n        reverse\n    });\n    return firstMatch; // if nothing matches this returns undefined\n};\nfunction ownKeys$8(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread$8(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys$8(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$8(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nvar addMark = (editor, key, value)=>{\n    var { selection } = editor;\n    if (selection) {\n        var match = (node, path)=>{\n            if (!Text.isText(node)) {\n                return false; // marks can only be applied to text\n            }\n            var [parentNode, parentPath] = Editor.parent(editor, path);\n            return !editor.isVoid(parentNode) || editor.markableVoid(parentNode);\n        };\n        var expandedSelection = Range.isExpanded(selection);\n        var markAcceptingVoidSelected = false;\n        if (!expandedSelection) {\n            var [selectedNode, selectedPath] = Editor.node(editor, selection);\n            if (selectedNode && match(selectedNode, selectedPath)) {\n                var [parentNode] = Editor.parent(editor, selectedPath);\n                markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);\n            }\n        }\n        if (expandedSelection || markAcceptingVoidSelected) {\n            Transforms.setNodes(editor, {\n                [key]: value\n            }, {\n                match,\n                split: true,\n                voids: true\n            });\n        } else {\n            var marks = _objectSpread$8(_objectSpread$8({}, Editor.marks(editor) || {}), {}, {\n                [key]: value\n            });\n            editor.marks = marks;\n            if (!FLUSHING.get(editor)) {\n                editor.onChange();\n            }\n        }\n    }\n};\nfunction ownKeys$7(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread$7(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys$7(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$7(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nvar after = function after(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var anchor = Editor.point(editor, at, {\n        edge: \"end\"\n    });\n    var focus = Editor.end(editor, []);\n    var range = {\n        anchor,\n        focus\n    };\n    var { distance = 1 } = options;\n    var d = 0;\n    var target;\n    for (var p of Editor.positions(editor, _objectSpread$7(_objectSpread$7({}, options), {}, {\n        at: range\n    }))){\n        if (d > distance) {\n            break;\n        }\n        if (d !== 0) {\n            target = p;\n        }\n        d++;\n    }\n    return target;\n};\nfunction ownKeys$6(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread$6(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys$6(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$6(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nvar before = function before(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var anchor = Editor.start(editor, []);\n    var focus = Editor.point(editor, at, {\n        edge: \"start\"\n    });\n    var range = {\n        anchor,\n        focus\n    };\n    var { distance = 1 } = options;\n    var d = 0;\n    var target;\n    for (var p of Editor.positions(editor, _objectSpread$6(_objectSpread$6({}, options), {}, {\n        at: range,\n        reverse: true\n    }))){\n        if (d > distance) {\n            break;\n        }\n        if (d !== 0) {\n            target = p;\n        }\n        d++;\n    }\n    return target;\n};\nvar deleteBackward = (editor, unit)=>{\n    var { selection } = editor;\n    if (selection && Range.isCollapsed(selection)) {\n        Transforms.delete(editor, {\n            unit,\n            reverse: true\n        });\n    }\n};\nvar deleteForward = (editor, unit)=>{\n    var { selection } = editor;\n    if (selection && Range.isCollapsed(selection)) {\n        Transforms.delete(editor, {\n            unit\n        });\n    }\n};\nvar deleteFragment = function deleteFragment(editor) {\n    var { direction = \"forward\" } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var { selection } = editor;\n    if (selection && Range.isExpanded(selection)) {\n        Transforms.delete(editor, {\n            reverse: direction === \"backward\"\n        });\n    }\n};\nvar edges = (editor, at)=>{\n    return [\n        Editor.start(editor, at),\n        Editor.end(editor, at)\n    ];\n};\nfunction ownKeys$5(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread$5(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys$5(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$5(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nvar elementReadOnly = function elementReadOnly(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return Editor.above(editor, _objectSpread$5(_objectSpread$5({}, options), {}, {\n        match: (n)=>Element.isElement(n) && Editor.isElementReadOnly(editor, n)\n    }));\n};\nvar end = (editor, at)=>{\n    return Editor.point(editor, at, {\n        edge: \"end\"\n    });\n};\nvar first = (editor, at)=>{\n    var path = Editor.path(editor, at, {\n        edge: \"start\"\n    });\n    return Editor.node(editor, path);\n};\nvar fragment = (editor, at)=>{\n    var range = Editor.range(editor, at);\n    return Node.fragment(editor, range);\n};\nfunction ownKeys$4(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread$4(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys$4(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$4(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nvar getVoid = function getVoid(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return Editor.above(editor, _objectSpread$4(_objectSpread$4({}, options), {}, {\n        match: (n)=>Element.isElement(n) && Editor.isVoid(editor, n)\n    }));\n};\nvar hasBlocks = (editor, element)=>{\n    return element.children.some((n)=>Element.isElement(n) && Editor.isBlock(editor, n));\n};\nvar hasInlines = (editor, element)=>{\n    return element.children.some((n)=>Text.isText(n) || Editor.isInline(editor, n));\n};\nvar hasPath = (editor, path)=>{\n    return Node.has(editor, path);\n};\nvar hasTexts = (editor, element)=>{\n    return element.children.every((n)=>Text.isText(n));\n};\nvar insertBreak = (editor)=>{\n    Transforms.splitNodes(editor, {\n        always: true\n    });\n};\nvar insertNode = (editor, node, options)=>{\n    Transforms.insertNodes(editor, node, options);\n};\nvar insertSoftBreak = (editor)=>{\n    Transforms.splitNodes(editor, {\n        always: true\n    });\n};\nfunction ownKeys$3(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread$3(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys$3(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$3(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nvar insertText = function insertText(editor, text) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var { selection, marks } = editor;\n    if (selection) {\n        if (marks) {\n            var node = _objectSpread$3({\n                text\n            }, marks);\n            Transforms.insertNodes(editor, node, {\n                at: options.at,\n                voids: options.voids\n            });\n        } else {\n            Transforms.insertText(editor, text, options);\n        }\n        editor.marks = null;\n    }\n};\nvar isBlock = (editor, value)=>{\n    return !editor.isInline(value);\n};\nvar isEdge = (editor, point, at)=>{\n    return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at);\n};\nvar isEmpty = (editor, element)=>{\n    var { children } = element;\n    var [first] = children;\n    return children.length === 0 || children.length === 1 && Text.isText(first) && first.text === \"\" && !editor.isVoid(element);\n};\nvar isEnd = (editor, point, at)=>{\n    var end = Editor.end(editor, at);\n    return Point.equals(point, end);\n};\nvar isNormalizing = (editor)=>{\n    var isNormalizing = NORMALIZING.get(editor);\n    return isNormalizing === undefined ? true : isNormalizing;\n};\nvar isStart = (editor, point, at)=>{\n    // PERF: If the offset isn't `0` we know it's not the start.\n    if (point.offset !== 0) {\n        return false;\n    }\n    var start = Editor.start(editor, at);\n    return Point.equals(point, start);\n};\nvar last = (editor, at)=>{\n    var path = Editor.path(editor, at, {\n        edge: \"end\"\n    });\n    return Editor.node(editor, path);\n};\nvar leaf = function leaf(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var node = Node.leaf(editor, path);\n    return [\n        node,\n        path\n    ];\n};\nfunction levels(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return function*() {\n        var { at = editor.selection, reverse = false, voids = false } = options;\n        var { match } = options;\n        if (match == null) {\n            match = ()=>true;\n        }\n        if (!at) {\n            return;\n        }\n        var levels = [];\n        var path = Editor.path(editor, at);\n        for (var [n, p] of Node.levels(editor, path)){\n            if (!match(n, p)) {\n                continue;\n            }\n            levels.push([\n                n,\n                p\n            ]);\n            if (!voids && Element.isElement(n) && Editor.isVoid(editor, n)) {\n                break;\n            }\n        }\n        if (reverse) {\n            levels.reverse();\n        }\n        yield* levels;\n    }();\n}\nvar _excluded$1 = [\n    \"text\"\n], _excluded2$1 = [\n    \"text\"\n];\nvar marks = function marks(editor) {\n    var { marks, selection } = editor;\n    if (!selection) {\n        return null;\n    }\n    var { anchor, focus } = selection;\n    if (marks) {\n        return marks;\n    }\n    if (Range.isExpanded(selection)) {\n        var isBackward = Range.isBackward(selection);\n        if (isBackward) {\n            [focus, anchor] = [\n                anchor,\n                focus\n            ];\n        }\n        /**\n     * COMPAT: Make sure hanging ranges (caused by double clicking in Firefox)\n     * do not adversely affect the returned marks.\n     */ var isEnd = Editor.isEnd(editor, anchor, anchor.path);\n        if (isEnd) {\n            var after = Editor.after(editor, anchor);\n            if (after) {\n                anchor = after;\n            }\n        }\n        var [match] = Editor.nodes(editor, {\n            match: Text.isText,\n            at: {\n                anchor,\n                focus\n            }\n        });\n        if (match) {\n            var [_node] = match;\n            var _rest = _objectWithoutProperties(_node, _excluded$1);\n            return _rest;\n        } else {\n            return {};\n        }\n    }\n    var { path } = anchor;\n    var [node] = Editor.leaf(editor, path);\n    if (anchor.offset === 0) {\n        var prev = Editor.previous(editor, {\n            at: path,\n            match: Text.isText\n        });\n        var markedVoid = Editor.above(editor, {\n            match: (n)=>Element.isElement(n) && Editor.isVoid(editor, n) && editor.markableVoid(n)\n        });\n        if (!markedVoid) {\n            var block = Editor.above(editor, {\n                match: (n)=>Element.isElement(n) && Editor.isBlock(editor, n)\n            });\n            if (prev && block) {\n                var [prevNode, prevPath] = prev;\n                var [, blockPath] = block;\n                if (Path.isAncestor(blockPath, prevPath)) {\n                    node = prevNode;\n                }\n            }\n        }\n    }\n    var rest = _objectWithoutProperties(node, _excluded2$1);\n    return rest;\n};\nvar next = function next(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var { mode = \"lowest\", voids = false } = options;\n    var { match, at = editor.selection } = options;\n    if (!at) {\n        return;\n    }\n    var pointAfterLocation = Editor.after(editor, at, {\n        voids\n    });\n    if (!pointAfterLocation) return;\n    var [, to] = Editor.last(editor, []);\n    var span = [\n        pointAfterLocation.path,\n        to\n    ];\n    if (Path.isPath(at) && at.length === 0) {\n        throw new Error(\"Cannot get the next node from the root node!\");\n    }\n    if (match == null) {\n        if (Path.isPath(at)) {\n            var [parent] = Editor.parent(editor, at);\n            match = (n)=>parent.children.includes(n);\n        } else {\n            match = ()=>true;\n        }\n    }\n    var [next] = Editor.nodes(editor, {\n        at: span,\n        match,\n        mode,\n        voids\n    });\n    return next;\n};\nvar node = function node(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var node = Node.get(editor, path);\n    return [\n        node,\n        path\n    ];\n};\nfunction nodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return function*() {\n        var { at = editor.selection, mode = \"all\", universal = false, reverse = false, voids = false, pass: _pass } = options;\n        var { match } = options;\n        if (!match) {\n            match = ()=>true;\n        }\n        if (!at) {\n            return;\n        }\n        var from;\n        var to;\n        if (Span.isSpan(at)) {\n            from = at[0];\n            to = at[1];\n        } else {\n            var first = Editor.path(editor, at, {\n                edge: \"start\"\n            });\n            var last = Editor.path(editor, at, {\n                edge: \"end\"\n            });\n            from = reverse ? last : first;\n            to = reverse ? first : last;\n        }\n        var nodeEntries = Node.nodes(editor, {\n            reverse,\n            from,\n            to,\n            pass: (_ref)=>{\n                var [node, path] = _ref;\n                if (_pass && _pass([\n                    node,\n                    path\n                ])) return true;\n                if (!Element.isElement(node)) return false;\n                if (!voids && (Editor.isVoid(editor, node) || Editor.isElementReadOnly(editor, node))) return true;\n                return false;\n            }\n        });\n        var matches = [];\n        var hit;\n        for (var [node, path] of nodeEntries){\n            var isLower = hit && Path.compare(path, hit[1]) === 0;\n            // In highest mode any node lower than the last hit is not a match.\n            if (mode === \"highest\" && isLower) {\n                continue;\n            }\n            if (!match(node, path)) {\n                // If we've arrived at a leaf text node that is not lower than the last\n                // hit, then we've found a branch that doesn't include a match, which\n                // means the match is not universal.\n                if (universal && !isLower && Text.isText(node)) {\n                    return;\n                } else {\n                    continue;\n                }\n            }\n            // If there's a match and it's lower than the last, update the hit.\n            if (mode === \"lowest\" && isLower) {\n                hit = [\n                    node,\n                    path\n                ];\n                continue;\n            }\n            // In lowest mode we emit the last hit, once it's guaranteed lowest.\n            var emit = mode === \"lowest\" ? hit : [\n                node,\n                path\n            ];\n            if (emit) {\n                if (universal) {\n                    matches.push(emit);\n                } else {\n                    yield emit;\n                }\n            }\n            hit = [\n                node,\n                path\n            ];\n        }\n        // Since lowest is always emitting one behind, catch up at the end.\n        if (mode === \"lowest\" && hit) {\n            if (universal) {\n                matches.push(hit);\n            } else {\n                yield hit;\n            }\n        }\n        // Universal defers to ensure that the match occurs in every branch, so we\n        // yield all of the matches after iterating.\n        if (universal) {\n            yield* matches;\n        }\n    }();\n}\nvar normalize = function normalize(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var { force = false, operation } = options;\n    var getDirtyPaths = (editor)=>{\n        return DIRTY_PATHS.get(editor) || [];\n    };\n    var getDirtyPathKeys = (editor)=>{\n        return DIRTY_PATH_KEYS.get(editor) || new Set();\n    };\n    var popDirtyPath = (editor)=>{\n        var path = getDirtyPaths(editor).pop();\n        var key = path.join(\",\");\n        getDirtyPathKeys(editor).delete(key);\n        return path;\n    };\n    if (!Editor.isNormalizing(editor)) {\n        return;\n    }\n    if (force) {\n        var allPaths = Array.from(Node.nodes(editor), (_ref)=>{\n            var [, p] = _ref;\n            return p;\n        });\n        var allPathKeys = new Set(allPaths.map((p)=>p.join(\",\")));\n        DIRTY_PATHS.set(editor, allPaths);\n        DIRTY_PATH_KEYS.set(editor, allPathKeys);\n    }\n    if (getDirtyPaths(editor).length === 0) {\n        return;\n    }\n    Editor.withoutNormalizing(editor, ()=>{\n        /*\n      Fix dirty elements with no children.\n      editor.normalizeNode() does fix this, but some normalization fixes also require it to work.\n      Running an initial pass avoids the catch-22 race condition.\n    */ for (var dirtyPath of getDirtyPaths(editor)){\n            if (Node.has(editor, dirtyPath)) {\n                var entry = Editor.node(editor, dirtyPath);\n                var [node, _] = entry;\n                /*\n          The default normalizer inserts an empty text node in this scenario, but it can be customised.\n          So there is some risk here.\n                   As long as the normalizer only inserts child nodes for this case it is safe to do in any order;\n          by definition adding children to an empty node can't cause other paths to change.\n        */ if (Element.isElement(node) && node.children.length === 0) {\n                    editor.normalizeNode(entry, {\n                        operation\n                    });\n                }\n            }\n        }\n        var dirtyPaths = getDirtyPaths(editor);\n        var initialDirtyPathsLength = dirtyPaths.length;\n        var iteration = 0;\n        while(dirtyPaths.length !== 0){\n            if (!editor.shouldNormalize({\n                dirtyPaths,\n                iteration,\n                initialDirtyPathsLength,\n                operation\n            })) {\n                return;\n            }\n            var _dirtyPath = popDirtyPath(editor);\n            // If the node doesn't exist in the tree, it does not need to be normalized.\n            if (Node.has(editor, _dirtyPath)) {\n                var _entry = Editor.node(editor, _dirtyPath);\n                editor.normalizeNode(_entry, {\n                    operation\n                });\n            }\n            iteration++;\n            dirtyPaths = getDirtyPaths(editor);\n        }\n    });\n};\nvar parent = function parent(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var parentPath = Path.parent(path);\n    var entry = Editor.node(editor, parentPath);\n    return entry;\n};\nvar pathRef = function pathRef(editor, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var { affinity = \"forward\" } = options;\n    var ref = {\n        current: path,\n        affinity,\n        unref () {\n            var { current } = ref;\n            var pathRefs = Editor.pathRefs(editor);\n            pathRefs.delete(ref);\n            ref.current = null;\n            return current;\n        }\n    };\n    var refs = Editor.pathRefs(editor);\n    refs.add(ref);\n    return ref;\n};\nvar pathRefs = (editor)=>{\n    var refs = PATH_REFS.get(editor);\n    if (!refs) {\n        refs = new Set();\n        PATH_REFS.set(editor, refs);\n    }\n    return refs;\n};\nvar path = function path(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var { depth, edge } = options;\n    if (Path.isPath(at)) {\n        if (edge === \"start\") {\n            var [, firstPath] = Node.first(editor, at);\n            at = firstPath;\n        } else if (edge === \"end\") {\n            var [, lastPath] = Node.last(editor, at);\n            at = lastPath;\n        }\n    }\n    if (Range.isRange(at)) {\n        if (edge === \"start\") {\n            at = Range.start(at);\n        } else if (edge === \"end\") {\n            at = Range.end(at);\n        } else {\n            at = Path.common(at.anchor.path, at.focus.path);\n        }\n    }\n    if (Point.isPoint(at)) {\n        at = at.path;\n    }\n    if (depth != null) {\n        at = at.slice(0, depth);\n    }\n    return at;\n};\nvar pointRef = function pointRef(editor, point) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var { affinity = \"forward\" } = options;\n    var ref = {\n        current: point,\n        affinity,\n        unref () {\n            var { current } = ref;\n            var pointRefs = Editor.pointRefs(editor);\n            pointRefs.delete(ref);\n            ref.current = null;\n            return current;\n        }\n    };\n    var refs = Editor.pointRefs(editor);\n    refs.add(ref);\n    return ref;\n};\nvar pointRefs = (editor)=>{\n    var refs = POINT_REFS.get(editor);\n    if (!refs) {\n        refs = new Set();\n        POINT_REFS.set(editor, refs);\n    }\n    return refs;\n};\nvar point = function point(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var { edge = \"start\" } = options;\n    if (Path.isPath(at)) {\n        var path;\n        if (edge === \"end\") {\n            var [, lastPath] = Node.last(editor, at);\n            path = lastPath;\n        } else {\n            var [, firstPath] = Node.first(editor, at);\n            path = firstPath;\n        }\n        var node = Node.get(editor, path);\n        if (!Text.isText(node)) {\n            throw new Error(\"Cannot get the \".concat(edge, \" point in the node at path [\").concat(at, \"] because it has no \").concat(edge, \" text node.\"));\n        }\n        return {\n            path,\n            offset: edge === \"end\" ? node.text.length : 0\n        };\n    }\n    if (Range.isRange(at)) {\n        var [start, end] = Range.edges(at);\n        return edge === \"start\" ? start : end;\n    }\n    return at;\n};\nfunction positions(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return function*() {\n        var { at = editor.selection, unit = \"offset\", reverse = false, voids = false } = options;\n        if (!at) {\n            return;\n        }\n        /**\n     * Algorithm notes:\n     *\n     * Each step `distance` is dynamic depending on the underlying text\n     * and the `unit` specified.  Each step, e.g., a line or word, may\n     * span multiple text nodes, so we iterate through the text both on\n     * two levels in step-sync:\n     *\n     * `leafText` stores the text on a text leaf level, and is advanced\n     * through using the counters `leafTextOffset` and `leafTextRemaining`.\n     *\n     * `blockText` stores the text on a block level, and is shortened\n     * by `distance` every time it is advanced.\n     *\n     * We only maintain a window of one blockText and one leafText because\n     * a block node always appears before all of its leaf nodes.\n     */ var range = Editor.range(editor, at);\n        var [start, end] = Range.edges(range);\n        var first = reverse ? end : start;\n        var isNewBlock = false;\n        var blockText = \"\";\n        var distance = 0; // Distance for leafText to catch up to blockText.\n        var leafTextRemaining = 0;\n        var leafTextOffset = 0;\n        // Iterate through all nodes in range, grabbing entire textual content\n        // of block nodes in blockText, and text nodes in leafText.\n        // Exploits the fact that nodes are sequenced in such a way that we first\n        // encounter the block node, then all of its text nodes, so when iterating\n        // through the blockText and leafText we just need to remember a window of\n        // one block node and leaf node, respectively.\n        for (var [node, path] of Editor.nodes(editor, {\n            at,\n            reverse,\n            voids\n        })){\n            /*\n       * ELEMENT NODE - Yield position(s) for voids, collect blockText for blocks\n       */ if (Element.isElement(node)) {\n                if (!editor.isSelectable(node)) {\n                    /**\n           * If the node is not selectable, skip it\n           */ if (reverse) {\n                        yield Editor.end(editor, Path.previous(path));\n                        continue;\n                    } else {\n                        yield Editor.start(editor, Path.next(path));\n                        continue;\n                    }\n                }\n                // Void nodes are a special case, so by default we will always\n                // yield their first point. If the `voids` option is set to true,\n                // then we will iterate over their content.\n                if (!voids && (editor.isVoid(node) || editor.isElementReadOnly(node))) {\n                    yield Editor.start(editor, path);\n                    continue;\n                }\n                // Inline element nodes are ignored as they don't themselves\n                // contribute to `blockText` or `leafText` - their parent and\n                // children do.\n                if (editor.isInline(node)) continue;\n                // Block element node - set `blockText` to its text content.\n                if (Editor.hasInlines(editor, node)) {\n                    // We always exhaust block nodes before encountering a new one:\n                    //   console.assert(blockText === '',\n                    //     `blockText='${blockText}' - `+\n                    //     `not exhausted before new block node`, path)\n                    // Ensure range considered is capped to `range`, in the\n                    // start/end edge cases where block extends beyond range.\n                    // Equivalent to this, but presumably more performant:\n                    //   blockRange = Editor.range(editor, ...Editor.edges(editor, path))\n                    //   blockRange = Range.intersection(range, blockRange) // intersect\n                    //   blockText = Editor.string(editor, blockRange, { voids })\n                    var e = Path.isAncestor(path, end.path) ? end : Editor.end(editor, path);\n                    var s = Path.isAncestor(path, start.path) ? start : Editor.start(editor, path);\n                    blockText = Editor.string(editor, {\n                        anchor: s,\n                        focus: e\n                    }, {\n                        voids\n                    });\n                    isNewBlock = true;\n                }\n            }\n            /*\n       * TEXT LEAF NODE - Iterate through text content, yielding\n       * positions every `distance` offset according to `unit`.\n       */ if (Text.isText(node)) {\n                var isFirst = Path.equals(path, first.path);\n                // Proof that we always exhaust text nodes before encountering a new one:\n                //   console.assert(leafTextRemaining <= 0,\n                //     `leafTextRemaining=${leafTextRemaining} - `+\n                //     `not exhausted before new leaf text node`, path)\n                // Reset `leafText` counters for new text node.\n                if (isFirst) {\n                    leafTextRemaining = reverse ? first.offset : node.text.length - first.offset;\n                    leafTextOffset = first.offset; // Works for reverse too.\n                } else {\n                    leafTextRemaining = node.text.length;\n                    leafTextOffset = reverse ? leafTextRemaining : 0;\n                }\n                // Yield position at the start of node (potentially).\n                if (isFirst || isNewBlock || unit === \"offset\") {\n                    yield {\n                        path,\n                        offset: leafTextOffset\n                    };\n                    isNewBlock = false;\n                }\n                // Yield positions every (dynamically calculated) `distance` offset.\n                while(true){\n                    // If `leafText` has caught up with `blockText` (distance=0),\n                    // and if blockText is exhausted, break to get another block node,\n                    // otherwise advance blockText forward by the new `distance`.\n                    if (distance === 0) {\n                        if (blockText === \"\") break;\n                        distance = calcDistance(blockText, unit, reverse);\n                        // Split the string at the previously found distance and use the\n                        // remaining string for the next iteration.\n                        blockText = splitByCharacterDistance(blockText, distance, reverse)[1];\n                    }\n                    // Advance `leafText` by the current `distance`.\n                    leafTextOffset = reverse ? leafTextOffset - distance : leafTextOffset + distance;\n                    leafTextRemaining = leafTextRemaining - distance;\n                    // If `leafText` is exhausted, break to get a new leaf node\n                    // and set distance to the overflow amount, so we'll (maybe)\n                    // catch up to blockText in the next leaf text node.\n                    if (leafTextRemaining < 0) {\n                        distance = -leafTextRemaining;\n                        break;\n                    }\n                    // Successfully walked `distance` offsets through `leafText`\n                    // to catch up with `blockText`, so we can reset `distance`\n                    // and yield this position in this node.\n                    distance = 0;\n                    yield {\n                        path,\n                        offset: leafTextOffset\n                    };\n                }\n            }\n        }\n        // Proof that upon completion, we've exahusted both leaf and block text:\n        //   console.assert(leafTextRemaining <= 0, \"leafText wasn't exhausted\")\n        //   console.assert(blockText === '', \"blockText wasn't exhausted\")\n        // Helper:\n        // Return the distance in offsets for a step of size `unit` on given string.\n        function calcDistance(text, unit, reverse) {\n            if (unit === \"character\") {\n                return getCharacterDistance(text, reverse);\n            } else if (unit === \"word\") {\n                return getWordDistance(text, reverse);\n            } else if (unit === \"line\" || unit === \"block\") {\n                return text.length;\n            }\n            return 1;\n        }\n    }();\n}\nvar previous = function previous(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var { mode = \"lowest\", voids = false } = options;\n    var { match, at = editor.selection } = options;\n    if (!at) {\n        return;\n    }\n    var pointBeforeLocation = Editor.before(editor, at, {\n        voids\n    });\n    if (!pointBeforeLocation) {\n        return;\n    }\n    var [, to] = Editor.first(editor, []);\n    // The search location is from the start of the document to the path of\n    // the point before the location passed in\n    var span = [\n        pointBeforeLocation.path,\n        to\n    ];\n    if (Path.isPath(at) && at.length === 0) {\n        throw new Error(\"Cannot get the previous node from the root node!\");\n    }\n    if (match == null) {\n        if (Path.isPath(at)) {\n            var [parent] = Editor.parent(editor, at);\n            match = (n)=>parent.children.includes(n);\n        } else {\n            match = ()=>true;\n        }\n    }\n    var [previous] = Editor.nodes(editor, {\n        reverse: true,\n        at: span,\n        match,\n        mode,\n        voids\n    });\n    return previous;\n};\nvar rangeRef = function rangeRef(editor, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var { affinity = \"forward\" } = options;\n    var ref = {\n        current: range,\n        affinity,\n        unref () {\n            var { current } = ref;\n            var rangeRefs = Editor.rangeRefs(editor);\n            rangeRefs.delete(ref);\n            ref.current = null;\n            return current;\n        }\n    };\n    var refs = Editor.rangeRefs(editor);\n    refs.add(ref);\n    return ref;\n};\nvar rangeRefs = (editor)=>{\n    var refs = RANGE_REFS.get(editor);\n    if (!refs) {\n        refs = new Set();\n        RANGE_REFS.set(editor, refs);\n    }\n    return refs;\n};\nvar range = (editor, at, to)=>{\n    if (Range.isRange(at) && !to) {\n        return at;\n    }\n    var start = Editor.start(editor, at);\n    var end = Editor.end(editor, to || at);\n    return {\n        anchor: start,\n        focus: end\n    };\n};\nfunction ownKeys$2(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread$2(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys$2(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nvar removeMark = (editor, key)=>{\n    var { selection } = editor;\n    if (selection) {\n        var match = (node, path)=>{\n            if (!Text.isText(node)) {\n                return false; // marks can only be applied to text\n            }\n            var [parentNode, parentPath] = Editor.parent(editor, path);\n            return !editor.isVoid(parentNode) || editor.markableVoid(parentNode);\n        };\n        var expandedSelection = Range.isExpanded(selection);\n        var markAcceptingVoidSelected = false;\n        if (!expandedSelection) {\n            var [selectedNode, selectedPath] = Editor.node(editor, selection);\n            if (selectedNode && match(selectedNode, selectedPath)) {\n                var [parentNode] = Editor.parent(editor, selectedPath);\n                markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);\n            }\n        }\n        if (expandedSelection || markAcceptingVoidSelected) {\n            Transforms.unsetNodes(editor, key, {\n                match,\n                split: true,\n                voids: true\n            });\n        } else {\n            var marks = _objectSpread$2({}, Editor.marks(editor) || {});\n            delete marks[key];\n            editor.marks = marks;\n            if (!FLUSHING.get(editor)) {\n                editor.onChange();\n            }\n        }\n    }\n};\nvar setNormalizing = (editor, isNormalizing)=>{\n    NORMALIZING.set(editor, isNormalizing);\n};\nvar start = (editor, at)=>{\n    return Editor.point(editor, at, {\n        edge: \"start\"\n    });\n};\nvar string = function string(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var { voids = false } = options;\n    var range = Editor.range(editor, at);\n    var [start, end] = Range.edges(range);\n    var text = \"\";\n    for (var [node, path] of Editor.nodes(editor, {\n        at: range,\n        match: Text.isText,\n        voids\n    })){\n        var t = node.text;\n        if (Path.equals(path, end.path)) {\n            t = t.slice(0, end.offset);\n        }\n        if (Path.equals(path, start.path)) {\n            t = t.slice(start.offset);\n        }\n        text += t;\n    }\n    return text;\n};\nvar unhangRange = function unhangRange(editor, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var { voids = false } = options;\n    var [start, end] = Range.edges(range);\n    // PERF: exit early if we can guarantee that the range isn't hanging.\n    if (start.offset !== 0 || end.offset !== 0 || Range.isCollapsed(range) || Path.hasPrevious(end.path)) {\n        return range;\n    }\n    var endBlock = Editor.above(editor, {\n        at: end,\n        match: (n)=>Element.isElement(n) && Editor.isBlock(editor, n),\n        voids\n    });\n    var blockPath = endBlock ? endBlock[1] : [];\n    var first = Editor.start(editor, start);\n    var before = {\n        anchor: first,\n        focus: end\n    };\n    var skip = true;\n    for (var [node, path] of Editor.nodes(editor, {\n        at: before,\n        match: Text.isText,\n        reverse: true,\n        voids\n    })){\n        if (skip) {\n            skip = false;\n            continue;\n        }\n        if (node.text !== \"\" || Path.isBefore(path, blockPath)) {\n            end = {\n                path,\n                offset: node.text.length\n            };\n            break;\n        }\n    }\n    return {\n        anchor: start,\n        focus: end\n    };\n};\nvar withoutNormalizing = (editor, fn)=>{\n    var value = Editor.isNormalizing(editor);\n    Editor.setNormalizing(editor, false);\n    try {\n        fn();\n    } finally{\n        Editor.setNormalizing(editor, value);\n    }\n    Editor.normalize(editor);\n};\nvar shouldMergeNodesRemovePrevNode = (editor, _ref, _ref2)=>{\n    var [prevNode, prevPath] = _ref;\n    // If the target node that we're merging with is empty, remove it instead\n    // of merging the two. This is a common rich text editor behavior to\n    // prevent losing formatting when deleting entire nodes when you have a\n    // hanging selection.\n    // if prevNode is first child in parent,don't remove it.\n    return Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode) || Text.isText(prevNode) && prevNode.text === \"\" && prevPath[prevPath.length - 1] !== 0;\n};\nvar deleteText = function deleteText(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, ()=>{\n        var _Editor$void, _Editor$void2;\n        var { reverse = false, unit = \"character\", distance = 1, voids = false } = options;\n        var { at = editor.selection, hanging = false } = options;\n        if (!at) {\n            return;\n        }\n        var isCollapsed = false;\n        if (Range.isRange(at) && Range.isCollapsed(at)) {\n            isCollapsed = true;\n            at = at.anchor;\n        }\n        if (Point.isPoint(at)) {\n            var furthestVoid = Editor.void(editor, {\n                at,\n                mode: \"highest\"\n            });\n            if (!voids && furthestVoid) {\n                var [, voidPath] = furthestVoid;\n                at = voidPath;\n            } else {\n                var opts = {\n                    unit,\n                    distance\n                };\n                var target = reverse ? Editor.before(editor, at, opts) || Editor.start(editor, []) : Editor.after(editor, at, opts) || Editor.end(editor, []);\n                at = {\n                    anchor: at,\n                    focus: target\n                };\n                hanging = true;\n            }\n        }\n        if (Path.isPath(at)) {\n            Transforms.removeNodes(editor, {\n                at,\n                voids\n            });\n            return;\n        }\n        if (Range.isCollapsed(at)) {\n            return;\n        }\n        if (!hanging) {\n            var [, _end] = Range.edges(at);\n            var endOfDoc = Editor.end(editor, []);\n            if (!Point.equals(_end, endOfDoc)) {\n                at = Editor.unhangRange(editor, at, {\n                    voids\n                });\n            }\n        }\n        var [start, end] = Range.edges(at);\n        var startBlock = Editor.above(editor, {\n            match: (n)=>Element.isElement(n) && Editor.isBlock(editor, n),\n            at: start,\n            voids\n        });\n        var endBlock = Editor.above(editor, {\n            match: (n)=>Element.isElement(n) && Editor.isBlock(editor, n),\n            at: end,\n            voids\n        });\n        var isAcrossBlocks = startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);\n        var isSingleText = Path.equals(start.path, end.path);\n        var startNonEditable = voids ? null : (_Editor$void = Editor.void(editor, {\n            at: start,\n            mode: \"highest\"\n        })) !== null && _Editor$void !== void 0 ? _Editor$void : Editor.elementReadOnly(editor, {\n            at: start,\n            mode: \"highest\"\n        });\n        var endNonEditable = voids ? null : (_Editor$void2 = Editor.void(editor, {\n            at: end,\n            mode: \"highest\"\n        })) !== null && _Editor$void2 !== void 0 ? _Editor$void2 : Editor.elementReadOnly(editor, {\n            at: end,\n            mode: \"highest\"\n        });\n        // If the start or end points are inside an inline void, nudge them out.\n        if (startNonEditable) {\n            var before = Editor.before(editor, start);\n            if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {\n                start = before;\n            }\n        }\n        if (endNonEditable) {\n            var after = Editor.after(editor, end);\n            if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n                end = after;\n            }\n        }\n        // Get the highest nodes that are completely inside the range, as well as\n        // the start and end nodes.\n        var matches = [];\n        var lastPath;\n        for (var entry of Editor.nodes(editor, {\n            at,\n            voids\n        })){\n            var [node, path] = entry;\n            if (lastPath && Path.compare(path, lastPath) === 0) {\n                continue;\n            }\n            if (!voids && Element.isElement(node) && (Editor.isVoid(editor, node) || Editor.isElementReadOnly(editor, node)) || !Path.isCommon(path, start.path) && !Path.isCommon(path, end.path)) {\n                matches.push(entry);\n                lastPath = path;\n            }\n        }\n        var pathRefs = Array.from(matches, (_ref)=>{\n            var [, p] = _ref;\n            return Editor.pathRef(editor, p);\n        });\n        var startRef = Editor.pointRef(editor, start);\n        var endRef = Editor.pointRef(editor, end);\n        var removedText = \"\";\n        if (!isSingleText && !startNonEditable) {\n            var _point = startRef.current;\n            var [_node] = Editor.leaf(editor, _point);\n            var { path: _path } = _point;\n            var { offset } = start;\n            var text = _node.text.slice(offset);\n            if (text.length > 0) {\n                editor.apply({\n                    type: \"remove_text\",\n                    path: _path,\n                    offset,\n                    text\n                });\n                removedText = text;\n            }\n        }\n        pathRefs.reverse().map((r)=>r.unref()).filter((r)=>r !== null).forEach((p)=>Transforms.removeNodes(editor, {\n                at: p,\n                voids\n            }));\n        if (!endNonEditable) {\n            var _point2 = endRef.current;\n            var [_node2] = Editor.leaf(editor, _point2);\n            var { path: _path2 } = _point2;\n            var _offset = isSingleText ? start.offset : 0;\n            var _text = _node2.text.slice(_offset, end.offset);\n            if (_text.length > 0) {\n                editor.apply({\n                    type: \"remove_text\",\n                    path: _path2,\n                    offset: _offset,\n                    text: _text\n                });\n                removedText = _text;\n            }\n        }\n        if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {\n            Transforms.mergeNodes(editor, {\n                at: endRef.current,\n                hanging: true,\n                voids\n            });\n        }\n        // For certain scripts, deleting N character(s) backward should delete\n        // N code point(s) instead of an entire grapheme cluster.\n        // Therefore, the remaining code points should be inserted back.\n        // Bengali: \\u0980-\\u09FF\n        // Thai: \\u0E00-\\u0E7F\n        // Burmese (Myanmar): \\u1000-\\u109F\n        // Hindi (Devanagari): \\u0900-\\u097F\n        // Khmer: \\u1780-\\u17FF\n        // Malayalam: \\u0D00-\\u0D7F\n        // Oriya: \\u0B00-\\u0B7F\n        // Punjabi (Gurmukhi): \\u0A00-\\u0A7F\n        // Tamil: \\u0B80-\\u0BFF\n        // Telugu: \\u0C00-\\u0C7F\n        if (isCollapsed && reverse && unit === \"character\" && removedText.length > 1 && removedText.match(/[\\u0980-\\u09FF\\u0E00-\\u0E7F\\u1000-\\u109F\\u0900-\\u097F\\u1780-\\u17FF\\u0D00-\\u0D7F\\u0B00-\\u0B7F\\u0A00-\\u0A7F\\u0B80-\\u0BFF\\u0C00-\\u0C7F]+/)) {\n            Transforms.insertText(editor, removedText.slice(0, removedText.length - distance));\n        }\n        var startUnref = startRef.unref();\n        var endUnref = endRef.unref();\n        var point = reverse ? startUnref || endUnref : endUnref || startUnref;\n        if (options.at == null && point) {\n            Transforms.select(editor, point);\n        }\n    });\n};\nvar insertFragment = function insertFragment(editor, fragment) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, ()=>{\n        var { hanging = false, voids = false } = options;\n        var { at = getDefaultInsertLocation(editor), batchDirty = true } = options;\n        if (!fragment.length) {\n            return;\n        }\n        if (Range.isRange(at)) {\n            if (!hanging) {\n                at = Editor.unhangRange(editor, at, {\n                    voids\n                });\n            }\n            if (Range.isCollapsed(at)) {\n                at = at.anchor;\n            } else {\n                var [, end] = Range.edges(at);\n                if (!voids && Editor.void(editor, {\n                    at: end\n                })) {\n                    return;\n                }\n                var pointRef = Editor.pointRef(editor, end);\n                Transforms.delete(editor, {\n                    at\n                });\n                at = pointRef.unref();\n            }\n        } else if (Path.isPath(at)) {\n            at = Editor.start(editor, at);\n        }\n        if (!voids && Editor.void(editor, {\n            at\n        })) {\n            return;\n        }\n        // If the insert point is at the edge of an inline node, move it outside\n        // instead since it will need to be split otherwise.\n        var inlineElementMatch = Editor.above(editor, {\n            at,\n            match: (n)=>Element.isElement(n) && Editor.isInline(editor, n),\n            mode: \"highest\",\n            voids\n        });\n        if (inlineElementMatch) {\n            var [, _inlinePath] = inlineElementMatch;\n            if (Editor.isEnd(editor, at, _inlinePath)) {\n                var after = Editor.after(editor, _inlinePath);\n                at = after;\n            } else if (Editor.isStart(editor, at, _inlinePath)) {\n                var before = Editor.before(editor, _inlinePath);\n                at = before;\n            }\n        }\n        var blockMatch = Editor.above(editor, {\n            match: (n)=>Element.isElement(n) && Editor.isBlock(editor, n),\n            at,\n            voids\n        });\n        var [, blockPath] = blockMatch;\n        var isBlockStart = Editor.isStart(editor, at, blockPath);\n        var isBlockEnd = Editor.isEnd(editor, at, blockPath);\n        var isBlockEmpty = isBlockStart && isBlockEnd;\n        var [, firstLeafPath] = Node.first({\n            children: fragment\n        }, []);\n        var [, lastLeafPath] = Node.last({\n            children: fragment\n        }, []);\n        // For each node in the fragment, determine what level of wrapping should\n        // be kept. At minimum, all text nodes will be inserted, but if\n        // `shouldInsert` returns true for some ancestor of a particular text node,\n        // then the entire ancestor will be inserted rather than inserting the text\n        // nodes individually.\n        var shouldInsert = (_ref)=>{\n            var [n, p] = _ref;\n            var isRoot = p.length === 0;\n            if (isRoot) {\n                return false;\n            }\n            // If the destination block is empty, insert all top-level blocks of the\n            // fragment.\n            if (isBlockEmpty) {\n                return true;\n            }\n            // Unless we're at the start of the destination block, unwrap any\n            // non-void blocks that contain the first leaf node in the fragment.\n            if (!isBlockStart && Path.isAncestor(p, firstLeafPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n                return false;\n            }\n            // Unless we're at the end of the destination block, unwrap any non-void\n            // blocks that contain the last leaf node in the fragment.\n            if (!isBlockEnd && Path.isAncestor(p, lastLeafPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n                return false;\n            }\n            // Always insert void nodes, inline elements and text nodes.\n            return true;\n        };\n        // Whether the current node is in the first block of the fragment.\n        var starting = true;\n        // Inline nodes in the first block of the fragment, to be merged with the\n        // destination block.\n        var starts = [];\n        // Blocks in the middle of the fragment.\n        var middles = [];\n        // Inline nodes in the last block of the fragment, to be merged with the\n        // destination block. If the fragment contains only one block, this will be\n        // empty.\n        var ends = [];\n        for (var entry of Node.nodes({\n            children: fragment\n        }, {\n            pass: shouldInsert\n        })){\n            var [node, path] = entry;\n            // If we encounter a block that does not contain the first leaf, we're no\n            // longer in the first block of the fragment.\n            if (starting && Element.isElement(node) && !editor.isInline(node) && !Path.isAncestor(path, firstLeafPath)) {\n                starting = false;\n            }\n            if (shouldInsert(entry)) {\n                if (Element.isElement(node) && !editor.isInline(node)) {\n                    starting = false;\n                    middles.push(node);\n                } else if (starting) {\n                    starts.push(node);\n                } else {\n                    ends.push(node);\n                }\n            }\n        }\n        var [inlineMatch] = Editor.nodes(editor, {\n            at,\n            match: (n)=>Text.isText(n) || Editor.isInline(editor, n),\n            mode: \"highest\",\n            voids\n        });\n        var [, inlinePath] = inlineMatch;\n        var isInlineStart = Editor.isStart(editor, at, inlinePath);\n        var isInlineEnd = Editor.isEnd(editor, at, inlinePath);\n        var middleRef = Editor.pathRef(editor, isBlockEnd && !ends.length ? Path.next(blockPath) : blockPath);\n        var endRef = Editor.pathRef(editor, isInlineEnd ? Path.next(inlinePath) : inlinePath);\n        // If the fragment contains inlines in multiple distinct blocks, split the\n        // destination block.\n        var splitBlock = ends.length > 0;\n        Transforms.splitNodes(editor, {\n            at,\n            match: (n)=>splitBlock ? Element.isElement(n) && Editor.isBlock(editor, n) : Text.isText(n) || Editor.isInline(editor, n),\n            mode: splitBlock ? \"lowest\" : \"highest\",\n            always: splitBlock && (!isBlockStart || starts.length > 0) && (!isBlockEnd || ends.length > 0),\n            voids\n        });\n        var startRef = Editor.pathRef(editor, !isInlineStart || isInlineStart && isInlineEnd ? Path.next(inlinePath) : inlinePath);\n        Transforms.insertNodes(editor, starts, {\n            at: startRef.current,\n            match: (n)=>Text.isText(n) || Editor.isInline(editor, n),\n            mode: \"highest\",\n            voids,\n            batchDirty\n        });\n        if (isBlockEmpty && !starts.length && middles.length && !ends.length) {\n            Transforms.delete(editor, {\n                at: blockPath,\n                voids\n            });\n        }\n        Transforms.insertNodes(editor, middles, {\n            at: middleRef.current,\n            match: (n)=>Element.isElement(n) && Editor.isBlock(editor, n),\n            mode: \"lowest\",\n            voids,\n            batchDirty\n        });\n        Transforms.insertNodes(editor, ends, {\n            at: endRef.current,\n            match: (n)=>Text.isText(n) || Editor.isInline(editor, n),\n            mode: \"highest\",\n            voids,\n            batchDirty\n        });\n        if (!options.at) {\n            var _path;\n            if (ends.length > 0 && endRef.current) {\n                _path = Path.previous(endRef.current);\n            } else if (middles.length > 0 && middleRef.current) {\n                _path = Path.previous(middleRef.current);\n            } else if (startRef.current) {\n                _path = Path.previous(startRef.current);\n            }\n            if (_path) {\n                var _end = Editor.end(editor, _path);\n                Transforms.select(editor, _end);\n            }\n        }\n        startRef.unref();\n        middleRef.unref();\n        endRef.unref();\n    });\n};\nvar collapse = function collapse(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var { edge = \"anchor\" } = options;\n    var { selection } = editor;\n    if (!selection) {\n        return;\n    } else if (edge === \"anchor\") {\n        Transforms.select(editor, selection.anchor);\n    } else if (edge === \"focus\") {\n        Transforms.select(editor, selection.focus);\n    } else if (edge === \"start\") {\n        var [start] = Range.edges(selection);\n        Transforms.select(editor, start);\n    } else if (edge === \"end\") {\n        var [, end] = Range.edges(selection);\n        Transforms.select(editor, end);\n    }\n};\nvar deselect = (editor)=>{\n    var { selection } = editor;\n    if (selection) {\n        editor.apply({\n            type: \"set_selection\",\n            properties: selection,\n            newProperties: null\n        });\n    }\n};\nvar move = function move(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var { selection } = editor;\n    var { distance = 1, unit = \"character\", reverse = false } = options;\n    var { edge = null } = options;\n    if (!selection) {\n        return;\n    }\n    if (edge === \"start\") {\n        edge = Range.isBackward(selection) ? \"focus\" : \"anchor\";\n    }\n    if (edge === \"end\") {\n        edge = Range.isBackward(selection) ? \"anchor\" : \"focus\";\n    }\n    var { anchor, focus } = selection;\n    var opts = {\n        distance,\n        unit\n    };\n    var props = {};\n    if (edge == null || edge === \"anchor\") {\n        var point = reverse ? Editor.before(editor, anchor, opts) : Editor.after(editor, anchor, opts);\n        if (point) {\n            props.anchor = point;\n        }\n    }\n    if (edge == null || edge === \"focus\") {\n        var _point = reverse ? Editor.before(editor, focus, opts) : Editor.after(editor, focus, opts);\n        if (_point) {\n            props.focus = _point;\n        }\n    }\n    Transforms.setSelection(editor, props);\n};\nvar select = (editor, target)=>{\n    var { selection } = editor;\n    target = Editor.range(editor, target);\n    if (selection) {\n        Transforms.setSelection(editor, target);\n        return;\n    }\n    if (!Range.isRange(target)) {\n        throw new Error(\"When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: \".concat(Scrubber.stringify(target)));\n    }\n    editor.apply({\n        type: \"set_selection\",\n        properties: selection,\n        newProperties: target\n    });\n};\nfunction ownKeys$1(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread$1(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys$1(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nvar setPoint = function setPoint(editor, props) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var { selection } = editor;\n    var { edge = \"both\" } = options;\n    if (!selection) {\n        return;\n    }\n    if (edge === \"start\") {\n        edge = Range.isBackward(selection) ? \"focus\" : \"anchor\";\n    }\n    if (edge === \"end\") {\n        edge = Range.isBackward(selection) ? \"anchor\" : \"focus\";\n    }\n    var { anchor, focus } = selection;\n    var point = edge === \"anchor\" ? anchor : focus;\n    Transforms.setSelection(editor, {\n        [edge === \"anchor\" ? \"anchor\" : \"focus\"]: _objectSpread$1(_objectSpread$1({}, point), props)\n    });\n};\nvar setSelection = (editor, props)=>{\n    var { selection } = editor;\n    var oldProps = {};\n    var newProps = {};\n    if (!selection) {\n        return;\n    }\n    for(var k in props){\n        if (k === \"anchor\" && props.anchor != null && !Point.equals(props.anchor, selection.anchor) || k === \"focus\" && props.focus != null && !Point.equals(props.focus, selection.focus) || k !== \"anchor\" && k !== \"focus\" && props[k] !== selection[k]) {\n            oldProps[k] = selection[k];\n            newProps[k] = props[k];\n        }\n    }\n    if (Object.keys(oldProps).length > 0) {\n        editor.apply({\n            type: \"set_selection\",\n            properties: oldProps,\n            newProperties: newProps\n        });\n    }\n};\nvar insertNodes = function insertNodes(editor, nodes) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, ()=>{\n        var { hanging = false, voids = false, mode = \"lowest\", batchDirty = true } = options;\n        var { at, match, select } = options;\n        if (Node.isNode(nodes)) {\n            nodes = [\n                nodes\n            ];\n        }\n        if (nodes.length === 0) {\n            return;\n        }\n        var [node] = nodes;\n        if (!at) {\n            at = getDefaultInsertLocation(editor);\n            if (select !== false) {\n                select = true;\n            }\n        }\n        if (select == null) {\n            select = false;\n        }\n        if (Range.isRange(at)) {\n            if (!hanging) {\n                at = Editor.unhangRange(editor, at, {\n                    voids\n                });\n            }\n            if (Range.isCollapsed(at)) {\n                at = at.anchor;\n            } else {\n                var [, end] = Range.edges(at);\n                var pointRef = Editor.pointRef(editor, end);\n                Transforms.delete(editor, {\n                    at\n                });\n                at = pointRef.unref();\n            }\n        }\n        if (Point.isPoint(at)) {\n            if (match == null) {\n                if (Text.isText(node)) {\n                    match = (n)=>Text.isText(n);\n                } else if (editor.isInline(node)) {\n                    match = (n)=>Text.isText(n) || Editor.isInline(editor, n);\n                } else {\n                    match = (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n                }\n            }\n            var [entry] = Editor.nodes(editor, {\n                at: at.path,\n                match,\n                mode,\n                voids\n            });\n            if (entry) {\n                var [, matchPath] = entry;\n                var pathRef = Editor.pathRef(editor, matchPath);\n                var isAtEnd = Editor.isEnd(editor, at, matchPath);\n                Transforms.splitNodes(editor, {\n                    at,\n                    match,\n                    mode,\n                    voids\n                });\n                var path = pathRef.unref();\n                at = isAtEnd ? Path.next(path) : path;\n            } else {\n                return;\n            }\n        }\n        var parentPath = Path.parent(at);\n        var index = at[at.length - 1];\n        if (!voids && Editor.void(editor, {\n            at: parentPath\n        })) {\n            return;\n        }\n        if (batchDirty) {\n            // PERF: batch update dirty paths\n            // batched ops used to transform existing dirty paths\n            var batchedOps = [];\n            var newDirtyPaths = Path.levels(parentPath);\n            batchDirtyPaths(editor, ()=>{\n                var _loop = function _loop() {\n                    var path = parentPath.concat(index);\n                    index++;\n                    var op = {\n                        type: \"insert_node\",\n                        path,\n                        node: _node\n                    };\n                    editor.apply(op);\n                    at = Path.next(at);\n                    batchedOps.push(op);\n                    if (Text.isText(_node)) {\n                        newDirtyPaths.push(path);\n                    } else {\n                        newDirtyPaths.push(...Array.from(Node.nodes(_node), (_ref)=>{\n                            var [, p] = _ref;\n                            return path.concat(p);\n                        }));\n                    }\n                };\n                for (var _node of nodes){\n                    _loop();\n                }\n            }, ()=>{\n                updateDirtyPaths(editor, newDirtyPaths, (p)=>{\n                    var newPath = p;\n                    for (var op of batchedOps){\n                        if (Path.operationCanTransformPath(op)) {\n                            newPath = Path.transform(newPath, op);\n                            if (!newPath) {\n                                return null;\n                            }\n                        }\n                    }\n                    return newPath;\n                });\n            });\n        } else {\n            for (var _node2 of nodes){\n                var _path = parentPath.concat(index);\n                index++;\n                editor.apply({\n                    type: \"insert_node\",\n                    path: _path,\n                    node: _node2\n                });\n                at = Path.next(at);\n            }\n        }\n        at = Path.previous(at);\n        if (select) {\n            var point = Editor.end(editor, at);\n            if (point) {\n                Transforms.select(editor, point);\n            }\n        }\n    });\n};\nvar liftNodes = function liftNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, ()=>{\n        var { at = editor.selection, mode = \"lowest\", voids = false } = options;\n        var { match } = options;\n        if (match == null) {\n            match = Path.isPath(at) ? matchPath(editor, at) : (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n        }\n        if (!at) {\n            return;\n        }\n        var matches = Editor.nodes(editor, {\n            at,\n            match,\n            mode,\n            voids\n        });\n        var pathRefs = Array.from(matches, (_ref)=>{\n            var [, p] = _ref;\n            return Editor.pathRef(editor, p);\n        });\n        for (var pathRef of pathRefs){\n            var path = pathRef.unref();\n            if (path.length < 2) {\n                throw new Error(\"Cannot lift node at a path [\".concat(path, \"] because it has a depth of less than `2`.\"));\n            }\n            var parentNodeEntry = Editor.node(editor, Path.parent(path));\n            var [parent, parentPath] = parentNodeEntry;\n            var index = path[path.length - 1];\n            var { length } = parent.children;\n            if (length === 1) {\n                var toPath = Path.next(parentPath);\n                Transforms.moveNodes(editor, {\n                    at: path,\n                    to: toPath,\n                    voids\n                });\n                Transforms.removeNodes(editor, {\n                    at: parentPath,\n                    voids\n                });\n            } else if (index === 0) {\n                Transforms.moveNodes(editor, {\n                    at: path,\n                    to: parentPath,\n                    voids\n                });\n            } else if (index === length - 1) {\n                var _toPath = Path.next(parentPath);\n                Transforms.moveNodes(editor, {\n                    at: path,\n                    to: _toPath,\n                    voids\n                });\n            } else {\n                var splitPath = Path.next(path);\n                var _toPath2 = Path.next(parentPath);\n                Transforms.splitNodes(editor, {\n                    at: splitPath,\n                    voids\n                });\n                Transforms.moveNodes(editor, {\n                    at: path,\n                    to: _toPath2,\n                    voids\n                });\n            }\n        }\n    });\n};\nvar _excluded = [\n    \"text\"\n], _excluded2 = [\n    \"children\"\n];\nvar hasSingleChildNest = (editor, node)=>{\n    if (Element.isElement(node)) {\n        var element = node;\n        if (Editor.isVoid(editor, node)) {\n            return true;\n        } else if (element.children.length === 1) {\n            return hasSingleChildNest(editor, element.children[0]);\n        } else {\n            return false;\n        }\n    } else if (Editor.isEditor(node)) {\n        return false;\n    } else {\n        return true;\n    }\n};\nvar mergeNodes = function mergeNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, ()=>{\n        var { match, at = editor.selection } = options;\n        var { hanging = false, voids = false, mode = \"lowest\" } = options;\n        if (!at) {\n            return;\n        }\n        if (match == null) {\n            if (Path.isPath(at)) {\n                var [parent] = Editor.parent(editor, at);\n                match = (n)=>parent.children.includes(n);\n            } else {\n                match = (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n            }\n        }\n        if (!hanging && Range.isRange(at)) {\n            at = Editor.unhangRange(editor, at, {\n                voids\n            });\n        }\n        if (Range.isRange(at)) {\n            if (Range.isCollapsed(at)) {\n                at = at.anchor;\n            } else {\n                var [, end] = Range.edges(at);\n                var pointRef = Editor.pointRef(editor, end);\n                Transforms.delete(editor, {\n                    at\n                });\n                at = pointRef.unref();\n                if (options.at == null) {\n                    Transforms.select(editor, at);\n                }\n            }\n        }\n        var [current] = Editor.nodes(editor, {\n            at,\n            match,\n            voids,\n            mode\n        });\n        var prev = Editor.previous(editor, {\n            at,\n            match,\n            voids,\n            mode\n        });\n        if (!current || !prev) {\n            return;\n        }\n        var [node, path] = current;\n        var [prevNode, prevPath] = prev;\n        if (path.length === 0 || prevPath.length === 0) {\n            return;\n        }\n        var newPath = Path.next(prevPath);\n        var commonPath = Path.common(path, prevPath);\n        var isPreviousSibling = Path.isSibling(path, prevPath);\n        var levels = Array.from(Editor.levels(editor, {\n            at: path\n        }), (_ref)=>{\n            var [n] = _ref;\n            return n;\n        }).slice(commonPath.length).slice(0, -1);\n        // Determine if the merge will leave an ancestor of the path empty as a\n        // result, in which case we'll want to remove it after merging.\n        var emptyAncestor = Editor.above(editor, {\n            at: path,\n            mode: \"highest\",\n            match: (n)=>levels.includes(n) && hasSingleChildNest(editor, n)\n        });\n        var emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1]);\n        var properties;\n        var position;\n        // Ensure that the nodes are equivalent, and figure out what the position\n        // and extra properties of the merge will be.\n        if (Text.isText(node) && Text.isText(prevNode)) {\n            var rest = _objectWithoutProperties(node, _excluded);\n            position = prevNode.text.length;\n            properties = rest;\n        } else if (Element.isElement(node) && Element.isElement(prevNode)) {\n            var rest = _objectWithoutProperties(node, _excluded2);\n            position = prevNode.children.length;\n            properties = rest;\n        } else {\n            throw new Error(\"Cannot merge the node at path [\".concat(path, \"] with the previous sibling because it is not the same kind: \").concat(Scrubber.stringify(node), \" \").concat(Scrubber.stringify(prevNode)));\n        }\n        // If the node isn't already the next sibling of the previous node, move\n        // it so that it is before merging.\n        if (!isPreviousSibling) {\n            Transforms.moveNodes(editor, {\n                at: path,\n                to: newPath,\n                voids\n            });\n        }\n        // If there was going to be an empty ancestor of the node that was merged,\n        // we remove it from the tree.\n        if (emptyRef) {\n            Transforms.removeNodes(editor, {\n                at: emptyRef.current,\n                voids\n            });\n        }\n        if (Editor.shouldMergeNodesRemovePrevNode(editor, prev, current)) {\n            Transforms.removeNodes(editor, {\n                at: prevPath,\n                voids\n            });\n        } else {\n            editor.apply({\n                type: \"merge_node\",\n                path: newPath,\n                position,\n                properties\n            });\n        }\n        if (emptyRef) {\n            emptyRef.unref();\n        }\n    });\n};\nvar moveNodes = (editor, options)=>{\n    Editor.withoutNormalizing(editor, ()=>{\n        var { to, at = editor.selection, mode = \"lowest\", voids = false } = options;\n        var { match } = options;\n        if (!at) {\n            return;\n        }\n        if (match == null) {\n            match = Path.isPath(at) ? matchPath(editor, at) : (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n        }\n        var toRef = Editor.pathRef(editor, to);\n        var targets = Editor.nodes(editor, {\n            at,\n            match,\n            mode,\n            voids\n        });\n        var pathRefs = Array.from(targets, (_ref)=>{\n            var [, p] = _ref;\n            return Editor.pathRef(editor, p);\n        });\n        for (var pathRef of pathRefs){\n            var path = pathRef.unref();\n            var newPath = toRef.current;\n            if (path.length !== 0) {\n                editor.apply({\n                    type: \"move_node\",\n                    path,\n                    newPath\n                });\n            }\n            if (toRef.current && Path.isSibling(newPath, path) && Path.isAfter(newPath, path)) {\n                // When performing a sibling move to a later index, the path at the destination is shifted\n                // to before the insertion point instead of after. To ensure our group of nodes are inserted\n                // in the correct order we increment toRef to account for that\n                toRef.current = Path.next(toRef.current);\n            }\n        }\n        toRef.unref();\n    });\n};\nvar removeNodes = function removeNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, ()=>{\n        var { hanging = false, voids = false, mode = \"lowest\" } = options;\n        var { at = editor.selection, match } = options;\n        if (!at) {\n            return;\n        }\n        if (match == null) {\n            match = Path.isPath(at) ? matchPath(editor, at) : (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n        }\n        if (!hanging && Range.isRange(at)) {\n            at = Editor.unhangRange(editor, at, {\n                voids\n            });\n        }\n        var depths = Editor.nodes(editor, {\n            at,\n            match,\n            mode,\n            voids\n        });\n        var pathRefs = Array.from(depths, (_ref)=>{\n            var [, p] = _ref;\n            return Editor.pathRef(editor, p);\n        });\n        for (var pathRef of pathRefs){\n            var path = pathRef.unref();\n            if (path) {\n                var [node] = Editor.node(editor, path);\n                editor.apply({\n                    type: \"remove_node\",\n                    path,\n                    node\n                });\n            }\n        }\n    });\n};\nvar setNodes = function setNodes(editor, props) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, ()=>{\n        var { match, at = editor.selection, compare, merge } = options;\n        var { hanging = false, mode = \"lowest\", split = false, voids = false } = options;\n        if (!at) {\n            return;\n        }\n        if (match == null) {\n            match = Path.isPath(at) ? matchPath(editor, at) : (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n        }\n        if (!hanging && Range.isRange(at)) {\n            at = Editor.unhangRange(editor, at, {\n                voids\n            });\n        }\n        if (split && Range.isRange(at)) {\n            if (Range.isCollapsed(at) && Editor.leaf(editor, at.anchor)[0].text.length > 0) {\n                // If the range is collapsed in a non-empty node and 'split' is true, there's nothing to\n                // set that won't get normalized away\n                return;\n            }\n            var rangeRef = Editor.rangeRef(editor, at, {\n                affinity: \"inward\"\n            });\n            var [start, end] = Range.edges(at);\n            var splitMode = mode === \"lowest\" ? \"lowest\" : \"highest\";\n            var endAtEndOfNode = Editor.isEnd(editor, end, end.path);\n            Transforms.splitNodes(editor, {\n                at: end,\n                match,\n                mode: splitMode,\n                voids,\n                always: !endAtEndOfNode\n            });\n            var startAtStartOfNode = Editor.isStart(editor, start, start.path);\n            Transforms.splitNodes(editor, {\n                at: start,\n                match,\n                mode: splitMode,\n                voids,\n                always: !startAtStartOfNode\n            });\n            at = rangeRef.unref();\n            if (options.at == null) {\n                Transforms.select(editor, at);\n            }\n        }\n        if (!compare) {\n            compare = (prop, nodeProp)=>prop !== nodeProp;\n        }\n        for (var [node, path] of Editor.nodes(editor, {\n            at,\n            match,\n            mode,\n            voids\n        })){\n            var properties = {};\n            // FIXME: is this correct?\n            var newProperties = {};\n            // You can't set properties on the editor node.\n            if (path.length === 0) {\n                continue;\n            }\n            var hasChanges = false;\n            for(var k in props){\n                if (k === \"children\" || k === \"text\") {\n                    continue;\n                }\n                if (compare(props[k], node[k])) {\n                    hasChanges = true;\n                    // Omit new properties from the old properties list\n                    if (node.hasOwnProperty(k)) properties[k] = node[k];\n                    // Omit properties that have been removed from the new properties list\n                    if (merge) {\n                        if (props[k] != null) newProperties[k] = merge(node[k], props[k]);\n                    } else {\n                        if (props[k] != null) newProperties[k] = props[k];\n                    }\n                }\n            }\n            if (hasChanges) {\n                editor.apply({\n                    type: \"set_node\",\n                    path,\n                    properties,\n                    newProperties\n                });\n            }\n        }\n    });\n};\n/**\n * Convert a range into a point by deleting it's content.\n */ var deleteRange = (editor, range)=>{\n    if (Range.isCollapsed(range)) {\n        return range.anchor;\n    } else {\n        var [, end] = Range.edges(range);\n        var pointRef = Editor.pointRef(editor, end);\n        Transforms.delete(editor, {\n            at: range\n        });\n        return pointRef.unref();\n    }\n};\nvar splitNodes = function splitNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, ()=>{\n        var { mode = \"lowest\", voids = false } = options;\n        var { match, at = editor.selection, height = 0, always = false } = options;\n        if (match == null) {\n            match = (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n        }\n        if (Range.isRange(at)) {\n            at = deleteRange(editor, at);\n        }\n        // If the target is a path, the default height-skipping and position\n        // counters need to account for us potentially splitting at a non-leaf.\n        if (Path.isPath(at)) {\n            var path = at;\n            var point = Editor.point(editor, path);\n            var [parent] = Editor.parent(editor, path);\n            match = (n)=>n === parent;\n            height = point.path.length - path.length + 1;\n            at = point;\n            always = true;\n        }\n        if (!at) {\n            return;\n        }\n        var beforeRef = Editor.pointRef(editor, at, {\n            affinity: \"backward\"\n        });\n        var afterRef;\n        try {\n            var [highest] = Editor.nodes(editor, {\n                at,\n                match,\n                mode,\n                voids\n            });\n            if (!highest) {\n                return;\n            }\n            var voidMatch = Editor.void(editor, {\n                at,\n                mode: \"highest\"\n            });\n            var nudge = 0;\n            if (!voids && voidMatch) {\n                var [voidNode, voidPath] = voidMatch;\n                if (Element.isElement(voidNode) && editor.isInline(voidNode)) {\n                    var after = Editor.after(editor, voidPath);\n                    if (!after) {\n                        var text = {\n                            text: \"\"\n                        };\n                        var afterPath = Path.next(voidPath);\n                        Transforms.insertNodes(editor, text, {\n                            at: afterPath,\n                            voids\n                        });\n                        after = Editor.point(editor, afterPath);\n                    }\n                    at = after;\n                    always = true;\n                }\n                var siblingHeight = at.path.length - voidPath.length;\n                height = siblingHeight + 1;\n                always = true;\n            }\n            afterRef = Editor.pointRef(editor, at);\n            var depth = at.path.length - height;\n            var [, highestPath] = highest;\n            var lowestPath = at.path.slice(0, depth);\n            var position = height === 0 ? at.offset : at.path[depth] + nudge;\n            for (var [node, _path] of Editor.levels(editor, {\n                at: lowestPath,\n                reverse: true,\n                voids\n            })){\n                var split = false;\n                if (_path.length < highestPath.length || _path.length === 0 || !voids && Element.isElement(node) && Editor.isVoid(editor, node)) {\n                    break;\n                }\n                var _point = beforeRef.current;\n                var isEnd = Editor.isEnd(editor, _point, _path);\n                if (always || !beforeRef || !Editor.isEdge(editor, _point, _path)) {\n                    split = true;\n                    var properties = Node.extractProps(node);\n                    editor.apply({\n                        type: \"split_node\",\n                        path: _path,\n                        position,\n                        properties\n                    });\n                }\n                position = _path[_path.length - 1] + (split || isEnd ? 1 : 0);\n            }\n            if (options.at == null) {\n                var _point2 = afterRef.current || Editor.end(editor, []);\n                Transforms.select(editor, _point2);\n            }\n        } finally{\n            var _afterRef;\n            beforeRef.unref();\n            (_afterRef = afterRef) === null || _afterRef === void 0 || _afterRef.unref();\n        }\n    });\n};\nvar unsetNodes = function unsetNodes(editor, props) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (!Array.isArray(props)) {\n        props = [\n            props\n        ];\n    }\n    var obj = {};\n    for (var key of props){\n        obj[key] = null;\n    }\n    Transforms.setNodes(editor, obj, options);\n};\nvar unwrapNodes = function unwrapNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, ()=>{\n        var { mode = \"lowest\", split = false, voids = false } = options;\n        var { at = editor.selection, match } = options;\n        if (!at) {\n            return;\n        }\n        if (match == null) {\n            match = Path.isPath(at) ? matchPath(editor, at) : (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n        }\n        if (Path.isPath(at)) {\n            at = Editor.range(editor, at);\n        }\n        var rangeRef = Range.isRange(at) ? Editor.rangeRef(editor, at) : null;\n        var matches = Editor.nodes(editor, {\n            at,\n            match,\n            mode,\n            voids\n        });\n        var pathRefs = Array.from(matches, (_ref)=>{\n            var [, p] = _ref;\n            return Editor.pathRef(editor, p);\n        }).reverse();\n        var _loop = function _loop() {\n            var path = pathRef.unref();\n            var [node] = Editor.node(editor, path);\n            var range = Editor.range(editor, path);\n            if (split && rangeRef) {\n                range = Range.intersection(rangeRef.current, range);\n            }\n            Transforms.liftNodes(editor, {\n                at: range,\n                match: (n)=>Element.isAncestor(node) && node.children.includes(n),\n                voids\n            });\n        };\n        for (var pathRef of pathRefs){\n            _loop();\n        }\n        if (rangeRef) {\n            rangeRef.unref();\n        }\n    });\n};\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nvar wrapNodes = function wrapNodes(editor, element) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, ()=>{\n        var { mode = \"lowest\", split = false, voids = false } = options;\n        var { match, at = editor.selection } = options;\n        if (!at) {\n            return;\n        }\n        if (match == null) {\n            if (Path.isPath(at)) {\n                match = matchPath(editor, at);\n            } else if (editor.isInline(element)) {\n                match = (n)=>Element.isElement(n) && Editor.isInline(editor, n) || Text.isText(n);\n            } else {\n                match = (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n            }\n        }\n        if (split && Range.isRange(at)) {\n            var [start, end] = Range.edges(at);\n            var rangeRef = Editor.rangeRef(editor, at, {\n                affinity: \"inward\"\n            });\n            Transforms.splitNodes(editor, {\n                at: end,\n                match,\n                voids\n            });\n            Transforms.splitNodes(editor, {\n                at: start,\n                match,\n                voids\n            });\n            at = rangeRef.unref();\n            if (options.at == null) {\n                Transforms.select(editor, at);\n            }\n        }\n        var roots = Array.from(Editor.nodes(editor, {\n            at,\n            match: editor.isInline(element) ? (n)=>Element.isElement(n) && Editor.isBlock(editor, n) : (n)=>Editor.isEditor(n),\n            mode: \"lowest\",\n            voids\n        }));\n        var _loop = function _loop() {\n            var a = Range.isRange(at) ? Range.intersection(at, Editor.range(editor, rootPath)) : at;\n            if (!a) {\n                return 0; // continue\n            }\n            var matches = Array.from(Editor.nodes(editor, {\n                at: a,\n                match,\n                mode,\n                voids\n            }));\n            if (matches.length > 0) {\n                var [first] = matches;\n                var last = matches[matches.length - 1];\n                var [, firstPath] = first;\n                var [, lastPath] = last;\n                if (firstPath.length === 0 && lastPath.length === 0) {\n                    // if there's no matching parent - usually means the node is an editor - don't do anything\n                    return 0; // continue\n                }\n                var commonPath = Path.equals(firstPath, lastPath) ? Path.parent(firstPath) : Path.common(firstPath, lastPath);\n                var range = Editor.range(editor, firstPath, lastPath);\n                var commonNodeEntry = Editor.node(editor, commonPath);\n                var [commonNode] = commonNodeEntry;\n                var depth = commonPath.length + 1;\n                var wrapperPath = Path.next(lastPath.slice(0, depth));\n                var wrapper = _objectSpread(_objectSpread({}, element), {}, {\n                    children: []\n                });\n                Transforms.insertNodes(editor, wrapper, {\n                    at: wrapperPath,\n                    voids\n                });\n                Transforms.moveNodes(editor, {\n                    at: range,\n                    match: (n)=>Element.isAncestor(commonNode) && commonNode.children.includes(n),\n                    to: wrapperPath.concat(0),\n                    voids\n                });\n            }\n        }, _ret;\n        for (var [, rootPath] of roots){\n            _ret = _loop();\n            if (_ret === 0) continue;\n        }\n    });\n};\n/**\n * Create a new Slate `Editor` object.\n */ var createEditor = ()=>{\n    var editor = {\n        children: [],\n        operations: [],\n        selection: null,\n        marks: null,\n        isElementReadOnly: ()=>false,\n        isInline: ()=>false,\n        isSelectable: ()=>true,\n        isVoid: ()=>false,\n        markableVoid: ()=>false,\n        onChange: ()=>{},\n        // Core\n        apply: function apply$1() {\n            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                args[_key] = arguments[_key];\n            }\n            return apply(editor, ...args);\n        },\n        // Editor\n        addMark: function addMark$1() {\n            for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n                args[_key2] = arguments[_key2];\n            }\n            return addMark(editor, ...args);\n        },\n        deleteBackward: function deleteBackward$1() {\n            for(var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++){\n                args[_key3] = arguments[_key3];\n            }\n            return deleteBackward(editor, ...args);\n        },\n        deleteForward: function deleteForward$1() {\n            for(var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++){\n                args[_key4] = arguments[_key4];\n            }\n            return deleteForward(editor, ...args);\n        },\n        deleteFragment: function deleteFragment$1() {\n            for(var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++){\n                args[_key5] = arguments[_key5];\n            }\n            return deleteFragment(editor, ...args);\n        },\n        getFragment: function getFragment$1() {\n            for(var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++){\n                args[_key6] = arguments[_key6];\n            }\n            return getFragment(editor, ...args);\n        },\n        insertBreak: function insertBreak$1() {\n            for(var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++){\n                args[_key7] = arguments[_key7];\n            }\n            return insertBreak(editor, ...args);\n        },\n        insertSoftBreak: function insertSoftBreak$1() {\n            for(var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++){\n                args[_key8] = arguments[_key8];\n            }\n            return insertSoftBreak(editor, ...args);\n        },\n        insertFragment: function insertFragment$1() {\n            for(var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++){\n                args[_key9] = arguments[_key9];\n            }\n            return insertFragment(editor, ...args);\n        },\n        insertNode: function insertNode$1() {\n            for(var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++){\n                args[_key10] = arguments[_key10];\n            }\n            return insertNode(editor, ...args);\n        },\n        insertText: function insertText$1() {\n            for(var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++){\n                args[_key11] = arguments[_key11];\n            }\n            return insertText(editor, ...args);\n        },\n        normalizeNode: function normalizeNode$1() {\n            for(var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++){\n                args[_key12] = arguments[_key12];\n            }\n            return normalizeNode(editor, ...args);\n        },\n        removeMark: function removeMark$1() {\n            for(var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++){\n                args[_key13] = arguments[_key13];\n            }\n            return removeMark(editor, ...args);\n        },\n        getDirtyPaths: function getDirtyPaths$1() {\n            for(var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++){\n                args[_key14] = arguments[_key14];\n            }\n            return getDirtyPaths(editor, ...args);\n        },\n        shouldNormalize: function shouldNormalize$1() {\n            for(var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++){\n                args[_key15] = arguments[_key15];\n            }\n            return shouldNormalize(editor, ...args);\n        },\n        // Editor interface\n        above: function above$1() {\n            for(var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++){\n                args[_key16] = arguments[_key16];\n            }\n            return above(editor, ...args);\n        },\n        after: function after$1() {\n            for(var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++){\n                args[_key17] = arguments[_key17];\n            }\n            return after(editor, ...args);\n        },\n        before: function before$1() {\n            for(var _len18 = arguments.length, args = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++){\n                args[_key18] = arguments[_key18];\n            }\n            return before(editor, ...args);\n        },\n        collapse: function collapse$1() {\n            for(var _len19 = arguments.length, args = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++){\n                args[_key19] = arguments[_key19];\n            }\n            return collapse(editor, ...args);\n        },\n        delete: function _delete() {\n            for(var _len20 = arguments.length, args = new Array(_len20), _key20 = 0; _key20 < _len20; _key20++){\n                args[_key20] = arguments[_key20];\n            }\n            return deleteText(editor, ...args);\n        },\n        deselect: function deselect$1() {\n            for(var _len21 = arguments.length, args = new Array(_len21), _key21 = 0; _key21 < _len21; _key21++){\n                args[_key21] = arguments[_key21];\n            }\n            return deselect(editor, ...args);\n        },\n        edges: function edges$1() {\n            for(var _len22 = arguments.length, args = new Array(_len22), _key22 = 0; _key22 < _len22; _key22++){\n                args[_key22] = arguments[_key22];\n            }\n            return edges(editor, ...args);\n        },\n        elementReadOnly: function elementReadOnly$1() {\n            for(var _len23 = arguments.length, args = new Array(_len23), _key23 = 0; _key23 < _len23; _key23++){\n                args[_key23] = arguments[_key23];\n            }\n            return elementReadOnly(editor, ...args);\n        },\n        end: function end$1() {\n            for(var _len24 = arguments.length, args = new Array(_len24), _key24 = 0; _key24 < _len24; _key24++){\n                args[_key24] = arguments[_key24];\n            }\n            return end(editor, ...args);\n        },\n        first: function first$1() {\n            for(var _len25 = arguments.length, args = new Array(_len25), _key25 = 0; _key25 < _len25; _key25++){\n                args[_key25] = arguments[_key25];\n            }\n            return first(editor, ...args);\n        },\n        fragment: function fragment$1() {\n            for(var _len26 = arguments.length, args = new Array(_len26), _key26 = 0; _key26 < _len26; _key26++){\n                args[_key26] = arguments[_key26];\n            }\n            return fragment(editor, ...args);\n        },\n        getMarks: function getMarks() {\n            for(var _len27 = arguments.length, args = new Array(_len27), _key27 = 0; _key27 < _len27; _key27++){\n                args[_key27] = arguments[_key27];\n            }\n            return marks(editor, ...args);\n        },\n        hasBlocks: function hasBlocks$1() {\n            for(var _len28 = arguments.length, args = new Array(_len28), _key28 = 0; _key28 < _len28; _key28++){\n                args[_key28] = arguments[_key28];\n            }\n            return hasBlocks(editor, ...args);\n        },\n        hasInlines: function hasInlines$1() {\n            for(var _len29 = arguments.length, args = new Array(_len29), _key29 = 0; _key29 < _len29; _key29++){\n                args[_key29] = arguments[_key29];\n            }\n            return hasInlines(editor, ...args);\n        },\n        hasPath: function hasPath$1() {\n            for(var _len30 = arguments.length, args = new Array(_len30), _key30 = 0; _key30 < _len30; _key30++){\n                args[_key30] = arguments[_key30];\n            }\n            return hasPath(editor, ...args);\n        },\n        hasTexts: function hasTexts$1() {\n            for(var _len31 = arguments.length, args = new Array(_len31), _key31 = 0; _key31 < _len31; _key31++){\n                args[_key31] = arguments[_key31];\n            }\n            return hasTexts(editor, ...args);\n        },\n        insertNodes: function insertNodes$1() {\n            for(var _len32 = arguments.length, args = new Array(_len32), _key32 = 0; _key32 < _len32; _key32++){\n                args[_key32] = arguments[_key32];\n            }\n            return insertNodes(editor, ...args);\n        },\n        isBlock: function isBlock$1() {\n            for(var _len33 = arguments.length, args = new Array(_len33), _key33 = 0; _key33 < _len33; _key33++){\n                args[_key33] = arguments[_key33];\n            }\n            return isBlock(editor, ...args);\n        },\n        isEdge: function isEdge$1() {\n            for(var _len34 = arguments.length, args = new Array(_len34), _key34 = 0; _key34 < _len34; _key34++){\n                args[_key34] = arguments[_key34];\n            }\n            return isEdge(editor, ...args);\n        },\n        isEmpty: function isEmpty$1() {\n            for(var _len35 = arguments.length, args = new Array(_len35), _key35 = 0; _key35 < _len35; _key35++){\n                args[_key35] = arguments[_key35];\n            }\n            return isEmpty(editor, ...args);\n        },\n        isEnd: function isEnd$1() {\n            for(var _len36 = arguments.length, args = new Array(_len36), _key36 = 0; _key36 < _len36; _key36++){\n                args[_key36] = arguments[_key36];\n            }\n            return isEnd(editor, ...args);\n        },\n        isNormalizing: function isNormalizing$1() {\n            for(var _len37 = arguments.length, args = new Array(_len37), _key37 = 0; _key37 < _len37; _key37++){\n                args[_key37] = arguments[_key37];\n            }\n            return isNormalizing(editor, ...args);\n        },\n        isStart: function isStart$1() {\n            for(var _len38 = arguments.length, args = new Array(_len38), _key38 = 0; _key38 < _len38; _key38++){\n                args[_key38] = arguments[_key38];\n            }\n            return isStart(editor, ...args);\n        },\n        last: function last$1() {\n            for(var _len39 = arguments.length, args = new Array(_len39), _key39 = 0; _key39 < _len39; _key39++){\n                args[_key39] = arguments[_key39];\n            }\n            return last(editor, ...args);\n        },\n        leaf: function leaf$1() {\n            for(var _len40 = arguments.length, args = new Array(_len40), _key40 = 0; _key40 < _len40; _key40++){\n                args[_key40] = arguments[_key40];\n            }\n            return leaf(editor, ...args);\n        },\n        levels: function levels$1() {\n            for(var _len41 = arguments.length, args = new Array(_len41), _key41 = 0; _key41 < _len41; _key41++){\n                args[_key41] = arguments[_key41];\n            }\n            return levels(editor, ...args);\n        },\n        liftNodes: function liftNodes$1() {\n            for(var _len42 = arguments.length, args = new Array(_len42), _key42 = 0; _key42 < _len42; _key42++){\n                args[_key42] = arguments[_key42];\n            }\n            return liftNodes(editor, ...args);\n        },\n        mergeNodes: function mergeNodes$1() {\n            for(var _len43 = arguments.length, args = new Array(_len43), _key43 = 0; _key43 < _len43; _key43++){\n                args[_key43] = arguments[_key43];\n            }\n            return mergeNodes(editor, ...args);\n        },\n        move: function move$1() {\n            for(var _len44 = arguments.length, args = new Array(_len44), _key44 = 0; _key44 < _len44; _key44++){\n                args[_key44] = arguments[_key44];\n            }\n            return move(editor, ...args);\n        },\n        moveNodes: function moveNodes$1() {\n            for(var _len45 = arguments.length, args = new Array(_len45), _key45 = 0; _key45 < _len45; _key45++){\n                args[_key45] = arguments[_key45];\n            }\n            return moveNodes(editor, ...args);\n        },\n        next: function next$1() {\n            for(var _len46 = arguments.length, args = new Array(_len46), _key46 = 0; _key46 < _len46; _key46++){\n                args[_key46] = arguments[_key46];\n            }\n            return next(editor, ...args);\n        },\n        node: function node$1() {\n            for(var _len47 = arguments.length, args = new Array(_len47), _key47 = 0; _key47 < _len47; _key47++){\n                args[_key47] = arguments[_key47];\n            }\n            return node(editor, ...args);\n        },\n        nodes: function nodes$1() {\n            for(var _len48 = arguments.length, args = new Array(_len48), _key48 = 0; _key48 < _len48; _key48++){\n                args[_key48] = arguments[_key48];\n            }\n            return nodes(editor, ...args);\n        },\n        normalize: function normalize$1() {\n            for(var _len49 = arguments.length, args = new Array(_len49), _key49 = 0; _key49 < _len49; _key49++){\n                args[_key49] = arguments[_key49];\n            }\n            return normalize(editor, ...args);\n        },\n        parent: function parent$1() {\n            for(var _len50 = arguments.length, args = new Array(_len50), _key50 = 0; _key50 < _len50; _key50++){\n                args[_key50] = arguments[_key50];\n            }\n            return parent(editor, ...args);\n        },\n        path: function path$1() {\n            for(var _len51 = arguments.length, args = new Array(_len51), _key51 = 0; _key51 < _len51; _key51++){\n                args[_key51] = arguments[_key51];\n            }\n            return path(editor, ...args);\n        },\n        pathRef: function pathRef$1() {\n            for(var _len52 = arguments.length, args = new Array(_len52), _key52 = 0; _key52 < _len52; _key52++){\n                args[_key52] = arguments[_key52];\n            }\n            return pathRef(editor, ...args);\n        },\n        pathRefs: function pathRefs$1() {\n            for(var _len53 = arguments.length, args = new Array(_len53), _key53 = 0; _key53 < _len53; _key53++){\n                args[_key53] = arguments[_key53];\n            }\n            return pathRefs(editor, ...args);\n        },\n        point: function point$1() {\n            for(var _len54 = arguments.length, args = new Array(_len54), _key54 = 0; _key54 < _len54; _key54++){\n                args[_key54] = arguments[_key54];\n            }\n            return point(editor, ...args);\n        },\n        pointRef: function pointRef$1() {\n            for(var _len55 = arguments.length, args = new Array(_len55), _key55 = 0; _key55 < _len55; _key55++){\n                args[_key55] = arguments[_key55];\n            }\n            return pointRef(editor, ...args);\n        },\n        pointRefs: function pointRefs$1() {\n            for(var _len56 = arguments.length, args = new Array(_len56), _key56 = 0; _key56 < _len56; _key56++){\n                args[_key56] = arguments[_key56];\n            }\n            return pointRefs(editor, ...args);\n        },\n        positions: function positions$1() {\n            for(var _len57 = arguments.length, args = new Array(_len57), _key57 = 0; _key57 < _len57; _key57++){\n                args[_key57] = arguments[_key57];\n            }\n            return positions(editor, ...args);\n        },\n        previous: function previous$1() {\n            for(var _len58 = arguments.length, args = new Array(_len58), _key58 = 0; _key58 < _len58; _key58++){\n                args[_key58] = arguments[_key58];\n            }\n            return previous(editor, ...args);\n        },\n        range: function range$1() {\n            for(var _len59 = arguments.length, args = new Array(_len59), _key59 = 0; _key59 < _len59; _key59++){\n                args[_key59] = arguments[_key59];\n            }\n            return range(editor, ...args);\n        },\n        rangeRef: function rangeRef$1() {\n            for(var _len60 = arguments.length, args = new Array(_len60), _key60 = 0; _key60 < _len60; _key60++){\n                args[_key60] = arguments[_key60];\n            }\n            return rangeRef(editor, ...args);\n        },\n        rangeRefs: function rangeRefs$1() {\n            for(var _len61 = arguments.length, args = new Array(_len61), _key61 = 0; _key61 < _len61; _key61++){\n                args[_key61] = arguments[_key61];\n            }\n            return rangeRefs(editor, ...args);\n        },\n        removeNodes: function removeNodes$1() {\n            for(var _len62 = arguments.length, args = new Array(_len62), _key62 = 0; _key62 < _len62; _key62++){\n                args[_key62] = arguments[_key62];\n            }\n            return removeNodes(editor, ...args);\n        },\n        select: function select$1() {\n            for(var _len63 = arguments.length, args = new Array(_len63), _key63 = 0; _key63 < _len63; _key63++){\n                args[_key63] = arguments[_key63];\n            }\n            return select(editor, ...args);\n        },\n        setNodes: function setNodes$1() {\n            for(var _len64 = arguments.length, args = new Array(_len64), _key64 = 0; _key64 < _len64; _key64++){\n                args[_key64] = arguments[_key64];\n            }\n            return setNodes(editor, ...args);\n        },\n        setNormalizing: function setNormalizing$1() {\n            for(var _len65 = arguments.length, args = new Array(_len65), _key65 = 0; _key65 < _len65; _key65++){\n                args[_key65] = arguments[_key65];\n            }\n            return setNormalizing(editor, ...args);\n        },\n        setPoint: function setPoint$1() {\n            for(var _len66 = arguments.length, args = new Array(_len66), _key66 = 0; _key66 < _len66; _key66++){\n                args[_key66] = arguments[_key66];\n            }\n            return setPoint(editor, ...args);\n        },\n        setSelection: function setSelection$1() {\n            for(var _len67 = arguments.length, args = new Array(_len67), _key67 = 0; _key67 < _len67; _key67++){\n                args[_key67] = arguments[_key67];\n            }\n            return setSelection(editor, ...args);\n        },\n        splitNodes: function splitNodes$1() {\n            for(var _len68 = arguments.length, args = new Array(_len68), _key68 = 0; _key68 < _len68; _key68++){\n                args[_key68] = arguments[_key68];\n            }\n            return splitNodes(editor, ...args);\n        },\n        start: function start$1() {\n            for(var _len69 = arguments.length, args = new Array(_len69), _key69 = 0; _key69 < _len69; _key69++){\n                args[_key69] = arguments[_key69];\n            }\n            return start(editor, ...args);\n        },\n        string: function string$1() {\n            for(var _len70 = arguments.length, args = new Array(_len70), _key70 = 0; _key70 < _len70; _key70++){\n                args[_key70] = arguments[_key70];\n            }\n            return string(editor, ...args);\n        },\n        unhangRange: function unhangRange$1() {\n            for(var _len71 = arguments.length, args = new Array(_len71), _key71 = 0; _key71 < _len71; _key71++){\n                args[_key71] = arguments[_key71];\n            }\n            return unhangRange(editor, ...args);\n        },\n        unsetNodes: function unsetNodes$1() {\n            for(var _len72 = arguments.length, args = new Array(_len72), _key72 = 0; _key72 < _len72; _key72++){\n                args[_key72] = arguments[_key72];\n            }\n            return unsetNodes(editor, ...args);\n        },\n        unwrapNodes: function unwrapNodes$1() {\n            for(var _len73 = arguments.length, args = new Array(_len73), _key73 = 0; _key73 < _len73; _key73++){\n                args[_key73] = arguments[_key73];\n            }\n            return unwrapNodes(editor, ...args);\n        },\n        void: function _void() {\n            for(var _len74 = arguments.length, args = new Array(_len74), _key74 = 0; _key74 < _len74; _key74++){\n                args[_key74] = arguments[_key74];\n            }\n            return getVoid(editor, ...args);\n        },\n        withoutNormalizing: function withoutNormalizing$1() {\n            for(var _len75 = arguments.length, args = new Array(_len75), _key75 = 0; _key75 < _len75; _key75++){\n                args[_key75] = arguments[_key75];\n            }\n            return withoutNormalizing(editor, ...args);\n        },\n        wrapNodes: function wrapNodes$1() {\n            for(var _len76 = arguments.length, args = new Array(_len76), _key76 = 0; _key76 < _len76; _key76++){\n                args[_key76] = arguments[_key76];\n            }\n            return wrapNodes(editor, ...args);\n        },\n        shouldMergeNodesRemovePrevNode: function shouldMergeNodesRemovePrevNode$1() {\n            for(var _len77 = arguments.length, args = new Array(_len77), _key77 = 0; _key77 < _len77; _key77++){\n                args[_key77] = arguments[_key77];\n            }\n            return shouldMergeNodesRemovePrevNode(editor, ...args);\n        }\n    };\n    return editor;\n};\n //# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2xhdGUvZGlzdC9pbmRleC5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ0M7QUFFaEMsd0NBQXdDO0FBQ3hDLElBQUlDLFVBQVU7SUFDWkMsV0FBVUMsR0FBRyxFQUFFQyxFQUFFO1FBQ2YsSUFBSSxFQUNGQyxPQUFPLEVBQ1BDLFFBQVEsRUFDVCxHQUFHSDtRQUNKLElBQUlFLFdBQVcsTUFBTTtZQUNuQjtRQUNGO1FBQ0EsSUFBSUUsT0FBT0MsS0FBS04sU0FBUyxDQUFDRyxTQUFTRCxJQUFJO1lBQ3JDRTtRQUNGO1FBQ0FILElBQUlFLE9BQU8sR0FBR0U7UUFDZCxJQUFJQSxRQUFRLE1BQU07WUFDaEJKLElBQUlNLEtBQUs7UUFDWDtJQUNGO0FBQ0Y7QUFFQSx3Q0FBd0M7QUFDeEMsSUFBSUMsV0FBVztJQUNiUixXQUFVQyxHQUFHLEVBQUVDLEVBQUU7UUFDZixJQUFJLEVBQ0ZDLE9BQU8sRUFDUEMsUUFBUSxFQUNULEdBQUdIO1FBQ0osSUFBSUUsV0FBVyxNQUFNO1lBQ25CO1FBQ0Y7UUFDQSxJQUFJTSxRQUFRQyxNQUFNVixTQUFTLENBQUNHLFNBQVNELElBQUk7WUFDdkNFO1FBQ0Y7UUFDQUgsSUFBSUUsT0FBTyxHQUFHTTtRQUNkLElBQUlBLFNBQVMsTUFBTTtZQUNqQlIsSUFBSU0sS0FBSztRQUNYO0lBQ0Y7QUFDRjtBQUVBLHdDQUF3QztBQUN4QyxJQUFJSSxXQUFXO0lBQ2JYLFdBQVVDLEdBQUcsRUFBRUMsRUFBRTtRQUNmLElBQUksRUFDRkMsT0FBTyxFQUNQQyxRQUFRLEVBQ1QsR0FBR0g7UUFDSixJQUFJRSxXQUFXLE1BQU07WUFDbkI7UUFDRjtRQUNBLElBQUlFLE9BQU9PLE1BQU1aLFNBQVMsQ0FBQ0csU0FBU0QsSUFBSTtZQUN0Q0U7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LEdBQUdBLFNBQVNELFFBQVFDLFNBQVU7Z0JBQ25HN04sSUFBSSxDQUFDNk4sT0FBTyxHQUFHdjNCLFNBQVMsQ0FBQ3UzQixPQUFPO1lBQ2xDO1lBQ0EsT0FBTzNoQiwrQkFBK0I1TyxXQUFXMGlCO1FBQ25EO0lBQ0Y7SUFDQSxPQUFPMWlCO0FBQ1Q7QUFFMitCLENBQzMrQixvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lcmEtcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL3NsYXRlL2Rpc3QvaW5kZXguZXMuanM/N2Y0YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwcm9kdWNlIH0gZnJvbSAnaW1tZXInO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG52YXIgUGF0aFJlZiA9IHtcbiAgdHJhbnNmb3JtKHJlZiwgb3ApIHtcbiAgICB2YXIge1xuICAgICAgY3VycmVudCxcbiAgICAgIGFmZmluaXR5XG4gICAgfSA9IHJlZjtcbiAgICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwYXRoID0gUGF0aC50cmFuc2Zvcm0oY3VycmVudCwgb3AsIHtcbiAgICAgIGFmZmluaXR5XG4gICAgfSk7XG4gICAgcmVmLmN1cnJlbnQgPSBwYXRoO1xuICAgIGlmIChwYXRoID09IG51bGwpIHtcbiAgICAgIHJlZi51bnJlZigpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIFBvaW50UmVmID0ge1xuICB0cmFuc2Zvcm0ocmVmLCBvcCkge1xuICAgIHZhciB7XG4gICAgICBjdXJyZW50LFxuICAgICAgYWZmaW5pdHlcbiAgICB9ID0gcmVmO1xuICAgIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHBvaW50ID0gUG9pbnQudHJhbnNmb3JtKGN1cnJlbnQsIG9wLCB7XG4gICAgICBhZmZpbml0eVxuICAgIH0pO1xuICAgIHJlZi5jdXJyZW50ID0gcG9pbnQ7XG4gICAgaWYgKHBvaW50ID09IG51bGwpIHtcbiAgICAgIHJlZi51bnJlZigpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIFJhbmdlUmVmID0ge1xuICB0cmFuc2Zvcm0ocmVmLCBvcCkge1xuICAgIHZhciB7XG4gICAgICBjdXJyZW50LFxuICAgICAgYWZmaW5pdHlcbiAgICB9ID0gcmVmO1xuICAgIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHBhdGggPSBSYW5nZS50cmFuc2Zvcm0oY3VycmVudCwgb3AsIHtcbiAgICAgIGFmZmluaXR5XG4gICAgfSk7XG4gICAgcmVmLmN1cnJlbnQgPSBwYXRoO1xuICAgIGlmIChwYXRoID09IG51bGwpIHtcbiAgICAgIHJlZi51bnJlZigpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIERJUlRZX1BBVEhTID0gbmV3IFdlYWtNYXAoKTtcbnZhciBESVJUWV9QQVRIX0tFWVMgPSBuZXcgV2Vha01hcCgpO1xudmFyIEZMVVNISU5HID0gbmV3IFdlYWtNYXAoKTtcbnZhciBOT1JNQUxJWklORyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgUEFUSF9SRUZTID0gbmV3IFdlYWtNYXAoKTtcbnZhciBQT0lOVF9SRUZTID0gbmV3IFdlYWtNYXAoKTtcbnZhciBSQU5HRV9SRUZTID0gbmV3IFdlYWtNYXAoKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIFBhdGggPSB7XG4gIGFuY2VzdG9ycyhwYXRoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICByZXZlcnNlID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIgcGF0aHMgPSBQYXRoLmxldmVscyhwYXRoLCBvcHRpb25zKTtcbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgcGF0aHMgPSBwYXRocy5zbGljZSgxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aHMgPSBwYXRocy5zbGljZSgwLCAtMSk7XG4gICAgfVxuICAgIHJldHVybiBwYXRocztcbiAgfSxcbiAgY29tbW9uKHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgY29tbW9uID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aCAmJiBpIDwgYW5vdGhlci5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGF2ID0gcGF0aFtpXTtcbiAgICAgIHZhciBidiA9IGFub3RoZXJbaV07XG4gICAgICBpZiAoYXYgIT09IGJ2KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29tbW9uLnB1c2goYXYpO1xuICAgIH1cbiAgICByZXR1cm4gY29tbW9uO1xuICB9LFxuICBjb21wYXJlKHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgbWluID0gTWF0aC5taW4ocGF0aC5sZW5ndGgsIGFub3RoZXIubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1pbjsgaSsrKSB7XG4gICAgICBpZiAocGF0aFtpXSA8IGFub3RoZXJbaV0pIHJldHVybiAtMTtcbiAgICAgIGlmIChwYXRoW2ldID4gYW5vdGhlcltpXSkgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICBlbmRzQWZ0ZXIocGF0aCwgYW5vdGhlcikge1xuICAgIHZhciBpID0gcGF0aC5sZW5ndGggLSAxO1xuICAgIHZhciBhcyA9IHBhdGguc2xpY2UoMCwgaSk7XG4gICAgdmFyIGJzID0gYW5vdGhlci5zbGljZSgwLCBpKTtcbiAgICB2YXIgYXYgPSBwYXRoW2ldO1xuICAgIHZhciBidiA9IGFub3RoZXJbaV07XG4gICAgcmV0dXJuIFBhdGguZXF1YWxzKGFzLCBicykgJiYgYXYgPiBidjtcbiAgfSxcbiAgZW5kc0F0KHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgaSA9IHBhdGgubGVuZ3RoO1xuICAgIHZhciBhcyA9IHBhdGguc2xpY2UoMCwgaSk7XG4gICAgdmFyIGJzID0gYW5vdGhlci5zbGljZSgwLCBpKTtcbiAgICByZXR1cm4gUGF0aC5lcXVhbHMoYXMsIGJzKTtcbiAgfSxcbiAgZW5kc0JlZm9yZShwYXRoLCBhbm90aGVyKSB7XG4gICAgdmFyIGkgPSBwYXRoLmxlbmd0aCAtIDE7XG4gICAgdmFyIGFzID0gcGF0aC5zbGljZSgwLCBpKTtcbiAgICB2YXIgYnMgPSBhbm90aGVyLnNsaWNlKDAsIGkpO1xuICAgIHZhciBhdiA9IHBhdGhbaV07XG4gICAgdmFyIGJ2ID0gYW5vdGhlcltpXTtcbiAgICByZXR1cm4gUGF0aC5lcXVhbHMoYXMsIGJzKSAmJiBhdiA8IGJ2O1xuICB9LFxuICBlcXVhbHMocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA9PT0gYW5vdGhlci5sZW5ndGggJiYgcGF0aC5ldmVyeSgobiwgaSkgPT4gbiA9PT0gYW5vdGhlcltpXSk7XG4gIH0sXG4gIGhhc1ByZXZpb3VzKHBhdGgpIHtcbiAgICByZXR1cm4gcGF0aFtwYXRoLmxlbmd0aCAtIDFdID4gMDtcbiAgfSxcbiAgaXNBZnRlcihwYXRoLCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gMTtcbiAgfSxcbiAgaXNBbmNlc3RvcihwYXRoLCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIHBhdGgubGVuZ3RoIDwgYW5vdGhlci5sZW5ndGggJiYgUGF0aC5jb21wYXJlKHBhdGgsIGFub3RoZXIpID09PSAwO1xuICB9LFxuICBpc0JlZm9yZShwYXRoLCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gLTE7XG4gIH0sXG4gIGlzQ2hpbGQocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA9PT0gYW5vdGhlci5sZW5ndGggKyAxICYmIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gMDtcbiAgfSxcbiAgaXNDb21tb24ocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA8PSBhbm90aGVyLmxlbmd0aCAmJiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IDA7XG4gIH0sXG4gIGlzRGVzY2VuZGFudChwYXRoLCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIHBhdGgubGVuZ3RoID4gYW5vdGhlci5sZW5ndGggJiYgUGF0aC5jb21wYXJlKHBhdGgsIGFub3RoZXIpID09PSAwO1xuICB9LFxuICBpc1BhcmVudChwYXRoLCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIHBhdGgubGVuZ3RoICsgMSA9PT0gYW5vdGhlci5sZW5ndGggJiYgUGF0aC5jb21wYXJlKHBhdGgsIGFub3RoZXIpID09PSAwO1xuICB9LFxuICBpc1BhdGgodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgKHZhbHVlLmxlbmd0aCA9PT0gMCB8fCB0eXBlb2YgdmFsdWVbMF0gPT09ICdudW1iZXInKTtcbiAgfSxcbiAgaXNTaWJsaW5nKHBhdGgsIGFub3RoZXIpIHtcbiAgICBpZiAocGF0aC5sZW5ndGggIT09IGFub3RoZXIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBhcyA9IHBhdGguc2xpY2UoMCwgLTEpO1xuICAgIHZhciBicyA9IGFub3RoZXIuc2xpY2UoMCwgLTEpO1xuICAgIHZhciBhbCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICB2YXIgYmwgPSBhbm90aGVyW2Fub3RoZXIubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIGFsICE9PSBibCAmJiBQYXRoLmVxdWFscyhhcywgYnMpO1xuICB9LFxuICBsZXZlbHMocGF0aCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgcmV2ZXJzZSA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIGxpc3QgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsaXN0LnB1c2gocGF0aC5zbGljZSgwLCBpKSk7XG4gICAgfVxuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICBsaXN0LnJldmVyc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH0sXG4gIG5leHQocGF0aCkge1xuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgbmV4dCBwYXRoIG9mIGEgcm9vdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdLCBiZWNhdXNlIGl0IGhhcyBubyBuZXh0IGluZGV4LlwiKSk7XG4gICAgfVxuICAgIHZhciBsYXN0ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBwYXRoLnNsaWNlKDAsIC0xKS5jb25jYXQobGFzdCArIDEpO1xuICB9LFxuICBvcGVyYXRpb25DYW5UcmFuc2Zvcm1QYXRoKG9wZXJhdGlvbikge1xuICAgIHN3aXRjaCAob3BlcmF0aW9uLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG4gIHBhcmVudChwYXRoKSB7XG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBwYXJlbnQgcGF0aCBvZiB0aGUgcm9vdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdLlwiKSk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoLnNsaWNlKDAsIC0xKTtcbiAgfSxcbiAgcHJldmlvdXMocGF0aCkge1xuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcHJldmlvdXMgcGF0aCBvZiBhIHJvb3QgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSwgYmVjYXVzZSBpdCBoYXMgbm8gcHJldmlvdXMgaW5kZXguXCIpKTtcbiAgICB9XG4gICAgdmFyIGxhc3QgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgaWYgKGxhc3QgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcHJldmlvdXMgcGF0aCBvZiBhIGZpcnN0IGNoaWxkIHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSBpdCB3b3VsZCByZXN1bHQgaW4gYSBuZWdhdGl2ZSBpbmRleC5cIikpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aC5zbGljZSgwLCAtMSkuY29uY2F0KGxhc3QgLSAxKTtcbiAgfSxcbiAgcmVsYXRpdmUocGF0aCwgYW5jZXN0b3IpIHtcbiAgICBpZiAoIVBhdGguaXNBbmNlc3RvcihhbmNlc3RvciwgcGF0aCkgJiYgIVBhdGguZXF1YWxzKHBhdGgsIGFuY2VzdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcmVsYXRpdmUgcGF0aCBvZiBbXCIuY29uY2F0KHBhdGgsIFwiXSBpbnNpZGUgYW5jZXN0b3IgW1wiKS5jb25jYXQoYW5jZXN0b3IsIFwiXSwgYmVjYXVzZSBpdCBpcyBub3QgYWJvdmUgb3IgZXF1YWwgdG8gdGhlIHBhdGguXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGguc2xpY2UoYW5jZXN0b3IubGVuZ3RoKTtcbiAgfSxcbiAgdHJhbnNmb3JtKHBhdGgsIG9wZXJhdGlvbikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBpZiAoIXBhdGgpIHJldHVybiBudWxsO1xuICAgIC8vIFBFUkY6IHVzZSBkZXN0cnVjdGluZyBpbnN0ZWFkIG9mIGltbWVyXG4gICAgdmFyIHAgPSBbLi4ucGF0aF07XG4gICAgdmFyIHtcbiAgICAgIGFmZmluaXR5ID0gJ2ZvcndhcmQnXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgLy8gUEVSRjogRXhpdCBlYXJseSBpZiB0aGUgb3BlcmF0aW9uIGlzIGd1YXJhbnRlZWQgbm90IHRvIGhhdmUgYW4gZWZmZWN0LlxuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIHN3aXRjaCAob3BlcmF0aW9uLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICBwYXRoOiBvcFxuICAgICAgICAgIH0gPSBvcGVyYXRpb247XG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9wLCBwKSB8fCBQYXRoLmVuZHNCZWZvcmUob3AsIHApIHx8IFBhdGguaXNBbmNlc3RvcihvcCwgcCkpIHtcbiAgICAgICAgICAgIHBbb3AubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICBwYXRoOiBfb3BcbiAgICAgICAgICB9ID0gb3BlcmF0aW9uO1xuICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhfb3AsIHApIHx8IFBhdGguaXNBbmNlc3Rvcihfb3AsIHApKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguZW5kc0JlZm9yZShfb3AsIHApKSB7XG4gICAgICAgICAgICBwW19vcC5sZW5ndGggLSAxXSAtPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgcGF0aDogX29wMixcbiAgICAgICAgICAgIHBvc2l0aW9uXG4gICAgICAgICAgfSA9IG9wZXJhdGlvbjtcbiAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMoX29wMiwgcCkgfHwgUGF0aC5lbmRzQmVmb3JlKF9vcDIsIHApKSB7XG4gICAgICAgICAgICBwW19vcDIubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguaXNBbmNlc3Rvcihfb3AyLCBwKSkge1xuICAgICAgICAgICAgcFtfb3AyLmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgICBwW19vcDIubGVuZ3RoXSArPSBwb3NpdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHBhdGg6IF9vcDMsXG4gICAgICAgICAgICBwb3NpdGlvbjogX3Bvc2l0aW9uXG4gICAgICAgICAgfSA9IG9wZXJhdGlvbjtcbiAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMoX29wMywgcCkpIHtcbiAgICAgICAgICAgIGlmIChhZmZpbml0eSA9PT0gJ2ZvcndhcmQnKSB7XG4gICAgICAgICAgICAgIHBbcC5sZW5ndGggLSAxXSArPSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhZmZpbml0eSA9PT0gJ2JhY2t3YXJkJykgOyBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wMywgcCkpIHtcbiAgICAgICAgICAgIHBbX29wMy5sZW5ndGggLSAxXSArPSAxO1xuICAgICAgICAgIH0gZWxzZSBpZiAoUGF0aC5pc0FuY2VzdG9yKF9vcDMsIHApICYmIHBhdGhbX29wMy5sZW5ndGhdID49IF9wb3NpdGlvbikge1xuICAgICAgICAgICAgcFtfb3AzLmxlbmd0aCAtIDFdICs9IDE7XG4gICAgICAgICAgICBwW19vcDMubGVuZ3RoXSAtPSBfcG9zaXRpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHBhdGg6IF9vcDQsXG4gICAgICAgICAgICBuZXdQYXRoOiBvbnBcbiAgICAgICAgICB9ID0gb3BlcmF0aW9uO1xuICAgICAgICAgIC8vIElmIHRoZSBvbGQgYW5kIG5ldyBwYXRoIGFyZSB0aGUgc2FtZSwgaXQncyBhIG5vLW9wLlxuICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhfb3A0LCBvbnApKSB7XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFBhdGguaXNBbmNlc3Rvcihfb3A0LCBwKSB8fCBQYXRoLmVxdWFscyhfb3A0LCBwKSkge1xuICAgICAgICAgICAgdmFyIGNvcHkgPSBvbnAuc2xpY2UoKTtcbiAgICAgICAgICAgIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wNCwgb25wKSAmJiBfb3A0Lmxlbmd0aCA8IG9ucC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgY29weVtfb3A0Lmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29weS5jb25jYXQocC5zbGljZShfb3A0Lmxlbmd0aCkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoUGF0aC5pc1NpYmxpbmcoX29wNCwgb25wKSAmJiAoUGF0aC5pc0FuY2VzdG9yKG9ucCwgcCkgfHwgUGF0aC5lcXVhbHMob25wLCBwKSkpIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wNCwgcCkpIHtcbiAgICAgICAgICAgICAgcFtfb3A0Lmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwW19vcDQubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguZW5kc0JlZm9yZShvbnAsIHApIHx8IFBhdGguZXF1YWxzKG9ucCwgcCkgfHwgUGF0aC5pc0FuY2VzdG9yKG9ucCwgcCkpIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wNCwgcCkpIHtcbiAgICAgICAgICAgICAgcFtfb3A0Lmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwW29ucC5sZW5ndGggLSAxXSArPSAxO1xuICAgICAgICAgIH0gZWxzZSBpZiAoUGF0aC5lbmRzQmVmb3JlKF9vcDQsIHApKSB7XG4gICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMob25wLCBwKSkge1xuICAgICAgICAgICAgICBwW29ucC5sZW5ndGggLSAxXSArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcFtfb3A0Lmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gdHlwZW9mIG87XG4gIH0gOiBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvO1xuICB9LCBfdHlwZW9mKG8pO1xufVxuXG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHtcbiAgaWYgKF90eXBlb2YoaW5wdXQpICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChfdHlwZW9mKHJlcykgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpO1xufVxuXG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHtcbiAgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gX3R5cGVvZihrZXkpID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gb3duS2V5cyRlKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkZShlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJGUoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJGUoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbnZhciBpbnNlcnRDaGlsZHJlbiA9IGZ1bmN0aW9uIGluc2VydENoaWxkcmVuKHhzLCBpbmRleCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbmV3VmFsdWVzID0gbmV3IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBuZXdWYWx1ZXNbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIHJldHVybiBbLi4ueHMuc2xpY2UoMCwgaW5kZXgpLCAuLi5uZXdWYWx1ZXMsIC4uLnhzLnNsaWNlKGluZGV4KV07XG59O1xudmFyIHJlcGxhY2VDaGlsZHJlbiA9IGZ1bmN0aW9uIHJlcGxhY2VDaGlsZHJlbih4cywgaW5kZXgsIHJlbW92ZUNvdW50KSB7XG4gIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgbmV3VmFsdWVzID0gbmV3IEFycmF5KF9sZW4yID4gMyA/IF9sZW4yIC0gMyA6IDApLCBfa2V5MiA9IDM7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICBuZXdWYWx1ZXNbX2tleTIgLSAzXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gIH1cbiAgcmV0dXJuIFsuLi54cy5zbGljZSgwLCBpbmRleCksIC4uLm5ld1ZhbHVlcywgLi4ueHMuc2xpY2UoaW5kZXggKyByZW1vdmVDb3VudCldO1xufTtcbnZhciByZW1vdmVDaGlsZHJlbiA9IHJlcGxhY2VDaGlsZHJlbjtcbi8qKlxuICogUmVwbGFjZSBhIGRlc2NlbmRhbnQgd2l0aCBhIG5ldyBub2RlLCByZXBsYWNpbmcgYWxsIGFuY2VzdG9yc1xuICovXG52YXIgbW9kaWZ5RGVzY2VuZGFudCA9IChlZGl0b3IsIHBhdGgsIGYpID0+IHtcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgbW9kaWZ5IHRoZSBlZGl0b3InKTtcbiAgfVxuICB2YXIgbm9kZSA9IE5vZGUuZ2V0KGVkaXRvciwgcGF0aCk7XG4gIHZhciBzbGljZWRQYXRoID0gcGF0aC5zbGljZSgpO1xuICB2YXIgbW9kaWZpZWROb2RlID0gZihub2RlKTtcbiAgd2hpbGUgKHNsaWNlZFBhdGgubGVuZ3RoID4gMSkge1xuICAgIHZhciBfaW5kZXggPSBzbGljZWRQYXRoLnBvcCgpO1xuICAgIHZhciBhbmNlc3Rvck5vZGUgPSBOb2RlLmdldChlZGl0b3IsIHNsaWNlZFBhdGgpO1xuICAgIG1vZGlmaWVkTm9kZSA9IF9vYmplY3RTcHJlYWQkZShfb2JqZWN0U3ByZWFkJGUoe30sIGFuY2VzdG9yTm9kZSksIHt9LCB7XG4gICAgICBjaGlsZHJlbjogcmVwbGFjZUNoaWxkcmVuKGFuY2VzdG9yTm9kZS5jaGlsZHJlbiwgX2luZGV4LCAxLCBtb2RpZmllZE5vZGUpXG4gICAgfSk7XG4gIH1cbiAgdmFyIGluZGV4ID0gc2xpY2VkUGF0aC5wb3AoKTtcbiAgZWRpdG9yLmNoaWxkcmVuID0gcmVwbGFjZUNoaWxkcmVuKGVkaXRvci5jaGlsZHJlbiwgaW5kZXgsIDEsIG1vZGlmaWVkTm9kZSk7XG59O1xuLyoqXG4gKiBSZXBsYWNlIHRoZSBjaGlsZHJlbiBvZiBhIG5vZGUsIHJlcGxhY2luZyBhbGwgYW5jZXN0b3JzXG4gKi9cbnZhciBtb2RpZnlDaGlsZHJlbiA9IChlZGl0b3IsIHBhdGgsIGYpID0+IHtcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgZWRpdG9yLmNoaWxkcmVuID0gZihlZGl0b3IuY2hpbGRyZW4pO1xuICB9IGVsc2Uge1xuICAgIG1vZGlmeURlc2NlbmRhbnQoZWRpdG9yLCBwYXRoLCBub2RlID0+IHtcbiAgICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBlbGVtZW50IGF0IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSBpdCByZWZlcnMgdG8gYSBsZWFmIG5vZGU6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KG5vZGUpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZCRlKF9vYmplY3RTcHJlYWQkZSh7fSwgbm9kZSksIHt9LCB7XG4gICAgICAgIGNoaWxkcmVuOiBmKG5vZGUuY2hpbGRyZW4pXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufTtcbi8qKlxuICogUmVwbGFjZSBhIGxlYWYsIHJlcGxhY2luZyBhbGwgYW5jZXN0b3JzXG4gKi9cbnZhciBtb2RpZnlMZWFmID0gKGVkaXRvciwgcGF0aCwgZikgPT4gbW9kaWZ5RGVzY2VuZGFudChlZGl0b3IsIHBhdGgsIG5vZGUgPT4ge1xuICBpZiAoIVRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgbGVhZiBub2RlIGF0IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSBpdCByZWZlcnMgdG8gYSBub24tbGVhZiBub2RlOiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShub2RlKSkpO1xuICB9XG4gIHJldHVybiBmKG5vZGUpO1xufSk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG52YXIgR2VuZXJhbFRyYW5zZm9ybXMgPSB7XG4gIHRyYW5zZm9ybShlZGl0b3IsIG9wKSB7XG4gICAgdmFyIHRyYW5zZm9ybVNlbGVjdGlvbiA9IGZhbHNlO1xuICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBub2RlXG4gICAgICAgICAgfSA9IG9wO1xuICAgICAgICAgIG1vZGlmeUNoaWxkcmVuKGVkaXRvciwgUGF0aC5wYXJlbnQocGF0aCksIGNoaWxkcmVuID0+IHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYXBwbHkgYW4gXFxcImluc2VydF9ub2RlXFxcIiBvcGVyYXRpb24gYXQgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBiZWNhdXNlIHRoZSBkZXN0aW5hdGlvbiBpcyBwYXN0IHRoZSBlbmQgb2YgdGhlIG5vZGUuXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnNlcnRDaGlsZHJlbihjaGlsZHJlbiwgaW5kZXgsIG5vZGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRyYW5zZm9ybVNlbGVjdGlvbiA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2luc2VydF90ZXh0JzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICBwYXRoOiBfcGF0aCxcbiAgICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICAgIHRleHRcbiAgICAgICAgICB9ID0gb3A7XG4gICAgICAgICAgaWYgKHRleHQubGVuZ3RoID09PSAwKSBicmVhaztcbiAgICAgICAgICBtb2RpZnlMZWFmKGVkaXRvciwgX3BhdGgsIG5vZGUgPT4ge1xuICAgICAgICAgICAgdmFyIGJlZm9yZSA9IG5vZGUudGV4dC5zbGljZSgwLCBvZmZzZXQpO1xuICAgICAgICAgICAgdmFyIGFmdGVyID0gbm9kZS50ZXh0LnNsaWNlKG9mZnNldCk7XG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCRlKF9vYmplY3RTcHJlYWQkZSh7fSwgbm9kZSksIHt9LCB7XG4gICAgICAgICAgICAgIHRleHQ6IGJlZm9yZSArIHRleHQgKyBhZnRlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdHJhbnNmb3JtU2VsZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgcGF0aDogX3BhdGgyXG4gICAgICAgICAgfSA9IG9wO1xuICAgICAgICAgIHZhciBpbmRleCA9IF9wYXRoMltfcGF0aDIubGVuZ3RoIC0gMV07XG4gICAgICAgICAgdmFyIHByZXZQYXRoID0gUGF0aC5wcmV2aW91cyhfcGF0aDIpO1xuICAgICAgICAgIHZhciBwcmV2SW5kZXggPSBwcmV2UGF0aFtwcmV2UGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgICBtb2RpZnlDaGlsZHJlbihlZGl0b3IsIFBhdGgucGFyZW50KF9wYXRoMiksIGNoaWxkcmVuID0+IHtcbiAgICAgICAgICAgIHZhciBub2RlID0gY2hpbGRyZW5baW5kZXhdO1xuICAgICAgICAgICAgdmFyIHByZXYgPSBjaGlsZHJlbltwcmV2SW5kZXhdO1xuICAgICAgICAgICAgdmFyIG5ld05vZGU7XG4gICAgICAgICAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkgJiYgVGV4dC5pc1RleHQocHJldikpIHtcbiAgICAgICAgICAgICAgbmV3Tm9kZSA9IF9vYmplY3RTcHJlYWQkZShfb2JqZWN0U3ByZWFkJGUoe30sIHByZXYpLCB7fSwge1xuICAgICAgICAgICAgICAgIHRleHQ6IHByZXYudGV4dCArIG5vZGUudGV4dFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIVRleHQuaXNUZXh0KG5vZGUpICYmICFUZXh0LmlzVGV4dChwcmV2KSkge1xuICAgICAgICAgICAgICBuZXdOb2RlID0gX29iamVjdFNwcmVhZCRlKF9vYmplY3RTcHJlYWQkZSh7fSwgcHJldiksIHt9LCB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IHByZXYuY2hpbGRyZW4uY29uY2F0KG5vZGUuY2hpbGRyZW4pXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFwcGx5IGEgXFxcIm1lcmdlX25vZGVcXFwiIG9wZXJhdGlvbiBhdCBwYXRoIFtcIi5jb25jYXQoX3BhdGgyLCBcIl0gdG8gbm9kZXMgb2YgZGlmZmVyZW50IGludGVyZmFjZXM6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KG5vZGUpLCBcIiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShwcmV2KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VDaGlsZHJlbihjaGlsZHJlbiwgcHJldkluZGV4LCAyLCBuZXdOb2RlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0cmFuc2Zvcm1TZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHBhdGg6IF9wYXRoMyxcbiAgICAgICAgICAgIG5ld1BhdGhcbiAgICAgICAgICB9ID0gb3A7XG4gICAgICAgICAgdmFyIF9pbmRleDIgPSBfcGF0aDNbX3BhdGgzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGlmIChQYXRoLmlzQW5jZXN0b3IoX3BhdGgzLCBuZXdQYXRoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IG1vdmUgYSBwYXRoIFtcIi5jb25jYXQoX3BhdGgzLCBcIl0gdG8gbmV3IHBhdGggW1wiKS5jb25jYXQobmV3UGF0aCwgXCJdIGJlY2F1c2UgdGhlIGRlc3RpbmF0aW9uIGlzIGluc2lkZSBpdHNlbGYuXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIF9ub2RlID0gTm9kZS5nZXQoZWRpdG9yLCBfcGF0aDMpO1xuICAgICAgICAgIG1vZGlmeUNoaWxkcmVuKGVkaXRvciwgUGF0aC5wYXJlbnQoX3BhdGgzKSwgY2hpbGRyZW4gPT4gcmVtb3ZlQ2hpbGRyZW4oY2hpbGRyZW4sIF9pbmRleDIsIDEpKTtcbiAgICAgICAgICAvLyBUaGlzIGlzIHRyaWNreSwgYnV0IHNpbmNlIHRoZSBgcGF0aGAgYW5kIGBuZXdQYXRoYCBib3RoIHJlZmVyIHRvXG4gICAgICAgICAgLy8gdGhlIHNhbWUgc25hcHNob3QgaW4gdGltZSwgdGhlcmUncyBhIG1pc21hdGNoLiBBZnRlciBlaXRoZXJcbiAgICAgICAgICAvLyByZW1vdmluZyB0aGUgb3JpZ2luYWwgcG9zaXRpb24sIHRoZSBzZWNvbmQgc3RlcCdzIHBhdGggY2FuIGJlIG91dFxuICAgICAgICAgIC8vIG9mIGRhdGUuIFNvIGluc3RlYWQgb2YgdXNpbmcgdGhlIGBvcC5uZXdQYXRoYCBkaXJlY3RseSwgd2VcbiAgICAgICAgICAvLyB0cmFuc2Zvcm0gYG9wLnBhdGhgIHRvIGFzY2VydGFpbiB3aGF0IHRoZSBgbmV3UGF0aGAgd291bGQgYmUgYWZ0ZXJcbiAgICAgICAgICAvLyB0aGUgb3BlcmF0aW9uIHdhcyBhcHBsaWVkLlxuICAgICAgICAgIHZhciB0cnVlUGF0aCA9IFBhdGgudHJhbnNmb3JtKF9wYXRoMywgb3ApO1xuICAgICAgICAgIHZhciBuZXdJbmRleCA9IHRydWVQYXRoW3RydWVQYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIG1vZGlmeUNoaWxkcmVuKGVkaXRvciwgUGF0aC5wYXJlbnQodHJ1ZVBhdGgpLCBjaGlsZHJlbiA9PiBpbnNlcnRDaGlsZHJlbihjaGlsZHJlbiwgbmV3SW5kZXgsIF9ub2RlKSk7XG4gICAgICAgICAgdHJhbnNmb3JtU2VsZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAncmVtb3ZlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHBhdGg6IF9wYXRoNFxuICAgICAgICAgIH0gPSBvcDtcbiAgICAgICAgICB2YXIgX2luZGV4MyA9IF9wYXRoNFtfcGF0aDQubGVuZ3RoIC0gMV07XG4gICAgICAgICAgbW9kaWZ5Q2hpbGRyZW4oZWRpdG9yLCBQYXRoLnBhcmVudChfcGF0aDQpLCBjaGlsZHJlbiA9PiByZW1vdmVDaGlsZHJlbihjaGlsZHJlbiwgX2luZGV4MywgMSkpO1xuICAgICAgICAgIC8vIFRyYW5zZm9ybSBhbGwgdGhlIHBvaW50cyBpbiB0aGUgdmFsdWUsIGJ1dCBpZiB0aGUgcG9pbnQgd2FzIGluIHRoZVxuICAgICAgICAgIC8vIG5vZGUgdGhhdCB3YXMgcmVtb3ZlZCB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgcmFuZ2Ugb3IgcmVtb3ZlIGl0LlxuICAgICAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gX29iamVjdFNwcmVhZCRlKHt9LCBlZGl0b3Iuc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIGZvciAodmFyIFtwb2ludCwga2V5XSBvZiBSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gUG9pbnQudHJhbnNmb3JtKHBvaW50LCBvcCk7XG4gICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24gIT0gbnVsbCAmJiByZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbltrZXldID0gcmVzdWx0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIFtuLCBwXSBvZiBOb2RlLnRleHRzKGVkaXRvcikpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChQYXRoLmNvbXBhcmUocCwgX3BhdGg0KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldiA9IFtuLCBwXTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSBbbiwgcF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcHJlZmVyTmV4dCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2ICYmIG5leHQpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhuZXh0WzFdLCBfcGF0aDQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWZlck5leHQgPSAhUGF0aC5oYXNQcmV2aW91cyhuZXh0WzFdKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWZlck5leHQgPSBQYXRoLmNvbW1vbihwcmV2WzFdLCBfcGF0aDQpLmxlbmd0aCA8IFBhdGguY29tbW9uKG5leHRbMV0sIF9wYXRoNCkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJldiAmJiAhcHJlZmVyTmV4dCkge1xuICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uW2tleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IHByZXZbMV0sXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogcHJldlswXS50ZXh0Lmxlbmd0aFxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5leHQpIHtcbiAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbltrZXldID0ge1xuICAgICAgICAgICAgICAgICAgICBwYXRoOiBuZXh0WzFdLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAncmVtb3ZlX3RleHQnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHBhdGg6IF9wYXRoNSxcbiAgICAgICAgICAgIG9mZnNldDogX29mZnNldCxcbiAgICAgICAgICAgIHRleHQ6IF90ZXh0XG4gICAgICAgICAgfSA9IG9wO1xuICAgICAgICAgIGlmIChfdGV4dC5sZW5ndGggPT09IDApIGJyZWFrO1xuICAgICAgICAgIG1vZGlmeUxlYWYoZWRpdG9yLCBfcGF0aDUsIG5vZGUgPT4ge1xuICAgICAgICAgICAgdmFyIGJlZm9yZSA9IG5vZGUudGV4dC5zbGljZSgwLCBfb2Zmc2V0KTtcbiAgICAgICAgICAgIHZhciBhZnRlciA9IG5vZGUudGV4dC5zbGljZShfb2Zmc2V0ICsgX3RleHQubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJGUoX29iamVjdFNwcmVhZCRlKHt9LCBub2RlKSwge30sIHtcbiAgICAgICAgICAgICAgdGV4dDogYmVmb3JlICsgYWZ0ZXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRyYW5zZm9ybVNlbGVjdGlvbiA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ3NldF9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICBwYXRoOiBfcGF0aDYsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzLFxuICAgICAgICAgICAgbmV3UHJvcGVydGllc1xuICAgICAgICAgIH0gPSBvcDtcbiAgICAgICAgICBpZiAoX3BhdGg2Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCBwcm9wZXJ0aWVzIG9uIHRoZSByb290IG5vZGUhXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtb2RpZnlEZXNjZW5kYW50KGVkaXRvciwgX3BhdGg2LCBub2RlID0+IHtcbiAgICAgICAgICAgIHZhciBuZXdOb2RlID0gX29iamVjdFNwcmVhZCRlKHt9LCBub2RlKTtcbiAgICAgICAgICAgIGZvciAodmFyIF9rZXkzIGluIG5ld1Byb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgaWYgKF9rZXkzID09PSAnY2hpbGRyZW4nIHx8IF9rZXkzID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IHRoZSBcXFwiXCIuY29uY2F0KF9rZXkzLCBcIlxcXCIgcHJvcGVydHkgb2Ygbm9kZXMhXCIpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBuZXdQcm9wZXJ0aWVzW19rZXkzXTtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgbmV3Tm9kZVtfa2V5M107XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3Tm9kZVtfa2V5M10gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcHJvcGVydGllcyB0aGF0IHdlcmUgcHJldmlvdXNseSBkZWZpbmVkLCBidXQgYXJlIG5vdyBtaXNzaW5nLCBtdXN0IGJlIGRlbGV0ZWRcbiAgICAgICAgICAgIGZvciAodmFyIF9rZXk0IGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgaWYgKCFuZXdQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KF9rZXk0KSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBuZXdOb2RlW19rZXk0XTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ld05vZGU7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ3NldF9zZWxlY3Rpb24nOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIG5ld1Byb3BlcnRpZXM6IF9uZXdQcm9wZXJ0aWVzXG4gICAgICAgICAgfSA9IG9wO1xuICAgICAgICAgIGlmIChfbmV3UHJvcGVydGllcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoIVJhbmdlLmlzUmFuZ2UoX25ld1Byb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhcHBseSBhbiBpbmNvbXBsZXRlIFxcXCJzZXRfc2VsZWN0aW9uXFxcIiBvcGVyYXRpb24gcHJvcGVydGllcyBcIi5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KF9uZXdQcm9wZXJ0aWVzKSwgXCIgd2hlbiB0aGVyZSBpcyBubyBjdXJyZW50IHNlbGVjdGlvbi5cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbiA9IF9vYmplY3RTcHJlYWQkZSh7fSwgX25ld1Byb3BlcnRpZXMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBfc2VsZWN0aW9uID0gX29iamVjdFNwcmVhZCRlKHt9LCBlZGl0b3Iuc2VsZWN0aW9uKTtcbiAgICAgICAgICBmb3IgKHZhciBfa2V5NSBpbiBfbmV3UHJvcGVydGllcykge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gX25ld1Byb3BlcnRpZXNbX2tleTVdO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKF9rZXk1ID09PSAnYW5jaG9yJyB8fCBfa2V5NSA9PT0gJ2ZvY3VzJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZW1vdmUgdGhlIFxcXCJcIi5jb25jYXQoX2tleTUsIFwiXFxcIiBzZWxlY3Rpb24gcHJvcGVydHlcIikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRlbGV0ZSBfc2VsZWN0aW9uW19rZXk1XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIF9zZWxlY3Rpb25bX2tleTVdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24gPSBfc2VsZWN0aW9uO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICBwYXRoOiBfcGF0aDcsXG4gICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IF9wcm9wZXJ0aWVzXG4gICAgICAgICAgfSA9IG9wO1xuICAgICAgICAgIHZhciBfaW5kZXg0ID0gX3BhdGg3W19wYXRoNy5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpZiAoX3BhdGg3Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFwcGx5IGEgXFxcInNwbGl0X25vZGVcXFwiIG9wZXJhdGlvbiBhdCBwYXRoIFtcIi5jb25jYXQoX3BhdGg3LCBcIl0gYmVjYXVzZSB0aGUgcm9vdCBub2RlIGNhbm5vdCBiZSBzcGxpdC5cIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtb2RpZnlDaGlsZHJlbihlZGl0b3IsIFBhdGgucGFyZW50KF9wYXRoNyksIGNoaWxkcmVuID0+IHtcbiAgICAgICAgICAgIHZhciBub2RlID0gY2hpbGRyZW5bX2luZGV4NF07XG4gICAgICAgICAgICB2YXIgbmV3Tm9kZTtcbiAgICAgICAgICAgIHZhciBuZXh0Tm9kZTtcbiAgICAgICAgICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgICAgICAgICB2YXIgYmVmb3JlID0gbm9kZS50ZXh0LnNsaWNlKDAsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgdmFyIGFmdGVyID0gbm9kZS50ZXh0LnNsaWNlKHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgbmV3Tm9kZSA9IF9vYmplY3RTcHJlYWQkZShfb2JqZWN0U3ByZWFkJGUoe30sIG5vZGUpLCB7fSwge1xuICAgICAgICAgICAgICAgIHRleHQ6IGJlZm9yZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbmV4dE5vZGUgPSBfb2JqZWN0U3ByZWFkJGUoX29iamVjdFNwcmVhZCRlKHt9LCBfcHJvcGVydGllcyksIHt9LCB7XG4gICAgICAgICAgICAgICAgdGV4dDogYWZ0ZXJcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgX2JlZm9yZSA9IG5vZGUuY2hpbGRyZW4uc2xpY2UoMCwgcG9zaXRpb24pO1xuICAgICAgICAgICAgICB2YXIgX2FmdGVyID0gbm9kZS5jaGlsZHJlbi5zbGljZShwb3NpdGlvbik7XG4gICAgICAgICAgICAgIG5ld05vZGUgPSBfb2JqZWN0U3ByZWFkJGUoX29iamVjdFNwcmVhZCRlKHt9LCBub2RlKSwge30sIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogX2JlZm9yZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbmV4dE5vZGUgPSBfb2JqZWN0U3ByZWFkJGUoX29iamVjdFNwcmVhZCRlKHt9LCBfcHJvcGVydGllcyksIHt9LCB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IF9hZnRlclxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXBsYWNlQ2hpbGRyZW4oY2hpbGRyZW4sIF9pbmRleDQsIDEsIG5ld05vZGUsIG5leHROb2RlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0cmFuc2Zvcm1TZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0cmFuc2Zvcm1TZWxlY3Rpb24gJiYgZWRpdG9yLnNlbGVjdGlvbikge1xuICAgICAgdmFyIF9zZWxlY3Rpb24yID0gX29iamVjdFNwcmVhZCRlKHt9LCBlZGl0b3Iuc2VsZWN0aW9uKTtcbiAgICAgIGZvciAodmFyIFtfcG9pbnQsIF9rZXk2XSBvZiBSYW5nZS5wb2ludHMoX3NlbGVjdGlvbjIpKSB7XG4gICAgICAgIF9zZWxlY3Rpb24yW19rZXk2XSA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQsIG9wKTtcbiAgICAgIH1cbiAgICAgIGVkaXRvci5zZWxlY3Rpb24gPSBfc2VsZWN0aW9uMjtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbnZhciBOb2RlVHJhbnNmb3JtcyA9IHtcbiAgaW5zZXJ0Tm9kZXMoZWRpdG9yLCBub2Rlcywgb3B0aW9ucykge1xuICAgIGVkaXRvci5pbnNlcnROb2Rlcyhub2Rlcywgb3B0aW9ucyk7XG4gIH0sXG4gIGxpZnROb2RlcyhlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3IubGlmdE5vZGVzKG9wdGlvbnMpO1xuICB9LFxuICBtZXJnZU5vZGVzKGVkaXRvciwgb3B0aW9ucykge1xuICAgIGVkaXRvci5tZXJnZU5vZGVzKG9wdGlvbnMpO1xuICB9LFxuICBtb3ZlTm9kZXMoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLm1vdmVOb2RlcyhvcHRpb25zKTtcbiAgfSxcbiAgcmVtb3ZlTm9kZXMoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLnJlbW92ZU5vZGVzKG9wdGlvbnMpO1xuICB9LFxuICBzZXROb2RlcyhlZGl0b3IsIHByb3BzLCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLnNldE5vZGVzKHByb3BzLCBvcHRpb25zKTtcbiAgfSxcbiAgc3BsaXROb2RlcyhlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3Iuc3BsaXROb2RlcyhvcHRpb25zKTtcbiAgfSxcbiAgdW5zZXROb2RlcyhlZGl0b3IsIHByb3BzLCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLnVuc2V0Tm9kZXMocHJvcHMsIG9wdGlvbnMpO1xuICB9LFxuICB1bndyYXBOb2RlcyhlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3IudW53cmFwTm9kZXMob3B0aW9ucyk7XG4gIH0sXG4gIHdyYXBOb2RlcyhlZGl0b3IsIGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3Iud3JhcE5vZGVzKGVsZW1lbnQsIG9wdGlvbnMpO1xuICB9XG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG52YXIgU2VsZWN0aW9uVHJhbnNmb3JtcyA9IHtcbiAgY29sbGFwc2UoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLmNvbGxhcHNlKG9wdGlvbnMpO1xuICB9LFxuICBkZXNlbGVjdChlZGl0b3IpIHtcbiAgICBlZGl0b3IuZGVzZWxlY3QoKTtcbiAgfSxcbiAgbW92ZShlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3IubW92ZShvcHRpb25zKTtcbiAgfSxcbiAgc2VsZWN0KGVkaXRvciwgdGFyZ2V0KSB7XG4gICAgZWRpdG9yLnNlbGVjdCh0YXJnZXQpO1xuICB9LFxuICBzZXRQb2ludChlZGl0b3IsIHByb3BzLCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLnNldFBvaW50KHByb3BzLCBvcHRpb25zKTtcbiAgfSxcbiAgc2V0U2VsZWN0aW9uKGVkaXRvciwgcHJvcHMpIHtcbiAgICBlZGl0b3Iuc2V0U2VsZWN0aW9uKHByb3BzKTtcbiAgfVxufTtcblxudmFyIGlzT2JqZWN0ID0gdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbDtcblxuLypcbiAgQ3VzdG9tIGRlZXAgZXF1YWwgY29tcGFyaXNvbiBmb3IgU2xhdGUgbm9kZXMuXG5cbiAgV2UgZG9uJ3QgbmVlZCBnZW5lcmFsIHB1cnBvc2UgZGVlcCBlcXVhbGl0eTtcbiAgU2xhdGUgb25seSBzdXBwb3J0cyBwbGFpbiB2YWx1ZXMsIEFycmF5cywgYW5kIG5lc3RlZCBvYmplY3RzLlxuICBDb21wbGV4IHZhbHVlcyBuZXN0ZWQgaW5zaWRlIEFycmF5cyBhcmUgbm90IHN1cHBvcnRlZC5cblxuICBTbGF0ZSBvYmplY3RzIGFyZSBkZXNpZ25lZCB0byBiZSBzZXJpYWxpc2VkLCBzb1xuICBtaXNzaW5nIGtleXMgYXJlIGRlbGliZXJhdGVseSBub3JtYWxpc2VkIHRvIHVuZGVmaW5lZC5cbiAqL1xudmFyIGlzRGVlcEVxdWFsID0gKG5vZGUsIGFub3RoZXIpID0+IHtcbiAgZm9yICh2YXIga2V5IGluIG5vZGUpIHtcbiAgICB2YXIgYSA9IG5vZGVba2V5XTtcbiAgICB2YXIgYiA9IGFub3RoZXJba2V5XTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSAmJiBBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGEpICYmIGlzT2JqZWN0KGIpKSB7XG4gICAgICBpZiAoIWlzRGVlcEVxdWFsKGEsIGIpKSByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChhICE9PSBiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8qXG4gICAgRGVlcCBvYmplY3QgZXF1YWxpdHkgaXMgb25seSBuZWNlc3NhcnkgaW4gb25lIGRpcmVjdGlvbjsgaW4gdGhlIHJldmVyc2UgZGlyZWN0aW9uXG4gICAgd2UgYXJlIG9ubHkgbG9va2luZyBmb3Iga2V5cyB0aGF0IGFyZSBtaXNzaW5nLlxuICAgIEFzIGFib3ZlLCB1bmRlZmluZWQga2V5cyBhcmUgbm9ybWFsaXNlZCB0byBtaXNzaW5nLlxuICAqL1xuICBmb3IgKHZhciBfa2V5IGluIGFub3RoZXIpIHtcbiAgICBpZiAobm9kZVtfa2V5XSA9PT0gdW5kZWZpbmVkICYmIGFub3RoZXJbX2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG4gIHZhciBrZXksIGk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbnZhciBfZXhjbHVkZWQkNCA9IFtcImFuY2hvclwiLCBcImZvY3VzXCJdO1xuZnVuY3Rpb24gb3duS2V5cyRkKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJGQoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJGQoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbnZhciBSYW5nZSA9IHtcbiAgZWRnZXMocmFuZ2UpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIHJldmVyc2UgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH0gPSByYW5nZTtcbiAgICByZXR1cm4gUmFuZ2UuaXNCYWNrd2FyZChyYW5nZSkgPT09IHJldmVyc2UgPyBbYW5jaG9yLCBmb2N1c10gOiBbZm9jdXMsIGFuY2hvcl07XG4gIH0sXG4gIGVuZChyYW5nZSkge1xuICAgIHZhciBbLCBlbmRdID0gUmFuZ2UuZWRnZXMocmFuZ2UpO1xuICAgIHJldHVybiBlbmQ7XG4gIH0sXG4gIGVxdWFscyhyYW5nZSwgYW5vdGhlcikge1xuICAgIHJldHVybiBQb2ludC5lcXVhbHMocmFuZ2UuYW5jaG9yLCBhbm90aGVyLmFuY2hvcikgJiYgUG9pbnQuZXF1YWxzKHJhbmdlLmZvY3VzLCBhbm90aGVyLmZvY3VzKTtcbiAgfSxcbiAgc3Vycm91bmRzKHJhbmdlLCB0YXJnZXQpIHtcbiAgICB2YXIgaW50ZXJzZWN0aW9uUmFuZ2UgPSBSYW5nZS5pbnRlcnNlY3Rpb24ocmFuZ2UsIHRhcmdldCk7XG4gICAgaWYgKCFpbnRlcnNlY3Rpb25SYW5nZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gUmFuZ2UuZXF1YWxzKGludGVyc2VjdGlvblJhbmdlLCB0YXJnZXQpO1xuICB9LFxuICBpbmNsdWRlcyhyYW5nZSwgdGFyZ2V0KSB7XG4gICAgaWYgKFJhbmdlLmlzUmFuZ2UodGFyZ2V0KSkge1xuICAgICAgaWYgKFJhbmdlLmluY2x1ZGVzKHJhbmdlLCB0YXJnZXQuYW5jaG9yKSB8fCBSYW5nZS5pbmNsdWRlcyhyYW5nZSwgdGFyZ2V0LmZvY3VzKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBbcnMsIHJlXSA9IFJhbmdlLmVkZ2VzKHJhbmdlKTtcbiAgICAgIHZhciBbdHMsIHRlXSA9IFJhbmdlLmVkZ2VzKHRhcmdldCk7XG4gICAgICByZXR1cm4gUG9pbnQuaXNCZWZvcmUocnMsIHRzKSAmJiBQb2ludC5pc0FmdGVyKHJlLCB0ZSk7XG4gICAgfVxuICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gICAgdmFyIGlzQWZ0ZXJTdGFydCA9IGZhbHNlO1xuICAgIHZhciBpc0JlZm9yZUVuZCA9IGZhbHNlO1xuICAgIGlmIChQb2ludC5pc1BvaW50KHRhcmdldCkpIHtcbiAgICAgIGlzQWZ0ZXJTdGFydCA9IFBvaW50LmNvbXBhcmUodGFyZ2V0LCBzdGFydCkgPj0gMDtcbiAgICAgIGlzQmVmb3JlRW5kID0gUG9pbnQuY29tcGFyZSh0YXJnZXQsIGVuZCkgPD0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgaXNBZnRlclN0YXJ0ID0gUGF0aC5jb21wYXJlKHRhcmdldCwgc3RhcnQucGF0aCkgPj0gMDtcbiAgICAgIGlzQmVmb3JlRW5kID0gUGF0aC5jb21wYXJlKHRhcmdldCwgZW5kLnBhdGgpIDw9IDA7XG4gICAgfVxuICAgIHJldHVybiBpc0FmdGVyU3RhcnQgJiYgaXNCZWZvcmVFbmQ7XG4gIH0sXG4gIGludGVyc2VjdGlvbihyYW5nZSwgYW5vdGhlcikge1xuICAgIHZhciByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHJhbmdlLCBfZXhjbHVkZWQkNCk7XG4gICAgdmFyIFtzMSwgZTFdID0gUmFuZ2UuZWRnZXMocmFuZ2UpO1xuICAgIHZhciBbczIsIGUyXSA9IFJhbmdlLmVkZ2VzKGFub3RoZXIpO1xuICAgIHZhciBzdGFydCA9IFBvaW50LmlzQmVmb3JlKHMxLCBzMikgPyBzMiA6IHMxO1xuICAgIHZhciBlbmQgPSBQb2ludC5pc0JlZm9yZShlMSwgZTIpID8gZTEgOiBlMjtcbiAgICBpZiAoUG9pbnQuaXNCZWZvcmUoZW5kLCBzdGFydCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZCRkKHtcbiAgICAgICAgYW5jaG9yOiBzdGFydCxcbiAgICAgICAgZm9jdXM6IGVuZFxuICAgICAgfSwgcmVzdCk7XG4gICAgfVxuICB9LFxuICBpc0JhY2t3YXJkKHJhbmdlKSB7XG4gICAgdmFyIHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzXG4gICAgfSA9IHJhbmdlO1xuICAgIHJldHVybiBQb2ludC5pc0FmdGVyKGFuY2hvciwgZm9jdXMpO1xuICB9LFxuICBpc0NvbGxhcHNlZChyYW5nZSkge1xuICAgIHZhciB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH0gPSByYW5nZTtcbiAgICByZXR1cm4gUG9pbnQuZXF1YWxzKGFuY2hvciwgZm9jdXMpO1xuICB9LFxuICBpc0V4cGFuZGVkKHJhbmdlKSB7XG4gICAgcmV0dXJuICFSYW5nZS5pc0NvbGxhcHNlZChyYW5nZSk7XG4gIH0sXG4gIGlzRm9yd2FyZChyYW5nZSkge1xuICAgIHJldHVybiAhUmFuZ2UuaXNCYWNrd2FyZChyYW5nZSk7XG4gIH0sXG4gIGlzUmFuZ2UodmFsdWUpIHtcbiAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIFBvaW50LmlzUG9pbnQodmFsdWUuYW5jaG9yKSAmJiBQb2ludC5pc1BvaW50KHZhbHVlLmZvY3VzKTtcbiAgfSxcbiAgKnBvaW50cyhyYW5nZSkge1xuICAgIHlpZWxkIFtyYW5nZS5hbmNob3IsICdhbmNob3InXTtcbiAgICB5aWVsZCBbcmFuZ2UuZm9jdXMsICdmb2N1cyddO1xuICB9LFxuICBzdGFydChyYW5nZSkge1xuICAgIHZhciBbc3RhcnRdID0gUmFuZ2UuZWRnZXMocmFuZ2UpO1xuICAgIHJldHVybiBzdGFydDtcbiAgfSxcbiAgdHJhbnNmb3JtKHJhbmdlLCBvcCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBpZiAocmFuZ2UgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIge1xuICAgICAgYWZmaW5pdHkgPSAnaW53YXJkJ1xuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciBhZmZpbml0eUFuY2hvcjtcbiAgICB2YXIgYWZmaW5pdHlGb2N1cztcbiAgICBpZiAoYWZmaW5pdHkgPT09ICdpbndhcmQnKSB7XG4gICAgICAvLyBJZiB0aGUgcmFuZ2UgaXMgY29sbGFwc2VkLCBtYWtlIHN1cmUgdG8gdXNlIHRoZSBzYW1lIGFmZmluaXR5IHRvXG4gICAgICAvLyBhdm9pZCB0aGUgdHdvIHBvaW50cyBwYXNzaW5nIGVhY2ggb3RoZXIgYW5kIGV4cGFuZGluZyBpbiB0aGUgb3Bwb3NpdGVcbiAgICAgIC8vIGRpcmVjdGlvblxuICAgICAgdmFyIGlzQ29sbGFwc2VkID0gUmFuZ2UuaXNDb2xsYXBzZWQocmFuZ2UpO1xuICAgICAgaWYgKFJhbmdlLmlzRm9yd2FyZChyYW5nZSkpIHtcbiAgICAgICAgYWZmaW5pdHlBbmNob3IgPSAnZm9yd2FyZCc7XG4gICAgICAgIGFmZmluaXR5Rm9jdXMgPSBpc0NvbGxhcHNlZCA/IGFmZmluaXR5QW5jaG9yIDogJ2JhY2t3YXJkJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFmZmluaXR5QW5jaG9yID0gJ2JhY2t3YXJkJztcbiAgICAgICAgYWZmaW5pdHlGb2N1cyA9IGlzQ29sbGFwc2VkID8gYWZmaW5pdHlBbmNob3IgOiAnZm9yd2FyZCc7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhZmZpbml0eSA9PT0gJ291dHdhcmQnKSB7XG4gICAgICBpZiAoUmFuZ2UuaXNGb3J3YXJkKHJhbmdlKSkge1xuICAgICAgICBhZmZpbml0eUFuY2hvciA9ICdiYWNrd2FyZCc7XG4gICAgICAgIGFmZmluaXR5Rm9jdXMgPSAnZm9yd2FyZCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZmZpbml0eUFuY2hvciA9ICdmb3J3YXJkJztcbiAgICAgICAgYWZmaW5pdHlGb2N1cyA9ICdiYWNrd2FyZCc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmZmluaXR5QW5jaG9yID0gYWZmaW5pdHk7XG4gICAgICBhZmZpbml0eUZvY3VzID0gYWZmaW5pdHk7XG4gICAgfVxuICAgIHZhciBhbmNob3IgPSBQb2ludC50cmFuc2Zvcm0ocmFuZ2UuYW5jaG9yLCBvcCwge1xuICAgICAgYWZmaW5pdHk6IGFmZmluaXR5QW5jaG9yXG4gICAgfSk7XG4gICAgdmFyIGZvY3VzID0gUG9pbnQudHJhbnNmb3JtKHJhbmdlLmZvY3VzLCBvcCwge1xuICAgICAgYWZmaW5pdHk6IGFmZmluaXR5Rm9jdXNcbiAgICB9KTtcbiAgICBpZiAoIWFuY2hvciB8fCAhZm9jdXMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgYW5jaG9yLFxuICAgICAgZm9jdXNcbiAgICB9O1xuICB9XG59O1xuXG4vKipcbiAqIFNoYXJlZCB0aGUgZnVuY3Rpb24gd2l0aCBpc0VsZW1lbnRUeXBlIHV0aWxpdHlcbiAqL1xudmFyIGlzRWxlbWVudCA9IGZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xuICB2YXIge1xuICAgIGRlZXAgPSBmYWxzZVxuICB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHJldHVybiBmYWxzZTtcbiAgLy8gUEVSRjogTm8gbmVlZCB0byB1c2UgdGhlIGZ1bGwgRWRpdG9yLmlzRWRpdG9yIGhlcmVcbiAgdmFyIGlzRWRpdG9yID0gdHlwZW9mIHZhbHVlLmFwcGx5ID09PSAnZnVuY3Rpb24nO1xuICBpZiAoaXNFZGl0b3IpIHJldHVybiBmYWxzZTtcbiAgdmFyIGlzQ2hpbGRyZW5WYWxpZCA9IGRlZXAgPyBOb2RlLmlzTm9kZUxpc3QodmFsdWUuY2hpbGRyZW4pIDogQXJyYXkuaXNBcnJheSh2YWx1ZS5jaGlsZHJlbik7XG4gIHJldHVybiBpc0NoaWxkcmVuVmFsaWQ7XG59O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIEVsZW1lbnQgPSB7XG4gIGlzQW5jZXN0b3IodmFsdWUpIHtcbiAgICB2YXIge1xuICAgICAgZGVlcCA9IGZhbHNlXG4gICAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBOb2RlLmlzTm9kZUxpc3QodmFsdWUuY2hpbGRyZW4sIHtcbiAgICAgIGRlZXBcbiAgICB9KTtcbiAgfSxcbiAgaXNFbGVtZW50LFxuICBpc0VsZW1lbnRMaXN0KHZhbHVlKSB7XG4gICAgdmFyIHtcbiAgICAgIGRlZXAgPSBmYWxzZVxuICAgIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeSh2YWwgPT4gRWxlbWVudC5pc0VsZW1lbnQodmFsLCB7XG4gICAgICBkZWVwXG4gICAgfSkpO1xuICB9LFxuICBpc0VsZW1lbnRQcm9wcyhwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy5jaGlsZHJlbiAhPT0gdW5kZWZpbmVkO1xuICB9LFxuICBpc0VsZW1lbnRUeXBlOiBmdW5jdGlvbiBpc0VsZW1lbnRUeXBlKHZhbHVlLCBlbGVtZW50VmFsKSB7XG4gICAgdmFyIGVsZW1lbnRLZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICd0eXBlJztcbiAgICByZXR1cm4gaXNFbGVtZW50KHZhbHVlKSAmJiB2YWx1ZVtlbGVtZW50S2V5XSA9PT0gZWxlbWVudFZhbDtcbiAgfSxcbiAgbWF0Y2hlcyhlbGVtZW50LCBwcm9wcykge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgaWYgKGtleSA9PT0gJ2NoaWxkcmVuJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50W2tleV0gIT09IHByb3BzW2tleV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxudmFyIF9leGNsdWRlZCQzID0gW1wiY2hpbGRyZW5cIl0sXG4gIF9leGNsdWRlZDIkMyA9IFtcInRleHRcIl07XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG52YXIgTm9kZSA9IHtcbiAgYW5jZXN0b3Iocm9vdCwgcGF0aCkge1xuICAgIHZhciBub2RlID0gTm9kZS5nZXQocm9vdCwgcGF0aCk7XG4gICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBhbmNlc3RvciBub2RlIGF0IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSBpdCByZWZlcnMgdG8gYSB0ZXh0IG5vZGUgaW5zdGVhZDogXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkobm9kZSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG4gIGFuY2VzdG9ycyhyb290LCBwYXRoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yICh2YXIgcCBvZiBQYXRoLmFuY2VzdG9ycyhwYXRoLCBvcHRpb25zKSkge1xuICAgICAgICB2YXIgbiA9IE5vZGUuYW5jZXN0b3Iocm9vdCwgcCk7XG4gICAgICAgIHZhciBlbnRyeSA9IFtuLCBwXTtcbiAgICAgICAgeWllbGQgZW50cnk7XG4gICAgICB9XG4gICAgfSgpO1xuICB9LFxuICBjaGlsZChyb290LCBpbmRleCkge1xuICAgIGlmIChUZXh0LmlzVGV4dChyb290KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgY2hpbGQgb2YgYSB0ZXh0IG5vZGU6IFwiLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkocm9vdCkpKTtcbiAgICB9XG4gICAgdmFyIGMgPSByb290LmNoaWxkcmVuW2luZGV4XTtcbiAgICBpZiAoYyA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IGNoaWxkIGF0IGluZGV4IGBcIi5jb25jYXQoaW5kZXgsIFwiYCBpbiBub2RlOiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShyb290KSkpO1xuICAgIH1cbiAgICByZXR1cm4gYztcbiAgfSxcbiAgY2hpbGRyZW4ocm9vdCwgcGF0aCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciB7XG4gICAgICAgIHJldmVyc2UgPSBmYWxzZVxuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBOb2RlLmFuY2VzdG9yKHJvb3QsIHBhdGgpO1xuICAgICAgdmFyIHtcbiAgICAgICAgY2hpbGRyZW5cbiAgICAgIH0gPSBhbmNlc3RvcjtcbiAgICAgIHZhciBpbmRleCA9IHJldmVyc2UgPyBjaGlsZHJlbi5sZW5ndGggLSAxIDogMDtcbiAgICAgIHdoaWxlIChyZXZlcnNlID8gaW5kZXggPj0gMCA6IGluZGV4IDwgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IE5vZGUuY2hpbGQoYW5jZXN0b3IsIGluZGV4KTtcbiAgICAgICAgdmFyIGNoaWxkUGF0aCA9IHBhdGguY29uY2F0KGluZGV4KTtcbiAgICAgICAgeWllbGQgW2NoaWxkLCBjaGlsZFBhdGhdO1xuICAgICAgICBpbmRleCA9IHJldmVyc2UgPyBpbmRleCAtIDEgOiBpbmRleCArIDE7XG4gICAgICB9XG4gICAgfSgpO1xuICB9LFxuICBjb21tb24ocm9vdCwgcGF0aCwgYW5vdGhlcikge1xuICAgIHZhciBwID0gUGF0aC5jb21tb24ocGF0aCwgYW5vdGhlcik7XG4gICAgdmFyIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICByZXR1cm4gW24sIHBdO1xuICB9LFxuICBkZXNjZW5kYW50KHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IE5vZGUuZ2V0KHJvb3QsIHBhdGgpO1xuICAgIGlmIChFZGl0b3IuaXNFZGl0b3Iobm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIGRlc2NlbmRhbnQgbm9kZSBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgaXQgcmVmZXJzIHRvIHRoZSByb290IGVkaXRvciBub2RlIGluc3RlYWQ6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KG5vZGUpKSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9LFxuICBkZXNjZW5kYW50cyhyb290KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIE5vZGUubm9kZXMocm9vdCwgb3B0aW9ucykpIHtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgLy8gTk9URTogd2UgaGF2ZSB0byBjb2VyY2UgaGVyZSBiZWNhdXNlIGNoZWNraW5nIHRoZSBwYXRoJ3MgbGVuZ3RoIGRvZXNcbiAgICAgICAgICAvLyBndWFyYW50ZWUgdGhhdCBgbm9kZWAgaXMgbm90IGEgYEVkaXRvcmAsIGJ1dCBUeXBlU2NyaXB0IGRvZXNuJ3Qga25vdy5cbiAgICAgICAgICB5aWVsZCBbbm9kZSwgcGF0aF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KCk7XG4gIH0sXG4gIGVsZW1lbnRzKHJvb3QpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBmb3IgKHZhciBbbm9kZSwgcGF0aF0gb2YgTm9kZS5ub2Rlcyhyb290LCBvcHRpb25zKSkge1xuICAgICAgICBpZiAoRWxlbWVudC5pc0VsZW1lbnQobm9kZSkpIHtcbiAgICAgICAgICB5aWVsZCBbbm9kZSwgcGF0aF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KCk7XG4gIH0sXG4gIGV4dHJhY3RQcm9wcyhub2RlKSB7XG4gICAgaWYgKEVsZW1lbnQuaXNBbmNlc3Rvcihub2RlKSkge1xuICAgICAgdmFyIHByb3BlcnRpZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMobm9kZSwgX2V4Y2x1ZGVkJDMpO1xuICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwcm9wZXJ0aWVzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG5vZGUsIF9leGNsdWRlZDIkMyk7XG4gICAgICByZXR1cm4gcHJvcGVydGllcztcbiAgICB9XG4gIH0sXG4gIGZpcnN0KHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgcCA9IHBhdGguc2xpY2UoKTtcbiAgICB2YXIgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgIHdoaWxlIChuKSB7XG4gICAgICBpZiAoVGV4dC5pc1RleHQobikgfHwgbi5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gbi5jaGlsZHJlblswXTtcbiAgICAgICAgcC5wdXNoKDApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW24sIHBdO1xuICB9LFxuICBmcmFnbWVudChyb290LCByYW5nZSkge1xuICAgIGlmIChUZXh0LmlzVGV4dChyb290KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCBhIGZyYWdtZW50IHN0YXJ0aW5nIGZyb20gYSByb290IHRleHQgbm9kZTogXCIuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShyb290KSkpO1xuICAgIH1cbiAgICB2YXIgbmV3Um9vdCA9IHByb2R1Y2Uoe1xuICAgICAgY2hpbGRyZW46IHJvb3QuY2hpbGRyZW5cbiAgICB9LCByID0+IHtcbiAgICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gICAgICB2YXIgbm9kZUVudHJpZXMgPSBOb2RlLm5vZGVzKHIsIHtcbiAgICAgICAgcmV2ZXJzZTogdHJ1ZSxcbiAgICAgICAgcGFzczogX3JlZiA9PiB7XG4gICAgICAgICAgdmFyIFssIHBhdGhdID0gX3JlZjtcbiAgICAgICAgICByZXR1cm4gIVJhbmdlLmluY2x1ZGVzKHJhbmdlLCBwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBmb3IgKHZhciBbLCBwYXRoXSBvZiBub2RlRW50cmllcykge1xuICAgICAgICBpZiAoIVJhbmdlLmluY2x1ZGVzKHJhbmdlLCBwYXRoKSkge1xuICAgICAgICAgIHZhciBwYXJlbnQgPSBOb2RlLnBhcmVudChyLCBwYXRoKTtcbiAgICAgICAgICB2YXIgaW5kZXggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFBhdGguZXF1YWxzKHBhdGgsIGVuZC5wYXRoKSkge1xuICAgICAgICAgIHZhciBsZWFmID0gTm9kZS5sZWFmKHIsIHBhdGgpO1xuICAgICAgICAgIGxlYWYudGV4dCA9IGxlYWYudGV4dC5zbGljZSgwLCBlbmQub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoUGF0aC5lcXVhbHMocGF0aCwgc3RhcnQucGF0aCkpIHtcbiAgICAgICAgICB2YXIgX2xlYWYgPSBOb2RlLmxlYWYociwgcGF0aCk7XG4gICAgICAgICAgX2xlYWYudGV4dCA9IF9sZWFmLnRleHQuc2xpY2Uoc3RhcnQub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKEVkaXRvci5pc0VkaXRvcihyKSkge1xuICAgICAgICByLnNlbGVjdGlvbiA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ld1Jvb3QuY2hpbGRyZW47XG4gIH0sXG4gIGdldChyb290LCBwYXRoKSB7XG4gICAgdmFyIG5vZGUgPSBOb2RlLmdldElmKHJvb3QsIHBhdGgpO1xuICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIGEgZGVzY2VuZGFudCBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGluIG5vZGU6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KHJvb3QpKSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9LFxuICBnZXRJZihyb290LCBwYXRoKSB7XG4gICAgdmFyIG5vZGUgPSByb290O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHAgPSBwYXRoW2ldO1xuICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpIHx8ICFub2RlLmNoaWxkcmVuW3BdKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuW3BdO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfSxcbiAgaGFzKHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IHJvb3Q7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcCA9IHBhdGhbaV07XG4gICAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkgfHwgIW5vZGUuY2hpbGRyZW5bcF0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5bcF07XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBpc05vZGUodmFsdWUpIHtcbiAgICB2YXIge1xuICAgICAgZGVlcCA9IGZhbHNlXG4gICAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgcmV0dXJuIFRleHQuaXNUZXh0KHZhbHVlKSB8fCBFbGVtZW50LmlzRWxlbWVudCh2YWx1ZSwge1xuICAgICAgZGVlcFxuICAgIH0pIHx8IEVkaXRvci5pc0VkaXRvcih2YWx1ZSwge1xuICAgICAgZGVlcFxuICAgIH0pO1xuICB9LFxuICBpc05vZGVMaXN0KHZhbHVlKSB7XG4gICAgdmFyIHtcbiAgICAgIGRlZXAgPSBmYWxzZVxuICAgIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeSh2YWwgPT4gTm9kZS5pc05vZGUodmFsLCB7XG4gICAgICBkZWVwXG4gICAgfSkpO1xuICB9LFxuICBsYXN0KHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgcCA9IHBhdGguc2xpY2UoKTtcbiAgICB2YXIgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgIHdoaWxlIChuKSB7XG4gICAgICBpZiAoVGV4dC5pc1RleHQobikgfHwgbi5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaSA9IG4uY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICAgICAgbiA9IG4uY2hpbGRyZW5baV07XG4gICAgICAgIHAucHVzaChpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtuLCBwXTtcbiAgfSxcbiAgbGVhZihyb290LCBwYXRoKSB7XG4gICAgdmFyIG5vZGUgPSBOb2RlLmdldChyb290LCBwYXRoKTtcbiAgICBpZiAoIVRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBsZWFmIG5vZGUgYXQgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBiZWNhdXNlIGl0IHJlZmVycyB0byBhIG5vbi1sZWFmIG5vZGU6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KG5vZGUpKSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9LFxuICBsZXZlbHMocm9vdCwgcGF0aCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgIGZvciAodmFyIHAgb2YgUGF0aC5sZXZlbHMocGF0aCwgb3B0aW9ucykpIHtcbiAgICAgICAgdmFyIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICAgICAgeWllbGQgW24sIHBdO1xuICAgICAgfVxuICAgIH0oKTtcbiAgfSxcbiAgbWF0Y2hlcyhub2RlLCBwcm9wcykge1xuICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBFbGVtZW50LmlzRWxlbWVudFByb3BzKHByb3BzKSAmJiBFbGVtZW50Lm1hdGNoZXMobm9kZSwgcHJvcHMpIHx8IFRleHQuaXNUZXh0KG5vZGUpICYmIFRleHQuaXNUZXh0UHJvcHMocHJvcHMpICYmIFRleHQubWF0Y2hlcyhub2RlLCBwcm9wcyk7XG4gIH0sXG4gIG5vZGVzKHJvb3QpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIge1xuICAgICAgICBwYXNzLFxuICAgICAgICByZXZlcnNlID0gZmFsc2VcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgdmFyIHtcbiAgICAgICAgZnJvbSA9IFtdLFxuICAgICAgICB0b1xuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICB2YXIgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgICAgIHZhciBwID0gW107XG4gICAgICB2YXIgbiA9IHJvb3Q7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAodG8gJiYgKHJldmVyc2UgPyBQYXRoLmlzQmVmb3JlKHAsIHRvKSA6IFBhdGguaXNBZnRlcihwLCB0bykpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF2aXNpdGVkLmhhcyhuKSkge1xuICAgICAgICAgIHlpZWxkIFtuLCBwXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSdyZSBhbGxvd2VkIHRvIGdvIGRvd253YXJkIGFuZCB3ZSBoYXZlbid0IGRlc2NlbmRlZCB5ZXQsIGRvLlxuICAgICAgICBpZiAoIXZpc2l0ZWQuaGFzKG4pICYmICFUZXh0LmlzVGV4dChuKSAmJiBuLmNoaWxkcmVuLmxlbmd0aCAhPT0gMCAmJiAocGFzcyA9PSBudWxsIHx8IHBhc3MoW24sIHBdKSA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgdmlzaXRlZC5hZGQobik7XG4gICAgICAgICAgdmFyIG5leHRJbmRleCA9IHJldmVyc2UgPyBuLmNoaWxkcmVuLmxlbmd0aCAtIDEgOiAwO1xuICAgICAgICAgIGlmIChQYXRoLmlzQW5jZXN0b3IocCwgZnJvbSkpIHtcbiAgICAgICAgICAgIG5leHRJbmRleCA9IGZyb21bcC5sZW5ndGhdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwID0gcC5jb25jYXQobmV4dEluZGV4KTtcbiAgICAgICAgICBuID0gTm9kZS5nZXQocm9vdCwgcCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UncmUgYXQgdGhlIHJvb3QgYW5kIHdlIGNhbid0IGdvIGRvd24sIHdlJ3JlIGRvbmUuXG4gICAgICAgIGlmIChwLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlJ3JlIGdvaW5nIGZvcndhcmQuLi5cbiAgICAgICAgaWYgKCFyZXZlcnNlKSB7XG4gICAgICAgICAgdmFyIG5ld1BhdGggPSBQYXRoLm5leHQocCk7XG4gICAgICAgICAgaWYgKE5vZGUuaGFzKHJvb3QsIG5ld1BhdGgpKSB7XG4gICAgICAgICAgICBwID0gbmV3UGF0aDtcbiAgICAgICAgICAgIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSdyZSBnb2luZyBiYWNrd2FyZC4uLlxuICAgICAgICBpZiAocmV2ZXJzZSAmJiBwW3AubGVuZ3RoIC0gMV0gIT09IDApIHtcbiAgICAgICAgICB2YXIgX25ld1BhdGggPSBQYXRoLnByZXZpb3VzKHApO1xuICAgICAgICAgIHAgPSBfbmV3UGF0aDtcbiAgICAgICAgICBuID0gTm9kZS5nZXQocm9vdCwgcCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlIHdlJ3JlIGdvaW5nIHVwd2FyZC4uLlxuICAgICAgICBwID0gUGF0aC5wYXJlbnQocCk7XG4gICAgICAgIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICAgICAgdmlzaXRlZC5hZGQobik7XG4gICAgICB9XG4gICAgfSgpO1xuICB9LFxuICBwYXJlbnQocm9vdCwgcGF0aCkge1xuICAgIHZhciBwYXJlbnRQYXRoID0gUGF0aC5wYXJlbnQocGF0aCk7XG4gICAgdmFyIHAgPSBOb2RlLmdldChyb290LCBwYXJlbnRQYXRoKTtcbiAgICBpZiAoVGV4dC5pc1RleHQocCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIHBhcmVudCBvZiBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgaXQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIHJvb3QuXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH0sXG4gIHN0cmluZyhub2RlKSB7XG4gICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICByZXR1cm4gbm9kZS50ZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZS5jaGlsZHJlbi5tYXAoTm9kZS5zdHJpbmcpLmpvaW4oJycpO1xuICAgIH1cbiAgfSxcbiAgdGV4dHMocm9vdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgIGZvciAodmFyIFtub2RlLCBwYXRoXSBvZiBOb2RlLm5vZGVzKHJvb3QsIG9wdGlvbnMpKSB7XG4gICAgICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgICAgIHlpZWxkIFtub2RlLCBwYXRoXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0oKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gb3duS2V5cyRjKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkYyhlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJGMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJGMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbnZhciBPcGVyYXRpb24gPSB7XG4gIGlzTm9kZU9wZXJhdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBPcGVyYXRpb24uaXNPcGVyYXRpb24odmFsdWUpICYmIHZhbHVlLnR5cGUuZW5kc1dpdGgoJ19ub2RlJyk7XG4gIH0sXG4gIGlzT3BlcmF0aW9uKHZhbHVlKSB7XG4gICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3dpdGNoICh2YWx1ZS50eXBlKSB7XG4gICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICAgIHJldHVybiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKSAmJiBOb2RlLmlzTm9kZSh2YWx1ZS5ub2RlKTtcbiAgICAgIGNhc2UgJ2luc2VydF90ZXh0JzpcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZS5vZmZzZXQgPT09ICdudW1iZXInICYmIHR5cGVvZiB2YWx1ZS50ZXh0ID09PSAnc3RyaW5nJyAmJiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKTtcbiAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlLnBvc2l0aW9uID09PSAnbnVtYmVyJyAmJiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKSAmJiBpc09iamVjdCh2YWx1ZS5wcm9wZXJ0aWVzKTtcbiAgICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICAgIHJldHVybiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKSAmJiBQYXRoLmlzUGF0aCh2YWx1ZS5uZXdQYXRoKTtcbiAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIE5vZGUuaXNOb2RlKHZhbHVlLm5vZGUpO1xuICAgICAgY2FzZSAncmVtb3ZlX3RleHQnOlxuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlLm9mZnNldCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHZhbHVlLnRleHQgPT09ICdzdHJpbmcnICYmIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpO1xuICAgICAgY2FzZSAnc2V0X25vZGUnOlxuICAgICAgICByZXR1cm4gUGF0aC5pc1BhdGgodmFsdWUucGF0aCkgJiYgaXNPYmplY3QodmFsdWUucHJvcGVydGllcykgJiYgaXNPYmplY3QodmFsdWUubmV3UHJvcGVydGllcyk7XG4gICAgICBjYXNlICdzZXRfc2VsZWN0aW9uJzpcbiAgICAgICAgcmV0dXJuIHZhbHVlLnByb3BlcnRpZXMgPT09IG51bGwgJiYgUmFuZ2UuaXNSYW5nZSh2YWx1ZS5uZXdQcm9wZXJ0aWVzKSB8fCB2YWx1ZS5uZXdQcm9wZXJ0aWVzID09PSBudWxsICYmIFJhbmdlLmlzUmFuZ2UodmFsdWUucHJvcGVydGllcykgfHwgaXNPYmplY3QodmFsdWUucHJvcGVydGllcykgJiYgaXNPYmplY3QodmFsdWUubmV3UHJvcGVydGllcyk7XG4gICAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIHR5cGVvZiB2YWx1ZS5wb3NpdGlvbiA9PT0gJ251bWJlcicgJiYgaXNPYmplY3QodmFsdWUucHJvcGVydGllcyk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuICBpc09wZXJhdGlvbkxpc3QodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkodmFsID0+IE9wZXJhdGlvbi5pc09wZXJhdGlvbih2YWwpKTtcbiAgfSxcbiAgaXNTZWxlY3Rpb25PcGVyYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gT3BlcmF0aW9uLmlzT3BlcmF0aW9uKHZhbHVlKSAmJiB2YWx1ZS50eXBlLmVuZHNXaXRoKCdfc2VsZWN0aW9uJyk7XG4gIH0sXG4gIGlzVGV4dE9wZXJhdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBPcGVyYXRpb24uaXNPcGVyYXRpb24odmFsdWUpICYmIHZhbHVlLnR5cGUuZW5kc1dpdGgoJ190ZXh0Jyk7XG4gIH0sXG4gIGludmVyc2Uob3ApIHtcbiAgICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJGMoX29iamVjdFNwcmVhZCRjKHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICB0eXBlOiAncmVtb3ZlX25vZGUnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2luc2VydF90ZXh0JzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJGMoX29iamVjdFNwcmVhZCRjKHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICB0eXBlOiAncmVtb3ZlX3RleHQnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkYyhfb2JqZWN0U3ByZWFkJGMoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgIHR5cGU6ICdzcGxpdF9ub2RlJyxcbiAgICAgICAgICAgIHBhdGg6IFBhdGgucHJldmlvdXMob3AucGF0aClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICBuZXdQYXRoLFxuICAgICAgICAgICAgcGF0aFxuICAgICAgICAgIH0gPSBvcDtcbiAgICAgICAgICAvLyBQRVJGOiBpbiB0aGlzIGNhc2UgdGhlIG1vdmUgb3BlcmF0aW9uIGlzIGEgbm8tb3AgYW55d2F5cy5cbiAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMobmV3UGF0aCwgcGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBvcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gSWYgdGhlIG1vdmUgaGFwcGVucyBjb21wbGV0ZWx5IHdpdGhpbiBhIHNpbmdsZSBwYXJlbnQgdGhlIHBhdGggYW5kXG4gICAgICAgICAgLy8gbmV3UGF0aCBhcmUgc3RhYmxlIHdpdGggcmVzcGVjdCB0byBlYWNoIG90aGVyLlxuICAgICAgICAgIGlmIChQYXRoLmlzU2libGluZyhwYXRoLCBuZXdQYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkYyhfb2JqZWN0U3ByZWFkJGMoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgICAgcGF0aDogbmV3UGF0aCxcbiAgICAgICAgICAgICAgbmV3UGF0aDogcGF0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIElmIHRoZSBtb3ZlIGRvZXMgbm90IGhhcHBlbiB3aXRoaW4gYSBzaW5nbGUgcGFyZW50IGl0IGlzIHBvc3NpYmxlXG4gICAgICAgICAgLy8gZm9yIHRoZSBtb3ZlIHRvIGltcGFjdCB0aGUgdHJ1ZSBwYXRoIHRvIHRoZSBsb2NhdGlvbiB3aGVyZSB0aGUgbm9kZVxuICAgICAgICAgIC8vIHdhcyByZW1vdmVkIGZyb20gYW5kIHdoZXJlIGl0IHdhcyBpbnNlcnRlZC4gV2UgaGF2ZSB0byBhZGp1c3QgZm9yIHRoaXNcbiAgICAgICAgICAvLyBhbmQgZmluZCB0aGUgb3JpZ2luYWwgcGF0aC4gV2UgY2FuIGFjY29tcGxpc2ggdGhpcyAob25seSBpbiBub24tc2libGluZylcbiAgICAgICAgICAvLyBtb3ZlcyBieSBsb29raW5nIGF0IHRoZSBpbXBhY3Qgb2YgdGhlIG1vdmUgb3BlcmF0aW9uIG9uIHRoZSBub2RlXG4gICAgICAgICAgLy8gYWZ0ZXIgdGhlIG9yaWdpbmFsIG1vdmUgcGF0aC5cbiAgICAgICAgICB2YXIgaW52ZXJzZVBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCk7XG4gICAgICAgICAgdmFyIGludmVyc2VOZXdQYXRoID0gUGF0aC50cmFuc2Zvcm0oUGF0aC5uZXh0KHBhdGgpLCBvcCk7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkYyhfb2JqZWN0U3ByZWFkJGMoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgIHBhdGg6IGludmVyc2VQYXRoLFxuICAgICAgICAgICAgbmV3UGF0aDogaW52ZXJzZU5ld1BhdGhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAncmVtb3ZlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkYyhfb2JqZWN0U3ByZWFkJGMoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgIHR5cGU6ICdpbnNlcnRfbm9kZSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAncmVtb3ZlX3RleHQnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkYyhfb2JqZWN0U3ByZWFkJGMoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgIHR5cGU6ICdpbnNlcnRfdGV4dCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAnc2V0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMsXG4gICAgICAgICAgICBuZXdQcm9wZXJ0aWVzXG4gICAgICAgICAgfSA9IG9wO1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJGMoX29iamVjdFNwcmVhZCRjKHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBuZXdQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgbmV3UHJvcGVydGllczogcHJvcGVydGllc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICBjYXNlICdzZXRfc2VsZWN0aW9uJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBfcHJvcGVydGllcyxcbiAgICAgICAgICAgIG5ld1Byb3BlcnRpZXM6IF9uZXdQcm9wZXJ0aWVzXG4gICAgICAgICAgfSA9IG9wO1xuICAgICAgICAgIGlmIChfcHJvcGVydGllcyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCRjKF9vYmplY3RTcHJlYWQkYyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBfbmV3UHJvcGVydGllcyxcbiAgICAgICAgICAgICAgbmV3UHJvcGVydGllczogbnVsbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChfbmV3UHJvcGVydGllcyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCRjKF9vYmplY3RTcHJlYWQkYyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBudWxsLFxuICAgICAgICAgICAgICBuZXdQcm9wZXJ0aWVzOiBfcHJvcGVydGllc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJGMoX29iamVjdFNwcmVhZCRjKHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICAgIHByb3BlcnRpZXM6IF9uZXdQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICBuZXdQcm9wZXJ0aWVzOiBfcHJvcGVydGllc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJGMoX29iamVjdFNwcmVhZCRjKHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICB0eXBlOiAnbWVyZ2Vfbm9kZScsXG4gICAgICAgICAgICBwYXRoOiBQYXRoLm5leHQob3AucGF0aClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGlzRWRpdG9yID0gZnVuY3Rpb24gaXNFZGl0b3IodmFsdWUpIHtcbiAgdmFyIHtcbiAgICBkZWVwID0gZmFsc2VcbiAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpc0VkaXRvciA9IHR5cGVvZiB2YWx1ZS5hZGRNYXJrID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5hcHBseSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuZGVsZXRlRnJhZ21lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmluc2VydEJyZWFrID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pbnNlcnRTb2Z0QnJlYWsgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmluc2VydEZyYWdtZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pbnNlcnROb2RlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pbnNlcnRUZXh0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pc0VsZW1lbnRSZWFkT25seSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaXNJbmxpbmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmlzU2VsZWN0YWJsZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaXNWb2lkID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5ub3JtYWxpemVOb2RlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5vbkNoYW5nZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUucmVtb3ZlTWFyayA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuZ2V0RGlydHlQYXRocyA9PT0gJ2Z1bmN0aW9uJyAmJiAodmFsdWUubWFya3MgPT09IG51bGwgfHwgaXNPYmplY3QodmFsdWUubWFya3MpKSAmJiAodmFsdWUuc2VsZWN0aW9uID09PSBudWxsIHx8IFJhbmdlLmlzUmFuZ2UodmFsdWUuc2VsZWN0aW9uKSkgJiYgKCFkZWVwIHx8IE5vZGUuaXNOb2RlTGlzdCh2YWx1ZS5jaGlsZHJlbikpICYmIE9wZXJhdGlvbi5pc09wZXJhdGlvbkxpc3QodmFsdWUub3BlcmF0aW9ucyk7XG4gIHJldHVybiBpc0VkaXRvcjtcbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbnZhciBFZGl0b3IgPSB7XG4gIGFib3ZlKGVkaXRvciwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3IuYWJvdmUob3B0aW9ucyk7XG4gIH0sXG4gIGFkZE1hcmsoZWRpdG9yLCBrZXksIHZhbHVlKSB7XG4gICAgZWRpdG9yLmFkZE1hcmsoa2V5LCB2YWx1ZSk7XG4gIH0sXG4gIGFmdGVyKGVkaXRvciwgYXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLmFmdGVyKGF0LCBvcHRpb25zKTtcbiAgfSxcbiAgYmVmb3JlKGVkaXRvciwgYXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLmJlZm9yZShhdCwgb3B0aW9ucyk7XG4gIH0sXG4gIGRlbGV0ZUJhY2t3YXJkKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgdW5pdCA9ICdjaGFyYWN0ZXInXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgZWRpdG9yLmRlbGV0ZUJhY2t3YXJkKHVuaXQpO1xuICB9LFxuICBkZWxldGVGb3J3YXJkKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgdW5pdCA9ICdjaGFyYWN0ZXInXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgZWRpdG9yLmRlbGV0ZUZvcndhcmQodW5pdCk7XG4gIH0sXG4gIGRlbGV0ZUZyYWdtZW50KGVkaXRvciwgb3B0aW9ucykge1xuICAgIGVkaXRvci5kZWxldGVGcmFnbWVudChvcHRpb25zKTtcbiAgfSxcbiAgZWRnZXMoZWRpdG9yLCBhdCkge1xuICAgIHJldHVybiBlZGl0b3IuZWRnZXMoYXQpO1xuICB9LFxuICBlbGVtZW50UmVhZE9ubHkoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHJldHVybiBlZGl0b3IuZWxlbWVudFJlYWRPbmx5KG9wdGlvbnMpO1xuICB9LFxuICBlbmQoZWRpdG9yLCBhdCkge1xuICAgIHJldHVybiBlZGl0b3IuZW5kKGF0KTtcbiAgfSxcbiAgZmlyc3QoZWRpdG9yLCBhdCkge1xuICAgIHJldHVybiBlZGl0b3IuZmlyc3QoYXQpO1xuICB9LFxuICBmcmFnbWVudChlZGl0b3IsIGF0KSB7XG4gICAgcmV0dXJuIGVkaXRvci5mcmFnbWVudChhdCk7XG4gIH0sXG4gIGhhc0Jsb2NrcyhlZGl0b3IsIGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWRpdG9yLmhhc0Jsb2NrcyhlbGVtZW50KTtcbiAgfSxcbiAgaGFzSW5saW5lcyhlZGl0b3IsIGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWRpdG9yLmhhc0lubGluZXMoZWxlbWVudCk7XG4gIH0sXG4gIGhhc1BhdGgoZWRpdG9yLCBwYXRoKSB7XG4gICAgcmV0dXJuIGVkaXRvci5oYXNQYXRoKHBhdGgpO1xuICB9LFxuICBoYXNUZXh0cyhlZGl0b3IsIGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWRpdG9yLmhhc1RleHRzKGVsZW1lbnQpO1xuICB9LFxuICBpbnNlcnRCcmVhayhlZGl0b3IpIHtcbiAgICBlZGl0b3IuaW5zZXJ0QnJlYWsoKTtcbiAgfSxcbiAgaW5zZXJ0RnJhZ21lbnQoZWRpdG9yLCBmcmFnbWVudCwgb3B0aW9ucykge1xuICAgIGVkaXRvci5pbnNlcnRGcmFnbWVudChmcmFnbWVudCwgb3B0aW9ucyk7XG4gIH0sXG4gIGluc2VydE5vZGUoZWRpdG9yLCBub2RlKSB7XG4gICAgZWRpdG9yLmluc2VydE5vZGUobm9kZSk7XG4gIH0sXG4gIGluc2VydFNvZnRCcmVhayhlZGl0b3IpIHtcbiAgICBlZGl0b3IuaW5zZXJ0U29mdEJyZWFrKCk7XG4gIH0sXG4gIGluc2VydFRleHQoZWRpdG9yLCB0ZXh0KSB7XG4gICAgZWRpdG9yLmluc2VydFRleHQodGV4dCk7XG4gIH0sXG4gIGlzQmxvY2soZWRpdG9yLCB2YWx1ZSkge1xuICAgIHJldHVybiBlZGl0b3IuaXNCbG9jayh2YWx1ZSk7XG4gIH0sXG4gIGlzRWRnZShlZGl0b3IsIHBvaW50LCBhdCkge1xuICAgIHJldHVybiBlZGl0b3IuaXNFZGdlKHBvaW50LCBhdCk7XG4gIH0sXG4gIGlzRWRpdG9yKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzRWRpdG9yKHZhbHVlKTtcbiAgfSxcbiAgaXNFbGVtZW50UmVhZE9ubHkoZWRpdG9yLCBlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc0VsZW1lbnRSZWFkT25seShlbGVtZW50KTtcbiAgfSxcbiAgaXNFbXB0eShlZGl0b3IsIGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWRpdG9yLmlzRW1wdHkoZWxlbWVudCk7XG4gIH0sXG4gIGlzRW5kKGVkaXRvciwgcG9pbnQsIGF0KSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc0VuZChwb2ludCwgYXQpO1xuICB9LFxuICBpc0lubGluZShlZGl0b3IsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc0lubGluZSh2YWx1ZSk7XG4gIH0sXG4gIGlzTm9ybWFsaXppbmcoZWRpdG9yKSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc05vcm1hbGl6aW5nKCk7XG4gIH0sXG4gIGlzU2VsZWN0YWJsZShlZGl0b3IsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc1NlbGVjdGFibGUodmFsdWUpO1xuICB9LFxuICBpc1N0YXJ0KGVkaXRvciwgcG9pbnQsIGF0KSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc1N0YXJ0KHBvaW50LCBhdCk7XG4gIH0sXG4gIGlzVm9pZChlZGl0b3IsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc1ZvaWQodmFsdWUpO1xuICB9LFxuICBsYXN0KGVkaXRvciwgYXQpIHtcbiAgICByZXR1cm4gZWRpdG9yLmxhc3QoYXQpO1xuICB9LFxuICBsZWFmKGVkaXRvciwgYXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLmxlYWYoYXQsIG9wdGlvbnMpO1xuICB9LFxuICBsZXZlbHMoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5sZXZlbHMob3B0aW9ucyk7XG4gIH0sXG4gIG1hcmtzKGVkaXRvcikge1xuICAgIHJldHVybiBlZGl0b3IuZ2V0TWFya3MoKTtcbiAgfSxcbiAgbmV4dChlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLm5leHQob3B0aW9ucyk7XG4gIH0sXG4gIG5vZGUoZWRpdG9yLCBhdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3Iubm9kZShhdCwgb3B0aW9ucyk7XG4gIH0sXG4gIG5vZGVzKGVkaXRvciwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3Iubm9kZXMob3B0aW9ucyk7XG4gIH0sXG4gIG5vcm1hbGl6ZShlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3Iubm9ybWFsaXplKG9wdGlvbnMpO1xuICB9LFxuICBwYXJlbnQoZWRpdG9yLCBhdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3IucGFyZW50KGF0LCBvcHRpb25zKTtcbiAgfSxcbiAgcGF0aChlZGl0b3IsIGF0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5wYXRoKGF0LCBvcHRpb25zKTtcbiAgfSxcbiAgcGF0aFJlZihlZGl0b3IsIHBhdGgsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLnBhdGhSZWYocGF0aCwgb3B0aW9ucyk7XG4gIH0sXG4gIHBhdGhSZWZzKGVkaXRvcikge1xuICAgIHJldHVybiBlZGl0b3IucGF0aFJlZnMoKTtcbiAgfSxcbiAgcG9pbnQoZWRpdG9yLCBhdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3IucG9pbnQoYXQsIG9wdGlvbnMpO1xuICB9LFxuICBwb2ludFJlZihlZGl0b3IsIHBvaW50LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5wb2ludFJlZihwb2ludCwgb3B0aW9ucyk7XG4gIH0sXG4gIHBvaW50UmVmcyhlZGl0b3IpIHtcbiAgICByZXR1cm4gZWRpdG9yLnBvaW50UmVmcygpO1xuICB9LFxuICBwb3NpdGlvbnMoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5wb3NpdGlvbnMob3B0aW9ucyk7XG4gIH0sXG4gIHByZXZpb3VzKGVkaXRvciwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3IucHJldmlvdXMob3B0aW9ucyk7XG4gIH0sXG4gIHJhbmdlKGVkaXRvciwgYXQsIHRvKSB7XG4gICAgcmV0dXJuIGVkaXRvci5yYW5nZShhdCwgdG8pO1xuICB9LFxuICByYW5nZVJlZihlZGl0b3IsIHJhbmdlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5yYW5nZVJlZihyYW5nZSwgb3B0aW9ucyk7XG4gIH0sXG4gIHJhbmdlUmVmcyhlZGl0b3IpIHtcbiAgICByZXR1cm4gZWRpdG9yLnJhbmdlUmVmcygpO1xuICB9LFxuICByZW1vdmVNYXJrKGVkaXRvciwga2V5KSB7XG4gICAgZWRpdG9yLnJlbW92ZU1hcmsoa2V5KTtcbiAgfSxcbiAgc2V0Tm9ybWFsaXppbmcoZWRpdG9yLCBpc05vcm1hbGl6aW5nKSB7XG4gICAgZWRpdG9yLnNldE5vcm1hbGl6aW5nKGlzTm9ybWFsaXppbmcpO1xuICB9LFxuICBzdGFydChlZGl0b3IsIGF0KSB7XG4gICAgcmV0dXJuIGVkaXRvci5zdGFydChhdCk7XG4gIH0sXG4gIHN0cmluZyhlZGl0b3IsIGF0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5zdHJpbmcoYXQsIG9wdGlvbnMpO1xuICB9LFxuICB1bmhhbmdSYW5nZShlZGl0b3IsIHJhbmdlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci51bmhhbmdSYW5nZShyYW5nZSwgb3B0aW9ucyk7XG4gIH0sXG4gIHZvaWQoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci52b2lkKG9wdGlvbnMpO1xuICB9LFxuICB3aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCBmbikge1xuICAgIGVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZm4pO1xuICB9LFxuICBzaG91bGRNZXJnZU5vZGVzUmVtb3ZlUHJldk5vZGU6IChlZGl0b3IsIHByZXZOb2RlLCBjdXJOb2RlKSA9PiB7XG4gICAgcmV0dXJuIGVkaXRvci5zaG91bGRNZXJnZU5vZGVzUmVtb3ZlUHJldk5vZGUocHJldk5vZGUsIGN1ck5vZGUpO1xuICB9XG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG52YXIgTG9jYXRpb24gPSB7XG4gIGlzTG9jYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gUGF0aC5pc1BhdGgodmFsdWUpIHx8IFBvaW50LmlzUG9pbnQodmFsdWUpIHx8IFJhbmdlLmlzUmFuZ2UodmFsdWUpO1xuICB9XG59O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIFNwYW4gPSB7XG4gIGlzU3Bhbih2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDIgJiYgdmFsdWUuZXZlcnkoUGF0aC5pc1BhdGgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJGIoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCRiKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkYihPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkYihPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIFBvaW50ID0ge1xuICBjb21wYXJlKHBvaW50LCBhbm90aGVyKSB7XG4gICAgdmFyIHJlc3VsdCA9IFBhdGguY29tcGFyZShwb2ludC5wYXRoLCBhbm90aGVyLnBhdGgpO1xuICAgIGlmIChyZXN1bHQgPT09IDApIHtcbiAgICAgIGlmIChwb2ludC5vZmZzZXQgPCBhbm90aGVyLm9mZnNldCkgcmV0dXJuIC0xO1xuICAgICAgaWYgKHBvaW50Lm9mZnNldCA+IGFub3RoZXIub2Zmc2V0KSByZXR1cm4gMTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICBpc0FmdGVyKHBvaW50LCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIFBvaW50LmNvbXBhcmUocG9pbnQsIGFub3RoZXIpID09PSAxO1xuICB9LFxuICBpc0JlZm9yZShwb2ludCwgYW5vdGhlcikge1xuICAgIHJldHVybiBQb2ludC5jb21wYXJlKHBvaW50LCBhbm90aGVyKSA9PT0gLTE7XG4gIH0sXG4gIGVxdWFscyhwb2ludCwgYW5vdGhlcikge1xuICAgIC8vIFBFUkY6IGVuc3VyZSB0aGUgb2Zmc2V0cyBhcmUgZXF1YWwgZmlyc3Qgc2luY2UgdGhleSBhcmUgY2hlYXBlciB0byBjaGVjay5cbiAgICByZXR1cm4gcG9pbnQub2Zmc2V0ID09PSBhbm90aGVyLm9mZnNldCAmJiBQYXRoLmVxdWFscyhwb2ludC5wYXRoLCBhbm90aGVyLnBhdGgpO1xuICB9LFxuICBpc1BvaW50KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUub2Zmc2V0ID09PSAnbnVtYmVyJyAmJiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKTtcbiAgfSxcbiAgdHJhbnNmb3JtKHBvaW50LCBvcCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBpZiAocG9pbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIge1xuICAgICAgYWZmaW5pdHkgPSAnZm9yd2FyZCdcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgcGF0aCxcbiAgICAgIG9mZnNldFxuICAgIH0gPSBwb2ludDtcbiAgICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICBwYXRoID0gUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3AsIG9wdGlvbnMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkgJiYgKG9wLm9mZnNldCA8IG9mZnNldCB8fCBvcC5vZmZzZXQgPT09IG9mZnNldCAmJiBhZmZpbml0eSA9PT0gJ2ZvcndhcmQnKSkge1xuICAgICAgICAgICAgb2Zmc2V0ICs9IG9wLnRleHQubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkpIHtcbiAgICAgICAgICAgIG9mZnNldCArPSBvcC5wb3NpdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGF0aCA9IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wLCBvcHRpb25zKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAncmVtb3ZlX3RleHQnOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpICYmIG9wLm9mZnNldCA8PSBvZmZzZXQpIHtcbiAgICAgICAgICAgIG9mZnNldCAtPSBNYXRoLm1pbihvZmZzZXQgLSBvcC5vZmZzZXQsIG9wLnRleHQubGVuZ3RoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSB8fCBQYXRoLmlzQW5jZXN0b3Iob3AucGF0aCwgcGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXRoID0gUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3AsIG9wdGlvbnMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSkge1xuICAgICAgICAgICAgaWYgKG9wLnBvc2l0aW9uID09PSBvZmZzZXQgJiYgYWZmaW5pdHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3AucG9zaXRpb24gPCBvZmZzZXQgfHwgb3AucG9zaXRpb24gPT09IG9mZnNldCAmJiBhZmZpbml0eSA9PT0gJ2ZvcndhcmQnKSB7XG4gICAgICAgICAgICAgIG9mZnNldCAtPSBvcC5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgcGF0aCA9IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wLCBfb2JqZWN0U3ByZWFkJGIoX29iamVjdFNwcmVhZCRiKHt9LCBvcHRpb25zKSwge30sIHtcbiAgICAgICAgICAgICAgICBhZmZpbml0eTogJ2ZvcndhcmQnXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF0aCA9IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wLCBvcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBwb2ludDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGgsXG4gICAgICBvZmZzZXRcbiAgICB9O1xuICB9XG59O1xuXG52YXIgX3NjcnViYmVyID0gdW5kZWZpbmVkO1xuLyoqXG4gKiBUaGlzIGludGVyZmFjZSBpbXBsZW1lbnRzIGEgc3RyaW5naWZ5KCkgZnVuY3Rpb24sIHdoaWNoIGlzIHVzZWQgYnkgU2xhdGVcbiAqIGludGVybmFsbHkgd2hlbiBnZW5lcmF0aW5nIGV4Y2VwdGlvbnMgY29udGFpbmluZyBlbmQgdXNlciBkYXRhLiBEZXZlbG9wZXJzXG4gKiB1c2luZyBTbGF0ZSBtYXkgY2FsbCBTY3J1YmJlci5zZXRTY3J1YmJlcigpIHRvIGFsdGVyIHRoZSBiZWhhdmlvciBvZiB0aGlzXG4gKiBzdHJpbmdpZnkoKSBmdW5jdGlvbi5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgdG8gcHJldmVudCB0aGUgY2xlYXJ0ZXh0IGxvZ2dpbmcgb2YgJ3RleHQnIGZpZWxkcyB3aXRoaW4gTm9kZXM6XG4gKlxuICogICAgaW1wb3J0IHsgU2NydWJiZXIgfSBmcm9tICdzbGF0ZSc7XG4gKiAgICBTY3J1YmJlci5zZXRTY3J1YmJlcigoa2V5LCB2YWwpID0+IHtcbiAqICAgICAgaWYgKGtleSA9PT0gJ3RleHQnKSByZXR1cm4gJy4uLnNjcnViYmVkLi4uJ1xuICogICAgICByZXR1cm4gdmFsXG4gKiAgICB9KTtcbiAqXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbnZhciBTY3J1YmJlciA9IHtcbiAgc2V0U2NydWJiZXIoc2NydWJiZXIpIHtcbiAgICBfc2NydWJiZXIgPSBzY3J1YmJlcjtcbiAgfSxcbiAgc3RyaW5naWZ5KHZhbHVlKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlLCBfc2NydWJiZXIpO1xuICB9XG59O1xuXG52YXIgX2V4Y2x1ZGVkJDIgPSBbXCJ0ZXh0XCJdLFxuICBfZXhjbHVkZWQyJDIgPSBbXCJhbmNob3JcIiwgXCJmb2N1c1wiLCBcIm1lcmdlXCJdO1xuZnVuY3Rpb24gb3duS2V5cyRhKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkYShlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJGEoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJGEoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbnZhciBUZXh0ID0ge1xuICBlcXVhbHModGV4dCwgYW5vdGhlcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgbG9vc2UgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIGZ1bmN0aW9uIG9taXRUZXh0KG9iaikge1xuICAgICAgdmFyIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBfZXhjbHVkZWQkMik7XG4gICAgICByZXR1cm4gcmVzdDtcbiAgICB9XG4gICAgcmV0dXJuIGlzRGVlcEVxdWFsKGxvb3NlID8gb21pdFRleHQodGV4dCkgOiB0ZXh0LCBsb29zZSA/IG9taXRUZXh0KGFub3RoZXIpIDogYW5vdGhlcik7XG4gIH0sXG4gIGlzVGV4dCh2YWx1ZSkge1xuICAgIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlLnRleHQgPT09ICdzdHJpbmcnO1xuICB9LFxuICBpc1RleHRMaXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KHZhbCA9PiBUZXh0LmlzVGV4dCh2YWwpKTtcbiAgfSxcbiAgaXNUZXh0UHJvcHMocHJvcHMpIHtcbiAgICByZXR1cm4gcHJvcHMudGV4dCAhPT0gdW5kZWZpbmVkO1xuICB9LFxuICBtYXRjaGVzKHRleHQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICBpZiAoa2V5ID09PSAndGV4dCcpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIXRleHQuaGFzT3duUHJvcGVydHkoa2V5KSB8fCB0ZXh0W2tleV0gIT09IHByb3BzW2tleV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgZGVjb3JhdGlvbnMobm9kZSwgZGVjb3JhdGlvbnMpIHtcbiAgICB2YXIgbGVhdmVzID0gW3tcbiAgICAgIGxlYWY6IF9vYmplY3RTcHJlYWQkYSh7fSwgbm9kZSlcbiAgICB9XTtcbiAgICBmb3IgKHZhciBkZWMgb2YgZGVjb3JhdGlvbnMpIHtcbiAgICAgIHZhciB7XG4gICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgIGZvY3VzLFxuICAgICAgICAgIG1lcmdlOiBtZXJnZURlY29yYXRpb25cbiAgICAgICAgfSA9IGRlYyxcbiAgICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhkZWMsIF9leGNsdWRlZDIkMik7XG4gICAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMoZGVjKTtcbiAgICAgIHZhciBuZXh0ID0gW107XG4gICAgICB2YXIgbGVhZkVuZCA9IDA7XG4gICAgICB2YXIgZGVjb3JhdGlvblN0YXJ0ID0gc3RhcnQub2Zmc2V0O1xuICAgICAgdmFyIGRlY29yYXRpb25FbmQgPSBlbmQub2Zmc2V0O1xuICAgICAgdmFyIG1lcmdlID0gbWVyZ2VEZWNvcmF0aW9uICE9PSBudWxsICYmIG1lcmdlRGVjb3JhdGlvbiAhPT0gdm9pZCAwID8gbWVyZ2VEZWNvcmF0aW9uIDogT2JqZWN0LmFzc2lnbjtcbiAgICAgIGZvciAodmFyIHtcbiAgICAgICAgbGVhZlxuICAgICAgfSBvZiBsZWF2ZXMpIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBsZW5ndGhcbiAgICAgICAgfSA9IGxlYWYudGV4dDtcbiAgICAgICAgdmFyIGxlYWZTdGFydCA9IGxlYWZFbmQ7XG4gICAgICAgIGxlYWZFbmQgKz0gbGVuZ3RoO1xuICAgICAgICAvLyBJZiB0aGUgcmFuZ2UgZW5jb21wYXNzZXMgdGhlIGVudGlyZSBsZWFmLCBhZGQgdGhlIHJhbmdlLlxuICAgICAgICBpZiAoZGVjb3JhdGlvblN0YXJ0IDw9IGxlYWZTdGFydCAmJiBsZWFmRW5kIDw9IGRlY29yYXRpb25FbmQpIHtcbiAgICAgICAgICBtZXJnZShsZWFmLCByZXN0KTtcbiAgICAgICAgICBuZXh0LnB1c2goe1xuICAgICAgICAgICAgbGVhZlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSByYW5nZSBleHBhbmRlZCBhbmQgbWF0Y2ggdGhlIGxlYWYsIG9yIHN0YXJ0cyBhZnRlciwgb3IgZW5kcyBiZWZvcmUgaXQsIGNvbnRpbnVlLlxuICAgICAgICBpZiAoZGVjb3JhdGlvblN0YXJ0ICE9PSBkZWNvcmF0aW9uRW5kICYmIChkZWNvcmF0aW9uU3RhcnQgPT09IGxlYWZFbmQgfHwgZGVjb3JhdGlvbkVuZCA9PT0gbGVhZlN0YXJ0KSB8fCBkZWNvcmF0aW9uU3RhcnQgPiBsZWFmRW5kIHx8IGRlY29yYXRpb25FbmQgPCBsZWFmU3RhcnQgfHwgZGVjb3JhdGlvbkVuZCA9PT0gbGVhZlN0YXJ0ICYmIGxlYWZTdGFydCAhPT0gMCkge1xuICAgICAgICAgIG5leHQucHVzaCh7XG4gICAgICAgICAgICBsZWFmXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIG5lZWQgdG8gc3BsaXQgdGhlIGxlYWYsIGF0IHRoZSBzdGFydCwgZW5kLCBvciBib3RoLFxuICAgICAgICAvLyBhbmQgYWRkIHRoZSByYW5nZSB0byB0aGUgbWlkZGxlIGludGVyc2VjdGluZyBzZWN0aW9uLiBEbyB0aGUgZW5kXG4gICAgICAgIC8vIHNwbGl0IGZpcnN0IHNpbmNlIHdlIGRvbid0IG5lZWQgdG8gdXBkYXRlIHRoZSBvZmZzZXQgdGhhdCB3YXkuXG4gICAgICAgIHZhciBtaWRkbGUgPSBsZWFmO1xuICAgICAgICB2YXIgYmVmb3JlID0gdm9pZCAwO1xuICAgICAgICB2YXIgYWZ0ZXIgPSB2b2lkIDA7XG4gICAgICAgIGlmIChkZWNvcmF0aW9uRW5kIDwgbGVhZkVuZCkge1xuICAgICAgICAgIHZhciBvZmYgPSBkZWNvcmF0aW9uRW5kIC0gbGVhZlN0YXJ0O1xuICAgICAgICAgIGFmdGVyID0ge1xuICAgICAgICAgICAgbGVhZjogX29iamVjdFNwcmVhZCRhKF9vYmplY3RTcHJlYWQkYSh7fSwgbWlkZGxlKSwge30sIHtcbiAgICAgICAgICAgICAgdGV4dDogbWlkZGxlLnRleHQuc2xpY2Uob2ZmKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9O1xuICAgICAgICAgIG1pZGRsZSA9IF9vYmplY3RTcHJlYWQkYShfb2JqZWN0U3ByZWFkJGEoe30sIG1pZGRsZSksIHt9LCB7XG4gICAgICAgICAgICB0ZXh0OiBtaWRkbGUudGV4dC5zbGljZSgwLCBvZmYpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlY29yYXRpb25TdGFydCA+IGxlYWZTdGFydCkge1xuICAgICAgICAgIHZhciBfb2ZmID0gZGVjb3JhdGlvblN0YXJ0IC0gbGVhZlN0YXJ0O1xuICAgICAgICAgIGJlZm9yZSA9IHtcbiAgICAgICAgICAgIGxlYWY6IF9vYmplY3RTcHJlYWQkYShfb2JqZWN0U3ByZWFkJGEoe30sIG1pZGRsZSksIHt9LCB7XG4gICAgICAgICAgICAgIHRleHQ6IG1pZGRsZS50ZXh0LnNsaWNlKDAsIF9vZmYpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH07XG4gICAgICAgICAgbWlkZGxlID0gX29iamVjdFNwcmVhZCRhKF9vYmplY3RTcHJlYWQkYSh7fSwgbWlkZGxlKSwge30sIHtcbiAgICAgICAgICAgIHRleHQ6IG1pZGRsZS50ZXh0LnNsaWNlKF9vZmYpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbWVyZ2UobWlkZGxlLCByZXN0KTtcbiAgICAgICAgaWYgKGJlZm9yZSkge1xuICAgICAgICAgIG5leHQucHVzaChiZWZvcmUpO1xuICAgICAgICB9XG4gICAgICAgIG5leHQucHVzaCh7XG4gICAgICAgICAgbGVhZjogbWlkZGxlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgICAgICBuZXh0LnB1c2goYWZ0ZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZWF2ZXMgPSBuZXh0O1xuICAgIH1cbiAgICBpZiAobGVhdmVzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHZhciBjdXJyZW50T2Zmc2V0ID0gMDtcbiAgICAgIGZvciAodmFyIFtpbmRleCwgaXRlbV0gb2YgbGVhdmVzLmVudHJpZXMoKSkge1xuICAgICAgICB2YXIgX3N0YXJ0ID0gY3VycmVudE9mZnNldDtcbiAgICAgICAgdmFyIF9lbmQgPSBfc3RhcnQgKyBpdGVtLmxlYWYudGV4dC5sZW5ndGg7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHtcbiAgICAgICAgICBzdGFydDogX3N0YXJ0LFxuICAgICAgICAgIGVuZDogX2VuZFxuICAgICAgICB9O1xuICAgICAgICBpZiAoaW5kZXggPT09IDApIHBvc2l0aW9uLmlzRmlyc3QgPSB0cnVlO1xuICAgICAgICBpZiAoaW5kZXggPT09IGxlYXZlcy5sZW5ndGggLSAxKSBwb3NpdGlvbi5pc0xhc3QgPSB0cnVlO1xuICAgICAgICBpdGVtLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgIGN1cnJlbnRPZmZzZXQgPSBfZW5kO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGVhdmVzO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCBsb2NhdGlvbiB0byBpbnNlcnQgY29udGVudCBpbnRvIHRoZSBlZGl0b3IuXG4gKiBCeSBkZWZhdWx0LCB1c2UgdGhlIHNlbGVjdGlvbiBhcyB0aGUgdGFyZ2V0IGxvY2F0aW9uLiBCdXQgaWYgdGhlcmUgaXNcbiAqIG5vIHNlbGVjdGlvbiwgaW5zZXJ0IGF0IHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50IHNpbmNlIHRoYXQgaXMgc3VjaCBhXG4gKiBjb21tb24gdXNlIGNhc2Ugd2hlbiBpbnNlcnRpbmcgZnJvbSBhIG5vbi1zZWxlY3RlZCBzdGF0ZS5cbiAqL1xudmFyIGdldERlZmF1bHRJbnNlcnRMb2NhdGlvbiA9IGVkaXRvciA9PiB7XG4gIGlmIChlZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuIGVkaXRvci5zZWxlY3Rpb247XG4gIH0gZWxzZSBpZiAoZWRpdG9yLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gRWRpdG9yLmVuZChlZGl0b3IsIFtdKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gWzBdO1xuICB9XG59O1xuXG52YXIgbWF0Y2hQYXRoID0gKGVkaXRvciwgcGF0aCkgPT4ge1xuICB2YXIgW25vZGVdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXRoKTtcbiAgcmV0dXJuIG4gPT4gbiA9PT0gbm9kZTtcbn07XG5cbi8vIENoYXJhY3RlciAoZ3JhcGhlbWUgY2x1c3RlcikgYm91bmRhcmllcyBhcmUgZGV0ZXJtaW5lZCBhY2NvcmRpbmcgdG9cbi8vIHRoZSBkZWZhdWx0IGdyYXBoZW1lIGNsdXN0ZXIgYm91bmRhcnkgc3BlY2lmaWNhdGlvbiwgZXh0ZW5kZWQgZ3JhcGhlbWUgY2x1c3RlcnMgdmFyaWFudFsxXS5cbi8vXG4vLyBSZWZlcmVuY2VzOlxuLy9cbi8vIFsxXSBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMjkvI0RlZmF1bHRfR3JhcGhlbWVfQ2x1c3Rlcl9UYWJsZVxuLy8gWzJdIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL1B1YmxpYy9VQ0QvbGF0ZXN0L3VjZC9hdXhpbGlhcnkvR3JhcGhlbWVCcmVha1Byb3BlcnR5LnR4dFxuLy8gWzNdIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL1B1YmxpYy9VQ0QvbGF0ZXN0L3VjZC9hdXhpbGlhcnkvR3JhcGhlbWVCcmVha1Rlc3QuaHRtbFxuLy8gWzRdIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL1B1YmxpYy9VQ0QvbGF0ZXN0L3VjZC9hdXhpbGlhcnkvR3JhcGhlbWVCcmVha1Rlc3QudHh0XG4vKipcbiAqIEdldCB0aGUgZGlzdGFuY2UgdG8gdGhlIGVuZCBvZiB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIGEgc3RyaW5nIG9mIHRleHQuXG4gKi9cbnZhciBnZXRDaGFyYWN0ZXJEaXN0YW5jZSA9IGZ1bmN0aW9uIGdldENoYXJhY3RlckRpc3RhbmNlKHN0cikge1xuICB2YXIgaXNSVEwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICB2YXIgaXNMVFIgPSAhaXNSVEw7XG4gIHZhciBjb2RlcG9pbnRzID0gaXNSVEwgPyBjb2RlcG9pbnRzSXRlcmF0b3JSVEwoc3RyKSA6IHN0cjtcbiAgdmFyIGxlZnQgPSBDb2RlcG9pbnRUeXBlLk5vbmU7XG4gIHZhciByaWdodCA9IENvZGVwb2ludFR5cGUuTm9uZTtcbiAgdmFyIGRpc3RhbmNlID0gMDtcbiAgLy8gRXZhbHVhdGlvbiBvZiB0aGVzZSBjb25kaXRpb25zIGFyZSBkZWZlcnJlZC5cbiAgdmFyIGdiMTEgPSBudWxsOyAvLyBJcyBHQjExIGFwcGxpY2FibGU/XG4gIHZhciBnYjEyT3IxMyA9IG51bGw7IC8vIElzIEdCMTIgb3IgR0IxMyBhcHBsaWNhYmxlP1xuICBmb3IgKHZhciBjaGFyIG9mIGNvZGVwb2ludHMpIHtcbiAgICB2YXIgY29kZSA9IGNoYXIuY29kZVBvaW50QXQoMCk7XG4gICAgaWYgKCFjb2RlKSBicmVhaztcbiAgICB2YXIgdHlwZSA9IGdldENvZGVwb2ludFR5cGUoY2hhciwgY29kZSk7XG4gICAgW2xlZnQsIHJpZ2h0XSA9IGlzTFRSID8gW3JpZ2h0LCB0eXBlXSA6IFt0eXBlLCBsZWZ0XTtcbiAgICBpZiAoaW50ZXJzZWN0cyhsZWZ0LCBDb2RlcG9pbnRUeXBlLlpXSikgJiYgaW50ZXJzZWN0cyhyaWdodCwgQ29kZXBvaW50VHlwZS5FeHRQaWN0KSkge1xuICAgICAgaWYgKGlzTFRSKSB7XG4gICAgICAgIGdiMTEgPSBlbmRzV2l0aEVtb2ppWldKKHN0ci5zdWJzdHJpbmcoMCwgZGlzdGFuY2UpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdiMTEgPSBlbmRzV2l0aEVtb2ppWldKKHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIGRpc3RhbmNlKSk7XG4gICAgICB9XG4gICAgICBpZiAoIWdiMTEpIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoaW50ZXJzZWN0cyhsZWZ0LCBDb2RlcG9pbnRUeXBlLlJJKSAmJiBpbnRlcnNlY3RzKHJpZ2h0LCBDb2RlcG9pbnRUeXBlLlJJKSkge1xuICAgICAgaWYgKGdiMTJPcjEzICE9PSBudWxsKSB7XG4gICAgICAgIGdiMTJPcjEzID0gIWdiMTJPcjEzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzTFRSKSB7XG4gICAgICAgICAgZ2IxMk9yMTMgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdiMTJPcjEzID0gZW5kc1dpdGhPZGROdW1iZXJPZlJJcyhzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSBkaXN0YW5jZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWdiMTJPcjEzKSBicmVhaztcbiAgICB9XG4gICAgaWYgKGxlZnQgIT09IENvZGVwb2ludFR5cGUuTm9uZSAmJiByaWdodCAhPT0gQ29kZXBvaW50VHlwZS5Ob25lICYmIGlzQm91bmRhcnlQYWlyKGxlZnQsIHJpZ2h0KSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRpc3RhbmNlICs9IGNoYXIubGVuZ3RoO1xuICB9XG4gIHJldHVybiBkaXN0YW5jZSB8fCAxO1xufTtcbnZhciBTUEFDRSA9IC9cXHMvO1xudmFyIFBVTkNUVUFUSU9OID0gL1tcXHUwMDJCXFx1MDAyMS1cXHUwMDIzXFx1MDAyNS1cXHUwMDJBXFx1MDAyQy1cXHUwMDJGXFx1MDAzQVxcdTAwM0JcXHUwMDNGXFx1MDA0MFxcdTAwNUItXFx1MDA1RFxcdTAwNUZcXHUwMDdCXFx1MDA3RFxcdTAwQTFcXHUwMEE3XFx1MDBBQlxcdTAwQjZcXHUwMEI3XFx1MDBCQlxcdTAwQkZcXHUwMzdFXFx1MDM4N1xcdTA1NUEtXFx1MDU1RlxcdTA1ODlcXHUwNThBXFx1MDVCRVxcdTA1QzBcXHUwNUMzXFx1MDVDNlxcdTA1RjNcXHUwNUY0XFx1MDYwOVxcdTA2MEFcXHUwNjBDXFx1MDYwRFxcdTA2MUJcXHUwNjFFXFx1MDYxRlxcdTA2NkEtXFx1MDY2RFxcdTA2RDRcXHUwNzAwLVxcdTA3MERcXHUwN0Y3LVxcdTA3RjlcXHUwODMwLVxcdTA4M0VcXHUwODVFXFx1MDk2NFxcdTA5NjVcXHUwOTcwXFx1MEFGMFxcdTBERjRcXHUwRTRGXFx1MEU1QVxcdTBFNUJcXHUwRjA0LVxcdTBGMTJcXHUwRjE0XFx1MEYzQS1cXHUwRjNEXFx1MEY4NVxcdTBGRDAtXFx1MEZENFxcdTBGRDlcXHUwRkRBXFx1MTA0QS1cXHUxMDRGXFx1MTBGQlxcdTEzNjAtXFx1MTM2OFxcdTE0MDBcXHUxNjZEXFx1MTY2RVxcdTE2OUJcXHUxNjlDXFx1MTZFQi1cXHUxNkVEXFx1MTczNVxcdTE3MzZcXHUxN0Q0LVxcdTE3RDZcXHUxN0Q4LVxcdTE3REFcXHUxODAwLVxcdTE4MEFcXHUxOTQ0XFx1MTk0NVxcdTFBMUVcXHUxQTFGXFx1MUFBMC1cXHUxQUE2XFx1MUFBOC1cXHUxQUFEXFx1MUI1QS1cXHUxQjYwXFx1MUJGQy1cXHUxQkZGXFx1MUMzQi1cXHUxQzNGXFx1MUM3RVxcdTFDN0ZcXHUxQ0MwLVxcdTFDQzdcXHUxQ0QzXFx1MjAxMC1cXHUyMDI3XFx1MjAzMC1cXHUyMDQzXFx1MjA0NS1cXHUyMDUxXFx1MjA1My1cXHUyMDVFXFx1MjA3RFxcdTIwN0VcXHUyMDhEXFx1MjA4RVxcdTIzMjlcXHUyMzJBXFx1Mjc2OC1cXHUyNzc1XFx1MjdDNVxcdTI3QzZcXHUyN0U2LVxcdTI3RUZcXHUyOTgzLVxcdTI5OThcXHUyOUQ4LVxcdTI5REJcXHUyOUZDXFx1MjlGRFxcdTJDRjktXFx1MkNGQ1xcdTJDRkVcXHUyQ0ZGXFx1MkQ3MFxcdTJFMDAtXFx1MkUyRVxcdTJFMzAtXFx1MkUzQlxcdTMwMDEtXFx1MzAwM1xcdTMwMDgtXFx1MzAxMVxcdTMwMTQtXFx1MzAxRlxcdTMwMzBcXHUzMDNEXFx1MzBBMFxcdTMwRkJcXHVBNEZFXFx1QTRGRlxcdUE2MEQtXFx1QTYwRlxcdUE2NzNcXHVBNjdFXFx1QTZGMi1cXHVBNkY3XFx1QTg3NC1cXHVBODc3XFx1QThDRVxcdUE4Q0ZcXHVBOEY4LVxcdUE4RkFcXHVBOTJFXFx1QTkyRlxcdUE5NUZcXHVBOUMxLVxcdUE5Q0RcXHVBOURFXFx1QTlERlxcdUFBNUMtXFx1QUE1RlxcdUFBREVcXHVBQURGXFx1QUFGMFxcdUFBRjFcXHVBQkVCXFx1RkQzRVxcdUZEM0ZcXHVGRTEwLVxcdUZFMTlcXHVGRTMwLVxcdUZFNTJcXHVGRTU0LVxcdUZFNjFcXHVGRTYzXFx1RkU2OFxcdUZFNkFcXHVGRTZCXFx1RkYwMS1cXHVGRjAzXFx1RkYwNS1cXHVGRjBBXFx1RkYwQy1cXHVGRjBGXFx1RkYxQVxcdUZGMUJcXHVGRjFGXFx1RkYyMFxcdUZGM0ItXFx1RkYzRFxcdUZGM0ZcXHVGRjVCXFx1RkY1RFxcdUZGNUYtXFx1RkY2NV0vO1xudmFyIENIQU1FTEVPTiA9IC9bJ1xcdTIwMThcXHUyMDE5XS87XG4vKipcbiAqIEdldCB0aGUgZGlzdGFuY2UgdG8gdGhlIGVuZCBvZiB0aGUgZmlyc3Qgd29yZCBpbiBhIHN0cmluZyBvZiB0ZXh0LlxuICovXG52YXIgZ2V0V29yZERpc3RhbmNlID0gZnVuY3Rpb24gZ2V0V29yZERpc3RhbmNlKHRleHQpIHtcbiAgdmFyIGlzUlRMID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgdmFyIGRpc3QgPSAwO1xuICB2YXIgc3RhcnRlZCA9IGZhbHNlO1xuICB3aGlsZSAodGV4dC5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGNoYXJEaXN0ID0gZ2V0Q2hhcmFjdGVyRGlzdGFuY2UodGV4dCwgaXNSVEwpO1xuICAgIHZhciBbY2hhciwgcmVtYWluaW5nXSA9IHNwbGl0QnlDaGFyYWN0ZXJEaXN0YW5jZSh0ZXh0LCBjaGFyRGlzdCwgaXNSVEwpO1xuICAgIGlmIChpc1dvcmRDaGFyYWN0ZXIoY2hhciwgcmVtYWluaW5nLCBpc1JUTCkpIHtcbiAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgZGlzdCArPSBjaGFyRGlzdDtcbiAgICB9IGVsc2UgaWYgKCFzdGFydGVkKSB7XG4gICAgICBkaXN0ICs9IGNoYXJEaXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdGV4dCA9IHJlbWFpbmluZztcbiAgfVxuICByZXR1cm4gZGlzdDtcbn07XG4vKipcbiAqIFNwbGl0IGEgc3RyaW5nIGluIHR3byBwYXJ0cyBhdCBhIGdpdmVuIGRpc3RhbmNlIHN0YXJ0aW5nIGZyb20gdGhlIGVuZCB3aGVuXG4gKiBgaXNSVExgIGlzIHNldCB0byBgdHJ1ZWAuXG4gKi9cbnZhciBzcGxpdEJ5Q2hhcmFjdGVyRGlzdGFuY2UgPSAoc3RyLCBkaXN0LCBpc1JUTCkgPT4ge1xuICBpZiAoaXNSVEwpIHtcbiAgICB2YXIgYXQgPSBzdHIubGVuZ3RoIC0gZGlzdDtcbiAgICByZXR1cm4gW3N0ci5zbGljZShhdCwgc3RyLmxlbmd0aCksIHN0ci5zbGljZSgwLCBhdCldO1xuICB9XG4gIHJldHVybiBbc3RyLnNsaWNlKDAsIGRpc3QpLCBzdHIuc2xpY2UoZGlzdCldO1xufTtcbi8qKlxuICogQ2hlY2sgaWYgYSBjaGFyYWN0ZXIgaXMgYSB3b3JkIGNoYXJhY3Rlci4gVGhlIGByZW1haW5pbmdgIGFyZ3VtZW50IGlzIHVzZWRcbiAqIGJlY2F1c2Ugc29tZXRpbWVzIHlvdSBtdXN0IHJlYWQgc3Vic2VxdWVudCBjaGFyYWN0ZXJzIHRvIHRydWx5IGRldGVybWluZSBpdC5cbiAqL1xudmFyIGlzV29yZENoYXJhY3RlciA9IGZ1bmN0aW9uIGlzV29yZENoYXJhY3RlcihjaGFyLCByZW1haW5pbmcpIHtcbiAgdmFyIGlzUlRMID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgaWYgKFNQQUNFLnRlc3QoY2hhcikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQ2hhbWVsZW9ucyBjb3VudCBhcyB3b3JkIGNoYXJhY3RlcnMgYXMgbG9uZyBhcyB0aGV5J3JlIGluIGEgd29yZCwgc29cbiAgLy8gcmVjdXJzZSB0byBzZWUgaWYgdGhlIG5leHQgb25lIGlzIGEgd29yZCBjaGFyYWN0ZXIgb3Igbm90LlxuICBpZiAoQ0hBTUVMRU9OLnRlc3QoY2hhcikpIHtcbiAgICB2YXIgY2hhckRpc3QgPSBnZXRDaGFyYWN0ZXJEaXN0YW5jZShyZW1haW5pbmcsIGlzUlRMKTtcbiAgICB2YXIgW25leHRDaGFyLCBuZXh0UmVtYWluaW5nXSA9IHNwbGl0QnlDaGFyYWN0ZXJEaXN0YW5jZShyZW1haW5pbmcsIGNoYXJEaXN0LCBpc1JUTCk7XG4gICAgaWYgKGlzV29yZENoYXJhY3RlcihuZXh0Q2hhciwgbmV4dFJlbWFpbmluZywgaXNSVEwpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKFBVTkNUVUFUSU9OLnRlc3QoY2hhcikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG4gKiBJdGVyYXRlIG9uIGNvZGVwb2ludHMgZnJvbSByaWdodCB0byBsZWZ0LlxuICovXG52YXIgY29kZXBvaW50c0l0ZXJhdG9yUlRMID0gZnVuY3Rpb24qIGNvZGVwb2ludHNJdGVyYXRvclJUTChzdHIpIHtcbiAgdmFyIGVuZCA9IHN0ci5sZW5ndGggLSAxO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjaGFyMSA9IHN0ci5jaGFyQXQoZW5kIC0gaSk7XG4gICAgaWYgKGlzTG93U3Vycm9nYXRlKGNoYXIxLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICB2YXIgY2hhcjIgPSBzdHIuY2hhckF0KGVuZCAtIGkgLSAxKTtcbiAgICAgIGlmIChpc0hpZ2hTdXJyb2dhdGUoY2hhcjIuY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgeWllbGQgY2hhcjIgKyBjaGFyMTtcbiAgICAgICAgaSsrO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgeWllbGQgY2hhcjE7XG4gIH1cbn07XG4vKipcbiAqIElzIGBjaGFyQ29kZWAgYSBoaWdoIHN1cnJvZ2F0ZS5cbiAqXG4gKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Vbml2ZXJzYWxfQ2hhcmFjdGVyX1NldF9jaGFyYWN0ZXJzI1N1cnJvZ2F0ZXNcbiAqL1xudmFyIGlzSGlnaFN1cnJvZ2F0ZSA9IGNoYXJDb2RlID0+IHtcbiAgcmV0dXJuIGNoYXJDb2RlID49IDB4ZDgwMCAmJiBjaGFyQ29kZSA8PSAweGRiZmY7XG59O1xuLyoqXG4gKiBJcyBgY2hhckNvZGVgIGEgbG93IHN1cnJvZ2F0ZS5cbiAqXG4gKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Vbml2ZXJzYWxfQ2hhcmFjdGVyX1NldF9jaGFyYWN0ZXJzI1N1cnJvZ2F0ZXNcbiAqL1xudmFyIGlzTG93U3Vycm9nYXRlID0gY2hhckNvZGUgPT4ge1xuICByZXR1cm4gY2hhckNvZGUgPj0gMHhkYzAwICYmIGNoYXJDb2RlIDw9IDB4ZGZmZjtcbn07XG52YXIgQ29kZXBvaW50VHlwZTtcbihmdW5jdGlvbiAoQ29kZXBvaW50VHlwZSkge1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiRXh0ZW5kXCJdID0gMV0gPSBcIkV4dGVuZFwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJaV0pcIl0gPSAyXSA9IFwiWldKXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIlJJXCJdID0gNF0gPSBcIlJJXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIlByZXBlbmRcIl0gPSA4XSA9IFwiUHJlcGVuZFwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJTcGFjaW5nTWFya1wiXSA9IDE2XSA9IFwiU3BhY2luZ01hcmtcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiTFwiXSA9IDMyXSA9IFwiTFwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJWXCJdID0gNjRdID0gXCJWXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIlRcIl0gPSAxMjhdID0gXCJUXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIkxWXCJdID0gMjU2XSA9IFwiTFZcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiTFZUXCJdID0gNTEyXSA9IFwiTFZUXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIkV4dFBpY3RcIl0gPSAxMDI0XSA9IFwiRXh0UGljdFwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJBbnlcIl0gPSAyMDQ4XSA9IFwiQW55XCI7XG59KShDb2RlcG9pbnRUeXBlIHx8IChDb2RlcG9pbnRUeXBlID0ge30pKTtcbnZhciByZUV4dGVuZCA9IC9eKD86W1xcdTAzMDAtXFx1MDM2RlxcdTA0ODMtXFx1MDQ4OVxcdTA1OTEtXFx1MDVCRFxcdTA1QkZcXHUwNUMxXFx1MDVDMlxcdTA1QzRcXHUwNUM1XFx1MDVDN1xcdTA2MTAtXFx1MDYxQVxcdTA2NEItXFx1MDY1RlxcdTA2NzBcXHUwNkQ2LVxcdTA2RENcXHUwNkRGLVxcdTA2RTRcXHUwNkU3XFx1MDZFOFxcdTA2RUEtXFx1MDZFRFxcdTA3MTFcXHUwNzMwLVxcdTA3NEFcXHUwN0E2LVxcdTA3QjBcXHUwN0VCLVxcdTA3RjNcXHUwN0ZEXFx1MDgxNi1cXHUwODE5XFx1MDgxQi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJEXFx1MDg1OS1cXHUwODVCXFx1MDg5OC1cXHUwODlGXFx1MDhDQS1cXHUwOEUxXFx1MDhFMy1cXHUwOTAyXFx1MDkzQVxcdTA5M0NcXHUwOTQxLVxcdTA5NDhcXHUwOTREXFx1MDk1MS1cXHUwOTU3XFx1MDk2MlxcdTA5NjNcXHUwOTgxXFx1MDlCQ1xcdTA5QkVcXHUwOUMxLVxcdTA5QzRcXHUwOUNEXFx1MDlEN1xcdTA5RTJcXHUwOUUzXFx1MDlGRVxcdTBBMDFcXHUwQTAyXFx1MEEzQ1xcdTBBNDFcXHUwQTQyXFx1MEE0N1xcdTBBNDhcXHUwQTRCLVxcdTBBNERcXHUwQTUxXFx1MEE3MFxcdTBBNzFcXHUwQTc1XFx1MEE4MVxcdTBBODJcXHUwQUJDXFx1MEFDMS1cXHUwQUM1XFx1MEFDN1xcdTBBQzhcXHUwQUNEXFx1MEFFMlxcdTBBRTNcXHUwQUZBLVxcdTBBRkZcXHUwQjAxXFx1MEIzQ1xcdTBCM0VcXHUwQjNGXFx1MEI0MS1cXHUwQjQ0XFx1MEI0RFxcdTBCNTUtXFx1MEI1N1xcdTBCNjJcXHUwQjYzXFx1MEI4MlxcdTBCQkVcXHUwQkMwXFx1MEJDRFxcdTBCRDdcXHUwQzAwXFx1MEMwNFxcdTBDM0NcXHUwQzNFLVxcdTBDNDBcXHUwQzQ2LVxcdTBDNDhcXHUwQzRBLVxcdTBDNERcXHUwQzU1XFx1MEM1NlxcdTBDNjJcXHUwQzYzXFx1MEM4MVxcdTBDQkNcXHUwQ0JGXFx1MENDMlxcdTBDQzZcXHUwQ0NDXFx1MENDRFxcdTBDRDVcXHUwQ0Q2XFx1MENFMlxcdTBDRTNcXHUwRDAwXFx1MEQwMVxcdTBEM0JcXHUwRDNDXFx1MEQzRVxcdTBENDEtXFx1MEQ0NFxcdTBENERcXHUwRDU3XFx1MEQ2MlxcdTBENjNcXHUwRDgxXFx1MERDQVxcdTBEQ0ZcXHUwREQyLVxcdTBERDRcXHUwREQ2XFx1MERERlxcdTBFMzFcXHUwRTM0LVxcdTBFM0FcXHUwRTQ3LVxcdTBFNEVcXHUwRUIxXFx1MEVCNC1cXHUwRUJDXFx1MEVDOC1cXHUwRUNFXFx1MEYxOFxcdTBGMTlcXHUwRjM1XFx1MEYzN1xcdTBGMzlcXHUwRjcxLVxcdTBGN0VcXHUwRjgwLVxcdTBGODRcXHUwRjg2XFx1MEY4N1xcdTBGOEQtXFx1MEY5N1xcdTBGOTktXFx1MEZCQ1xcdTBGQzZcXHUxMDJELVxcdTEwMzBcXHUxMDMyLVxcdTEwMzdcXHUxMDM5XFx1MTAzQVxcdTEwM0RcXHUxMDNFXFx1MTA1OFxcdTEwNTlcXHUxMDVFLVxcdTEwNjBcXHUxMDcxLVxcdTEwNzRcXHUxMDgyXFx1MTA4NVxcdTEwODZcXHUxMDhEXFx1MTA5RFxcdTEzNUQtXFx1MTM1RlxcdTE3MTItXFx1MTcxNFxcdTE3MzJcXHUxNzMzXFx1MTc1MlxcdTE3NTNcXHUxNzcyXFx1MTc3M1xcdTE3QjRcXHUxN0I1XFx1MTdCNy1cXHUxN0JEXFx1MTdDNlxcdTE3QzktXFx1MTdEM1xcdTE3RERcXHUxODBCLVxcdTE4MERcXHUxODBGXFx1MTg4NVxcdTE4ODZcXHUxOEE5XFx1MTkyMC1cXHUxOTIyXFx1MTkyN1xcdTE5MjhcXHUxOTMyXFx1MTkzOS1cXHUxOTNCXFx1MUExN1xcdTFBMThcXHUxQTFCXFx1MUE1NlxcdTFBNTgtXFx1MUE1RVxcdTFBNjBcXHUxQTYyXFx1MUE2NS1cXHUxQTZDXFx1MUE3My1cXHUxQTdDXFx1MUE3RlxcdTFBQjAtXFx1MUFDRVxcdTFCMDAtXFx1MUIwM1xcdTFCMzQtXFx1MUIzQVxcdTFCM0NcXHUxQjQyXFx1MUI2Qi1cXHUxQjczXFx1MUI4MFxcdTFCODFcXHUxQkEyLVxcdTFCQTVcXHUxQkE4XFx1MUJBOVxcdTFCQUItXFx1MUJBRFxcdTFCRTZcXHUxQkU4XFx1MUJFOVxcdTFCRURcXHUxQkVGLVxcdTFCRjFcXHUxQzJDLVxcdTFDMzNcXHUxQzM2XFx1MUMzN1xcdTFDRDAtXFx1MUNEMlxcdTFDRDQtXFx1MUNFMFxcdTFDRTItXFx1MUNFOFxcdTFDRURcXHUxQ0Y0XFx1MUNGOFxcdTFDRjlcXHUxREMwLVxcdTFERkZcXHUyMDBDXFx1MjBEMC1cXHUyMEYwXFx1MkNFRi1cXHUyQ0YxXFx1MkQ3RlxcdTJERTAtXFx1MkRGRlxcdTMwMkEtXFx1MzAyRlxcdTMwOTlcXHUzMDlBXFx1QTY2Ri1cXHVBNjcyXFx1QTY3NC1cXHVBNjdEXFx1QTY5RVxcdUE2OUZcXHVBNkYwXFx1QTZGMVxcdUE4MDJcXHVBODA2XFx1QTgwQlxcdUE4MjVcXHVBODI2XFx1QTgyQ1xcdUE4QzRcXHVBOEM1XFx1QThFMC1cXHVBOEYxXFx1QThGRlxcdUE5MjYtXFx1QTkyRFxcdUE5NDctXFx1QTk1MVxcdUE5ODAtXFx1QTk4MlxcdUE5QjNcXHVBOUI2LVxcdUE5QjlcXHVBOUJDXFx1QTlCRFxcdUE5RTVcXHVBQTI5LVxcdUFBMkVcXHVBQTMxXFx1QUEzMlxcdUFBMzVcXHVBQTM2XFx1QUE0M1xcdUFBNENcXHVBQTdDXFx1QUFCMFxcdUFBQjItXFx1QUFCNFxcdUFBQjdcXHVBQUI4XFx1QUFCRVxcdUFBQkZcXHVBQUMxXFx1QUFFQ1xcdUFBRURcXHVBQUY2XFx1QUJFNVxcdUFCRThcXHVBQkVEXFx1RkIxRVxcdUZFMDAtXFx1RkUwRlxcdUZFMjAtXFx1RkUyRlxcdUZGOUVcXHVGRjlGXXxcXHVEODAwW1xcdURERkRcXHVERUUwXFx1REY3Ni1cXHVERjdBXXxcXHVEODAyW1xcdURFMDEtXFx1REUwM1xcdURFMDVcXHVERTA2XFx1REUwQy1cXHVERTBGXFx1REUzOC1cXHVERTNBXFx1REUzRlxcdURFRTVcXHVERUU2XXxcXHVEODAzW1xcdUREMjQtXFx1REQyN1xcdURFQUJcXHVERUFDXFx1REVGRC1cXHVERUZGXFx1REY0Ni1cXHVERjUwXFx1REY4Mi1cXHVERjg1XXxcXHVEODA0W1xcdURDMDFcXHVEQzM4LVxcdURDNDZcXHVEQzcwXFx1REM3M1xcdURDNzRcXHVEQzdGLVxcdURDODFcXHVEQ0IzLVxcdURDQjZcXHVEQ0I5XFx1RENCQVxcdURDQzJcXHVERDAwLVxcdUREMDJcXHVERDI3LVxcdUREMkJcXHVERDJELVxcdUREMzRcXHVERDczXFx1REQ4MFxcdUREODFcXHVEREI2LVxcdUREQkVcXHVEREM5LVxcdUREQ0NcXHVERENGXFx1REUyRi1cXHVERTMxXFx1REUzNFxcdURFMzZcXHVERTM3XFx1REUzRVxcdURFNDFcXHVERURGXFx1REVFMy1cXHVERUVBXFx1REYwMFxcdURGMDFcXHVERjNCXFx1REYzQ1xcdURGM0VcXHVERjQwXFx1REY1N1xcdURGNjYtXFx1REY2Q1xcdURGNzAtXFx1REY3NF18XFx1RDgwNVtcXHVEQzM4LVxcdURDM0ZcXHVEQzQyLVxcdURDNDRcXHVEQzQ2XFx1REM1RVxcdURDQjBcXHVEQ0IzLVxcdURDQjhcXHVEQ0JBXFx1RENCRFxcdURDQkZcXHVEQ0MwXFx1RENDMlxcdURDQzNcXHVEREFGXFx1RERCMi1cXHVEREI1XFx1RERCQ1xcdUREQkRcXHVEREJGXFx1RERDMFxcdURERENcXHVEREREXFx1REUzMy1cXHVERTNBXFx1REUzRFxcdURFM0ZcXHVERTQwXFx1REVBQlxcdURFQURcXHVERUIwLVxcdURFQjVcXHVERUI3XFx1REYxRC1cXHVERjFGXFx1REYyMi1cXHVERjI1XFx1REYyNy1cXHVERjJCXXxcXHVEODA2W1xcdURDMkYtXFx1REMzN1xcdURDMzlcXHVEQzNBXFx1REQzMFxcdUREM0JcXHVERDNDXFx1REQzRVxcdURENDNcXHVEREQ0LVxcdURERDdcXHVERERBXFx1REREQlxcdURERTBcXHVERTAxLVxcdURFMEFcXHVERTMzLVxcdURFMzhcXHVERTNCLVxcdURFM0VcXHVERTQ3XFx1REU1MS1cXHVERTU2XFx1REU1OS1cXHVERTVCXFx1REU4QS1cXHVERTk2XFx1REU5OFxcdURFOTldfFxcdUQ4MDdbXFx1REMzMC1cXHVEQzM2XFx1REMzOC1cXHVEQzNEXFx1REMzRlxcdURDOTItXFx1RENBN1xcdURDQUEtXFx1RENCMFxcdURDQjJcXHVEQ0IzXFx1RENCNVxcdURDQjZcXHVERDMxLVxcdUREMzZcXHVERDNBXFx1REQzQ1xcdUREM0RcXHVERDNGLVxcdURENDVcXHVERDQ3XFx1REQ5MFxcdUREOTFcXHVERDk1XFx1REQ5N1xcdURFRjNcXHVERUY0XFx1REYwMFxcdURGMDFcXHVERjM2LVxcdURGM0FcXHVERjQwXFx1REY0Ml18XFx1RDgwRFtcXHVEQzQwXFx1REM0Ny1cXHVEQzU1XXxcXHVEODFBW1xcdURFRjAtXFx1REVGNFxcdURGMzAtXFx1REYzNl18XFx1RDgxQltcXHVERjRGXFx1REY4Ri1cXHVERjkyXFx1REZFNF18XFx1RDgyRltcXHVEQzlEXFx1REM5RV18XFx1RDgzM1tcXHVERjAwLVxcdURGMkRcXHVERjMwLVxcdURGNDZdfFxcdUQ4MzRbXFx1REQ2NVxcdURENjctXFx1REQ2OVxcdURENkUtXFx1REQ3MlxcdUREN0ItXFx1REQ4MlxcdUREODUtXFx1REQ4QlxcdUREQUEtXFx1RERBRFxcdURFNDItXFx1REU0NF18XFx1RDgzNltcXHVERTAwLVxcdURFMzZcXHVERTNCLVxcdURFNkNcXHVERTc1XFx1REU4NFxcdURFOUItXFx1REU5RlxcdURFQTEtXFx1REVBRl18XFx1RDgzOFtcXHVEQzAwLVxcdURDMDZcXHVEQzA4LVxcdURDMThcXHVEQzFCLVxcdURDMjFcXHVEQzIzXFx1REMyNFxcdURDMjYtXFx1REMyQVxcdURDOEZcXHVERDMwLVxcdUREMzZcXHVERUFFXFx1REVFQy1cXHVERUVGXXxcXHVEODM5W1xcdURDRUMtXFx1RENFRl18XFx1RDgzQVtcXHVEQ0QwLVxcdURDRDZcXHVERDQ0LVxcdURENEFdfFxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXXxcXHVEQjQwW1xcdURDMjAtXFx1REM3RlxcdUREMDAtXFx1RERFRl0pJC87XG52YXIgcmVQcmVwZW5kID0gL14oPzpbXFx1MDYwMC1cXHUwNjA1XFx1MDZERFxcdTA3MEZcXHUwODkwXFx1MDg5MVxcdTA4RTJcXHUwRDRFXXxcXHVEODA0W1xcdURDQkRcXHVEQ0NEXFx1RERDMlxcdUREQzNdfFxcdUQ4MDZbXFx1REQzRlxcdURENDFcXHVERTNBXFx1REU4NC1cXHVERTg5XXxcXHVEODA3XFx1REQ0NikkLztcbnZhciByZVNwYWNpbmdNYXJrID0gL14oPzpbXFx1MDkwM1xcdTA5M0JcXHUwOTNFLVxcdTA5NDBcXHUwOTQ5LVxcdTA5NENcXHUwOTRFXFx1MDk0RlxcdTA5ODJcXHUwOTgzXFx1MDlCRlxcdTA5QzBcXHUwOUM3XFx1MDlDOFxcdTA5Q0JcXHUwOUNDXFx1MEEwM1xcdTBBM0UtXFx1MEE0MFxcdTBBODNcXHUwQUJFLVxcdTBBQzBcXHUwQUM5XFx1MEFDQlxcdTBBQ0NcXHUwQjAyXFx1MEIwM1xcdTBCNDBcXHUwQjQ3XFx1MEI0OFxcdTBCNEJcXHUwQjRDXFx1MEJCRlxcdTBCQzFcXHUwQkMyXFx1MEJDNi1cXHUwQkM4XFx1MEJDQS1cXHUwQkNDXFx1MEMwMS1cXHUwQzAzXFx1MEM0MS1cXHUwQzQ0XFx1MEM4MlxcdTBDODNcXHUwQ0JFXFx1MENDMFxcdTBDQzFcXHUwQ0MzXFx1MENDNFxcdTBDQzdcXHUwQ0M4XFx1MENDQVxcdTBDQ0JcXHUwRDAyXFx1MEQwM1xcdTBEM0ZcXHUwRDQwXFx1MEQ0Ni1cXHUwRDQ4XFx1MEQ0QS1cXHUwRDRDXFx1MEQ4MlxcdTBEODNcXHUwREQwXFx1MEREMVxcdTBERDgtXFx1MERERVxcdTBERjJcXHUwREYzXFx1MEUzM1xcdTBFQjNcXHUwRjNFXFx1MEYzRlxcdTBGN0ZcXHUxMDMxXFx1MTAzQlxcdTEwM0NcXHUxMDU2XFx1MTA1N1xcdTEwODRcXHUxNzE1XFx1MTczNFxcdTE3QjZcXHUxN0JFLVxcdTE3QzVcXHUxN0M3XFx1MTdDOFxcdTE5MjMtXFx1MTkyNlxcdTE5MjktXFx1MTkyQlxcdTE5MzBcXHUxOTMxXFx1MTkzMy1cXHUxOTM4XFx1MUExOVxcdTFBMUFcXHUxQTU1XFx1MUE1N1xcdTFBNkQtXFx1MUE3MlxcdTFCMDRcXHUxQjNCXFx1MUIzRC1cXHUxQjQxXFx1MUI0M1xcdTFCNDRcXHUxQjgyXFx1MUJBMVxcdTFCQTZcXHUxQkE3XFx1MUJBQVxcdTFCRTdcXHUxQkVBLVxcdTFCRUNcXHUxQkVFXFx1MUJGMlxcdTFCRjNcXHUxQzI0LVxcdTFDMkJcXHUxQzM0XFx1MUMzNVxcdTFDRTFcXHUxQ0Y3XFx1QTgyM1xcdUE4MjRcXHVBODI3XFx1QTg4MFxcdUE4ODFcXHVBOEI0LVxcdUE4QzNcXHVBOTUyXFx1QTk1M1xcdUE5ODNcXHVBOUI0XFx1QTlCNVxcdUE5QkFcXHVBOUJCXFx1QTlCRS1cXHVBOUMwXFx1QUEyRlxcdUFBMzBcXHVBQTMzXFx1QUEzNFxcdUFBNERcXHVBQUVCXFx1QUFFRVxcdUFBRUZcXHVBQUY1XFx1QUJFM1xcdUFCRTRcXHVBQkU2XFx1QUJFN1xcdUFCRTlcXHVBQkVBXFx1QUJFQ118XFx1RDgwNFtcXHVEQzAwXFx1REMwMlxcdURDODJcXHVEQ0IwLVxcdURDQjJcXHVEQ0I3XFx1RENCOFxcdUREMkNcXHVERDQ1XFx1REQ0NlxcdUREODJcXHVEREIzLVxcdUREQjVcXHVEREJGXFx1RERDMFxcdUREQ0VcXHVERTJDLVxcdURFMkVcXHVERTMyXFx1REUzM1xcdURFMzVcXHVERUUwLVxcdURFRTJcXHVERjAyXFx1REYwM1xcdURGM0ZcXHVERjQxLVxcdURGNDRcXHVERjQ3XFx1REY0OFxcdURGNEItXFx1REY0RFxcdURGNjJcXHVERjYzXXxcXHVEODA1W1xcdURDMzUtXFx1REMzN1xcdURDNDBcXHVEQzQxXFx1REM0NVxcdURDQjFcXHVEQ0IyXFx1RENCOVxcdURDQkJcXHVEQ0JDXFx1RENCRVxcdURDQzFcXHVEREIwXFx1RERCMVxcdUREQjgtXFx1RERCQlxcdUREQkVcXHVERTMwLVxcdURFMzJcXHVERTNCXFx1REUzQ1xcdURFM0VcXHVERUFDXFx1REVBRVxcdURFQUZcXHVERUI2XFx1REYyNl18XFx1RDgwNltcXHVEQzJDLVxcdURDMkVcXHVEQzM4XFx1REQzMS1cXHVERDM1XFx1REQzN1xcdUREMzhcXHVERDNEXFx1REQ0MFxcdURENDJcXHVEREQxLVxcdURERDNcXHVERERDLVxcdUREREZcXHVEREU0XFx1REUzOVxcdURFNTdcXHVERTU4XFx1REU5N118XFx1RDgwN1tcXHVEQzJGXFx1REMzRVxcdURDQTlcXHVEQ0IxXFx1RENCNFxcdUREOEEtXFx1REQ4RVxcdUREOTNcXHVERDk0XFx1REQ5NlxcdURFRjVcXHVERUY2XXxcXHVEODFCW1xcdURGNTEtXFx1REY4N1xcdURGRjBcXHVERkYxXXxcXHVEODM0W1xcdURENjZcXHVERDZEXSkkLztcbnZhciByZUwgPSAvXltcXHUxMTAwLVxcdTExNUZcXHVBOTYwLVxcdUE5N0NdJC87XG52YXIgcmVWID0gL15bXFx1MTE2MC1cXHUxMUE3XFx1RDdCMC1cXHVEN0M2XSQvO1xudmFyIHJlVCA9IC9eW1xcdTExQTgtXFx1MTFGRlxcdUQ3Q0ItXFx1RDdGQl0kLztcbnZhciByZUxWID0gL15bXFx1QUMwMFxcdUFDMUNcXHVBQzM4XFx1QUM1NFxcdUFDNzBcXHVBQzhDXFx1QUNBOFxcdUFDQzRcXHVBQ0UwXFx1QUNGQ1xcdUFEMThcXHVBRDM0XFx1QUQ1MFxcdUFENkNcXHVBRDg4XFx1QURBNFxcdUFEQzBcXHVBRERDXFx1QURGOFxcdUFFMTRcXHVBRTMwXFx1QUU0Q1xcdUFFNjhcXHVBRTg0XFx1QUVBMFxcdUFFQkNcXHVBRUQ4XFx1QUVGNFxcdUFGMTBcXHVBRjJDXFx1QUY0OFxcdUFGNjRcXHVBRjgwXFx1QUY5Q1xcdUFGQjhcXHVBRkQ0XFx1QUZGMFxcdUIwMENcXHVCMDI4XFx1QjA0NFxcdUIwNjBcXHVCMDdDXFx1QjA5OFxcdUIwQjRcXHVCMEQwXFx1QjBFQ1xcdUIxMDhcXHVCMTI0XFx1QjE0MFxcdUIxNUNcXHVCMTc4XFx1QjE5NFxcdUIxQjBcXHVCMUNDXFx1QjFFOFxcdUIyMDRcXHVCMjIwXFx1QjIzQ1xcdUIyNThcXHVCMjc0XFx1QjI5MFxcdUIyQUNcXHVCMkM4XFx1QjJFNFxcdUIzMDBcXHVCMzFDXFx1QjMzOFxcdUIzNTRcXHVCMzcwXFx1QjM4Q1xcdUIzQThcXHVCM0M0XFx1QjNFMFxcdUIzRkNcXHVCNDE4XFx1QjQzNFxcdUI0NTBcXHVCNDZDXFx1QjQ4OFxcdUI0QTRcXHVCNEMwXFx1QjREQ1xcdUI0RjhcXHVCNTE0XFx1QjUzMFxcdUI1NENcXHVCNTY4XFx1QjU4NFxcdUI1QTBcXHVCNUJDXFx1QjVEOFxcdUI1RjRcXHVCNjEwXFx1QjYyQ1xcdUI2NDhcXHVCNjY0XFx1QjY4MFxcdUI2OUNcXHVCNkI4XFx1QjZENFxcdUI2RjBcXHVCNzBDXFx1QjcyOFxcdUI3NDRcXHVCNzYwXFx1Qjc3Q1xcdUI3OThcXHVCN0I0XFx1QjdEMFxcdUI3RUNcXHVCODA4XFx1QjgyNFxcdUI4NDBcXHVCODVDXFx1Qjg3OFxcdUI4OTRcXHVCOEIwXFx1QjhDQ1xcdUI4RThcXHVCOTA0XFx1QjkyMFxcdUI5M0NcXHVCOTU4XFx1Qjk3NFxcdUI5OTBcXHVCOUFDXFx1QjlDOFxcdUI5RTRcXHVCQTAwXFx1QkExQ1xcdUJBMzhcXHVCQTU0XFx1QkE3MFxcdUJBOENcXHVCQUE4XFx1QkFDNFxcdUJBRTBcXHVCQUZDXFx1QkIxOFxcdUJCMzRcXHVCQjUwXFx1QkI2Q1xcdUJCODhcXHVCQkE0XFx1QkJDMFxcdUJCRENcXHVCQkY4XFx1QkMxNFxcdUJDMzBcXHVCQzRDXFx1QkM2OFxcdUJDODRcXHVCQ0EwXFx1QkNCQ1xcdUJDRDhcXHVCQ0Y0XFx1QkQxMFxcdUJEMkNcXHVCRDQ4XFx1QkQ2NFxcdUJEODBcXHVCRDlDXFx1QkRCOFxcdUJERDRcXHVCREYwXFx1QkUwQ1xcdUJFMjhcXHVCRTQ0XFx1QkU2MFxcdUJFN0NcXHVCRTk4XFx1QkVCNFxcdUJFRDBcXHVCRUVDXFx1QkYwOFxcdUJGMjRcXHVCRjQwXFx1QkY1Q1xcdUJGNzhcXHVCRjk0XFx1QkZCMFxcdUJGQ0NcXHVCRkU4XFx1QzAwNFxcdUMwMjBcXHVDMDNDXFx1QzA1OFxcdUMwNzRcXHVDMDkwXFx1QzBBQ1xcdUMwQzhcXHVDMEU0XFx1QzEwMFxcdUMxMUNcXHVDMTM4XFx1QzE1NFxcdUMxNzBcXHVDMThDXFx1QzFBOFxcdUMxQzRcXHVDMUUwXFx1QzFGQ1xcdUMyMThcXHVDMjM0XFx1QzI1MFxcdUMyNkNcXHVDMjg4XFx1QzJBNFxcdUMyQzBcXHVDMkRDXFx1QzJGOFxcdUMzMTRcXHVDMzMwXFx1QzM0Q1xcdUMzNjhcXHVDMzg0XFx1QzNBMFxcdUMzQkNcXHVDM0Q4XFx1QzNGNFxcdUM0MTBcXHVDNDJDXFx1QzQ0OFxcdUM0NjRcXHVDNDgwXFx1QzQ5Q1xcdUM0QjhcXHVDNEQ0XFx1QzRGMFxcdUM1MENcXHVDNTI4XFx1QzU0NFxcdUM1NjBcXHVDNTdDXFx1QzU5OFxcdUM1QjRcXHVDNUQwXFx1QzVFQ1xcdUM2MDhcXHVDNjI0XFx1QzY0MFxcdUM2NUNcXHVDNjc4XFx1QzY5NFxcdUM2QjBcXHVDNkNDXFx1QzZFOFxcdUM3MDRcXHVDNzIwXFx1QzczQ1xcdUM3NThcXHVDNzc0XFx1Qzc5MFxcdUM3QUNcXHVDN0M4XFx1QzdFNFxcdUM4MDBcXHVDODFDXFx1QzgzOFxcdUM4NTRcXHVDODcwXFx1Qzg4Q1xcdUM4QThcXHVDOEM0XFx1QzhFMFxcdUM4RkNcXHVDOTE4XFx1QzkzNFxcdUM5NTBcXHVDOTZDXFx1Qzk4OFxcdUM5QTRcXHVDOUMwXFx1QzlEQ1xcdUM5RjhcXHVDQTE0XFx1Q0EzMFxcdUNBNENcXHVDQTY4XFx1Q0E4NFxcdUNBQTBcXHVDQUJDXFx1Q0FEOFxcdUNBRjRcXHVDQjEwXFx1Q0IyQ1xcdUNCNDhcXHVDQjY0XFx1Q0I4MFxcdUNCOUNcXHVDQkI4XFx1Q0JENFxcdUNCRjBcXHVDQzBDXFx1Q0MyOFxcdUNDNDRcXHVDQzYwXFx1Q0M3Q1xcdUNDOThcXHVDQ0I0XFx1Q0NEMFxcdUNDRUNcXHVDRDA4XFx1Q0QyNFxcdUNENDBcXHVDRDVDXFx1Q0Q3OFxcdUNEOTRcXHVDREIwXFx1Q0RDQ1xcdUNERThcXHVDRTA0XFx1Q0UyMFxcdUNFM0NcXHVDRTU4XFx1Q0U3NFxcdUNFOTBcXHVDRUFDXFx1Q0VDOFxcdUNFRTRcXHVDRjAwXFx1Q0YxQ1xcdUNGMzhcXHVDRjU0XFx1Q0Y3MFxcdUNGOENcXHVDRkE4XFx1Q0ZDNFxcdUNGRTBcXHVDRkZDXFx1RDAxOFxcdUQwMzRcXHVEMDUwXFx1RDA2Q1xcdUQwODhcXHVEMEE0XFx1RDBDMFxcdUQwRENcXHVEMEY4XFx1RDExNFxcdUQxMzBcXHVEMTRDXFx1RDE2OFxcdUQxODRcXHVEMUEwXFx1RDFCQ1xcdUQxRDhcXHVEMUY0XFx1RDIxMFxcdUQyMkNcXHVEMjQ4XFx1RDI2NFxcdUQyODBcXHVEMjlDXFx1RDJCOFxcdUQyRDRcXHVEMkYwXFx1RDMwQ1xcdUQzMjhcXHVEMzQ0XFx1RDM2MFxcdUQzN0NcXHVEMzk4XFx1RDNCNFxcdUQzRDBcXHVEM0VDXFx1RDQwOFxcdUQ0MjRcXHVENDQwXFx1RDQ1Q1xcdUQ0NzhcXHVENDk0XFx1RDRCMFxcdUQ0Q0NcXHVENEU4XFx1RDUwNFxcdUQ1MjBcXHVENTNDXFx1RDU1OFxcdUQ1NzRcXHVENTkwXFx1RDVBQ1xcdUQ1QzhcXHVENUU0XFx1RDYwMFxcdUQ2MUNcXHVENjM4XFx1RDY1NFxcdUQ2NzBcXHVENjhDXFx1RDZBOFxcdUQ2QzRcXHVENkUwXFx1RDZGQ1xcdUQ3MThcXHVENzM0XFx1RDc1MFxcdUQ3NkNcXHVENzg4XSQvO1xudmFyIHJlTFZUID0gL15bXFx1QUMwMS1cXHVBQzFCXFx1QUMxRC1cXHVBQzM3XFx1QUMzOS1cXHVBQzUzXFx1QUM1NS1cXHVBQzZGXFx1QUM3MS1cXHVBQzhCXFx1QUM4RC1cXHVBQ0E3XFx1QUNBOS1cXHVBQ0MzXFx1QUNDNS1cXHVBQ0RGXFx1QUNFMS1cXHVBQ0ZCXFx1QUNGRC1cXHVBRDE3XFx1QUQxOS1cXHVBRDMzXFx1QUQzNS1cXHVBRDRGXFx1QUQ1MS1cXHVBRDZCXFx1QUQ2RC1cXHVBRDg3XFx1QUQ4OS1cXHVBREEzXFx1QURBNS1cXHVBREJGXFx1QURDMS1cXHVBRERCXFx1QURERC1cXHVBREY3XFx1QURGOS1cXHVBRTEzXFx1QUUxNS1cXHVBRTJGXFx1QUUzMS1cXHVBRTRCXFx1QUU0RC1cXHVBRTY3XFx1QUU2OS1cXHVBRTgzXFx1QUU4NS1cXHVBRTlGXFx1QUVBMS1cXHVBRUJCXFx1QUVCRC1cXHVBRUQ3XFx1QUVEOS1cXHVBRUYzXFx1QUVGNS1cXHVBRjBGXFx1QUYxMS1cXHVBRjJCXFx1QUYyRC1cXHVBRjQ3XFx1QUY0OS1cXHVBRjYzXFx1QUY2NS1cXHVBRjdGXFx1QUY4MS1cXHVBRjlCXFx1QUY5RC1cXHVBRkI3XFx1QUZCOS1cXHVBRkQzXFx1QUZENS1cXHVBRkVGXFx1QUZGMS1cXHVCMDBCXFx1QjAwRC1cXHVCMDI3XFx1QjAyOS1cXHVCMDQzXFx1QjA0NS1cXHVCMDVGXFx1QjA2MS1cXHVCMDdCXFx1QjA3RC1cXHVCMDk3XFx1QjA5OS1cXHVCMEIzXFx1QjBCNS1cXHVCMENGXFx1QjBEMS1cXHVCMEVCXFx1QjBFRC1cXHVCMTA3XFx1QjEwOS1cXHVCMTIzXFx1QjEyNS1cXHVCMTNGXFx1QjE0MS1cXHVCMTVCXFx1QjE1RC1cXHVCMTc3XFx1QjE3OS1cXHVCMTkzXFx1QjE5NS1cXHVCMUFGXFx1QjFCMS1cXHVCMUNCXFx1QjFDRC1cXHVCMUU3XFx1QjFFOS1cXHVCMjAzXFx1QjIwNS1cXHVCMjFGXFx1QjIyMS1cXHVCMjNCXFx1QjIzRC1cXHVCMjU3XFx1QjI1OS1cXHVCMjczXFx1QjI3NS1cXHVCMjhGXFx1QjI5MS1cXHVCMkFCXFx1QjJBRC1cXHVCMkM3XFx1QjJDOS1cXHVCMkUzXFx1QjJFNS1cXHVCMkZGXFx1QjMwMS1cXHVCMzFCXFx1QjMxRC1cXHVCMzM3XFx1QjMzOS1cXHVCMzUzXFx1QjM1NS1cXHVCMzZGXFx1QjM3MS1cXHVCMzhCXFx1QjM4RC1cXHVCM0E3XFx1QjNBOS1cXHVCM0MzXFx1QjNDNS1cXHVCM0RGXFx1QjNFMS1cXHVCM0ZCXFx1QjNGRC1cXHVCNDE3XFx1QjQxOS1cXHVCNDMzXFx1QjQzNS1cXHVCNDRGXFx1QjQ1MS1cXHVCNDZCXFx1QjQ2RC1cXHVCNDg3XFx1QjQ4OS1cXHVCNEEzXFx1QjRBNS1cXHVCNEJGXFx1QjRDMS1cXHVCNERCXFx1QjRERC1cXHVCNEY3XFx1QjRGOS1cXHVCNTEzXFx1QjUxNS1cXHVCNTJGXFx1QjUzMS1cXHVCNTRCXFx1QjU0RC1cXHVCNTY3XFx1QjU2OS1cXHVCNTgzXFx1QjU4NS1cXHVCNTlGXFx1QjVBMS1cXHVCNUJCXFx1QjVCRC1cXHVCNUQ3XFx1QjVEOS1cXHVCNUYzXFx1QjVGNS1cXHVCNjBGXFx1QjYxMS1cXHVCNjJCXFx1QjYyRC1cXHVCNjQ3XFx1QjY0OS1cXHVCNjYzXFx1QjY2NS1cXHVCNjdGXFx1QjY4MS1cXHVCNjlCXFx1QjY5RC1cXHVCNkI3XFx1QjZCOS1cXHVCNkQzXFx1QjZENS1cXHVCNkVGXFx1QjZGMS1cXHVCNzBCXFx1QjcwRC1cXHVCNzI3XFx1QjcyOS1cXHVCNzQzXFx1Qjc0NS1cXHVCNzVGXFx1Qjc2MS1cXHVCNzdCXFx1Qjc3RC1cXHVCNzk3XFx1Qjc5OS1cXHVCN0IzXFx1QjdCNS1cXHVCN0NGXFx1QjdEMS1cXHVCN0VCXFx1QjdFRC1cXHVCODA3XFx1QjgwOS1cXHVCODIzXFx1QjgyNS1cXHVCODNGXFx1Qjg0MS1cXHVCODVCXFx1Qjg1RC1cXHVCODc3XFx1Qjg3OS1cXHVCODkzXFx1Qjg5NS1cXHVCOEFGXFx1QjhCMS1cXHVCOENCXFx1QjhDRC1cXHVCOEU3XFx1QjhFOS1cXHVCOTAzXFx1QjkwNS1cXHVCOTFGXFx1QjkyMS1cXHVCOTNCXFx1QjkzRC1cXHVCOTU3XFx1Qjk1OS1cXHVCOTczXFx1Qjk3NS1cXHVCOThGXFx1Qjk5MS1cXHVCOUFCXFx1QjlBRC1cXHVCOUM3XFx1QjlDOS1cXHVCOUUzXFx1QjlFNS1cXHVCOUZGXFx1QkEwMS1cXHVCQTFCXFx1QkExRC1cXHVCQTM3XFx1QkEzOS1cXHVCQTUzXFx1QkE1NS1cXHVCQTZGXFx1QkE3MS1cXHVCQThCXFx1QkE4RC1cXHVCQUE3XFx1QkFBOS1cXHVCQUMzXFx1QkFDNS1cXHVCQURGXFx1QkFFMS1cXHVCQUZCXFx1QkFGRC1cXHVCQjE3XFx1QkIxOS1cXHVCQjMzXFx1QkIzNS1cXHVCQjRGXFx1QkI1MS1cXHVCQjZCXFx1QkI2RC1cXHVCQjg3XFx1QkI4OS1cXHVCQkEzXFx1QkJBNS1cXHVCQkJGXFx1QkJDMS1cXHVCQkRCXFx1QkJERC1cXHVCQkY3XFx1QkJGOS1cXHVCQzEzXFx1QkMxNS1cXHVCQzJGXFx1QkMzMS1cXHVCQzRCXFx1QkM0RC1cXHVCQzY3XFx1QkM2OS1cXHVCQzgzXFx1QkM4NS1cXHVCQzlGXFx1QkNBMS1cXHVCQ0JCXFx1QkNCRC1cXHVCQ0Q3XFx1QkNEOS1cXHVCQ0YzXFx1QkNGNS1cXHVCRDBGXFx1QkQxMS1cXHVCRDJCXFx1QkQyRC1cXHVCRDQ3XFx1QkQ0OS1cXHVCRDYzXFx1QkQ2NS1cXHVCRDdGXFx1QkQ4MS1cXHVCRDlCXFx1QkQ5RC1cXHVCREI3XFx1QkRCOS1cXHVCREQzXFx1QkRENS1cXHVCREVGXFx1QkRGMS1cXHVCRTBCXFx1QkUwRC1cXHVCRTI3XFx1QkUyOS1cXHVCRTQzXFx1QkU0NS1cXHVCRTVGXFx1QkU2MS1cXHVCRTdCXFx1QkU3RC1cXHVCRTk3XFx1QkU5OS1cXHVCRUIzXFx1QkVCNS1cXHVCRUNGXFx1QkVEMS1cXHVCRUVCXFx1QkVFRC1cXHVCRjA3XFx1QkYwOS1cXHVCRjIzXFx1QkYyNS1cXHVCRjNGXFx1QkY0MS1cXHVCRjVCXFx1QkY1RC1cXHVCRjc3XFx1QkY3OS1cXHVCRjkzXFx1QkY5NS1cXHVCRkFGXFx1QkZCMS1cXHVCRkNCXFx1QkZDRC1cXHVCRkU3XFx1QkZFOS1cXHVDMDAzXFx1QzAwNS1cXHVDMDFGXFx1QzAyMS1cXHVDMDNCXFx1QzAzRC1cXHVDMDU3XFx1QzA1OS1cXHVDMDczXFx1QzA3NS1cXHVDMDhGXFx1QzA5MS1cXHVDMEFCXFx1QzBBRC1cXHVDMEM3XFx1QzBDOS1cXHVDMEUzXFx1QzBFNS1cXHVDMEZGXFx1QzEwMS1cXHVDMTFCXFx1QzExRC1cXHVDMTM3XFx1QzEzOS1cXHVDMTUzXFx1QzE1NS1cXHVDMTZGXFx1QzE3MS1cXHVDMThCXFx1QzE4RC1cXHVDMUE3XFx1QzFBOS1cXHVDMUMzXFx1QzFDNS1cXHVDMURGXFx1QzFFMS1cXHVDMUZCXFx1QzFGRC1cXHVDMjE3XFx1QzIxOS1cXHVDMjMzXFx1QzIzNS1cXHVDMjRGXFx1QzI1MS1cXHVDMjZCXFx1QzI2RC1cXHVDMjg3XFx1QzI4OS1cXHVDMkEzXFx1QzJBNS1cXHVDMkJGXFx1QzJDMS1cXHVDMkRCXFx1QzJERC1cXHVDMkY3XFx1QzJGOS1cXHVDMzEzXFx1QzMxNS1cXHVDMzJGXFx1QzMzMS1cXHVDMzRCXFx1QzM0RC1cXHVDMzY3XFx1QzM2OS1cXHVDMzgzXFx1QzM4NS1cXHVDMzlGXFx1QzNBMS1cXHVDM0JCXFx1QzNCRC1cXHVDM0Q3XFx1QzNEOS1cXHVDM0YzXFx1QzNGNS1cXHVDNDBGXFx1QzQxMS1cXHVDNDJCXFx1QzQyRC1cXHVDNDQ3XFx1QzQ0OS1cXHVDNDYzXFx1QzQ2NS1cXHVDNDdGXFx1QzQ4MS1cXHVDNDlCXFx1QzQ5RC1cXHVDNEI3XFx1QzRCOS1cXHVDNEQzXFx1QzRENS1cXHVDNEVGXFx1QzRGMS1cXHVDNTBCXFx1QzUwRC1cXHVDNTI3XFx1QzUyOS1cXHVDNTQzXFx1QzU0NS1cXHVDNTVGXFx1QzU2MS1cXHVDNTdCXFx1QzU3RC1cXHVDNTk3XFx1QzU5OS1cXHVDNUIzXFx1QzVCNS1cXHVDNUNGXFx1QzVEMS1cXHVDNUVCXFx1QzVFRC1cXHVDNjA3XFx1QzYwOS1cXHVDNjIzXFx1QzYyNS1cXHVDNjNGXFx1QzY0MS1cXHVDNjVCXFx1QzY1RC1cXHVDNjc3XFx1QzY3OS1cXHVDNjkzXFx1QzY5NS1cXHVDNkFGXFx1QzZCMS1cXHVDNkNCXFx1QzZDRC1cXHVDNkU3XFx1QzZFOS1cXHVDNzAzXFx1QzcwNS1cXHVDNzFGXFx1QzcyMS1cXHVDNzNCXFx1QzczRC1cXHVDNzU3XFx1Qzc1OS1cXHVDNzczXFx1Qzc3NS1cXHVDNzhGXFx1Qzc5MS1cXHVDN0FCXFx1QzdBRC1cXHVDN0M3XFx1QzdDOS1cXHVDN0UzXFx1QzdFNS1cXHVDN0ZGXFx1QzgwMS1cXHVDODFCXFx1QzgxRC1cXHVDODM3XFx1QzgzOS1cXHVDODUzXFx1Qzg1NS1cXHVDODZGXFx1Qzg3MS1cXHVDODhCXFx1Qzg4RC1cXHVDOEE3XFx1QzhBOS1cXHVDOEMzXFx1QzhDNS1cXHVDOERGXFx1QzhFMS1cXHVDOEZCXFx1QzhGRC1cXHVDOTE3XFx1QzkxOS1cXHVDOTMzXFx1QzkzNS1cXHVDOTRGXFx1Qzk1MS1cXHVDOTZCXFx1Qzk2RC1cXHVDOTg3XFx1Qzk4OS1cXHVDOUEzXFx1QzlBNS1cXHVDOUJGXFx1QzlDMS1cXHVDOURCXFx1QzlERC1cXHVDOUY3XFx1QzlGOS1cXHVDQTEzXFx1Q0ExNS1cXHVDQTJGXFx1Q0EzMS1cXHVDQTRCXFx1Q0E0RC1cXHVDQTY3XFx1Q0E2OS1cXHVDQTgzXFx1Q0E4NS1cXHVDQTlGXFx1Q0FBMS1cXHVDQUJCXFx1Q0FCRC1cXHVDQUQ3XFx1Q0FEOS1cXHVDQUYzXFx1Q0FGNS1cXHVDQjBGXFx1Q0IxMS1cXHVDQjJCXFx1Q0IyRC1cXHVDQjQ3XFx1Q0I0OS1cXHVDQjYzXFx1Q0I2NS1cXHVDQjdGXFx1Q0I4MS1cXHVDQjlCXFx1Q0I5RC1cXHVDQkI3XFx1Q0JCOS1cXHVDQkQzXFx1Q0JENS1cXHVDQkVGXFx1Q0JGMS1cXHVDQzBCXFx1Q0MwRC1cXHVDQzI3XFx1Q0MyOS1cXHVDQzQzXFx1Q0M0NS1cXHVDQzVGXFx1Q0M2MS1cXHVDQzdCXFx1Q0M3RC1cXHVDQzk3XFx1Q0M5OS1cXHVDQ0IzXFx1Q0NCNS1cXHVDQ0NGXFx1Q0NEMS1cXHVDQ0VCXFx1Q0NFRC1cXHVDRDA3XFx1Q0QwOS1cXHVDRDIzXFx1Q0QyNS1cXHVDRDNGXFx1Q0Q0MS1cXHVDRDVCXFx1Q0Q1RC1cXHVDRDc3XFx1Q0Q3OS1cXHVDRDkzXFx1Q0Q5NS1cXHVDREFGXFx1Q0RCMS1cXHVDRENCXFx1Q0RDRC1cXHVDREU3XFx1Q0RFOS1cXHVDRTAzXFx1Q0UwNS1cXHVDRTFGXFx1Q0UyMS1cXHVDRTNCXFx1Q0UzRC1cXHVDRTU3XFx1Q0U1OS1cXHVDRTczXFx1Q0U3NS1cXHVDRThGXFx1Q0U5MS1cXHVDRUFCXFx1Q0VBRC1cXHVDRUM3XFx1Q0VDOS1cXHVDRUUzXFx1Q0VFNS1cXHVDRUZGXFx1Q0YwMS1cXHVDRjFCXFx1Q0YxRC1cXHVDRjM3XFx1Q0YzOS1cXHVDRjUzXFx1Q0Y1NS1cXHVDRjZGXFx1Q0Y3MS1cXHVDRjhCXFx1Q0Y4RC1cXHVDRkE3XFx1Q0ZBOS1cXHVDRkMzXFx1Q0ZDNS1cXHVDRkRGXFx1Q0ZFMS1cXHVDRkZCXFx1Q0ZGRC1cXHVEMDE3XFx1RDAxOS1cXHVEMDMzXFx1RDAzNS1cXHVEMDRGXFx1RDA1MS1cXHVEMDZCXFx1RDA2RC1cXHVEMDg3XFx1RDA4OS1cXHVEMEEzXFx1RDBBNS1cXHVEMEJGXFx1RDBDMS1cXHVEMERCXFx1RDBERC1cXHVEMEY3XFx1RDBGOS1cXHVEMTEzXFx1RDExNS1cXHVEMTJGXFx1RDEzMS1cXHVEMTRCXFx1RDE0RC1cXHVEMTY3XFx1RDE2OS1cXHVEMTgzXFx1RDE4NS1cXHVEMTlGXFx1RDFBMS1cXHVEMUJCXFx1RDFCRC1cXHVEMUQ3XFx1RDFEOS1cXHVEMUYzXFx1RDFGNS1cXHVEMjBGXFx1RDIxMS1cXHVEMjJCXFx1RDIyRC1cXHVEMjQ3XFx1RDI0OS1cXHVEMjYzXFx1RDI2NS1cXHVEMjdGXFx1RDI4MS1cXHVEMjlCXFx1RDI5RC1cXHVEMkI3XFx1RDJCOS1cXHVEMkQzXFx1RDJENS1cXHVEMkVGXFx1RDJGMS1cXHVEMzBCXFx1RDMwRC1cXHVEMzI3XFx1RDMyOS1cXHVEMzQzXFx1RDM0NS1cXHVEMzVGXFx1RDM2MS1cXHVEMzdCXFx1RDM3RC1cXHVEMzk3XFx1RDM5OS1cXHVEM0IzXFx1RDNCNS1cXHVEM0NGXFx1RDNEMS1cXHVEM0VCXFx1RDNFRC1cXHVENDA3XFx1RDQwOS1cXHVENDIzXFx1RDQyNS1cXHVENDNGXFx1RDQ0MS1cXHVENDVCXFx1RDQ1RC1cXHVENDc3XFx1RDQ3OS1cXHVENDkzXFx1RDQ5NS1cXHVENEFGXFx1RDRCMS1cXHVENENCXFx1RDRDRC1cXHVENEU3XFx1RDRFOS1cXHVENTAzXFx1RDUwNS1cXHVENTFGXFx1RDUyMS1cXHVENTNCXFx1RDUzRC1cXHVENTU3XFx1RDU1OS1cXHVENTczXFx1RDU3NS1cXHVENThGXFx1RDU5MS1cXHVENUFCXFx1RDVBRC1cXHVENUM3XFx1RDVDOS1cXHVENUUzXFx1RDVFNS1cXHVENUZGXFx1RDYwMS1cXHVENjFCXFx1RDYxRC1cXHVENjM3XFx1RDYzOS1cXHVENjUzXFx1RDY1NS1cXHVENjZGXFx1RDY3MS1cXHVENjhCXFx1RDY4RC1cXHVENkE3XFx1RDZBOS1cXHVENkMzXFx1RDZDNS1cXHVENkRGXFx1RDZFMS1cXHVENkZCXFx1RDZGRC1cXHVENzE3XFx1RDcxOS1cXHVENzMzXFx1RDczNS1cXHVENzRGXFx1RDc1MS1cXHVENzZCXFx1RDc2RC1cXHVENzg3XFx1RDc4OS1cXHVEN0EzXSQvO1xudmFyIHJlRXh0UGljdCA9IC9eKD86W1xceEE5XFx4QUVcXHUyMDNDXFx1MjA0OVxcdTIxMjJcXHUyMTM5XFx1MjE5NC1cXHUyMTk5XFx1MjFBOVxcdTIxQUFcXHUyMzFBXFx1MjMxQlxcdTIzMjhcXHUyMzg4XFx1MjNDRlxcdTIzRTktXFx1MjNGM1xcdTIzRjgtXFx1MjNGQVxcdTI0QzJcXHUyNUFBXFx1MjVBQlxcdTI1QjZcXHUyNUMwXFx1MjVGQi1cXHUyNUZFXFx1MjYwMC1cXHUyNjA1XFx1MjYwNy1cXHUyNjEyXFx1MjYxNC1cXHUyNjg1XFx1MjY5MC1cXHUyNzA1XFx1MjcwOC1cXHUyNzEyXFx1MjcxNFxcdTI3MTZcXHUyNzFEXFx1MjcyMVxcdTI3MjhcXHUyNzMzXFx1MjczNFxcdTI3NDRcXHUyNzQ3XFx1Mjc0Q1xcdTI3NEVcXHUyNzUzLVxcdTI3NTVcXHUyNzU3XFx1Mjc2My1cXHUyNzY3XFx1Mjc5NS1cXHUyNzk3XFx1MjdBMVxcdTI3QjBcXHUyN0JGXFx1MjkzNFxcdTI5MzVcXHUyQjA1LVxcdTJCMDdcXHUyQjFCXFx1MkIxQ1xcdTJCNTBcXHUyQjU1XFx1MzAzMFxcdTMwM0RcXHUzMjk3XFx1MzI5OV18XFx1RDgzQ1tcXHVEQzAwLVxcdURDRkZcXHVERDBELVxcdUREMEZcXHVERDJGXFx1REQ2Qy1cXHVERDcxXFx1REQ3RVxcdUREN0ZcXHVERDhFXFx1REQ5MS1cXHVERDlBXFx1RERBRC1cXHVEREU1XFx1REUwMS1cXHVERTBGXFx1REUxQVxcdURFMkZcXHVERTMyLVxcdURFM0FcXHVERTNDLVxcdURFM0ZcXHVERTQ5LVxcdURGRkFdfFxcdUQ4M0RbXFx1REMwMC1cXHVERDNEXFx1REQ0Ni1cXHVERTRGXFx1REU4MC1cXHVERUZGXFx1REY3NC1cXHVERjdGXFx1REZENS1cXHVERkZGXXxcXHVEODNFW1xcdURDMEMtXFx1REMwRlxcdURDNDgtXFx1REM0RlxcdURDNUEtXFx1REM1RlxcdURDODgtXFx1REM4RlxcdURDQUUtXFx1RENGRlxcdUREMEMtXFx1REQzQVxcdUREM0MtXFx1REQ0NVxcdURENDctXFx1REVGRl18XFx1RDgzRltcXHVEQzAwLVxcdURGRkRdKSQvO1xudmFyIGdldENvZGVwb2ludFR5cGUgPSAoY2hhciwgY29kZSkgPT4ge1xuICB2YXIgdHlwZSA9IENvZGVwb2ludFR5cGUuQW55O1xuICBpZiAoY2hhci5zZWFyY2gocmVFeHRlbmQpICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5FeHRlbmQ7XG4gIH1cbiAgaWYgKGNvZGUgPT09IDB4MjAwZCkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5aV0o7XG4gIH1cbiAgaWYgKGNvZGUgPj0gMHgxZjFlNiAmJiBjb2RlIDw9IDB4MWYxZmYpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuUkk7XG4gIH1cbiAgaWYgKGNoYXIuc2VhcmNoKHJlUHJlcGVuZCkgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLlByZXBlbmQ7XG4gIH1cbiAgaWYgKGNoYXIuc2VhcmNoKHJlU3BhY2luZ01hcmspICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5TcGFjaW5nTWFyaztcbiAgfVxuICBpZiAoY2hhci5zZWFyY2gocmVMKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuTDtcbiAgfVxuICBpZiAoY2hhci5zZWFyY2gocmVWKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuVjtcbiAgfVxuICBpZiAoY2hhci5zZWFyY2gocmVUKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuVDtcbiAgfVxuICBpZiAoY2hhci5zZWFyY2gocmVMVikgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLkxWO1xuICB9XG4gIGlmIChjaGFyLnNlYXJjaChyZUxWVCkgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLkxWVDtcbiAgfVxuICBpZiAoY2hhci5zZWFyY2gocmVFeHRQaWN0KSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuRXh0UGljdDtcbiAgfVxuICByZXR1cm4gdHlwZTtcbn07XG5mdW5jdGlvbiBpbnRlcnNlY3RzKHgsIHkpIHtcbiAgcmV0dXJuICh4ICYgeSkgIT09IDA7XG59XG52YXIgTm9uQm91bmRhcnlQYWlycyA9IFtcbi8vIEdCNlxuW0NvZGVwb2ludFR5cGUuTCwgQ29kZXBvaW50VHlwZS5MIHwgQ29kZXBvaW50VHlwZS5WIHwgQ29kZXBvaW50VHlwZS5MViB8IENvZGVwb2ludFR5cGUuTFZUXSxcbi8vIEdCN1xuW0NvZGVwb2ludFR5cGUuTFYgfCBDb2RlcG9pbnRUeXBlLlYsIENvZGVwb2ludFR5cGUuViB8IENvZGVwb2ludFR5cGUuVF0sXG4vLyBHQjhcbltDb2RlcG9pbnRUeXBlLkxWVCB8IENvZGVwb2ludFR5cGUuVCwgQ29kZXBvaW50VHlwZS5UXSxcbi8vIEdCOVxuW0NvZGVwb2ludFR5cGUuQW55LCBDb2RlcG9pbnRUeXBlLkV4dGVuZCB8IENvZGVwb2ludFR5cGUuWldKXSxcbi8vIEdCOWFcbltDb2RlcG9pbnRUeXBlLkFueSwgQ29kZXBvaW50VHlwZS5TcGFjaW5nTWFya10sXG4vLyBHQjliXG5bQ29kZXBvaW50VHlwZS5QcmVwZW5kLCBDb2RlcG9pbnRUeXBlLkFueV0sXG4vLyBHQjExXG5bQ29kZXBvaW50VHlwZS5aV0osIENvZGVwb2ludFR5cGUuRXh0UGljdF0sXG4vLyBHQjEyIGFuZCBHQjEzXG5bQ29kZXBvaW50VHlwZS5SSSwgQ29kZXBvaW50VHlwZS5SSV1dO1xuZnVuY3Rpb24gaXNCb3VuZGFyeVBhaXIobGVmdCwgcmlnaHQpIHtcbiAgcmV0dXJuIE5vbkJvdW5kYXJ5UGFpcnMuZmluZEluZGV4KHIgPT4gaW50ZXJzZWN0cyhsZWZ0LCByWzBdKSAmJiBpbnRlcnNlY3RzKHJpZ2h0LCByWzFdKSkgPT09IC0xO1xufVxudmFyIGVuZGluZ0Vtb2ppWldKID0gLyg/OltcXHhBOVxceEFFXFx1MjAzQ1xcdTIwNDlcXHUyMTIyXFx1MjEzOVxcdTIxOTQtXFx1MjE5OVxcdTIxQTlcXHUyMUFBXFx1MjMxQVxcdTIzMUJcXHUyMzI4XFx1MjM4OFxcdTIzQ0ZcXHUyM0U5LVxcdTIzRjNcXHUyM0Y4LVxcdTIzRkFcXHUyNEMyXFx1MjVBQVxcdTI1QUJcXHUyNUI2XFx1MjVDMFxcdTI1RkItXFx1MjVGRVxcdTI2MDAtXFx1MjYwNVxcdTI2MDctXFx1MjYxMlxcdTI2MTQtXFx1MjY4NVxcdTI2OTAtXFx1MjcwNVxcdTI3MDgtXFx1MjcxMlxcdTI3MTRcXHUyNzE2XFx1MjcxRFxcdTI3MjFcXHUyNzI4XFx1MjczM1xcdTI3MzRcXHUyNzQ0XFx1Mjc0N1xcdTI3NENcXHUyNzRFXFx1Mjc1My1cXHUyNzU1XFx1Mjc1N1xcdTI3NjMtXFx1Mjc2N1xcdTI3OTUtXFx1Mjc5N1xcdTI3QTFcXHUyN0IwXFx1MjdCRlxcdTI5MzRcXHUyOTM1XFx1MkIwNS1cXHUyQjA3XFx1MkIxQlxcdTJCMUNcXHUyQjUwXFx1MkI1NVxcdTMwMzBcXHUzMDNEXFx1MzI5N1xcdTMyOTldfFxcdUQ4M0NbXFx1REMwMC1cXHVEQ0ZGXFx1REQwRC1cXHVERDBGXFx1REQyRlxcdURENkMtXFx1REQ3MVxcdUREN0VcXHVERDdGXFx1REQ4RVxcdUREOTEtXFx1REQ5QVxcdUREQUQtXFx1RERFNVxcdURFMDEtXFx1REUwRlxcdURFMUFcXHVERTJGXFx1REUzMi1cXHVERTNBXFx1REUzQy1cXHVERTNGXFx1REU0OS1cXHVERkZBXXxcXHVEODNEW1xcdURDMDAtXFx1REQzRFxcdURENDYtXFx1REU0RlxcdURFODAtXFx1REVGRlxcdURGNzQtXFx1REY3RlxcdURGRDUtXFx1REZGRl18XFx1RDgzRVtcXHVEQzBDLVxcdURDMEZcXHVEQzQ4LVxcdURDNEZcXHVEQzVBLVxcdURDNUZcXHVEQzg4LVxcdURDOEZcXHVEQ0FFLVxcdURDRkZcXHVERDBDLVxcdUREM0FcXHVERDNDLVxcdURENDVcXHVERDQ3LVxcdURFRkZdfFxcdUQ4M0ZbXFx1REMwMC1cXHVERkZEXSkoPzpbXFx1MDMwMC1cXHUwMzZGXFx1MDQ4My1cXHUwNDg5XFx1MDU5MS1cXHUwNUJEXFx1MDVCRlxcdTA1QzFcXHUwNUMyXFx1MDVDNFxcdTA1QzVcXHUwNUM3XFx1MDYxMC1cXHUwNjFBXFx1MDY0Qi1cXHUwNjVGXFx1MDY3MFxcdTA2RDYtXFx1MDZEQ1xcdTA2REYtXFx1MDZFNFxcdTA2RTdcXHUwNkU4XFx1MDZFQS1cXHUwNkVEXFx1MDcxMVxcdTA3MzAtXFx1MDc0QVxcdTA3QTYtXFx1MDdCMFxcdTA3RUItXFx1MDdGM1xcdTA3RkRcXHUwODE2LVxcdTA4MTlcXHUwODFCLVxcdTA4MjNcXHUwODI1LVxcdTA4MjdcXHUwODI5LVxcdTA4MkRcXHUwODU5LVxcdTA4NUJcXHUwODk4LVxcdTA4OUZcXHUwOENBLVxcdTA4RTFcXHUwOEUzLVxcdTA5MDJcXHUwOTNBXFx1MDkzQ1xcdTA5NDEtXFx1MDk0OFxcdTA5NERcXHUwOTUxLVxcdTA5NTdcXHUwOTYyXFx1MDk2M1xcdTA5ODFcXHUwOUJDXFx1MDlCRVxcdTA5QzEtXFx1MDlDNFxcdTA5Q0RcXHUwOUQ3XFx1MDlFMlxcdTA5RTNcXHUwOUZFXFx1MEEwMVxcdTBBMDJcXHUwQTNDXFx1MEE0MVxcdTBBNDJcXHUwQTQ3XFx1MEE0OFxcdTBBNEItXFx1MEE0RFxcdTBBNTFcXHUwQTcwXFx1MEE3MVxcdTBBNzVcXHUwQTgxXFx1MEE4MlxcdTBBQkNcXHUwQUMxLVxcdTBBQzVcXHUwQUM3XFx1MEFDOFxcdTBBQ0RcXHUwQUUyXFx1MEFFM1xcdTBBRkEtXFx1MEFGRlxcdTBCMDFcXHUwQjNDXFx1MEIzRVxcdTBCM0ZcXHUwQjQxLVxcdTBCNDRcXHUwQjREXFx1MEI1NS1cXHUwQjU3XFx1MEI2MlxcdTBCNjNcXHUwQjgyXFx1MEJCRVxcdTBCQzBcXHUwQkNEXFx1MEJEN1xcdTBDMDBcXHUwQzA0XFx1MEMzQ1xcdTBDM0UtXFx1MEM0MFxcdTBDNDYtXFx1MEM0OFxcdTBDNEEtXFx1MEM0RFxcdTBDNTVcXHUwQzU2XFx1MEM2MlxcdTBDNjNcXHUwQzgxXFx1MENCQ1xcdTBDQkZcXHUwQ0MyXFx1MENDNlxcdTBDQ0NcXHUwQ0NEXFx1MENENVxcdTBDRDZcXHUwQ0UyXFx1MENFM1xcdTBEMDBcXHUwRDAxXFx1MEQzQlxcdTBEM0NcXHUwRDNFXFx1MEQ0MS1cXHUwRDQ0XFx1MEQ0RFxcdTBENTdcXHUwRDYyXFx1MEQ2M1xcdTBEODFcXHUwRENBXFx1MERDRlxcdTBERDItXFx1MERENFxcdTBERDZcXHUwRERGXFx1MEUzMVxcdTBFMzQtXFx1MEUzQVxcdTBFNDctXFx1MEU0RVxcdTBFQjFcXHUwRUI0LVxcdTBFQkNcXHUwRUM4LVxcdTBFQ0VcXHUwRjE4XFx1MEYxOVxcdTBGMzVcXHUwRjM3XFx1MEYzOVxcdTBGNzEtXFx1MEY3RVxcdTBGODAtXFx1MEY4NFxcdTBGODZcXHUwRjg3XFx1MEY4RC1cXHUwRjk3XFx1MEY5OS1cXHUwRkJDXFx1MEZDNlxcdTEwMkQtXFx1MTAzMFxcdTEwMzItXFx1MTAzN1xcdTEwMzlcXHUxMDNBXFx1MTAzRFxcdTEwM0VcXHUxMDU4XFx1MTA1OVxcdTEwNUUtXFx1MTA2MFxcdTEwNzEtXFx1MTA3NFxcdTEwODJcXHUxMDg1XFx1MTA4NlxcdTEwOERcXHUxMDlEXFx1MTM1RC1cXHUxMzVGXFx1MTcxMi1cXHUxNzE0XFx1MTczMlxcdTE3MzNcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdCNFxcdTE3QjVcXHUxN0I3LVxcdTE3QkRcXHUxN0M2XFx1MTdDOS1cXHUxN0QzXFx1MTdERFxcdTE4MEItXFx1MTgwRFxcdTE4MEZcXHUxODg1XFx1MTg4NlxcdTE4QTlcXHUxOTIwLVxcdTE5MjJcXHUxOTI3XFx1MTkyOFxcdTE5MzJcXHUxOTM5LVxcdTE5M0JcXHUxQTE3XFx1MUExOFxcdTFBMUJcXHUxQTU2XFx1MUE1OC1cXHUxQTVFXFx1MUE2MFxcdTFBNjJcXHUxQTY1LVxcdTFBNkNcXHUxQTczLVxcdTFBN0NcXHUxQTdGXFx1MUFCMC1cXHUxQUNFXFx1MUIwMC1cXHUxQjAzXFx1MUIzNC1cXHUxQjNBXFx1MUIzQ1xcdTFCNDJcXHUxQjZCLVxcdTFCNzNcXHUxQjgwXFx1MUI4MVxcdTFCQTItXFx1MUJBNVxcdTFCQThcXHUxQkE5XFx1MUJBQi1cXHUxQkFEXFx1MUJFNlxcdTFCRThcXHUxQkU5XFx1MUJFRFxcdTFCRUYtXFx1MUJGMVxcdTFDMkMtXFx1MUMzM1xcdTFDMzZcXHUxQzM3XFx1MUNEMC1cXHUxQ0QyXFx1MUNENC1cXHUxQ0UwXFx1MUNFMi1cXHUxQ0U4XFx1MUNFRFxcdTFDRjRcXHUxQ0Y4XFx1MUNGOVxcdTFEQzAtXFx1MURGRlxcdTIwMENcXHUyMEQwLVxcdTIwRjBcXHUyQ0VGLVxcdTJDRjFcXHUyRDdGXFx1MkRFMC1cXHUyREZGXFx1MzAyQS1cXHUzMDJGXFx1MzA5OVxcdTMwOUFcXHVBNjZGLVxcdUE2NzJcXHVBNjc0LVxcdUE2N0RcXHVBNjlFXFx1QTY5RlxcdUE2RjBcXHVBNkYxXFx1QTgwMlxcdUE4MDZcXHVBODBCXFx1QTgyNVxcdUE4MjZcXHVBODJDXFx1QThDNFxcdUE4QzVcXHVBOEUwLVxcdUE4RjFcXHVBOEZGXFx1QTkyNi1cXHVBOTJEXFx1QTk0Ny1cXHVBOTUxXFx1QTk4MC1cXHVBOTgyXFx1QTlCM1xcdUE5QjYtXFx1QTlCOVxcdUE5QkNcXHVBOUJEXFx1QTlFNVxcdUFBMjktXFx1QUEyRVxcdUFBMzFcXHVBQTMyXFx1QUEzNVxcdUFBMzZcXHVBQTQzXFx1QUE0Q1xcdUFBN0NcXHVBQUIwXFx1QUFCMi1cXHVBQUI0XFx1QUFCN1xcdUFBQjhcXHVBQUJFXFx1QUFCRlxcdUFBQzFcXHVBQUVDXFx1QUFFRFxcdUFBRjZcXHVBQkU1XFx1QUJFOFxcdUFCRURcXHVGQjFFXFx1RkUwMC1cXHVGRTBGXFx1RkUyMC1cXHVGRTJGXFx1RkY5RVxcdUZGOUZdfFxcdUQ4MDBbXFx1RERGRFxcdURFRTBcXHVERjc2LVxcdURGN0FdfFxcdUQ4MDJbXFx1REUwMS1cXHVERTAzXFx1REUwNVxcdURFMDZcXHVERTBDLVxcdURFMEZcXHVERTM4LVxcdURFM0FcXHVERTNGXFx1REVFNVxcdURFRTZdfFxcdUQ4MDNbXFx1REQyNC1cXHVERDI3XFx1REVBQlxcdURFQUNcXHVERUZELVxcdURFRkZcXHVERjQ2LVxcdURGNTBcXHVERjgyLVxcdURGODVdfFxcdUQ4MDRbXFx1REMwMVxcdURDMzgtXFx1REM0NlxcdURDNzBcXHVEQzczXFx1REM3NFxcdURDN0YtXFx1REM4MVxcdURDQjMtXFx1RENCNlxcdURDQjlcXHVEQ0JBXFx1RENDMlxcdUREMDAtXFx1REQwMlxcdUREMjctXFx1REQyQlxcdUREMkQtXFx1REQzNFxcdURENzNcXHVERDgwXFx1REQ4MVxcdUREQjYtXFx1RERCRVxcdUREQzktXFx1RERDQ1xcdUREQ0ZcXHVERTJGLVxcdURFMzFcXHVERTM0XFx1REUzNlxcdURFMzdcXHVERTNFXFx1REU0MVxcdURFREZcXHVERUUzLVxcdURFRUFcXHVERjAwXFx1REYwMVxcdURGM0JcXHVERjNDXFx1REYzRVxcdURGNDBcXHVERjU3XFx1REY2Ni1cXHVERjZDXFx1REY3MC1cXHVERjc0XXxcXHVEODA1W1xcdURDMzgtXFx1REMzRlxcdURDNDItXFx1REM0NFxcdURDNDZcXHVEQzVFXFx1RENCMFxcdURDQjMtXFx1RENCOFxcdURDQkFcXHVEQ0JEXFx1RENCRlxcdURDQzBcXHVEQ0MyXFx1RENDM1xcdUREQUZcXHVEREIyLVxcdUREQjVcXHVEREJDXFx1RERCRFxcdUREQkZcXHVEREMwXFx1REREQ1xcdURERERcXHVERTMzLVxcdURFM0FcXHVERTNEXFx1REUzRlxcdURFNDBcXHVERUFCXFx1REVBRFxcdURFQjAtXFx1REVCNVxcdURFQjdcXHVERjFELVxcdURGMUZcXHVERjIyLVxcdURGMjVcXHVERjI3LVxcdURGMkJdfFxcdUQ4MDZbXFx1REMyRi1cXHVEQzM3XFx1REMzOVxcdURDM0FcXHVERDMwXFx1REQzQlxcdUREM0NcXHVERDNFXFx1REQ0M1xcdURERDQtXFx1REREN1xcdUREREFcXHVERERCXFx1RERFMFxcdURFMDEtXFx1REUwQVxcdURFMzMtXFx1REUzOFxcdURFM0ItXFx1REUzRVxcdURFNDdcXHVERTUxLVxcdURFNTZcXHVERTU5LVxcdURFNUJcXHVERThBLVxcdURFOTZcXHVERTk4XFx1REU5OV18XFx1RDgwN1tcXHVEQzMwLVxcdURDMzZcXHVEQzM4LVxcdURDM0RcXHVEQzNGXFx1REM5Mi1cXHVEQ0E3XFx1RENBQS1cXHVEQ0IwXFx1RENCMlxcdURDQjNcXHVEQ0I1XFx1RENCNlxcdUREMzEtXFx1REQzNlxcdUREM0FcXHVERDNDXFx1REQzRFxcdUREM0YtXFx1REQ0NVxcdURENDdcXHVERDkwXFx1REQ5MVxcdUREOTVcXHVERDk3XFx1REVGM1xcdURFRjRcXHVERjAwXFx1REYwMVxcdURGMzYtXFx1REYzQVxcdURGNDBcXHVERjQyXXxcXHVEODBEW1xcdURDNDBcXHVEQzQ3LVxcdURDNTVdfFxcdUQ4MUFbXFx1REVGMC1cXHVERUY0XFx1REYzMC1cXHVERjM2XXxcXHVEODFCW1xcdURGNEZcXHVERjhGLVxcdURGOTJcXHVERkU0XXxcXHVEODJGW1xcdURDOURcXHVEQzlFXXxcXHVEODMzW1xcdURGMDAtXFx1REYyRFxcdURGMzAtXFx1REY0Nl18XFx1RDgzNFtcXHVERDY1XFx1REQ2Ny1cXHVERDY5XFx1REQ2RS1cXHVERDcyXFx1REQ3Qi1cXHVERDgyXFx1REQ4NS1cXHVERDhCXFx1RERBQS1cXHVEREFEXFx1REU0Mi1cXHVERTQ0XXxcXHVEODM2W1xcdURFMDAtXFx1REUzNlxcdURFM0ItXFx1REU2Q1xcdURFNzVcXHVERTg0XFx1REU5Qi1cXHVERTlGXFx1REVBMS1cXHVERUFGXXxcXHVEODM4W1xcdURDMDAtXFx1REMwNlxcdURDMDgtXFx1REMxOFxcdURDMUItXFx1REMyMVxcdURDMjNcXHVEQzI0XFx1REMyNi1cXHVEQzJBXFx1REM4RlxcdUREMzAtXFx1REQzNlxcdURFQUVcXHVERUVDLVxcdURFRUZdfFxcdUQ4MzlbXFx1RENFQy1cXHVEQ0VGXXxcXHVEODNBW1xcdURDRDAtXFx1RENENlxcdURENDQtXFx1REQ0QV18XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdfFxcdURCNDBbXFx1REMyMC1cXHVEQzdGXFx1REQwMC1cXHVEREVGXSkqXFx1MjAwRCQvO1xudmFyIGVuZHNXaXRoRW1vamlaV0ogPSBzdHIgPT4ge1xuICByZXR1cm4gc3RyLnNlYXJjaChlbmRpbmdFbW9qaVpXSikgIT09IC0xO1xufTtcbnZhciBlbmRpbmdSSXMgPSAvKD86XFx1RDgzQ1tcXHVEREU2LVxcdURERkZdKSskL2c7XG52YXIgZW5kc1dpdGhPZGROdW1iZXJPZlJJcyA9IHN0ciA9PiB7XG4gIHZhciBtYXRjaCA9IHN0ci5tYXRjaChlbmRpbmdSSXMpO1xuICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgLy8gQSBSSSBpcyByZXByZXNlbnRlZCBieSBhIHN1cnJvZ2F0ZSBwYWlyLlxuICAgIHZhciBudW1SSXMgPSBtYXRjaFswXS5sZW5ndGggLyAyO1xuICAgIHJldHVybiBudW1SSXMgJSAyID09PSAxO1xuICB9XG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG52YXIgVGV4dFRyYW5zZm9ybXMgPSB7XG4gIGRlbGV0ZShlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3IuZGVsZXRlKG9wdGlvbnMpO1xuICB9LFxuICBpbnNlcnRGcmFnbWVudChlZGl0b3IsIGZyYWdtZW50LCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLmluc2VydEZyYWdtZW50KGZyYWdtZW50LCBvcHRpb25zKTtcbiAgfSxcbiAgaW5zZXJ0VGV4dChlZGl0b3IsIHRleHQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIHZvaWRzID0gZmFsc2VcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgdmFyIHtcbiAgICAgICAgYXQgPSBnZXREZWZhdWx0SW5zZXJ0TG9jYXRpb24oZWRpdG9yKVxuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICAgIGF0ID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgYXQpO1xuICAgICAgfVxuICAgICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChhdCkpIHtcbiAgICAgICAgICBhdCA9IGF0LmFuY2hvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZW5kID0gUmFuZ2UuZW5kKGF0KTtcbiAgICAgICAgICBpZiAoIXZvaWRzICYmIEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IGVuZFxuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBzdGFydCA9IFJhbmdlLnN0YXJ0KGF0KTtcbiAgICAgICAgICB2YXIgc3RhcnRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBzdGFydCk7XG4gICAgICAgICAgdmFyIGVuZFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGVuZCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdCxcbiAgICAgICAgICAgIHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIHN0YXJ0UG9pbnQgPSBzdGFydFJlZi51bnJlZigpO1xuICAgICAgICAgIHZhciBlbmRQb2ludCA9IGVuZFJlZi51bnJlZigpO1xuICAgICAgICAgIGF0ID0gc3RhcnRQb2ludCB8fCBlbmRQb2ludDtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnNldFNlbGVjdGlvbihlZGl0b3IsIHtcbiAgICAgICAgICAgIGFuY2hvcjogYXQsXG4gICAgICAgICAgICBmb2N1czogYXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF2b2lkcyAmJiBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgICAgYXRcbiAgICAgIH0pIHx8IEVkaXRvci5lbGVtZW50UmVhZE9ubHkoZWRpdG9yLCB7XG4gICAgICAgIGF0XG4gICAgICB9KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIge1xuICAgICAgICBwYXRoLFxuICAgICAgICBvZmZzZXRcbiAgICAgIH0gPSBhdDtcbiAgICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDApIGVkaXRvci5hcHBseSh7XG4gICAgICAgIHR5cGU6ICdpbnNlcnRfdGV4dCcsXG4gICAgICAgIHBhdGgsXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgdGV4dFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIG93bktleXMkOShlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDkoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyQ5KE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyQ5KE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG52YXIgVHJhbnNmb3JtcyA9IF9vYmplY3RTcHJlYWQkOShfb2JqZWN0U3ByZWFkJDkoX29iamVjdFNwcmVhZCQ5KF9vYmplY3RTcHJlYWQkOSh7fSwgR2VuZXJhbFRyYW5zZm9ybXMpLCBOb2RlVHJhbnNmb3JtcyksIFNlbGVjdGlvblRyYW5zZm9ybXMpLCBUZXh0VHJhbnNmb3Jtcyk7XG5cbi8vIHBlcmZcbnZhciBCQVRDSElOR19ESVJUWV9QQVRIUyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgaXNCYXRjaGluZ0RpcnR5UGF0aHMgPSBlZGl0b3IgPT4ge1xuICByZXR1cm4gQkFUQ0hJTkdfRElSVFlfUEFUSFMuZ2V0KGVkaXRvcikgfHwgZmFsc2U7XG59O1xudmFyIGJhdGNoRGlydHlQYXRocyA9IChlZGl0b3IsIGZuLCB1cGRhdGUpID0+IHtcbiAgdmFyIHZhbHVlID0gQkFUQ0hJTkdfRElSVFlfUEFUSFMuZ2V0KGVkaXRvcikgfHwgZmFsc2U7XG4gIEJBVENISU5HX0RJUlRZX1BBVEhTLnNldChlZGl0b3IsIHRydWUpO1xuICB0cnkge1xuICAgIGZuKCk7XG4gICAgdXBkYXRlKCk7XG4gIH0gZmluYWxseSB7XG4gICAgQkFUQ0hJTkdfRElSVFlfUEFUSFMuc2V0KGVkaXRvciwgdmFsdWUpO1xuICB9XG59O1xuXG4vKipcbiAqIHVwZGF0ZSBlZGl0b3IgZGlydHkgcGF0aHNcbiAqXG4gKiBAcGFyYW0gbmV3RGlydHlQYXRoczogUGF0aFtdOyBuZXcgZGlydHkgcGF0aHNcbiAqIEBwYXJhbSB0cmFuc2Zvcm06IChwOiBQYXRoKSA9PiBQYXRoIHwgbnVsbDsgaG93IHRvIHRyYW5zZm9ybSBleGlzdGluZyBkaXJ0eSBwYXRoc1xuICovXG5mdW5jdGlvbiB1cGRhdGVEaXJ0eVBhdGhzKGVkaXRvciwgbmV3RGlydHlQYXRocywgdHJhbnNmb3JtKSB7XG4gIHZhciBvbGREaXJ0eVBhdGhzID0gRElSVFlfUEFUSFMuZ2V0KGVkaXRvcikgfHwgW107XG4gIHZhciBvbGREaXJ0eVBhdGhLZXlzID0gRElSVFlfUEFUSF9LRVlTLmdldChlZGl0b3IpIHx8IG5ldyBTZXQoKTtcbiAgdmFyIGRpcnR5UGF0aHM7XG4gIHZhciBkaXJ0eVBhdGhLZXlzO1xuICB2YXIgYWRkID0gcGF0aCA9PiB7XG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHZhciBrZXkgPSBwYXRoLmpvaW4oJywnKTtcbiAgICAgIGlmICghZGlydHlQYXRoS2V5cy5oYXMoa2V5KSkge1xuICAgICAgICBkaXJ0eVBhdGhLZXlzLmFkZChrZXkpO1xuICAgICAgICBkaXJ0eVBhdGhzLnB1c2gocGF0aCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBpZiAodHJhbnNmb3JtKSB7XG4gICAgZGlydHlQYXRocyA9IFtdO1xuICAgIGRpcnR5UGF0aEtleXMgPSBuZXcgU2V0KCk7XG4gICAgZm9yICh2YXIgcGF0aCBvZiBvbGREaXJ0eVBhdGhzKSB7XG4gICAgICB2YXIgbmV3UGF0aCA9IHRyYW5zZm9ybShwYXRoKTtcbiAgICAgIGFkZChuZXdQYXRoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGlydHlQYXRocyA9IG9sZERpcnR5UGF0aHM7XG4gICAgZGlydHlQYXRoS2V5cyA9IG9sZERpcnR5UGF0aEtleXM7XG4gIH1cbiAgZm9yICh2YXIgX3BhdGggb2YgbmV3RGlydHlQYXRocykge1xuICAgIGFkZChfcGF0aCk7XG4gIH1cbiAgRElSVFlfUEFUSFMuc2V0KGVkaXRvciwgZGlydHlQYXRocyk7XG4gIERJUlRZX1BBVEhfS0VZUy5zZXQoZWRpdG9yLCBkaXJ0eVBhdGhLZXlzKTtcbn1cblxudmFyIGFwcGx5ID0gKGVkaXRvciwgb3ApID0+IHtcbiAgZm9yICh2YXIgcmVmIG9mIEVkaXRvci5wYXRoUmVmcyhlZGl0b3IpKSB7XG4gICAgUGF0aFJlZi50cmFuc2Zvcm0ocmVmLCBvcCk7XG4gIH1cbiAgZm9yICh2YXIgX3JlZiBvZiBFZGl0b3IucG9pbnRSZWZzKGVkaXRvcikpIHtcbiAgICBQb2ludFJlZi50cmFuc2Zvcm0oX3JlZiwgb3ApO1xuICB9XG4gIGZvciAodmFyIF9yZWYyIG9mIEVkaXRvci5yYW5nZVJlZnMoZWRpdG9yKSkge1xuICAgIFJhbmdlUmVmLnRyYW5zZm9ybShfcmVmMiwgb3ApO1xuICB9XG4gIC8vIHVwZGF0ZSBkaXJ0eSBwYXRoc1xuICBpZiAoIWlzQmF0Y2hpbmdEaXJ0eVBhdGhzKGVkaXRvcikpIHtcbiAgICB2YXIgdHJhbnNmb3JtID0gUGF0aC5vcGVyYXRpb25DYW5UcmFuc2Zvcm1QYXRoKG9wKSA/IHAgPT4gUGF0aC50cmFuc2Zvcm0ocCwgb3ApIDogdW5kZWZpbmVkO1xuICAgIHVwZGF0ZURpcnR5UGF0aHMoZWRpdG9yLCBlZGl0b3IuZ2V0RGlydHlQYXRocyhvcCksIHRyYW5zZm9ybSk7XG4gIH1cbiAgVHJhbnNmb3Jtcy50cmFuc2Zvcm0oZWRpdG9yLCBvcCk7XG4gIGVkaXRvci5vcGVyYXRpb25zLnB1c2gob3ApO1xuICBFZGl0b3Iubm9ybWFsaXplKGVkaXRvciwge1xuICAgIG9wZXJhdGlvbjogb3BcbiAgfSk7XG4gIC8vIENsZWFyIGFueSBmb3JtYXRzIGFwcGxpZWQgdG8gdGhlIGN1cnNvciBpZiB0aGUgc2VsZWN0aW9uIGNoYW5nZXMuXG4gIGlmIChvcC50eXBlID09PSAnc2V0X3NlbGVjdGlvbicpIHtcbiAgICBlZGl0b3IubWFya3MgPSBudWxsO1xuICB9XG4gIGlmICghRkxVU0hJTkcuZ2V0KGVkaXRvcikpIHtcbiAgICBGTFVTSElORy5zZXQoZWRpdG9yLCB0cnVlKTtcbiAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgIEZMVVNISU5HLnNldChlZGl0b3IsIGZhbHNlKTtcbiAgICAgIGVkaXRvci5vbkNoYW5nZSh7XG4gICAgICAgIG9wZXJhdGlvbjogb3BcbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLm9wZXJhdGlvbnMgPSBbXTtcbiAgICB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIFwiZGlydHlcIiBwYXRocyBnZW5lcmF0ZWQgZnJvbSBhbiBvcGVyYXRpb24uXG4gKi9cbnZhciBnZXREaXJ0eVBhdGhzID0gKGVkaXRvciwgb3ApID0+IHtcbiAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgY2FzZSAnaW5zZXJ0X3RleHQnOlxuICAgIGNhc2UgJ3JlbW92ZV90ZXh0JzpcbiAgICBjYXNlICdzZXRfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aFxuICAgICAgICB9ID0gb3A7XG4gICAgICAgIHJldHVybiBQYXRoLmxldmVscyhwYXRoKTtcbiAgICAgIH1cbiAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICBwYXRoOiBfcGF0aFxuICAgICAgICB9ID0gb3A7XG4gICAgICAgIHZhciBsZXZlbHMgPSBQYXRoLmxldmVscyhfcGF0aCk7XG4gICAgICAgIHZhciBkZXNjZW5kYW50cyA9IFRleHQuaXNUZXh0KG5vZGUpID8gW10gOiBBcnJheS5mcm9tKE5vZGUubm9kZXMobm9kZSksIF9yZWYgPT4ge1xuICAgICAgICAgIHZhciBbLCBwXSA9IF9yZWY7XG4gICAgICAgICAgcmV0dXJuIF9wYXRoLmNvbmNhdChwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbLi4ubGV2ZWxzLCAuLi5kZXNjZW5kYW50c107XG4gICAgICB9XG4gICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGgyXG4gICAgICAgIH0gPSBvcDtcbiAgICAgICAgdmFyIGFuY2VzdG9ycyA9IFBhdGguYW5jZXN0b3JzKF9wYXRoMik7XG4gICAgICAgIHZhciBwcmV2aW91c1BhdGggPSBQYXRoLnByZXZpb3VzKF9wYXRoMik7XG4gICAgICAgIHJldHVybiBbLi4uYW5jZXN0b3JzLCBwcmV2aW91c1BhdGhdO1xuICAgICAgfVxuICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGgzLFxuICAgICAgICAgIG5ld1BhdGhcbiAgICAgICAgfSA9IG9wO1xuICAgICAgICBpZiAoUGF0aC5lcXVhbHMoX3BhdGgzLCBuZXdQYXRoKSkge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb2xkQW5jZXN0b3JzID0gW107XG4gICAgICAgIHZhciBuZXdBbmNlc3RvcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgYW5jZXN0b3Igb2YgUGF0aC5hbmNlc3RvcnMoX3BhdGgzKSkge1xuICAgICAgICAgIHZhciBwID0gUGF0aC50cmFuc2Zvcm0oYW5jZXN0b3IsIG9wKTtcbiAgICAgICAgICBvbGRBbmNlc3RvcnMucHVzaChwKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfYW5jZXN0b3Igb2YgUGF0aC5hbmNlc3RvcnMobmV3UGF0aCkpIHtcbiAgICAgICAgICB2YXIgX3AgPSBQYXRoLnRyYW5zZm9ybShfYW5jZXN0b3IsIG9wKTtcbiAgICAgICAgICBuZXdBbmNlc3RvcnMucHVzaChfcCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld1BhcmVudCA9IG5ld0FuY2VzdG9yc1tuZXdBbmNlc3RvcnMubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBuZXdJbmRleCA9IG5ld1BhdGhbbmV3UGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIHJlc3VsdFBhdGggPSBuZXdQYXJlbnQuY29uY2F0KG5ld0luZGV4KTtcbiAgICAgICAgcmV0dXJuIFsuLi5vbGRBbmNlc3RvcnMsIC4uLm5ld0FuY2VzdG9ycywgcmVzdWx0UGF0aF07XG4gICAgICB9XG4gICAgY2FzZSAncmVtb3ZlX25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGg6IF9wYXRoNFxuICAgICAgICB9ID0gb3A7XG4gICAgICAgIHZhciBfYW5jZXN0b3JzID0gUGF0aC5hbmNlc3RvcnMoX3BhdGg0KTtcbiAgICAgICAgcmV0dXJuIFsuLi5fYW5jZXN0b3JzXTtcbiAgICAgIH1cbiAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aDVcbiAgICAgICAgfSA9IG9wO1xuICAgICAgICB2YXIgX2xldmVscyA9IFBhdGgubGV2ZWxzKF9wYXRoNSk7XG4gICAgICAgIHZhciBuZXh0UGF0aCA9IFBhdGgubmV4dChfcGF0aDUpO1xuICAgICAgICByZXR1cm4gWy4uLl9sZXZlbHMsIG5leHRQYXRoXTtcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gIH1cbn07XG5cbnZhciBnZXRGcmFnbWVudCA9IGVkaXRvciA9PiB7XG4gIHZhciB7XG4gICAgc2VsZWN0aW9uXG4gIH0gPSBlZGl0b3I7XG4gIGlmIChzZWxlY3Rpb24pIHtcbiAgICByZXR1cm4gTm9kZS5mcmFnbWVudChlZGl0b3IsIHNlbGVjdGlvbik7XG4gIH1cbiAgcmV0dXJuIFtdO1xufTtcblxudmFyIG5vcm1hbGl6ZU5vZGUgPSAoZWRpdG9yLCBlbnRyeSwgb3B0aW9ucykgPT4ge1xuICB2YXIgW25vZGUsIHBhdGhdID0gZW50cnk7XG4gIC8vIFRoZXJlIGFyZSBubyBjb3JlIG5vcm1hbGl6YXRpb25zIGZvciB0ZXh0IG5vZGVzLlxuICBpZiAoVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gRW5zdXJlIHRoYXQgYmxvY2sgYW5kIGlubGluZSBub2RlcyBoYXZlIGF0IGxlYXN0IG9uZSB0ZXh0IGNoaWxkLlxuICBpZiAoRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICB2YXIgY2hpbGQgPSB7XG4gICAgICB0ZXh0OiAnJ1xuICAgIH07XG4gICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIGNoaWxkLCB7XG4gICAgICBhdDogcGF0aC5jb25jYXQoMCksXG4gICAgICB2b2lkczogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBEZXRlcm1pbmUgd2hldGhlciB0aGUgbm9kZSBzaG91bGQgaGF2ZSBibG9jayBvciBpbmxpbmUgY2hpbGRyZW4uXG4gIHZhciBzaG91bGRIYXZlSW5saW5lcyA9IEVkaXRvci5pc0VkaXRvcihub2RlKSA/IGZhbHNlIDogRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgKGVkaXRvci5pc0lubGluZShub2RlKSB8fCBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCB8fCBUZXh0LmlzVGV4dChub2RlLmNoaWxkcmVuWzBdKSB8fCBlZGl0b3IuaXNJbmxpbmUobm9kZS5jaGlsZHJlblswXSkpO1xuICAvLyBTaW5jZSB3ZSdsbCBiZSBhcHBseWluZyBvcGVyYXRpb25zIHdoaWxlIGl0ZXJhdGluZywga2VlcCB0cmFjayBvZiBhblxuICAvLyBpbmRleCB0aGF0IGFjY291bnRzIGZvciBhbnkgYWRkZWQvcmVtb3ZlZCBub2Rlcy5cbiAgdmFyIG4gPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyssIG4rKykge1xuICAgIHZhciBjdXJyZW50Tm9kZSA9IE5vZGUuZ2V0KGVkaXRvciwgcGF0aCk7XG4gICAgaWYgKFRleHQuaXNUZXh0KGN1cnJlbnROb2RlKSkgY29udGludWU7XG4gICAgdmFyIF9jaGlsZCA9IGN1cnJlbnROb2RlLmNoaWxkcmVuW25dO1xuICAgIHZhciBwcmV2ID0gY3VycmVudE5vZGUuY2hpbGRyZW5bbiAtIDFdO1xuICAgIHZhciBpc0xhc3QgPSBpID09PSBub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgdmFyIGlzSW5saW5lT3JUZXh0ID0gVGV4dC5pc1RleHQoX2NoaWxkKSB8fCBFbGVtZW50LmlzRWxlbWVudChfY2hpbGQpICYmIGVkaXRvci5pc0lubGluZShfY2hpbGQpO1xuICAgIC8vIE9ubHkgYWxsb3cgYmxvY2sgbm9kZXMgaW4gdGhlIHRvcC1sZXZlbCBjaGlsZHJlbiBhbmQgcGFyZW50IGJsb2Nrc1xuICAgIC8vIHRoYXQgb25seSBjb250YWluIGJsb2NrIG5vZGVzLiBTaW1pbGFybHksIG9ubHkgYWxsb3cgaW5saW5lIG5vZGVzIGluXG4gICAgLy8gb3RoZXIgaW5saW5lIG5vZGVzLCBvciBwYXJlbnQgYmxvY2tzIHRoYXQgb25seSBjb250YWluIGlubGluZXMgYW5kXG4gICAgLy8gdGV4dC5cbiAgICBpZiAoaXNJbmxpbmVPclRleHQgIT09IHNob3VsZEhhdmVJbmxpbmVzKSB7XG4gICAgICBpZiAoaXNJbmxpbmVPclRleHQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwICYmIG9wdGlvbnMuZmFsbGJhY2tFbGVtZW50KSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy53cmFwTm9kZXMoZWRpdG9yLCBvcHRpb25zLmZhbGxiYWNrRWxlbWVudCgpLCB7XG4gICAgICAgICAgICBhdDogcGF0aC5jb25jYXQobiksXG4gICAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogcGF0aC5jb25jYXQobiksXG4gICAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBUcmFuc2Zvcm1zLnVud3JhcE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBwYXRoLmNvbmNhdChuKSxcbiAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIG4tLTtcbiAgICB9IGVsc2UgaWYgKEVsZW1lbnQuaXNFbGVtZW50KF9jaGlsZCkpIHtcbiAgICAgIC8vIEVuc3VyZSB0aGF0IGlubGluZSBub2RlcyBhcmUgc3Vycm91bmRlZCBieSB0ZXh0IG5vZGVzLlxuICAgICAgaWYgKGVkaXRvci5pc0lubGluZShfY2hpbGQpKSB7XG4gICAgICAgIGlmIChwcmV2ID09IG51bGwgfHwgIVRleHQuaXNUZXh0KHByZXYpKSB7XG4gICAgICAgICAgdmFyIG5ld0NoaWxkID0ge1xuICAgICAgICAgICAgdGV4dDogJydcbiAgICAgICAgICB9O1xuICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBuZXdDaGlsZCwge1xuICAgICAgICAgICAgYXQ6IHBhdGguY29uY2F0KG4pLFxuICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBuKys7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNMYXN0KSB7XG4gICAgICAgICAgdmFyIF9uZXdDaGlsZCA9IHtcbiAgICAgICAgICAgIHRleHQ6ICcnXG4gICAgICAgICAgfTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgX25ld0NoaWxkLCB7XG4gICAgICAgICAgICBhdDogcGF0aC5jb25jYXQobiArIDEpLFxuICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBuKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhlIGNoaWxkIGlzIG5vdCBhIHRleHQgbm9kZSwgYW5kIGRvZXNuJ3QgaGF2ZSBhIGBjaGlsZHJlbmAgZmllbGQsXG4gICAgICAvLyB0aGVuIHdlIGhhdmUgYW4gaW52YWxpZCBub2RlIHRoYXQgd2lsbCB1cHNldCBzbGF0ZS5cbiAgICAgIC8vXG4gICAgICAvLyBlZzogYHsgdHlwZTogJ3NvbWVfbm9kZScgfWAuXG4gICAgICAvL1xuICAgICAgLy8gVG8gcHJldmVudCBzbGF0ZSBmcm9tIGJyZWFraW5nLCB3ZSBjYW4gYWRkIHRoZSBgY2hpbGRyZW5gIGZpZWxkLFxuICAgICAgLy8gYW5kIG5vdyB0aGF0IGl0IGlzIHZhbGlkLCB3ZSBjYW4gdG8gbWFueSBtb3JlIG9wZXJhdGlvbnMgZWFzaWx5LFxuICAgICAgLy8gc3VjaCBhcyBleHRlbmQgbm9ybWFsaXplcnMgdG8gZml4IGVycm9ub3VzIHN0cnVjdHVyZS5cbiAgICAgIGlmICghVGV4dC5pc1RleHQoX2NoaWxkKSAmJiAhKCdjaGlsZHJlbicgaW4gX2NoaWxkKSkge1xuICAgICAgICB2YXIgZWxlbWVudENoaWxkID0gX2NoaWxkO1xuICAgICAgICBlbGVtZW50Q2hpbGQuY2hpbGRyZW4gPSBbXTtcbiAgICAgIH1cbiAgICAgIC8vIE1lcmdlIGFkamFjZW50IHRleHQgbm9kZXMgdGhhdCBhcmUgZW1wdHkgb3IgbWF0Y2guXG4gICAgICBpZiAocHJldiAhPSBudWxsICYmIFRleHQuaXNUZXh0KHByZXYpKSB7XG4gICAgICAgIGlmIChUZXh0LmVxdWFscyhfY2hpbGQsIHByZXYsIHtcbiAgICAgICAgICBsb29zZTogdHJ1ZVxuICAgICAgICB9KSkge1xuICAgICAgICAgIFRyYW5zZm9ybXMubWVyZ2VOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoLmNvbmNhdChuKSxcbiAgICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbi0tO1xuICAgICAgICB9IGVsc2UgaWYgKHByZXYudGV4dCA9PT0gJycpIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IHBhdGguY29uY2F0KG4gLSAxKSxcbiAgICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbi0tO1xuICAgICAgICB9IGVsc2UgaWYgKF9jaGlsZC50ZXh0ID09PSAnJykge1xuICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogcGF0aC5jb25jYXQobiksXG4gICAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG4tLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIHNob3VsZE5vcm1hbGl6ZSA9IChlZGl0b3IsIF9yZWYpID0+IHtcbiAgdmFyIHtcbiAgICBpdGVyYXRpb24sXG4gICAgaW5pdGlhbERpcnR5UGF0aHNMZW5ndGhcbiAgfSA9IF9yZWY7XG4gIHZhciBtYXhJdGVyYXRpb25zID0gaW5pdGlhbERpcnR5UGF0aHNMZW5ndGggKiA0MjsgLy8gSEFDSzogYmV0dGVyIHdheT9cbiAgaWYgKGl0ZXJhdGlvbiA+IG1heEl0ZXJhdGlvbnMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgY29tcGxldGVseSBub3JtYWxpemUgdGhlIGVkaXRvciBhZnRlciBcIi5jb25jYXQobWF4SXRlcmF0aW9ucywgXCIgaXRlcmF0aW9ucyEgVGhpcyBpcyB1c3VhbGx5IGR1ZSB0byBpbmNvcnJlY3Qgbm9ybWFsaXphdGlvbiBsb2dpYyB0aGF0IGxlYXZlcyBhIG5vZGUgaW4gYW4gaW52YWxpZCBzdGF0ZS5cIikpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIGFib3ZlID0gZnVuY3Rpb24gYWJvdmUoZWRpdG9yKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIHtcbiAgICB2b2lkcyA9IGZhbHNlLFxuICAgIG1vZGUgPSAnbG93ZXN0JyxcbiAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgbWF0Y2hcbiAgfSA9IG9wdGlvbnM7XG4gIGlmICghYXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0KTtcbiAgLy8gSWYgYGF0YCBpcyBhIFJhbmdlIHRoYXQgc3BhbnMgbXVsaXRwbGUgbm9kZXMsIGBwYXRoYCB3aWxsIGJlIHRoZWlyIGNvbW1vbiBhbmNlc3Rvci5cbiAgLy8gT3RoZXJ3aXNlIGBwYXRoYCB3aWxsIGJlIGEgdGV4dCBub2RlIGFuZC9vciB0aGUgc2FtZSBhcyBgYXRgLCBpbiB3aGljaCBjYXNlcyB3ZSB3YW50IHRvIHN0YXJ0IHdpdGggaXRzIHBhcmVudC5cbiAgaWYgKCFSYW5nZS5pc1JhbmdlKGF0KSB8fCBQYXRoLmVxdWFscyhhdC5mb2N1cy5wYXRoLCBhdC5hbmNob3IucGF0aCkpIHtcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICBwYXRoID0gUGF0aC5wYXJlbnQocGF0aCk7XG4gIH1cbiAgdmFyIHJldmVyc2UgPSBtb2RlID09PSAnbG93ZXN0JztcbiAgdmFyIFtmaXJzdE1hdGNoXSA9IEVkaXRvci5sZXZlbHMoZWRpdG9yLCB7XG4gICAgYXQ6IHBhdGgsXG4gICAgdm9pZHMsXG4gICAgbWF0Y2gsXG4gICAgcmV2ZXJzZVxuICB9KTtcbiAgcmV0dXJuIGZpcnN0TWF0Y2g7IC8vIGlmIG5vdGhpbmcgbWF0Y2hlcyB0aGlzIHJldHVybnMgdW5kZWZpbmVkXG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDgoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ4KGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkOChPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkOChPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxudmFyIGFkZE1hcmsgPSAoZWRpdG9yLCBrZXksIHZhbHVlKSA9PiB7XG4gIHZhciB7XG4gICAgc2VsZWN0aW9uXG4gIH0gPSBlZGl0b3I7XG4gIGlmIChzZWxlY3Rpb24pIHtcbiAgICB2YXIgbWF0Y2ggPSAobm9kZSwgcGF0aCkgPT4ge1xuICAgICAgaWYgKCFUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIG1hcmtzIGNhbiBvbmx5IGJlIGFwcGxpZWQgdG8gdGV4dFxuICAgICAgfVxuXG4gICAgICB2YXIgW3BhcmVudE5vZGUsIHBhcmVudFBhdGhdID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIHBhdGgpO1xuICAgICAgcmV0dXJuICFlZGl0b3IuaXNWb2lkKHBhcmVudE5vZGUpIHx8IGVkaXRvci5tYXJrYWJsZVZvaWQocGFyZW50Tm9kZSk7XG4gICAgfTtcbiAgICB2YXIgZXhwYW5kZWRTZWxlY3Rpb24gPSBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbik7XG4gICAgdmFyIG1hcmtBY2NlcHRpbmdWb2lkU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICBpZiAoIWV4cGFuZGVkU2VsZWN0aW9uKSB7XG4gICAgICB2YXIgW3NlbGVjdGVkTm9kZSwgc2VsZWN0ZWRQYXRoXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgc2VsZWN0aW9uKTtcbiAgICAgIGlmIChzZWxlY3RlZE5vZGUgJiYgbWF0Y2goc2VsZWN0ZWROb2RlLCBzZWxlY3RlZFBhdGgpKSB7XG4gICAgICAgIHZhciBbcGFyZW50Tm9kZV0gPSBFZGl0b3IucGFyZW50KGVkaXRvciwgc2VsZWN0ZWRQYXRoKTtcbiAgICAgICAgbWFya0FjY2VwdGluZ1ZvaWRTZWxlY3RlZCA9IHBhcmVudE5vZGUgJiYgZWRpdG9yLm1hcmthYmxlVm9pZChwYXJlbnROb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGV4cGFuZGVkU2VsZWN0aW9uIHx8IG1hcmtBY2NlcHRpbmdWb2lkU2VsZWN0ZWQpIHtcbiAgICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIFtrZXldOiB2YWx1ZVxuICAgICAgfSwge1xuICAgICAgICBtYXRjaCxcbiAgICAgICAgc3BsaXQ6IHRydWUsXG4gICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1hcmtzID0gX29iamVjdFNwcmVhZCQ4KF9vYmplY3RTcHJlYWQkOCh7fSwgRWRpdG9yLm1hcmtzKGVkaXRvcikgfHwge30pLCB7fSwge1xuICAgICAgICBba2V5XTogdmFsdWVcbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLm1hcmtzID0gbWFya3M7XG4gICAgICBpZiAoIUZMVVNISU5HLmdldChlZGl0b3IpKSB7XG4gICAgICAgIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gb3duS2V5cyQ3KGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkNyhlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJDcoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJDcoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbnZhciBhZnRlciA9IGZ1bmN0aW9uIGFmdGVyKGVkaXRvciwgYXQpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICB2YXIgYW5jaG9yID0gRWRpdG9yLnBvaW50KGVkaXRvciwgYXQsIHtcbiAgICBlZGdlOiAnZW5kJ1xuICB9KTtcbiAgdmFyIGZvY3VzID0gRWRpdG9yLmVuZChlZGl0b3IsIFtdKTtcbiAgdmFyIHJhbmdlID0ge1xuICAgIGFuY2hvcixcbiAgICBmb2N1c1xuICB9O1xuICB2YXIge1xuICAgIGRpc3RhbmNlID0gMVxuICB9ID0gb3B0aW9ucztcbiAgdmFyIGQgPSAwO1xuICB2YXIgdGFyZ2V0O1xuICBmb3IgKHZhciBwIG9mIEVkaXRvci5wb3NpdGlvbnMoZWRpdG9yLCBfb2JqZWN0U3ByZWFkJDcoX29iamVjdFNwcmVhZCQ3KHt9LCBvcHRpb25zKSwge30sIHtcbiAgICBhdDogcmFuZ2VcbiAgfSkpKSB7XG4gICAgaWYgKGQgPiBkaXN0YW5jZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChkICE9PSAwKSB7XG4gICAgICB0YXJnZXQgPSBwO1xuICAgIH1cbiAgICBkKys7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbmZ1bmN0aW9uIG93bktleXMkNihlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDYoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyQ2KE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyQ2KE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG52YXIgYmVmb3JlID0gZnVuY3Rpb24gYmVmb3JlKGVkaXRvciwgYXQpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICB2YXIgYW5jaG9yID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgW10pO1xuICB2YXIgZm9jdXMgPSBFZGl0b3IucG9pbnQoZWRpdG9yLCBhdCwge1xuICAgIGVkZ2U6ICdzdGFydCdcbiAgfSk7XG4gIHZhciByYW5nZSA9IHtcbiAgICBhbmNob3IsXG4gICAgZm9jdXNcbiAgfTtcbiAgdmFyIHtcbiAgICBkaXN0YW5jZSA9IDFcbiAgfSA9IG9wdGlvbnM7XG4gIHZhciBkID0gMDtcbiAgdmFyIHRhcmdldDtcbiAgZm9yICh2YXIgcCBvZiBFZGl0b3IucG9zaXRpb25zKGVkaXRvciwgX29iamVjdFNwcmVhZCQ2KF9vYmplY3RTcHJlYWQkNih7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgYXQ6IHJhbmdlLFxuICAgIHJldmVyc2U6IHRydWVcbiAgfSkpKSB7XG4gICAgaWYgKGQgPiBkaXN0YW5jZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChkICE9PSAwKSB7XG4gICAgICB0YXJnZXQgPSBwO1xuICAgIH1cbiAgICBkKys7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbnZhciBkZWxldGVCYWNrd2FyZCA9IChlZGl0b3IsIHVuaXQpID0+IHtcbiAgdmFyIHtcbiAgICBzZWxlY3Rpb25cbiAgfSA9IGVkaXRvcjtcbiAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0NvbGxhcHNlZChzZWxlY3Rpb24pKSB7XG4gICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICB1bml0LFxuICAgICAgcmV2ZXJzZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59O1xuXG52YXIgZGVsZXRlRm9yd2FyZCA9IChlZGl0b3IsIHVuaXQpID0+IHtcbiAgdmFyIHtcbiAgICBzZWxlY3Rpb25cbiAgfSA9IGVkaXRvcjtcbiAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0NvbGxhcHNlZChzZWxlY3Rpb24pKSB7XG4gICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICB1bml0XG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBkZWxldGVGcmFnbWVudCA9IGZ1bmN0aW9uIGRlbGV0ZUZyYWdtZW50KGVkaXRvcikge1xuICB2YXIge1xuICAgIGRpcmVjdGlvbiA9ICdmb3J3YXJkJ1xuICB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIHtcbiAgICBzZWxlY3Rpb25cbiAgfSA9IGVkaXRvcjtcbiAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgIHJldmVyc2U6IGRpcmVjdGlvbiA9PT0gJ2JhY2t3YXJkJ1xuICAgIH0pO1xuICB9XG59O1xuXG52YXIgZWRnZXMgPSAoZWRpdG9yLCBhdCkgPT4ge1xuICByZXR1cm4gW0VkaXRvci5zdGFydChlZGl0b3IsIGF0KSwgRWRpdG9yLmVuZChlZGl0b3IsIGF0KV07XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDUoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ1KGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkNShPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkNShPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxudmFyIGVsZW1lbnRSZWFkT25seSA9IGZ1bmN0aW9uIGVsZW1lbnRSZWFkT25seShlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICByZXR1cm4gRWRpdG9yLmFib3ZlKGVkaXRvciwgX29iamVjdFNwcmVhZCQ1KF9vYmplY3RTcHJlYWQkNSh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgbWF0Y2g6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzRWxlbWVudFJlYWRPbmx5KGVkaXRvciwgbilcbiAgfSkpO1xufTtcblxudmFyIGVuZCA9IChlZGl0b3IsIGF0KSA9PiB7XG4gIHJldHVybiBFZGl0b3IucG9pbnQoZWRpdG9yLCBhdCwge1xuICAgIGVkZ2U6ICdlbmQnXG4gIH0pO1xufTtcblxudmFyIGZpcnN0ID0gKGVkaXRvciwgYXQpID0+IHtcbiAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0LCB7XG4gICAgZWRnZTogJ3N0YXJ0J1xuICB9KTtcbiAgcmV0dXJuIEVkaXRvci5ub2RlKGVkaXRvciwgcGF0aCk7XG59O1xuXG52YXIgZnJhZ21lbnQgPSAoZWRpdG9yLCBhdCkgPT4ge1xuICB2YXIgcmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBhdCk7XG4gIHJldHVybiBOb2RlLmZyYWdtZW50KGVkaXRvciwgcmFuZ2UpO1xufTtcblxuZnVuY3Rpb24gb3duS2V5cyQ0KGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkNChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJDQoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJDQoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbnZhciBnZXRWb2lkID0gZnVuY3Rpb24gZ2V0Vm9pZChlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICByZXR1cm4gRWRpdG9yLmFib3ZlKGVkaXRvciwgX29iamVjdFNwcmVhZCQ0KF9vYmplY3RTcHJlYWQkNCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgbWF0Y2g6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG4pXG4gIH0pKTtcbn07XG5cbnZhciBoYXNCbG9ja3MgPSAoZWRpdG9yLCBlbGVtZW50KSA9PiB7XG4gIHJldHVybiBlbGVtZW50LmNoaWxkcmVuLnNvbWUobiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pKTtcbn07XG5cbnZhciBoYXNJbmxpbmVzID0gKGVkaXRvciwgZWxlbWVudCkgPT4ge1xuICByZXR1cm4gZWxlbWVudC5jaGlsZHJlbi5zb21lKG4gPT4gVGV4dC5pc1RleHQobikgfHwgRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbikpO1xufTtcblxudmFyIGhhc1BhdGggPSAoZWRpdG9yLCBwYXRoKSA9PiB7XG4gIHJldHVybiBOb2RlLmhhcyhlZGl0b3IsIHBhdGgpO1xufTtcblxudmFyIGhhc1RleHRzID0gKGVkaXRvciwgZWxlbWVudCkgPT4ge1xuICByZXR1cm4gZWxlbWVudC5jaGlsZHJlbi5ldmVyeShuID0+IFRleHQuaXNUZXh0KG4pKTtcbn07XG5cbnZhciBpbnNlcnRCcmVhayA9IGVkaXRvciA9PiB7XG4gIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICBhbHdheXM6IHRydWVcbiAgfSk7XG59O1xuXG52YXIgaW5zZXJ0Tm9kZSA9IChlZGl0b3IsIG5vZGUsIG9wdGlvbnMpID0+IHtcbiAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIG5vZGUsIG9wdGlvbnMpO1xufTtcblxudmFyIGluc2VydFNvZnRCcmVhayA9IGVkaXRvciA9PiB7XG4gIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICBhbHdheXM6IHRydWVcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQzKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkMyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkMyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxudmFyIGluc2VydFRleHQgPSBmdW5jdGlvbiBpbnNlcnRUZXh0KGVkaXRvciwgdGV4dCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciB7XG4gICAgc2VsZWN0aW9uLFxuICAgIG1hcmtzXG4gIH0gPSBlZGl0b3I7XG4gIGlmIChzZWxlY3Rpb24pIHtcbiAgICBpZiAobWFya3MpIHtcbiAgICAgIHZhciBub2RlID0gX29iamVjdFNwcmVhZCQzKHtcbiAgICAgICAgdGV4dFxuICAgICAgfSwgbWFya3MpO1xuICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIG5vZGUsIHtcbiAgICAgICAgYXQ6IG9wdGlvbnMuYXQsXG4gICAgICAgIHZvaWRzOiBvcHRpb25zLnZvaWRzXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgVHJhbnNmb3Jtcy5pbnNlcnRUZXh0KGVkaXRvciwgdGV4dCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGVkaXRvci5tYXJrcyA9IG51bGw7XG4gIH1cbn07XG5cbnZhciBpc0Jsb2NrID0gKGVkaXRvciwgdmFsdWUpID0+IHtcbiAgcmV0dXJuICFlZGl0b3IuaXNJbmxpbmUodmFsdWUpO1xufTtcblxudmFyIGlzRWRnZSA9IChlZGl0b3IsIHBvaW50LCBhdCkgPT4ge1xuICByZXR1cm4gRWRpdG9yLmlzU3RhcnQoZWRpdG9yLCBwb2ludCwgYXQpIHx8IEVkaXRvci5pc0VuZChlZGl0b3IsIHBvaW50LCBhdCk7XG59O1xuXG52YXIgaXNFbXB0eSA9IChlZGl0b3IsIGVsZW1lbnQpID0+IHtcbiAgdmFyIHtcbiAgICBjaGlsZHJlblxuICB9ID0gZWxlbWVudDtcbiAgdmFyIFtmaXJzdF0gPSBjaGlsZHJlbjtcbiAgcmV0dXJuIGNoaWxkcmVuLmxlbmd0aCA9PT0gMCB8fCBjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgVGV4dC5pc1RleHQoZmlyc3QpICYmIGZpcnN0LnRleHQgPT09ICcnICYmICFlZGl0b3IuaXNWb2lkKGVsZW1lbnQpO1xufTtcblxudmFyIGlzRW5kID0gKGVkaXRvciwgcG9pbnQsIGF0KSA9PiB7XG4gIHZhciBlbmQgPSBFZGl0b3IuZW5kKGVkaXRvciwgYXQpO1xuICByZXR1cm4gUG9pbnQuZXF1YWxzKHBvaW50LCBlbmQpO1xufTtcblxudmFyIGlzTm9ybWFsaXppbmcgPSBlZGl0b3IgPT4ge1xuICB2YXIgaXNOb3JtYWxpemluZyA9IE5PUk1BTElaSU5HLmdldChlZGl0b3IpO1xuICByZXR1cm4gaXNOb3JtYWxpemluZyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGlzTm9ybWFsaXppbmc7XG59O1xuXG52YXIgaXNTdGFydCA9IChlZGl0b3IsIHBvaW50LCBhdCkgPT4ge1xuICAvLyBQRVJGOiBJZiB0aGUgb2Zmc2V0IGlzbid0IGAwYCB3ZSBrbm93IGl0J3Mgbm90IHRoZSBzdGFydC5cbiAgaWYgKHBvaW50Lm9mZnNldCAhPT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgc3RhcnQgPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBhdCk7XG4gIHJldHVybiBQb2ludC5lcXVhbHMocG9pbnQsIHN0YXJ0KTtcbn07XG5cbnZhciBsYXN0ID0gKGVkaXRvciwgYXQpID0+IHtcbiAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0LCB7XG4gICAgZWRnZTogJ2VuZCdcbiAgfSk7XG4gIHJldHVybiBFZGl0b3Iubm9kZShlZGl0b3IsIHBhdGgpO1xufTtcblxudmFyIGxlYWYgPSBmdW5jdGlvbiBsZWFmKGVkaXRvciwgYXQpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIG9wdGlvbnMpO1xuICB2YXIgbm9kZSA9IE5vZGUubGVhZihlZGl0b3IsIHBhdGgpO1xuICByZXR1cm4gW25vZGUsIHBhdGhdO1xufTtcblxuZnVuY3Rpb24gbGV2ZWxzKGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgIHZhciB7XG4gICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICByZXZlcnNlID0gZmFsc2UsXG4gICAgICB2b2lkcyA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHtcbiAgICAgIG1hdGNoXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgIG1hdGNoID0gKCkgPT4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbGV2ZWxzID0gW107XG4gICAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0KTtcbiAgICBmb3IgKHZhciBbbiwgcF0gb2YgTm9kZS5sZXZlbHMoZWRpdG9yLCBwYXRoKSkge1xuICAgICAgaWYgKCFtYXRjaChuLCBwKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxldmVscy5wdXNoKFtuLCBwXSk7XG4gICAgICBpZiAoIXZvaWRzICYmIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBuKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIGxldmVscy5yZXZlcnNlKCk7XG4gICAgfVxuICAgIHlpZWxkKiBsZXZlbHM7XG4gIH0oKTtcbn1cblxudmFyIF9leGNsdWRlZCQxID0gW1widGV4dFwiXSxcbiAgX2V4Y2x1ZGVkMiQxID0gW1widGV4dFwiXTtcbnZhciBtYXJrcyA9IGZ1bmN0aW9uIG1hcmtzKGVkaXRvcikge1xuICB2YXIge1xuICAgIG1hcmtzLFxuICAgIHNlbGVjdGlvblxuICB9ID0gZWRpdG9yO1xuICBpZiAoIXNlbGVjdGlvbikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciB7XG4gICAgYW5jaG9yLFxuICAgIGZvY3VzXG4gIH0gPSBzZWxlY3Rpb247XG4gIGlmIChtYXJrcykge1xuICAgIHJldHVybiBtYXJrcztcbiAgfVxuICBpZiAoUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgdmFyIGlzQmFja3dhcmQgPSBSYW5nZS5pc0JhY2t3YXJkKHNlbGVjdGlvbik7XG4gICAgaWYgKGlzQmFja3dhcmQpIHtcbiAgICAgIFtmb2N1cywgYW5jaG9yXSA9IFthbmNob3IsIGZvY3VzXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ09NUEFUOiBNYWtlIHN1cmUgaGFuZ2luZyByYW5nZXMgKGNhdXNlZCBieSBkb3VibGUgY2xpY2tpbmcgaW4gRmlyZWZveClcbiAgICAgKiBkbyBub3QgYWR2ZXJzZWx5IGFmZmVjdCB0aGUgcmV0dXJuZWQgbWFya3MuXG4gICAgICovXG4gICAgdmFyIGlzRW5kID0gRWRpdG9yLmlzRW5kKGVkaXRvciwgYW5jaG9yLCBhbmNob3IucGF0aCk7XG4gICAgaWYgKGlzRW5kKSB7XG4gICAgICB2YXIgYWZ0ZXIgPSBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBhbmNob3IpO1xuICAgICAgaWYgKGFmdGVyKSB7XG4gICAgICAgIGFuY2hvciA9IGFmdGVyO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgW21hdGNoXSA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIG1hdGNoOiBUZXh0LmlzVGV4dCxcbiAgICAgIGF0OiB7XG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgZm9jdXNcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHZhciBbX25vZGVdID0gbWF0Y2g7XG4gICAgICB2YXIgX3Jlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX25vZGUsIF9leGNsdWRlZCQxKTtcbiAgICAgIHJldHVybiBfcmVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfVxuICB2YXIge1xuICAgIHBhdGhcbiAgfSA9IGFuY2hvcjtcbiAgdmFyIFtub2RlXSA9IEVkaXRvci5sZWFmKGVkaXRvciwgcGF0aCk7XG4gIGlmIChhbmNob3Iub2Zmc2V0ID09PSAwKSB7XG4gICAgdmFyIHByZXYgPSBFZGl0b3IucHJldmlvdXMoZWRpdG9yLCB7XG4gICAgICBhdDogcGF0aCxcbiAgICAgIG1hdGNoOiBUZXh0LmlzVGV4dFxuICAgIH0pO1xuICAgIHZhciBtYXJrZWRWb2lkID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgbWF0Y2g6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG4pICYmIGVkaXRvci5tYXJrYWJsZVZvaWQobilcbiAgICB9KTtcbiAgICBpZiAoIW1hcmtlZFZvaWQpIHtcbiAgICAgIHZhciBibG9jayA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgbWF0Y2g6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKVxuICAgICAgfSk7XG4gICAgICBpZiAocHJldiAmJiBibG9jaykge1xuICAgICAgICB2YXIgW3ByZXZOb2RlLCBwcmV2UGF0aF0gPSBwcmV2O1xuICAgICAgICB2YXIgWywgYmxvY2tQYXRoXSA9IGJsb2NrO1xuICAgICAgICBpZiAoUGF0aC5pc0FuY2VzdG9yKGJsb2NrUGF0aCwgcHJldlBhdGgpKSB7XG4gICAgICAgICAgbm9kZSA9IHByZXZOb2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG5vZGUsIF9leGNsdWRlZDIkMSk7XG4gIHJldHVybiByZXN0O1xufTtcblxudmFyIG5leHQgPSBmdW5jdGlvbiBuZXh0KGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciB7XG4gICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgIHZvaWRzID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIHZhciB7XG4gICAgbWF0Y2gsXG4gICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uXG4gIH0gPSBvcHRpb25zO1xuICBpZiAoIWF0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBwb2ludEFmdGVyTG9jYXRpb24gPSBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBhdCwge1xuICAgIHZvaWRzXG4gIH0pO1xuICBpZiAoIXBvaW50QWZ0ZXJMb2NhdGlvbikgcmV0dXJuO1xuICB2YXIgWywgdG9dID0gRWRpdG9yLmxhc3QoZWRpdG9yLCBbXSk7XG4gIHZhciBzcGFuID0gW3BvaW50QWZ0ZXJMb2NhdGlvbi5wYXRoLCB0b107XG4gIGlmIChQYXRoLmlzUGF0aChhdCkgJiYgYXQubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgbmV4dCBub2RlIGZyb20gdGhlIHJvb3Qgbm9kZSFcIik7XG4gIH1cbiAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICB2YXIgW3BhcmVudF0gPSBFZGl0b3IucGFyZW50KGVkaXRvciwgYXQpO1xuICAgICAgbWF0Y2ggPSBuID0+IHBhcmVudC5jaGlsZHJlbi5pbmNsdWRlcyhuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF0Y2ggPSAoKSA9PiB0cnVlO1xuICAgIH1cbiAgfVxuICB2YXIgW25leHRdID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgIGF0OiBzcGFuLFxuICAgIG1hdGNoLFxuICAgIG1vZGUsXG4gICAgdm9pZHNcbiAgfSk7XG4gIHJldHVybiBuZXh0O1xufTtcblxudmFyIG5vZGUgPSBmdW5jdGlvbiBub2RlKGVkaXRvciwgYXQpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIG9wdGlvbnMpO1xuICB2YXIgbm9kZSA9IE5vZGUuZ2V0KGVkaXRvciwgcGF0aCk7XG4gIHJldHVybiBbbm9kZSwgcGF0aF07XG59O1xuXG5mdW5jdGlvbiBub2RlcyhlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICB2YXIge1xuICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgbW9kZSA9ICdhbGwnLFxuICAgICAgdW5pdmVyc2FsID0gZmFsc2UsXG4gICAgICByZXZlcnNlID0gZmFsc2UsXG4gICAgICB2b2lkcyA9IGZhbHNlLFxuICAgICAgcGFzczogX3Bhc3NcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgbWF0Y2hcbiAgICB9ID0gb3B0aW9ucztcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICBtYXRjaCA9ICgpID0+IHRydWU7XG4gICAgfVxuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGZyb207XG4gICAgdmFyIHRvO1xuICAgIGlmIChTcGFuLmlzU3BhbihhdCkpIHtcbiAgICAgIGZyb20gPSBhdFswXTtcbiAgICAgIHRvID0gYXRbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBmaXJzdCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIHtcbiAgICAgICAgZWRnZTogJ3N0YXJ0J1xuICAgICAgfSk7XG4gICAgICB2YXIgbGFzdCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIHtcbiAgICAgICAgZWRnZTogJ2VuZCdcbiAgICAgIH0pO1xuICAgICAgZnJvbSA9IHJldmVyc2UgPyBsYXN0IDogZmlyc3Q7XG4gICAgICB0byA9IHJldmVyc2UgPyBmaXJzdCA6IGxhc3Q7XG4gICAgfVxuICAgIHZhciBub2RlRW50cmllcyA9IE5vZGUubm9kZXMoZWRpdG9yLCB7XG4gICAgICByZXZlcnNlLFxuICAgICAgZnJvbSxcbiAgICAgIHRvLFxuICAgICAgcGFzczogX3JlZiA9PiB7XG4gICAgICAgIHZhciBbbm9kZSwgcGF0aF0gPSBfcmVmO1xuICAgICAgICBpZiAoX3Bhc3MgJiYgX3Bhc3MoW25vZGUsIHBhdGhdKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICghRWxlbWVudC5pc0VsZW1lbnQobm9kZSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCF2b2lkcyAmJiAoRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpIHx8IEVkaXRvci5pc0VsZW1lbnRSZWFkT25seShlZGl0b3IsIG5vZGUpKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgIHZhciBoaXQ7XG4gICAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIG5vZGVFbnRyaWVzKSB7XG4gICAgICB2YXIgaXNMb3dlciA9IGhpdCAmJiBQYXRoLmNvbXBhcmUocGF0aCwgaGl0WzFdKSA9PT0gMDtcbiAgICAgIC8vIEluIGhpZ2hlc3QgbW9kZSBhbnkgbm9kZSBsb3dlciB0aGFuIHRoZSBsYXN0IGhpdCBpcyBub3QgYSBtYXRjaC5cbiAgICAgIGlmIChtb2RlID09PSAnaGlnaGVzdCcgJiYgaXNMb3dlcikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghbWF0Y2gobm9kZSwgcGF0aCkpIHtcbiAgICAgICAgLy8gSWYgd2UndmUgYXJyaXZlZCBhdCBhIGxlYWYgdGV4dCBub2RlIHRoYXQgaXMgbm90IGxvd2VyIHRoYW4gdGhlIGxhc3RcbiAgICAgICAgLy8gaGl0LCB0aGVuIHdlJ3ZlIGZvdW5kIGEgYnJhbmNoIHRoYXQgZG9lc24ndCBpbmNsdWRlIGEgbWF0Y2gsIHdoaWNoXG4gICAgICAgIC8vIG1lYW5zIHRoZSBtYXRjaCBpcyBub3QgdW5pdmVyc2FsLlxuICAgICAgICBpZiAodW5pdmVyc2FsICYmICFpc0xvd2VyICYmIFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBJZiB0aGVyZSdzIGEgbWF0Y2ggYW5kIGl0J3MgbG93ZXIgdGhhbiB0aGUgbGFzdCwgdXBkYXRlIHRoZSBoaXQuXG4gICAgICBpZiAobW9kZSA9PT0gJ2xvd2VzdCcgJiYgaXNMb3dlcikge1xuICAgICAgICBoaXQgPSBbbm9kZSwgcGF0aF07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gSW4gbG93ZXN0IG1vZGUgd2UgZW1pdCB0aGUgbGFzdCBoaXQsIG9uY2UgaXQncyBndWFyYW50ZWVkIGxvd2VzdC5cbiAgICAgIHZhciBlbWl0ID0gbW9kZSA9PT0gJ2xvd2VzdCcgPyBoaXQgOiBbbm9kZSwgcGF0aF07XG4gICAgICBpZiAoZW1pdCkge1xuICAgICAgICBpZiAodW5pdmVyc2FsKSB7XG4gICAgICAgICAgbWF0Y2hlcy5wdXNoKGVtaXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHlpZWxkIGVtaXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGhpdCA9IFtub2RlLCBwYXRoXTtcbiAgICB9XG4gICAgLy8gU2luY2UgbG93ZXN0IGlzIGFsd2F5cyBlbWl0dGluZyBvbmUgYmVoaW5kLCBjYXRjaCB1cCBhdCB0aGUgZW5kLlxuICAgIGlmIChtb2RlID09PSAnbG93ZXN0JyAmJiBoaXQpIHtcbiAgICAgIGlmICh1bml2ZXJzYWwpIHtcbiAgICAgICAgbWF0Y2hlcy5wdXNoKGhpdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5aWVsZCBoaXQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFVuaXZlcnNhbCBkZWZlcnMgdG8gZW5zdXJlIHRoYXQgdGhlIG1hdGNoIG9jY3VycyBpbiBldmVyeSBicmFuY2gsIHNvIHdlXG4gICAgLy8geWllbGQgYWxsIG9mIHRoZSBtYXRjaGVzIGFmdGVyIGl0ZXJhdGluZy5cbiAgICBpZiAodW5pdmVyc2FsKSB7XG4gICAgICB5aWVsZCogbWF0Y2hlcztcbiAgICB9XG4gIH0oKTtcbn1cblxudmFyIG5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZShlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIge1xuICAgIGZvcmNlID0gZmFsc2UsXG4gICAgb3BlcmF0aW9uXG4gIH0gPSBvcHRpb25zO1xuICB2YXIgZ2V0RGlydHlQYXRocyA9IGVkaXRvciA9PiB7XG4gICAgcmV0dXJuIERJUlRZX1BBVEhTLmdldChlZGl0b3IpIHx8IFtdO1xuICB9O1xuICB2YXIgZ2V0RGlydHlQYXRoS2V5cyA9IGVkaXRvciA9PiB7XG4gICAgcmV0dXJuIERJUlRZX1BBVEhfS0VZUy5nZXQoZWRpdG9yKSB8fCBuZXcgU2V0KCk7XG4gIH07XG4gIHZhciBwb3BEaXJ0eVBhdGggPSBlZGl0b3IgPT4ge1xuICAgIHZhciBwYXRoID0gZ2V0RGlydHlQYXRocyhlZGl0b3IpLnBvcCgpO1xuICAgIHZhciBrZXkgPSBwYXRoLmpvaW4oJywnKTtcbiAgICBnZXREaXJ0eVBhdGhLZXlzKGVkaXRvcikuZGVsZXRlKGtleSk7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH07XG4gIGlmICghRWRpdG9yLmlzTm9ybWFsaXppbmcoZWRpdG9yKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZm9yY2UpIHtcbiAgICB2YXIgYWxsUGF0aHMgPSBBcnJheS5mcm9tKE5vZGUubm9kZXMoZWRpdG9yKSwgX3JlZiA9PiB7XG4gICAgICB2YXIgWywgcF0gPSBfcmVmO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfSk7XG4gICAgdmFyIGFsbFBhdGhLZXlzID0gbmV3IFNldChhbGxQYXRocy5tYXAocCA9PiBwLmpvaW4oJywnKSkpO1xuICAgIERJUlRZX1BBVEhTLnNldChlZGl0b3IsIGFsbFBhdGhzKTtcbiAgICBESVJUWV9QQVRIX0tFWVMuc2V0KGVkaXRvciwgYWxsUGF0aEtleXMpO1xuICB9XG4gIGlmIChnZXREaXJ0eVBhdGhzKGVkaXRvcikubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgLypcbiAgICAgIEZpeCBkaXJ0eSBlbGVtZW50cyB3aXRoIG5vIGNoaWxkcmVuLlxuICAgICAgZWRpdG9yLm5vcm1hbGl6ZU5vZGUoKSBkb2VzIGZpeCB0aGlzLCBidXQgc29tZSBub3JtYWxpemF0aW9uIGZpeGVzIGFsc28gcmVxdWlyZSBpdCB0byB3b3JrLlxuICAgICAgUnVubmluZyBhbiBpbml0aWFsIHBhc3MgYXZvaWRzIHRoZSBjYXRjaC0yMiByYWNlIGNvbmRpdGlvbi5cbiAgICAqL1xuICAgIGZvciAodmFyIGRpcnR5UGF0aCBvZiBnZXREaXJ0eVBhdGhzKGVkaXRvcikpIHtcbiAgICAgIGlmIChOb2RlLmhhcyhlZGl0b3IsIGRpcnR5UGF0aCkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBkaXJ0eVBhdGgpO1xuICAgICAgICB2YXIgW25vZGUsIF9dID0gZW50cnk7XG4gICAgICAgIC8qXG4gICAgICAgICAgVGhlIGRlZmF1bHQgbm9ybWFsaXplciBpbnNlcnRzIGFuIGVtcHR5IHRleHQgbm9kZSBpbiB0aGlzIHNjZW5hcmlvLCBidXQgaXQgY2FuIGJlIGN1c3RvbWlzZWQuXG4gICAgICAgICAgU28gdGhlcmUgaXMgc29tZSByaXNrIGhlcmUuXG4gICAgICAgICAgICAgICAgICAgQXMgbG9uZyBhcyB0aGUgbm9ybWFsaXplciBvbmx5IGluc2VydHMgY2hpbGQgbm9kZXMgZm9yIHRoaXMgY2FzZSBpdCBpcyBzYWZlIHRvIGRvIGluIGFueSBvcmRlcjtcbiAgICAgICAgICBieSBkZWZpbml0aW9uIGFkZGluZyBjaGlsZHJlbiB0byBhbiBlbXB0eSBub2RlIGNhbid0IGNhdXNlIG90aGVyIHBhdGhzIHRvIGNoYW5nZS5cbiAgICAgICAgKi9cbiAgICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZWRpdG9yLm5vcm1hbGl6ZU5vZGUoZW50cnksIHtcbiAgICAgICAgICAgIG9wZXJhdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBkaXJ0eVBhdGhzID0gZ2V0RGlydHlQYXRocyhlZGl0b3IpO1xuICAgIHZhciBpbml0aWFsRGlydHlQYXRoc0xlbmd0aCA9IGRpcnR5UGF0aHMubGVuZ3RoO1xuICAgIHZhciBpdGVyYXRpb24gPSAwO1xuICAgIHdoaWxlIChkaXJ0eVBhdGhzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgaWYgKCFlZGl0b3Iuc2hvdWxkTm9ybWFsaXplKHtcbiAgICAgICAgZGlydHlQYXRocyxcbiAgICAgICAgaXRlcmF0aW9uLFxuICAgICAgICBpbml0aWFsRGlydHlQYXRoc0xlbmd0aCxcbiAgICAgICAgb3BlcmF0aW9uXG4gICAgICB9KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgX2RpcnR5UGF0aCA9IHBvcERpcnR5UGF0aChlZGl0b3IpO1xuICAgICAgLy8gSWYgdGhlIG5vZGUgZG9lc24ndCBleGlzdCBpbiB0aGUgdHJlZSwgaXQgZG9lcyBub3QgbmVlZCB0byBiZSBub3JtYWxpemVkLlxuICAgICAgaWYgKE5vZGUuaGFzKGVkaXRvciwgX2RpcnR5UGF0aCkpIHtcbiAgICAgICAgdmFyIF9lbnRyeSA9IEVkaXRvci5ub2RlKGVkaXRvciwgX2RpcnR5UGF0aCk7XG4gICAgICAgIGVkaXRvci5ub3JtYWxpemVOb2RlKF9lbnRyeSwge1xuICAgICAgICAgIG9wZXJhdGlvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGl0ZXJhdGlvbisrO1xuICAgICAgZGlydHlQYXRocyA9IGdldERpcnR5UGF0aHMoZWRpdG9yKTtcbiAgICB9XG4gIH0pO1xufTtcblxudmFyIHBhcmVudCA9IGZ1bmN0aW9uIHBhcmVudChlZGl0b3IsIGF0KSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0LCBvcHRpb25zKTtcbiAgdmFyIHBhcmVudFBhdGggPSBQYXRoLnBhcmVudChwYXRoKTtcbiAgdmFyIGVudHJ5ID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXJlbnRQYXRoKTtcbiAgcmV0dXJuIGVudHJ5O1xufTtcblxudmFyIHBhdGhSZWYgPSBmdW5jdGlvbiBwYXRoUmVmKGVkaXRvciwgcGF0aCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciB7XG4gICAgYWZmaW5pdHkgPSAnZm9yd2FyZCdcbiAgfSA9IG9wdGlvbnM7XG4gIHZhciByZWYgPSB7XG4gICAgY3VycmVudDogcGF0aCxcbiAgICBhZmZpbml0eSxcbiAgICB1bnJlZigpIHtcbiAgICAgIHZhciB7XG4gICAgICAgIGN1cnJlbnRcbiAgICAgIH0gPSByZWY7XG4gICAgICB2YXIgcGF0aFJlZnMgPSBFZGl0b3IucGF0aFJlZnMoZWRpdG9yKTtcbiAgICAgIHBhdGhSZWZzLmRlbGV0ZShyZWYpO1xuICAgICAgcmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICB9O1xuICB2YXIgcmVmcyA9IEVkaXRvci5wYXRoUmVmcyhlZGl0b3IpO1xuICByZWZzLmFkZChyZWYpO1xuICByZXR1cm4gcmVmO1xufTtcblxudmFyIHBhdGhSZWZzID0gZWRpdG9yID0+IHtcbiAgdmFyIHJlZnMgPSBQQVRIX1JFRlMuZ2V0KGVkaXRvcik7XG4gIGlmICghcmVmcykge1xuICAgIHJlZnMgPSBuZXcgU2V0KCk7XG4gICAgUEFUSF9SRUZTLnNldChlZGl0b3IsIHJlZnMpO1xuICB9XG4gIHJldHVybiByZWZzO1xufTtcblxudmFyIHBhdGggPSBmdW5jdGlvbiBwYXRoKGVkaXRvciwgYXQpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICB2YXIge1xuICAgIGRlcHRoLFxuICAgIGVkZ2VcbiAgfSA9IG9wdGlvbnM7XG4gIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICBpZiAoZWRnZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgdmFyIFssIGZpcnN0UGF0aF0gPSBOb2RlLmZpcnN0KGVkaXRvciwgYXQpO1xuICAgICAgYXQgPSBmaXJzdFBhdGg7XG4gICAgfSBlbHNlIGlmIChlZGdlID09PSAnZW5kJykge1xuICAgICAgdmFyIFssIGxhc3RQYXRoXSA9IE5vZGUubGFzdChlZGl0b3IsIGF0KTtcbiAgICAgIGF0ID0gbGFzdFBhdGg7XG4gICAgfVxuICB9XG4gIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgIGlmIChlZGdlID09PSAnc3RhcnQnKSB7XG4gICAgICBhdCA9IFJhbmdlLnN0YXJ0KGF0KTtcbiAgICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdlbmQnKSB7XG4gICAgICBhdCA9IFJhbmdlLmVuZChhdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF0ID0gUGF0aC5jb21tb24oYXQuYW5jaG9yLnBhdGgsIGF0LmZvY3VzLnBhdGgpO1xuICAgIH1cbiAgfVxuICBpZiAoUG9pbnQuaXNQb2ludChhdCkpIHtcbiAgICBhdCA9IGF0LnBhdGg7XG4gIH1cbiAgaWYgKGRlcHRoICE9IG51bGwpIHtcbiAgICBhdCA9IGF0LnNsaWNlKDAsIGRlcHRoKTtcbiAgfVxuICByZXR1cm4gYXQ7XG59O1xuXG52YXIgcG9pbnRSZWYgPSBmdW5jdGlvbiBwb2ludFJlZihlZGl0b3IsIHBvaW50KSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIHtcbiAgICBhZmZpbml0eSA9ICdmb3J3YXJkJ1xuICB9ID0gb3B0aW9ucztcbiAgdmFyIHJlZiA9IHtcbiAgICBjdXJyZW50OiBwb2ludCxcbiAgICBhZmZpbml0eSxcbiAgICB1bnJlZigpIHtcbiAgICAgIHZhciB7XG4gICAgICAgIGN1cnJlbnRcbiAgICAgIH0gPSByZWY7XG4gICAgICB2YXIgcG9pbnRSZWZzID0gRWRpdG9yLnBvaW50UmVmcyhlZGl0b3IpO1xuICAgICAgcG9pbnRSZWZzLmRlbGV0ZShyZWYpO1xuICAgICAgcmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICB9O1xuICB2YXIgcmVmcyA9IEVkaXRvci5wb2ludFJlZnMoZWRpdG9yKTtcbiAgcmVmcy5hZGQocmVmKTtcbiAgcmV0dXJuIHJlZjtcbn07XG5cbnZhciBwb2ludFJlZnMgPSBlZGl0b3IgPT4ge1xuICB2YXIgcmVmcyA9IFBPSU5UX1JFRlMuZ2V0KGVkaXRvcik7XG4gIGlmICghcmVmcykge1xuICAgIHJlZnMgPSBuZXcgU2V0KCk7XG4gICAgUE9JTlRfUkVGUy5zZXQoZWRpdG9yLCByZWZzKTtcbiAgfVxuICByZXR1cm4gcmVmcztcbn07XG5cbnZhciBwb2ludCA9IGZ1bmN0aW9uIHBvaW50KGVkaXRvciwgYXQpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICB2YXIge1xuICAgIGVkZ2UgPSAnc3RhcnQnXG4gIH0gPSBvcHRpb25zO1xuICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgdmFyIHBhdGg7XG4gICAgaWYgKGVkZ2UgPT09ICdlbmQnKSB7XG4gICAgICB2YXIgWywgbGFzdFBhdGhdID0gTm9kZS5sYXN0KGVkaXRvciwgYXQpO1xuICAgICAgcGF0aCA9IGxhc3RQYXRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgWywgZmlyc3RQYXRoXSA9IE5vZGUuZmlyc3QoZWRpdG9yLCBhdCk7XG4gICAgICBwYXRoID0gZmlyc3RQYXRoO1xuICAgIH1cbiAgICB2YXIgbm9kZSA9IE5vZGUuZ2V0KGVkaXRvciwgcGF0aCk7XG4gICAgaWYgKCFUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgXCIuY29uY2F0KGVkZ2UsIFwiIHBvaW50IGluIHRoZSBub2RlIGF0IHBhdGggW1wiKS5jb25jYXQoYXQsIFwiXSBiZWNhdXNlIGl0IGhhcyBubyBcIikuY29uY2F0KGVkZ2UsIFwiIHRleHQgbm9kZS5cIikpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcGF0aCxcbiAgICAgIG9mZnNldDogZWRnZSA9PT0gJ2VuZCcgPyBub2RlLnRleHQubGVuZ3RoIDogMFxuICAgIH07XG4gIH1cbiAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKGF0KTtcbiAgICByZXR1cm4gZWRnZSA9PT0gJ3N0YXJ0JyA/IHN0YXJ0IDogZW5kO1xuICB9XG4gIHJldHVybiBhdDtcbn07XG5cbmZ1bmN0aW9uIHBvc2l0aW9ucyhlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICB2YXIge1xuICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgdW5pdCA9ICdvZmZzZXQnLFxuICAgICAgcmV2ZXJzZSA9IGZhbHNlLFxuICAgICAgdm9pZHMgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxnb3JpdGhtIG5vdGVzOlxuICAgICAqXG4gICAgICogRWFjaCBzdGVwIGBkaXN0YW5jZWAgaXMgZHluYW1pYyBkZXBlbmRpbmcgb24gdGhlIHVuZGVybHlpbmcgdGV4dFxuICAgICAqIGFuZCB0aGUgYHVuaXRgIHNwZWNpZmllZC4gIEVhY2ggc3RlcCwgZS5nLiwgYSBsaW5lIG9yIHdvcmQsIG1heVxuICAgICAqIHNwYW4gbXVsdGlwbGUgdGV4dCBub2Rlcywgc28gd2UgaXRlcmF0ZSB0aHJvdWdoIHRoZSB0ZXh0IGJvdGggb25cbiAgICAgKiB0d28gbGV2ZWxzIGluIHN0ZXAtc3luYzpcbiAgICAgKlxuICAgICAqIGBsZWFmVGV4dGAgc3RvcmVzIHRoZSB0ZXh0IG9uIGEgdGV4dCBsZWFmIGxldmVsLCBhbmQgaXMgYWR2YW5jZWRcbiAgICAgKiB0aHJvdWdoIHVzaW5nIHRoZSBjb3VudGVycyBgbGVhZlRleHRPZmZzZXRgIGFuZCBgbGVhZlRleHRSZW1haW5pbmdgLlxuICAgICAqXG4gICAgICogYGJsb2NrVGV4dGAgc3RvcmVzIHRoZSB0ZXh0IG9uIGEgYmxvY2sgbGV2ZWwsIGFuZCBpcyBzaG9ydGVuZWRcbiAgICAgKiBieSBgZGlzdGFuY2VgIGV2ZXJ5IHRpbWUgaXQgaXMgYWR2YW5jZWQuXG4gICAgICpcbiAgICAgKiBXZSBvbmx5IG1haW50YWluIGEgd2luZG93IG9mIG9uZSBibG9ja1RleHQgYW5kIG9uZSBsZWFmVGV4dCBiZWNhdXNlXG4gICAgICogYSBibG9jayBub2RlIGFsd2F5cyBhcHBlYXJzIGJlZm9yZSBhbGwgb2YgaXRzIGxlYWYgbm9kZXMuXG4gICAgICovXG4gICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgYXQpO1xuICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gICAgdmFyIGZpcnN0ID0gcmV2ZXJzZSA/IGVuZCA6IHN0YXJ0O1xuICAgIHZhciBpc05ld0Jsb2NrID0gZmFsc2U7XG4gICAgdmFyIGJsb2NrVGV4dCA9ICcnO1xuICAgIHZhciBkaXN0YW5jZSA9IDA7IC8vIERpc3RhbmNlIGZvciBsZWFmVGV4dCB0byBjYXRjaCB1cCB0byBibG9ja1RleHQuXG4gICAgdmFyIGxlYWZUZXh0UmVtYWluaW5nID0gMDtcbiAgICB2YXIgbGVhZlRleHRPZmZzZXQgPSAwO1xuICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBhbGwgbm9kZXMgaW4gcmFuZ2UsIGdyYWJiaW5nIGVudGlyZSB0ZXh0dWFsIGNvbnRlbnRcbiAgICAvLyBvZiBibG9jayBub2RlcyBpbiBibG9ja1RleHQsIGFuZCB0ZXh0IG5vZGVzIGluIGxlYWZUZXh0LlxuICAgIC8vIEV4cGxvaXRzIHRoZSBmYWN0IHRoYXQgbm9kZXMgYXJlIHNlcXVlbmNlZCBpbiBzdWNoIGEgd2F5IHRoYXQgd2UgZmlyc3RcbiAgICAvLyBlbmNvdW50ZXIgdGhlIGJsb2NrIG5vZGUsIHRoZW4gYWxsIG9mIGl0cyB0ZXh0IG5vZGVzLCBzbyB3aGVuIGl0ZXJhdGluZ1xuICAgIC8vIHRocm91Z2ggdGhlIGJsb2NrVGV4dCBhbmQgbGVhZlRleHQgd2UganVzdCBuZWVkIHRvIHJlbWVtYmVyIGEgd2luZG93IG9mXG4gICAgLy8gb25lIGJsb2NrIG5vZGUgYW5kIGxlYWYgbm9kZSwgcmVzcGVjdGl2ZWx5LlxuICAgIGZvciAodmFyIFtub2RlLCBwYXRoXSBvZiBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdCxcbiAgICAgIHJldmVyc2UsXG4gICAgICB2b2lkc1xuICAgIH0pKSB7XG4gICAgICAvKlxuICAgICAgICogRUxFTUVOVCBOT0RFIC0gWWllbGQgcG9zaXRpb24ocykgZm9yIHZvaWRzLCBjb2xsZWN0IGJsb2NrVGV4dCBmb3IgYmxvY2tzXG4gICAgICAgKi9cbiAgICAgIGlmIChFbGVtZW50LmlzRWxlbWVudChub2RlKSkge1xuICAgICAgICBpZiAoIWVkaXRvci5pc1NlbGVjdGFibGUobm9kZSkpIHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBJZiB0aGUgbm9kZSBpcyBub3Qgc2VsZWN0YWJsZSwgc2tpcCBpdFxuICAgICAgICAgICAqL1xuICAgICAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgICAgICB5aWVsZCBFZGl0b3IuZW5kKGVkaXRvciwgUGF0aC5wcmV2aW91cyhwYXRoKSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeWllbGQgRWRpdG9yLnN0YXJ0KGVkaXRvciwgUGF0aC5uZXh0KHBhdGgpKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBWb2lkIG5vZGVzIGFyZSBhIHNwZWNpYWwgY2FzZSwgc28gYnkgZGVmYXVsdCB3ZSB3aWxsIGFsd2F5c1xuICAgICAgICAvLyB5aWVsZCB0aGVpciBmaXJzdCBwb2ludC4gSWYgdGhlIGB2b2lkc2Agb3B0aW9uIGlzIHNldCB0byB0cnVlLFxuICAgICAgICAvLyB0aGVuIHdlIHdpbGwgaXRlcmF0ZSBvdmVyIHRoZWlyIGNvbnRlbnQuXG4gICAgICAgIGlmICghdm9pZHMgJiYgKGVkaXRvci5pc1ZvaWQobm9kZSkgfHwgZWRpdG9yLmlzRWxlbWVudFJlYWRPbmx5KG5vZGUpKSkge1xuICAgICAgICAgIHlpZWxkIEVkaXRvci5zdGFydChlZGl0b3IsIHBhdGgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElubGluZSBlbGVtZW50IG5vZGVzIGFyZSBpZ25vcmVkIGFzIHRoZXkgZG9uJ3QgdGhlbXNlbHZlc1xuICAgICAgICAvLyBjb250cmlidXRlIHRvIGBibG9ja1RleHRgIG9yIGBsZWFmVGV4dGAgLSB0aGVpciBwYXJlbnQgYW5kXG4gICAgICAgIC8vIGNoaWxkcmVuIGRvLlxuICAgICAgICBpZiAoZWRpdG9yLmlzSW5saW5lKG5vZGUpKSBjb250aW51ZTtcbiAgICAgICAgLy8gQmxvY2sgZWxlbWVudCBub2RlIC0gc2V0IGBibG9ja1RleHRgIHRvIGl0cyB0ZXh0IGNvbnRlbnQuXG4gICAgICAgIGlmIChFZGl0b3IuaGFzSW5saW5lcyhlZGl0b3IsIG5vZGUpKSB7XG4gICAgICAgICAgLy8gV2UgYWx3YXlzIGV4aGF1c3QgYmxvY2sgbm9kZXMgYmVmb3JlIGVuY291bnRlcmluZyBhIG5ldyBvbmU6XG4gICAgICAgICAgLy8gICBjb25zb2xlLmFzc2VydChibG9ja1RleHQgPT09ICcnLFxuICAgICAgICAgIC8vICAgICBgYmxvY2tUZXh0PScke2Jsb2NrVGV4dH0nIC0gYCtcbiAgICAgICAgICAvLyAgICAgYG5vdCBleGhhdXN0ZWQgYmVmb3JlIG5ldyBibG9jayBub2RlYCwgcGF0aClcbiAgICAgICAgICAvLyBFbnN1cmUgcmFuZ2UgY29uc2lkZXJlZCBpcyBjYXBwZWQgdG8gYHJhbmdlYCwgaW4gdGhlXG4gICAgICAgICAgLy8gc3RhcnQvZW5kIGVkZ2UgY2FzZXMgd2hlcmUgYmxvY2sgZXh0ZW5kcyBiZXlvbmQgcmFuZ2UuXG4gICAgICAgICAgLy8gRXF1aXZhbGVudCB0byB0aGlzLCBidXQgcHJlc3VtYWJseSBtb3JlIHBlcmZvcm1hbnQ6XG4gICAgICAgICAgLy8gICBibG9ja1JhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgLi4uRWRpdG9yLmVkZ2VzKGVkaXRvciwgcGF0aCkpXG4gICAgICAgICAgLy8gICBibG9ja1JhbmdlID0gUmFuZ2UuaW50ZXJzZWN0aW9uKHJhbmdlLCBibG9ja1JhbmdlKSAvLyBpbnRlcnNlY3RcbiAgICAgICAgICAvLyAgIGJsb2NrVGV4dCA9IEVkaXRvci5zdHJpbmcoZWRpdG9yLCBibG9ja1JhbmdlLCB7IHZvaWRzIH0pXG4gICAgICAgICAgdmFyIGUgPSBQYXRoLmlzQW5jZXN0b3IocGF0aCwgZW5kLnBhdGgpID8gZW5kIDogRWRpdG9yLmVuZChlZGl0b3IsIHBhdGgpO1xuICAgICAgICAgIHZhciBzID0gUGF0aC5pc0FuY2VzdG9yKHBhdGgsIHN0YXJ0LnBhdGgpID8gc3RhcnQgOiBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgICBibG9ja1RleHQgPSBFZGl0b3Iuc3RyaW5nKGVkaXRvciwge1xuICAgICAgICAgICAgYW5jaG9yOiBzLFxuICAgICAgICAgICAgZm9jdXM6IGVcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlzTmV3QmxvY2sgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKlxuICAgICAgICogVEVYVCBMRUFGIE5PREUgLSBJdGVyYXRlIHRocm91Z2ggdGV4dCBjb250ZW50LCB5aWVsZGluZ1xuICAgICAgICogcG9zaXRpb25zIGV2ZXJ5IGBkaXN0YW5jZWAgb2Zmc2V0IGFjY29yZGluZyB0byBgdW5pdGAuXG4gICAgICAgKi9cbiAgICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgICB2YXIgaXNGaXJzdCA9IFBhdGguZXF1YWxzKHBhdGgsIGZpcnN0LnBhdGgpO1xuICAgICAgICAvLyBQcm9vZiB0aGF0IHdlIGFsd2F5cyBleGhhdXN0IHRleHQgbm9kZXMgYmVmb3JlIGVuY291bnRlcmluZyBhIG5ldyBvbmU6XG4gICAgICAgIC8vICAgY29uc29sZS5hc3NlcnQobGVhZlRleHRSZW1haW5pbmcgPD0gMCxcbiAgICAgICAgLy8gICAgIGBsZWFmVGV4dFJlbWFpbmluZz0ke2xlYWZUZXh0UmVtYWluaW5nfSAtIGArXG4gICAgICAgIC8vICAgICBgbm90IGV4aGF1c3RlZCBiZWZvcmUgbmV3IGxlYWYgdGV4dCBub2RlYCwgcGF0aClcbiAgICAgICAgLy8gUmVzZXQgYGxlYWZUZXh0YCBjb3VudGVycyBmb3IgbmV3IHRleHQgbm9kZS5cbiAgICAgICAgaWYgKGlzRmlyc3QpIHtcbiAgICAgICAgICBsZWFmVGV4dFJlbWFpbmluZyA9IHJldmVyc2UgPyBmaXJzdC5vZmZzZXQgOiBub2RlLnRleHQubGVuZ3RoIC0gZmlyc3Qub2Zmc2V0O1xuICAgICAgICAgIGxlYWZUZXh0T2Zmc2V0ID0gZmlyc3Qub2Zmc2V0OyAvLyBXb3JrcyBmb3IgcmV2ZXJzZSB0b28uXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGVhZlRleHRSZW1haW5pbmcgPSBub2RlLnRleHQubGVuZ3RoO1xuICAgICAgICAgIGxlYWZUZXh0T2Zmc2V0ID0gcmV2ZXJzZSA/IGxlYWZUZXh0UmVtYWluaW5nIDogMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBZaWVsZCBwb3NpdGlvbiBhdCB0aGUgc3RhcnQgb2Ygbm9kZSAocG90ZW50aWFsbHkpLlxuICAgICAgICBpZiAoaXNGaXJzdCB8fCBpc05ld0Jsb2NrIHx8IHVuaXQgPT09ICdvZmZzZXQnKSB7XG4gICAgICAgICAgeWllbGQge1xuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIG9mZnNldDogbGVhZlRleHRPZmZzZXRcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlzTmV3QmxvY2sgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBZaWVsZCBwb3NpdGlvbnMgZXZlcnkgKGR5bmFtaWNhbGx5IGNhbGN1bGF0ZWQpIGBkaXN0YW5jZWAgb2Zmc2V0LlxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIC8vIElmIGBsZWFmVGV4dGAgaGFzIGNhdWdodCB1cCB3aXRoIGBibG9ja1RleHRgIChkaXN0YW5jZT0wKSxcbiAgICAgICAgICAvLyBhbmQgaWYgYmxvY2tUZXh0IGlzIGV4aGF1c3RlZCwgYnJlYWsgdG8gZ2V0IGFub3RoZXIgYmxvY2sgbm9kZSxcbiAgICAgICAgICAvLyBvdGhlcndpc2UgYWR2YW5jZSBibG9ja1RleHQgZm9yd2FyZCBieSB0aGUgbmV3IGBkaXN0YW5jZWAuXG4gICAgICAgICAgaWYgKGRpc3RhbmNlID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoYmxvY2tUZXh0ID09PSAnJykgYnJlYWs7XG4gICAgICAgICAgICBkaXN0YW5jZSA9IGNhbGNEaXN0YW5jZShibG9ja1RleHQsIHVuaXQsIHJldmVyc2UpO1xuICAgICAgICAgICAgLy8gU3BsaXQgdGhlIHN0cmluZyBhdCB0aGUgcHJldmlvdXNseSBmb3VuZCBkaXN0YW5jZSBhbmQgdXNlIHRoZVxuICAgICAgICAgICAgLy8gcmVtYWluaW5nIHN0cmluZyBmb3IgdGhlIG5leHQgaXRlcmF0aW9uLlxuICAgICAgICAgICAgYmxvY2tUZXh0ID0gc3BsaXRCeUNoYXJhY3RlckRpc3RhbmNlKGJsb2NrVGV4dCwgZGlzdGFuY2UsIHJldmVyc2UpWzFdO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBBZHZhbmNlIGBsZWFmVGV4dGAgYnkgdGhlIGN1cnJlbnQgYGRpc3RhbmNlYC5cbiAgICAgICAgICBsZWFmVGV4dE9mZnNldCA9IHJldmVyc2UgPyBsZWFmVGV4dE9mZnNldCAtIGRpc3RhbmNlIDogbGVhZlRleHRPZmZzZXQgKyBkaXN0YW5jZTtcbiAgICAgICAgICBsZWFmVGV4dFJlbWFpbmluZyA9IGxlYWZUZXh0UmVtYWluaW5nIC0gZGlzdGFuY2U7XG4gICAgICAgICAgLy8gSWYgYGxlYWZUZXh0YCBpcyBleGhhdXN0ZWQsIGJyZWFrIHRvIGdldCBhIG5ldyBsZWFmIG5vZGVcbiAgICAgICAgICAvLyBhbmQgc2V0IGRpc3RhbmNlIHRvIHRoZSBvdmVyZmxvdyBhbW91bnQsIHNvIHdlJ2xsIChtYXliZSlcbiAgICAgICAgICAvLyBjYXRjaCB1cCB0byBibG9ja1RleHQgaW4gdGhlIG5leHQgbGVhZiB0ZXh0IG5vZGUuXG4gICAgICAgICAgaWYgKGxlYWZUZXh0UmVtYWluaW5nIDwgMCkge1xuICAgICAgICAgICAgZGlzdGFuY2UgPSAtbGVhZlRleHRSZW1haW5pbmc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gU3VjY2Vzc2Z1bGx5IHdhbGtlZCBgZGlzdGFuY2VgIG9mZnNldHMgdGhyb3VnaCBgbGVhZlRleHRgXG4gICAgICAgICAgLy8gdG8gY2F0Y2ggdXAgd2l0aCBgYmxvY2tUZXh0YCwgc28gd2UgY2FuIHJlc2V0IGBkaXN0YW5jZWBcbiAgICAgICAgICAvLyBhbmQgeWllbGQgdGhpcyBwb3NpdGlvbiBpbiB0aGlzIG5vZGUuXG4gICAgICAgICAgZGlzdGFuY2UgPSAwO1xuICAgICAgICAgIHlpZWxkIHtcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBvZmZzZXQ6IGxlYWZUZXh0T2Zmc2V0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBQcm9vZiB0aGF0IHVwb24gY29tcGxldGlvbiwgd2UndmUgZXhhaHVzdGVkIGJvdGggbGVhZiBhbmQgYmxvY2sgdGV4dDpcbiAgICAvLyAgIGNvbnNvbGUuYXNzZXJ0KGxlYWZUZXh0UmVtYWluaW5nIDw9IDAsIFwibGVhZlRleHQgd2Fzbid0IGV4aGF1c3RlZFwiKVxuICAgIC8vICAgY29uc29sZS5hc3NlcnQoYmxvY2tUZXh0ID09PSAnJywgXCJibG9ja1RleHQgd2Fzbid0IGV4aGF1c3RlZFwiKVxuICAgIC8vIEhlbHBlcjpcbiAgICAvLyBSZXR1cm4gdGhlIGRpc3RhbmNlIGluIG9mZnNldHMgZm9yIGEgc3RlcCBvZiBzaXplIGB1bml0YCBvbiBnaXZlbiBzdHJpbmcuXG4gICAgZnVuY3Rpb24gY2FsY0Rpc3RhbmNlKHRleHQsIHVuaXQsIHJldmVyc2UpIHtcbiAgICAgIGlmICh1bml0ID09PSAnY2hhcmFjdGVyJykge1xuICAgICAgICByZXR1cm4gZ2V0Q2hhcmFjdGVyRGlzdGFuY2UodGV4dCwgcmV2ZXJzZSk7XG4gICAgICB9IGVsc2UgaWYgKHVuaXQgPT09ICd3b3JkJykge1xuICAgICAgICByZXR1cm4gZ2V0V29yZERpc3RhbmNlKHRleHQsIHJldmVyc2UpO1xuICAgICAgfSBlbHNlIGlmICh1bml0ID09PSAnbGluZScgfHwgdW5pdCA9PT0gJ2Jsb2NrJykge1xuICAgICAgICByZXR1cm4gdGV4dC5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH0oKTtcbn1cblxudmFyIHByZXZpb3VzID0gZnVuY3Rpb24gcHJldmlvdXMoZWRpdG9yKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIHtcbiAgICBtb2RlID0gJ2xvd2VzdCcsXG4gICAgdm9pZHMgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgdmFyIHtcbiAgICBtYXRjaCxcbiAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb25cbiAgfSA9IG9wdGlvbnM7XG4gIGlmICghYXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHBvaW50QmVmb3JlTG9jYXRpb24gPSBFZGl0b3IuYmVmb3JlKGVkaXRvciwgYXQsIHtcbiAgICB2b2lkc1xuICB9KTtcbiAgaWYgKCFwb2ludEJlZm9yZUxvY2F0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBbLCB0b10gPSBFZGl0b3IuZmlyc3QoZWRpdG9yLCBbXSk7XG4gIC8vIFRoZSBzZWFyY2ggbG9jYXRpb24gaXMgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIGRvY3VtZW50IHRvIHRoZSBwYXRoIG9mXG4gIC8vIHRoZSBwb2ludCBiZWZvcmUgdGhlIGxvY2F0aW9uIHBhc3NlZCBpblxuICB2YXIgc3BhbiA9IFtwb2ludEJlZm9yZUxvY2F0aW9uLnBhdGgsIHRvXTtcbiAgaWYgKFBhdGguaXNQYXRoKGF0KSAmJiBhdC5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBwcmV2aW91cyBub2RlIGZyb20gdGhlIHJvb3Qgbm9kZSFcIik7XG4gIH1cbiAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICB2YXIgW3BhcmVudF0gPSBFZGl0b3IucGFyZW50KGVkaXRvciwgYXQpO1xuICAgICAgbWF0Y2ggPSBuID0+IHBhcmVudC5jaGlsZHJlbi5pbmNsdWRlcyhuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF0Y2ggPSAoKSA9PiB0cnVlO1xuICAgIH1cbiAgfVxuICB2YXIgW3ByZXZpb3VzXSA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICByZXZlcnNlOiB0cnVlLFxuICAgIGF0OiBzcGFuLFxuICAgIG1hdGNoLFxuICAgIG1vZGUsXG4gICAgdm9pZHNcbiAgfSk7XG4gIHJldHVybiBwcmV2aW91cztcbn07XG5cbnZhciByYW5nZVJlZiA9IGZ1bmN0aW9uIHJhbmdlUmVmKGVkaXRvciwgcmFuZ2UpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICB2YXIge1xuICAgIGFmZmluaXR5ID0gJ2ZvcndhcmQnXG4gIH0gPSBvcHRpb25zO1xuICB2YXIgcmVmID0ge1xuICAgIGN1cnJlbnQ6IHJhbmdlLFxuICAgIGFmZmluaXR5LFxuICAgIHVucmVmKCkge1xuICAgICAgdmFyIHtcbiAgICAgICAgY3VycmVudFxuICAgICAgfSA9IHJlZjtcbiAgICAgIHZhciByYW5nZVJlZnMgPSBFZGl0b3IucmFuZ2VSZWZzKGVkaXRvcik7XG4gICAgICByYW5nZVJlZnMuZGVsZXRlKHJlZik7XG4gICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9XG4gIH07XG4gIHZhciByZWZzID0gRWRpdG9yLnJhbmdlUmVmcyhlZGl0b3IpO1xuICByZWZzLmFkZChyZWYpO1xuICByZXR1cm4gcmVmO1xufTtcblxudmFyIHJhbmdlUmVmcyA9IGVkaXRvciA9PiB7XG4gIHZhciByZWZzID0gUkFOR0VfUkVGUy5nZXQoZWRpdG9yKTtcbiAgaWYgKCFyZWZzKSB7XG4gICAgcmVmcyA9IG5ldyBTZXQoKTtcbiAgICBSQU5HRV9SRUZTLnNldChlZGl0b3IsIHJlZnMpO1xuICB9XG4gIHJldHVybiByZWZzO1xufTtcblxudmFyIHJhbmdlID0gKGVkaXRvciwgYXQsIHRvKSA9PiB7XG4gIGlmIChSYW5nZS5pc1JhbmdlKGF0KSAmJiAhdG8pIHtcbiAgICByZXR1cm4gYXQ7XG4gIH1cbiAgdmFyIHN0YXJ0ID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgYXQpO1xuICB2YXIgZW5kID0gRWRpdG9yLmVuZChlZGl0b3IsIHRvIHx8IGF0KTtcbiAgcmV0dXJuIHtcbiAgICBhbmNob3I6IHN0YXJ0LFxuICAgIGZvY3VzOiBlbmRcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIG93bktleXMkMihlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDIoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyQyKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyQyKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG52YXIgcmVtb3ZlTWFyayA9IChlZGl0b3IsIGtleSkgPT4ge1xuICB2YXIge1xuICAgIHNlbGVjdGlvblxuICB9ID0gZWRpdG9yO1xuICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgdmFyIG1hdGNoID0gKG5vZGUsIHBhdGgpID0+IHtcbiAgICAgIGlmICghVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBtYXJrcyBjYW4gb25seSBiZSBhcHBsaWVkIHRvIHRleHRcbiAgICAgIH1cblxuICAgICAgdmFyIFtwYXJlbnROb2RlLCBwYXJlbnRQYXRoXSA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBwYXRoKTtcbiAgICAgIHJldHVybiAhZWRpdG9yLmlzVm9pZChwYXJlbnROb2RlKSB8fCBlZGl0b3IubWFya2FibGVWb2lkKHBhcmVudE5vZGUpO1xuICAgIH07XG4gICAgdmFyIGV4cGFuZGVkU2VsZWN0aW9uID0gUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pO1xuICAgIHZhciBtYXJrQWNjZXB0aW5nVm9pZFNlbGVjdGVkID0gZmFsc2U7XG4gICAgaWYgKCFleHBhbmRlZFNlbGVjdGlvbikge1xuICAgICAgdmFyIFtzZWxlY3RlZE5vZGUsIHNlbGVjdGVkUGF0aF0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIHNlbGVjdGlvbik7XG4gICAgICBpZiAoc2VsZWN0ZWROb2RlICYmIG1hdGNoKHNlbGVjdGVkTm9kZSwgc2VsZWN0ZWRQYXRoKSkge1xuICAgICAgICB2YXIgW3BhcmVudE5vZGVdID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIHNlbGVjdGVkUGF0aCk7XG4gICAgICAgIG1hcmtBY2NlcHRpbmdWb2lkU2VsZWN0ZWQgPSBwYXJlbnROb2RlICYmIGVkaXRvci5tYXJrYWJsZVZvaWQocGFyZW50Tm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChleHBhbmRlZFNlbGVjdGlvbiB8fCBtYXJrQWNjZXB0aW5nVm9pZFNlbGVjdGVkKSB7XG4gICAgICBUcmFuc2Zvcm1zLnVuc2V0Tm9kZXMoZWRpdG9yLCBrZXksIHtcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIHNwbGl0OiB0cnVlLFxuICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtYXJrcyA9IF9vYmplY3RTcHJlYWQkMih7fSwgRWRpdG9yLm1hcmtzKGVkaXRvcikgfHwge30pO1xuICAgICAgZGVsZXRlIG1hcmtzW2tleV07XG4gICAgICBlZGl0b3IubWFya3MgPSBtYXJrcztcbiAgICAgIGlmICghRkxVU0hJTkcuZ2V0KGVkaXRvcikpIHtcbiAgICAgICAgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgc2V0Tm9ybWFsaXppbmcgPSAoZWRpdG9yLCBpc05vcm1hbGl6aW5nKSA9PiB7XG4gIE5PUk1BTElaSU5HLnNldChlZGl0b3IsIGlzTm9ybWFsaXppbmcpO1xufTtcblxudmFyIHN0YXJ0ID0gKGVkaXRvciwgYXQpID0+IHtcbiAgcmV0dXJuIEVkaXRvci5wb2ludChlZGl0b3IsIGF0LCB7XG4gICAgZWRnZTogJ3N0YXJ0J1xuICB9KTtcbn07XG5cbnZhciBzdHJpbmcgPSBmdW5jdGlvbiBzdHJpbmcoZWRpdG9yLCBhdCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciB7XG4gICAgdm9pZHMgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgYXQpO1xuICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMocmFuZ2UpO1xuICB2YXIgdGV4dCA9ICcnO1xuICBmb3IgKHZhciBbbm9kZSwgcGF0aF0gb2YgRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgIGF0OiByYW5nZSxcbiAgICBtYXRjaDogVGV4dC5pc1RleHQsXG4gICAgdm9pZHNcbiAgfSkpIHtcbiAgICB2YXIgdCA9IG5vZGUudGV4dDtcbiAgICBpZiAoUGF0aC5lcXVhbHMocGF0aCwgZW5kLnBhdGgpKSB7XG4gICAgICB0ID0gdC5zbGljZSgwLCBlbmQub2Zmc2V0KTtcbiAgICB9XG4gICAgaWYgKFBhdGguZXF1YWxzKHBhdGgsIHN0YXJ0LnBhdGgpKSB7XG4gICAgICB0ID0gdC5zbGljZShzdGFydC5vZmZzZXQpO1xuICAgIH1cbiAgICB0ZXh0ICs9IHQ7XG4gIH1cbiAgcmV0dXJuIHRleHQ7XG59O1xuXG52YXIgdW5oYW5nUmFuZ2UgPSBmdW5jdGlvbiB1bmhhbmdSYW5nZShlZGl0b3IsIHJhbmdlKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIHtcbiAgICB2b2lkcyA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMocmFuZ2UpO1xuICAvLyBQRVJGOiBleGl0IGVhcmx5IGlmIHdlIGNhbiBndWFyYW50ZWUgdGhhdCB0aGUgcmFuZ2UgaXNuJ3QgaGFuZ2luZy5cbiAgaWYgKHN0YXJ0Lm9mZnNldCAhPT0gMCB8fCBlbmQub2Zmc2V0ICE9PSAwIHx8IFJhbmdlLmlzQ29sbGFwc2VkKHJhbmdlKSB8fCBQYXRoLmhhc1ByZXZpb3VzKGVuZC5wYXRoKSkge1xuICAgIHJldHVybiByYW5nZTtcbiAgfVxuICB2YXIgZW5kQmxvY2sgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgYXQ6IGVuZCxcbiAgICBtYXRjaDogbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pLFxuICAgIHZvaWRzXG4gIH0pO1xuICB2YXIgYmxvY2tQYXRoID0gZW5kQmxvY2sgPyBlbmRCbG9ja1sxXSA6IFtdO1xuICB2YXIgZmlyc3QgPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBzdGFydCk7XG4gIHZhciBiZWZvcmUgPSB7XG4gICAgYW5jaG9yOiBmaXJzdCxcbiAgICBmb2N1czogZW5kXG4gIH07XG4gIHZhciBza2lwID0gdHJ1ZTtcbiAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICBhdDogYmVmb3JlLFxuICAgIG1hdGNoOiBUZXh0LmlzVGV4dCxcbiAgICByZXZlcnNlOiB0cnVlLFxuICAgIHZvaWRzXG4gIH0pKSB7XG4gICAgaWYgKHNraXApIHtcbiAgICAgIHNraXAgPSBmYWxzZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobm9kZS50ZXh0ICE9PSAnJyB8fCBQYXRoLmlzQmVmb3JlKHBhdGgsIGJsb2NrUGF0aCkpIHtcbiAgICAgIGVuZCA9IHtcbiAgICAgICAgcGF0aCxcbiAgICAgICAgb2Zmc2V0OiBub2RlLnRleHQubGVuZ3RoXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgYW5jaG9yOiBzdGFydCxcbiAgICBmb2N1czogZW5kXG4gIH07XG59O1xuXG52YXIgd2l0aG91dE5vcm1hbGl6aW5nID0gKGVkaXRvciwgZm4pID0+IHtcbiAgdmFyIHZhbHVlID0gRWRpdG9yLmlzTm9ybWFsaXppbmcoZWRpdG9yKTtcbiAgRWRpdG9yLnNldE5vcm1hbGl6aW5nKGVkaXRvciwgZmFsc2UpO1xuICB0cnkge1xuICAgIGZuKCk7XG4gIH0gZmluYWxseSB7XG4gICAgRWRpdG9yLnNldE5vcm1hbGl6aW5nKGVkaXRvciwgdmFsdWUpO1xuICB9XG4gIEVkaXRvci5ub3JtYWxpemUoZWRpdG9yKTtcbn07XG5cbnZhciBzaG91bGRNZXJnZU5vZGVzUmVtb3ZlUHJldk5vZGUgPSAoZWRpdG9yLCBfcmVmLCBfcmVmMikgPT4ge1xuICB2YXIgW3ByZXZOb2RlLCBwcmV2UGF0aF0gPSBfcmVmO1xuICAvLyBJZiB0aGUgdGFyZ2V0IG5vZGUgdGhhdCB3ZSdyZSBtZXJnaW5nIHdpdGggaXMgZW1wdHksIHJlbW92ZSBpdCBpbnN0ZWFkXG4gIC8vIG9mIG1lcmdpbmcgdGhlIHR3by4gVGhpcyBpcyBhIGNvbW1vbiByaWNoIHRleHQgZWRpdG9yIGJlaGF2aW9yIHRvXG4gIC8vIHByZXZlbnQgbG9zaW5nIGZvcm1hdHRpbmcgd2hlbiBkZWxldGluZyBlbnRpcmUgbm9kZXMgd2hlbiB5b3UgaGF2ZSBhXG4gIC8vIGhhbmdpbmcgc2VsZWN0aW9uLlxuICAvLyBpZiBwcmV2Tm9kZSBpcyBmaXJzdCBjaGlsZCBpbiBwYXJlbnQsZG9uJ3QgcmVtb3ZlIGl0LlxuICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQocHJldk5vZGUpICYmIEVkaXRvci5pc0VtcHR5KGVkaXRvciwgcHJldk5vZGUpIHx8IFRleHQuaXNUZXh0KHByZXZOb2RlKSAmJiBwcmV2Tm9kZS50ZXh0ID09PSAnJyAmJiBwcmV2UGF0aFtwcmV2UGF0aC5sZW5ndGggLSAxXSAhPT0gMDtcbn07XG5cbnZhciBkZWxldGVUZXh0ID0gZnVuY3Rpb24gZGVsZXRlVGV4dChlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgIHZhciBfRWRpdG9yJHZvaWQsIF9FZGl0b3Ikdm9pZDI7XG4gICAgdmFyIHtcbiAgICAgIHJldmVyc2UgPSBmYWxzZSxcbiAgICAgIHVuaXQgPSAnY2hhcmFjdGVyJyxcbiAgICAgIGRpc3RhbmNlID0gMSxcbiAgICAgIHZvaWRzID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgaGFuZ2luZyA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaXNDb2xsYXBzZWQgPSBmYWxzZTtcbiAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkgJiYgUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4gICAgICBpc0NvbGxhcHNlZCA9IHRydWU7XG4gICAgICBhdCA9IGF0LmFuY2hvcjtcbiAgICB9XG4gICAgaWYgKFBvaW50LmlzUG9pbnQoYXQpKSB7XG4gICAgICB2YXIgZnVydGhlc3RWb2lkID0gRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgIGF0LFxuICAgICAgICBtb2RlOiAnaGlnaGVzdCdcbiAgICAgIH0pO1xuICAgICAgaWYgKCF2b2lkcyAmJiBmdXJ0aGVzdFZvaWQpIHtcbiAgICAgICAgdmFyIFssIHZvaWRQYXRoXSA9IGZ1cnRoZXN0Vm9pZDtcbiAgICAgICAgYXQgPSB2b2lkUGF0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvcHRzID0ge1xuICAgICAgICAgIHVuaXQsXG4gICAgICAgICAgZGlzdGFuY2VcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRhcmdldCA9IHJldmVyc2UgPyBFZGl0b3IuYmVmb3JlKGVkaXRvciwgYXQsIG9wdHMpIHx8IEVkaXRvci5zdGFydChlZGl0b3IsIFtdKSA6IEVkaXRvci5hZnRlcihlZGl0b3IsIGF0LCBvcHRzKSB8fCBFZGl0b3IuZW5kKGVkaXRvciwgW10pO1xuICAgICAgICBhdCA9IHtcbiAgICAgICAgICBhbmNob3I6IGF0LFxuICAgICAgICAgIGZvY3VzOiB0YXJnZXRcbiAgICAgICAgfTtcbiAgICAgICAgaGFuZ2luZyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0LFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChhdCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFoYW5naW5nKSB7XG4gICAgICB2YXIgWywgX2VuZF0gPSBSYW5nZS5lZGdlcyhhdCk7XG4gICAgICB2YXIgZW5kT2ZEb2MgPSBFZGl0b3IuZW5kKGVkaXRvciwgW10pO1xuICAgICAgaWYgKCFQb2ludC5lcXVhbHMoX2VuZCwgZW5kT2ZEb2MpKSB7XG4gICAgICAgIGF0ID0gRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgYXQsIHtcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKGF0KTtcbiAgICB2YXIgc3RhcnRCbG9jayA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbiksXG4gICAgICBhdDogc3RhcnQsXG4gICAgICB2b2lkc1xuICAgIH0pO1xuICAgIHZhciBlbmRCbG9jayA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbiksXG4gICAgICBhdDogZW5kLFxuICAgICAgdm9pZHNcbiAgICB9KTtcbiAgICB2YXIgaXNBY3Jvc3NCbG9ja3MgPSBzdGFydEJsb2NrICYmIGVuZEJsb2NrICYmICFQYXRoLmVxdWFscyhzdGFydEJsb2NrWzFdLCBlbmRCbG9ja1sxXSk7XG4gICAgdmFyIGlzU2luZ2xlVGV4dCA9IFBhdGguZXF1YWxzKHN0YXJ0LnBhdGgsIGVuZC5wYXRoKTtcbiAgICB2YXIgc3RhcnROb25FZGl0YWJsZSA9IHZvaWRzID8gbnVsbCA6IChfRWRpdG9yJHZvaWQgPSBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgIGF0OiBzdGFydCxcbiAgICAgIG1vZGU6ICdoaWdoZXN0J1xuICAgIH0pKSAhPT0gbnVsbCAmJiBfRWRpdG9yJHZvaWQgIT09IHZvaWQgMCA/IF9FZGl0b3Ikdm9pZCA6IEVkaXRvci5lbGVtZW50UmVhZE9ubHkoZWRpdG9yLCB7XG4gICAgICBhdDogc3RhcnQsXG4gICAgICBtb2RlOiAnaGlnaGVzdCdcbiAgICB9KTtcbiAgICB2YXIgZW5kTm9uRWRpdGFibGUgPSB2b2lkcyA/IG51bGwgOiAoX0VkaXRvciR2b2lkMiA9IEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgYXQ6IGVuZCxcbiAgICAgIG1vZGU6ICdoaWdoZXN0J1xuICAgIH0pKSAhPT0gbnVsbCAmJiBfRWRpdG9yJHZvaWQyICE9PSB2b2lkIDAgPyBfRWRpdG9yJHZvaWQyIDogRWRpdG9yLmVsZW1lbnRSZWFkT25seShlZGl0b3IsIHtcbiAgICAgIGF0OiBlbmQsXG4gICAgICBtb2RlOiAnaGlnaGVzdCdcbiAgICB9KTtcbiAgICAvLyBJZiB0aGUgc3RhcnQgb3IgZW5kIHBvaW50cyBhcmUgaW5zaWRlIGFuIGlubGluZSB2b2lkLCBudWRnZSB0aGVtIG91dC5cbiAgICBpZiAoc3RhcnROb25FZGl0YWJsZSkge1xuICAgICAgdmFyIGJlZm9yZSA9IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBzdGFydCk7XG4gICAgICBpZiAoYmVmb3JlICYmIHN0YXJ0QmxvY2sgJiYgUGF0aC5pc0FuY2VzdG9yKHN0YXJ0QmxvY2tbMV0sIGJlZm9yZS5wYXRoKSkge1xuICAgICAgICBzdGFydCA9IGJlZm9yZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuZE5vbkVkaXRhYmxlKSB7XG4gICAgICB2YXIgYWZ0ZXIgPSBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBlbmQpO1xuICAgICAgaWYgKGFmdGVyICYmIGVuZEJsb2NrICYmIFBhdGguaXNBbmNlc3RvcihlbmRCbG9ja1sxXSwgYWZ0ZXIucGF0aCkpIHtcbiAgICAgICAgZW5kID0gYWZ0ZXI7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEdldCB0aGUgaGlnaGVzdCBub2RlcyB0aGF0IGFyZSBjb21wbGV0ZWx5IGluc2lkZSB0aGUgcmFuZ2UsIGFzIHdlbGwgYXNcbiAgICAvLyB0aGUgc3RhcnQgYW5kIGVuZCBub2Rlcy5cbiAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgIHZhciBsYXN0UGF0aDtcbiAgICBmb3IgKHZhciBlbnRyeSBvZiBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdCxcbiAgICAgIHZvaWRzXG4gICAgfSkpIHtcbiAgICAgIHZhciBbbm9kZSwgcGF0aF0gPSBlbnRyeTtcbiAgICAgIGlmIChsYXN0UGF0aCAmJiBQYXRoLmNvbXBhcmUocGF0aCwgbGFzdFBhdGgpID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCF2b2lkcyAmJiBFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiAoRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpIHx8IEVkaXRvci5pc0VsZW1lbnRSZWFkT25seShlZGl0b3IsIG5vZGUpKSB8fCAhUGF0aC5pc0NvbW1vbihwYXRoLCBzdGFydC5wYXRoKSAmJiAhUGF0aC5pc0NvbW1vbihwYXRoLCBlbmQucGF0aCkpIHtcbiAgICAgICAgbWF0Y2hlcy5wdXNoKGVudHJ5KTtcbiAgICAgICAgbGFzdFBhdGggPSBwYXRoO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgcGF0aFJlZnMgPSBBcnJheS5mcm9tKG1hdGNoZXMsIF9yZWYgPT4ge1xuICAgICAgdmFyIFssIHBdID0gX3JlZjtcbiAgICAgIHJldHVybiBFZGl0b3IucGF0aFJlZihlZGl0b3IsIHApO1xuICAgIH0pO1xuICAgIHZhciBzdGFydFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIHN0YXJ0KTtcbiAgICB2YXIgZW5kUmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICB2YXIgcmVtb3ZlZFRleHQgPSAnJztcbiAgICBpZiAoIWlzU2luZ2xlVGV4dCAmJiAhc3RhcnROb25FZGl0YWJsZSkge1xuICAgICAgdmFyIF9wb2ludCA9IHN0YXJ0UmVmLmN1cnJlbnQ7XG4gICAgICB2YXIgW19ub2RlXSA9IEVkaXRvci5sZWFmKGVkaXRvciwgX3BvaW50KTtcbiAgICAgIHZhciB7XG4gICAgICAgIHBhdGg6IF9wYXRoXG4gICAgICB9ID0gX3BvaW50O1xuICAgICAgdmFyIHtcbiAgICAgICAgb2Zmc2V0XG4gICAgICB9ID0gc3RhcnQ7XG4gICAgICB2YXIgdGV4dCA9IF9ub2RlLnRleHQuc2xpY2Uob2Zmc2V0KTtcbiAgICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICB0eXBlOiAncmVtb3ZlX3RleHQnLFxuICAgICAgICAgIHBhdGg6IF9wYXRoLFxuICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICB0ZXh0XG4gICAgICAgIH0pO1xuICAgICAgICByZW1vdmVkVGV4dCA9IHRleHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHBhdGhSZWZzLnJldmVyc2UoKS5tYXAociA9PiByLnVucmVmKCkpLmZpbHRlcihyID0+IHIgIT09IG51bGwpLmZvckVhY2gocCA9PiBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgYXQ6IHAsXG4gICAgICB2b2lkc1xuICAgIH0pKTtcbiAgICBpZiAoIWVuZE5vbkVkaXRhYmxlKSB7XG4gICAgICB2YXIgX3BvaW50MiA9IGVuZFJlZi5jdXJyZW50O1xuICAgICAgdmFyIFtfbm9kZTJdID0gRWRpdG9yLmxlYWYoZWRpdG9yLCBfcG9pbnQyKTtcbiAgICAgIHZhciB7XG4gICAgICAgIHBhdGg6IF9wYXRoMlxuICAgICAgfSA9IF9wb2ludDI7XG4gICAgICB2YXIgX29mZnNldCA9IGlzU2luZ2xlVGV4dCA/IHN0YXJ0Lm9mZnNldCA6IDA7XG4gICAgICB2YXIgX3RleHQgPSBfbm9kZTIudGV4dC5zbGljZShfb2Zmc2V0LCBlbmQub2Zmc2V0KTtcbiAgICAgIGlmIChfdGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgdHlwZTogJ3JlbW92ZV90ZXh0JyxcbiAgICAgICAgICBwYXRoOiBfcGF0aDIsXG4gICAgICAgICAgb2Zmc2V0OiBfb2Zmc2V0LFxuICAgICAgICAgIHRleHQ6IF90ZXh0XG4gICAgICAgIH0pO1xuICAgICAgICByZW1vdmVkVGV4dCA9IF90ZXh0O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzU2luZ2xlVGV4dCAmJiBpc0Fjcm9zc0Jsb2NrcyAmJiBlbmRSZWYuY3VycmVudCAmJiBzdGFydFJlZi5jdXJyZW50KSB7XG4gICAgICBUcmFuc2Zvcm1zLm1lcmdlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBlbmRSZWYuY3VycmVudCxcbiAgICAgICAgaGFuZ2luZzogdHJ1ZSxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBGb3IgY2VydGFpbiBzY3JpcHRzLCBkZWxldGluZyBOIGNoYXJhY3RlcihzKSBiYWNrd2FyZCBzaG91bGQgZGVsZXRlXG4gICAgLy8gTiBjb2RlIHBvaW50KHMpIGluc3RlYWQgb2YgYW4gZW50aXJlIGdyYXBoZW1lIGNsdXN0ZXIuXG4gICAgLy8gVGhlcmVmb3JlLCB0aGUgcmVtYWluaW5nIGNvZGUgcG9pbnRzIHNob3VsZCBiZSBpbnNlcnRlZCBiYWNrLlxuICAgIC8vIEJlbmdhbGk6IFxcdTA5ODAtXFx1MDlGRlxuICAgIC8vIFRoYWk6IFxcdTBFMDAtXFx1MEU3RlxuICAgIC8vIEJ1cm1lc2UgKE15YW5tYXIpOiBcXHUxMDAwLVxcdTEwOUZcbiAgICAvLyBIaW5kaSAoRGV2YW5hZ2FyaSk6IFxcdTA5MDAtXFx1MDk3RlxuICAgIC8vIEtobWVyOiBcXHUxNzgwLVxcdTE3RkZcbiAgICAvLyBNYWxheWFsYW06IFxcdTBEMDAtXFx1MEQ3RlxuICAgIC8vIE9yaXlhOiBcXHUwQjAwLVxcdTBCN0ZcbiAgICAvLyBQdW5qYWJpIChHdXJtdWtoaSk6IFxcdTBBMDAtXFx1MEE3RlxuICAgIC8vIFRhbWlsOiBcXHUwQjgwLVxcdTBCRkZcbiAgICAvLyBUZWx1Z3U6IFxcdTBDMDAtXFx1MEM3RlxuICAgIGlmIChpc0NvbGxhcHNlZCAmJiByZXZlcnNlICYmIHVuaXQgPT09ICdjaGFyYWN0ZXInICYmIHJlbW92ZWRUZXh0Lmxlbmd0aCA+IDEgJiYgcmVtb3ZlZFRleHQubWF0Y2goL1tcXHUwOTgwLVxcdTA5RkZcXHUwRTAwLVxcdTBFN0ZcXHUxMDAwLVxcdTEwOUZcXHUwOTAwLVxcdTA5N0ZcXHUxNzgwLVxcdTE3RkZcXHUwRDAwLVxcdTBEN0ZcXHUwQjAwLVxcdTBCN0ZcXHUwQTAwLVxcdTBBN0ZcXHUwQjgwLVxcdTBCRkZcXHUwQzAwLVxcdTBDN0ZdKy8pKSB7XG4gICAgICBUcmFuc2Zvcm1zLmluc2VydFRleHQoZWRpdG9yLCByZW1vdmVkVGV4dC5zbGljZSgwLCByZW1vdmVkVGV4dC5sZW5ndGggLSBkaXN0YW5jZSkpO1xuICAgIH1cbiAgICB2YXIgc3RhcnRVbnJlZiA9IHN0YXJ0UmVmLnVucmVmKCk7XG4gICAgdmFyIGVuZFVucmVmID0gZW5kUmVmLnVucmVmKCk7XG4gICAgdmFyIHBvaW50ID0gcmV2ZXJzZSA/IHN0YXJ0VW5yZWYgfHwgZW5kVW5yZWYgOiBlbmRVbnJlZiB8fCBzdGFydFVucmVmO1xuICAgIGlmIChvcHRpb25zLmF0ID09IG51bGwgJiYgcG9pbnQpIHtcbiAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgcG9pbnQpO1xuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgaW5zZXJ0RnJhZ21lbnQgPSBmdW5jdGlvbiBpbnNlcnRGcmFnbWVudChlZGl0b3IsIGZyYWdtZW50KSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICB2YXIge1xuICAgICAgaGFuZ2luZyA9IGZhbHNlLFxuICAgICAgdm9pZHMgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBhdCA9IGdldERlZmF1bHRJbnNlcnRMb2NhdGlvbihlZGl0b3IpLFxuICAgICAgYmF0Y2hEaXJ0eSA9IHRydWVcbiAgICB9ID0gb3B0aW9ucztcbiAgICBpZiAoIWZyYWdtZW50Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgIGlmICghaGFuZ2luZykge1xuICAgICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7XG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4gICAgICAgIGF0ID0gYXQuYW5jaG9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIFssIGVuZF0gPSBSYW5nZS5lZGdlcyhhdCk7XG4gICAgICAgIGlmICghdm9pZHMgJiYgRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGVuZFxuICAgICAgICB9KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcG9pbnRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBlbmQpO1xuICAgICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgICAgICBhdFxuICAgICAgICB9KTtcbiAgICAgICAgYXQgPSBwb2ludFJlZi51bnJlZigpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICBhdCA9IEVkaXRvci5zdGFydChlZGl0b3IsIGF0KTtcbiAgICB9XG4gICAgaWYgKCF2b2lkcyAmJiBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgIGF0XG4gICAgfSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgdGhlIGluc2VydCBwb2ludCBpcyBhdCB0aGUgZWRnZSBvZiBhbiBpbmxpbmUgbm9kZSwgbW92ZSBpdCBvdXRzaWRlXG4gICAgLy8gaW5zdGVhZCBzaW5jZSBpdCB3aWxsIG5lZWQgdG8gYmUgc3BsaXQgb3RoZXJ3aXNlLlxuICAgIHZhciBpbmxpbmVFbGVtZW50TWF0Y2ggPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICBhdCxcbiAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pLFxuICAgICAgbW9kZTogJ2hpZ2hlc3QnLFxuICAgICAgdm9pZHNcbiAgICB9KTtcbiAgICBpZiAoaW5saW5lRWxlbWVudE1hdGNoKSB7XG4gICAgICB2YXIgWywgX2lubGluZVBhdGhdID0gaW5saW5lRWxlbWVudE1hdGNoO1xuICAgICAgaWYgKEVkaXRvci5pc0VuZChlZGl0b3IsIGF0LCBfaW5saW5lUGF0aCkpIHtcbiAgICAgICAgdmFyIGFmdGVyID0gRWRpdG9yLmFmdGVyKGVkaXRvciwgX2lubGluZVBhdGgpO1xuICAgICAgICBhdCA9IGFmdGVyO1xuICAgICAgfSBlbHNlIGlmIChFZGl0b3IuaXNTdGFydChlZGl0b3IsIGF0LCBfaW5saW5lUGF0aCkpIHtcbiAgICAgICAgdmFyIGJlZm9yZSA9IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBfaW5saW5lUGF0aCk7XG4gICAgICAgIGF0ID0gYmVmb3JlO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgYmxvY2tNYXRjaCA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbiksXG4gICAgICBhdCxcbiAgICAgIHZvaWRzXG4gICAgfSk7XG4gICAgdmFyIFssIGJsb2NrUGF0aF0gPSBibG9ja01hdGNoO1xuICAgIHZhciBpc0Jsb2NrU3RhcnQgPSBFZGl0b3IuaXNTdGFydChlZGl0b3IsIGF0LCBibG9ja1BhdGgpO1xuICAgIHZhciBpc0Jsb2NrRW5kID0gRWRpdG9yLmlzRW5kKGVkaXRvciwgYXQsIGJsb2NrUGF0aCk7XG4gICAgdmFyIGlzQmxvY2tFbXB0eSA9IGlzQmxvY2tTdGFydCAmJiBpc0Jsb2NrRW5kO1xuICAgIHZhciBbLCBmaXJzdExlYWZQYXRoXSA9IE5vZGUuZmlyc3Qoe1xuICAgICAgY2hpbGRyZW46IGZyYWdtZW50XG4gICAgfSwgW10pO1xuICAgIHZhciBbLCBsYXN0TGVhZlBhdGhdID0gTm9kZS5sYXN0KHtcbiAgICAgIGNoaWxkcmVuOiBmcmFnbWVudFxuICAgIH0sIFtdKTtcbiAgICAvLyBGb3IgZWFjaCBub2RlIGluIHRoZSBmcmFnbWVudCwgZGV0ZXJtaW5lIHdoYXQgbGV2ZWwgb2Ygd3JhcHBpbmcgc2hvdWxkXG4gICAgLy8gYmUga2VwdC4gQXQgbWluaW11bSwgYWxsIHRleHQgbm9kZXMgd2lsbCBiZSBpbnNlcnRlZCwgYnV0IGlmXG4gICAgLy8gYHNob3VsZEluc2VydGAgcmV0dXJucyB0cnVlIGZvciBzb21lIGFuY2VzdG9yIG9mIGEgcGFydGljdWxhciB0ZXh0IG5vZGUsXG4gICAgLy8gdGhlbiB0aGUgZW50aXJlIGFuY2VzdG9yIHdpbGwgYmUgaW5zZXJ0ZWQgcmF0aGVyIHRoYW4gaW5zZXJ0aW5nIHRoZSB0ZXh0XG4gICAgLy8gbm9kZXMgaW5kaXZpZHVhbGx5LlxuICAgIHZhciBzaG91bGRJbnNlcnQgPSBfcmVmID0+IHtcbiAgICAgIHZhciBbbiwgcF0gPSBfcmVmO1xuICAgICAgdmFyIGlzUm9vdCA9IHAubGVuZ3RoID09PSAwO1xuICAgICAgaWYgKGlzUm9vdCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBJZiB0aGUgZGVzdGluYXRpb24gYmxvY2sgaXMgZW1wdHksIGluc2VydCBhbGwgdG9wLWxldmVsIGJsb2NrcyBvZiB0aGVcbiAgICAgIC8vIGZyYWdtZW50LlxuICAgICAgaWYgKGlzQmxvY2tFbXB0eSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8vIFVubGVzcyB3ZSdyZSBhdCB0aGUgc3RhcnQgb2YgdGhlIGRlc3RpbmF0aW9uIGJsb2NrLCB1bndyYXAgYW55XG4gICAgICAvLyBub24tdm9pZCBibG9ja3MgdGhhdCBjb250YWluIHRoZSBmaXJzdCBsZWFmIG5vZGUgaW4gdGhlIGZyYWdtZW50LlxuICAgICAgaWYgKCFpc0Jsb2NrU3RhcnQgJiYgUGF0aC5pc0FuY2VzdG9yKHAsIGZpcnN0TGVhZlBhdGgpICYmIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmICFlZGl0b3IuaXNWb2lkKG4pICYmICFlZGl0b3IuaXNJbmxpbmUobikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gVW5sZXNzIHdlJ3JlIGF0IHRoZSBlbmQgb2YgdGhlIGRlc3RpbmF0aW9uIGJsb2NrLCB1bndyYXAgYW55IG5vbi12b2lkXG4gICAgICAvLyBibG9ja3MgdGhhdCBjb250YWluIHRoZSBsYXN0IGxlYWYgbm9kZSBpbiB0aGUgZnJhZ21lbnQuXG4gICAgICBpZiAoIWlzQmxvY2tFbmQgJiYgUGF0aC5pc0FuY2VzdG9yKHAsIGxhc3RMZWFmUGF0aCkgJiYgRWxlbWVudC5pc0VsZW1lbnQobikgJiYgIWVkaXRvci5pc1ZvaWQobikgJiYgIWVkaXRvci5pc0lubGluZShuKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBbHdheXMgaW5zZXJ0IHZvaWQgbm9kZXMsIGlubGluZSBlbGVtZW50cyBhbmQgdGV4dCBub2Rlcy5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLy8gV2hldGhlciB0aGUgY3VycmVudCBub2RlIGlzIGluIHRoZSBmaXJzdCBibG9jayBvZiB0aGUgZnJhZ21lbnQuXG4gICAgdmFyIHN0YXJ0aW5nID0gdHJ1ZTtcbiAgICAvLyBJbmxpbmUgbm9kZXMgaW4gdGhlIGZpcnN0IGJsb2NrIG9mIHRoZSBmcmFnbWVudCwgdG8gYmUgbWVyZ2VkIHdpdGggdGhlXG4gICAgLy8gZGVzdGluYXRpb24gYmxvY2suXG4gICAgdmFyIHN0YXJ0cyA9IFtdO1xuICAgIC8vIEJsb2NrcyBpbiB0aGUgbWlkZGxlIG9mIHRoZSBmcmFnbWVudC5cbiAgICB2YXIgbWlkZGxlcyA9IFtdO1xuICAgIC8vIElubGluZSBub2RlcyBpbiB0aGUgbGFzdCBibG9jayBvZiB0aGUgZnJhZ21lbnQsIHRvIGJlIG1lcmdlZCB3aXRoIHRoZVxuICAgIC8vIGRlc3RpbmF0aW9uIGJsb2NrLiBJZiB0aGUgZnJhZ21lbnQgY29udGFpbnMgb25seSBvbmUgYmxvY2ssIHRoaXMgd2lsbCBiZVxuICAgIC8vIGVtcHR5LlxuICAgIHZhciBlbmRzID0gW107XG4gICAgZm9yICh2YXIgZW50cnkgb2YgTm9kZS5ub2Rlcyh7XG4gICAgICBjaGlsZHJlbjogZnJhZ21lbnRcbiAgICB9LCB7XG4gICAgICBwYXNzOiBzaG91bGRJbnNlcnRcbiAgICB9KSkge1xuICAgICAgdmFyIFtub2RlLCBwYXRoXSA9IGVudHJ5O1xuICAgICAgLy8gSWYgd2UgZW5jb3VudGVyIGEgYmxvY2sgdGhhdCBkb2VzIG5vdCBjb250YWluIHRoZSBmaXJzdCBsZWFmLCB3ZSdyZSBub1xuICAgICAgLy8gbG9uZ2VyIGluIHRoZSBmaXJzdCBibG9jayBvZiB0aGUgZnJhZ21lbnQuXG4gICAgICBpZiAoc3RhcnRpbmcgJiYgRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgIWVkaXRvci5pc0lubGluZShub2RlKSAmJiAhUGF0aC5pc0FuY2VzdG9yKHBhdGgsIGZpcnN0TGVhZlBhdGgpKSB7XG4gICAgICAgIHN0YXJ0aW5nID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkSW5zZXJ0KGVudHJ5KSkge1xuICAgICAgICBpZiAoRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgIWVkaXRvci5pc0lubGluZShub2RlKSkge1xuICAgICAgICAgIHN0YXJ0aW5nID0gZmFsc2U7XG4gICAgICAgICAgbWlkZGxlcy5wdXNoKG5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0aW5nKSB7XG4gICAgICAgICAgc3RhcnRzLnB1c2gobm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5kcy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBbaW5saW5lTWF0Y2hdID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgYXQsXG4gICAgICBtYXRjaDogbiA9PiBUZXh0LmlzVGV4dChuKSB8fCBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKSxcbiAgICAgIG1vZGU6ICdoaWdoZXN0JyxcbiAgICAgIHZvaWRzXG4gICAgfSk7XG4gICAgdmFyIFssIGlubGluZVBhdGhdID0gaW5saW5lTWF0Y2g7XG4gICAgdmFyIGlzSW5saW5lU3RhcnQgPSBFZGl0b3IuaXNTdGFydChlZGl0b3IsIGF0LCBpbmxpbmVQYXRoKTtcbiAgICB2YXIgaXNJbmxpbmVFbmQgPSBFZGl0b3IuaXNFbmQoZWRpdG9yLCBhdCwgaW5saW5lUGF0aCk7XG4gICAgdmFyIG1pZGRsZVJlZiA9IEVkaXRvci5wYXRoUmVmKGVkaXRvciwgaXNCbG9ja0VuZCAmJiAhZW5kcy5sZW5ndGggPyBQYXRoLm5leHQoYmxvY2tQYXRoKSA6IGJsb2NrUGF0aCk7XG4gICAgdmFyIGVuZFJlZiA9IEVkaXRvci5wYXRoUmVmKGVkaXRvciwgaXNJbmxpbmVFbmQgPyBQYXRoLm5leHQoaW5saW5lUGF0aCkgOiBpbmxpbmVQYXRoKTtcbiAgICAvLyBJZiB0aGUgZnJhZ21lbnQgY29udGFpbnMgaW5saW5lcyBpbiBtdWx0aXBsZSBkaXN0aW5jdCBibG9ja3MsIHNwbGl0IHRoZVxuICAgIC8vIGRlc3RpbmF0aW9uIGJsb2NrLlxuICAgIHZhciBzcGxpdEJsb2NrID0gZW5kcy5sZW5ndGggPiAwO1xuICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0LFxuICAgICAgbWF0Y2g6IG4gPT4gc3BsaXRCbG9jayA/IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbikgOiBUZXh0LmlzVGV4dChuKSB8fCBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKSxcbiAgICAgIG1vZGU6IHNwbGl0QmxvY2sgPyAnbG93ZXN0JyA6ICdoaWdoZXN0JyxcbiAgICAgIGFsd2F5czogc3BsaXRCbG9jayAmJiAoIWlzQmxvY2tTdGFydCB8fCBzdGFydHMubGVuZ3RoID4gMCkgJiYgKCFpc0Jsb2NrRW5kIHx8IGVuZHMubGVuZ3RoID4gMCksXG4gICAgICB2b2lkc1xuICAgIH0pO1xuICAgIHZhciBzdGFydFJlZiA9IEVkaXRvci5wYXRoUmVmKGVkaXRvciwgIWlzSW5saW5lU3RhcnQgfHwgaXNJbmxpbmVTdGFydCAmJiBpc0lubGluZUVuZCA/IFBhdGgubmV4dChpbmxpbmVQYXRoKSA6IGlubGluZVBhdGgpO1xuICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBzdGFydHMsIHtcbiAgICAgIGF0OiBzdGFydFJlZi5jdXJyZW50LFxuICAgICAgbWF0Y2g6IG4gPT4gVGV4dC5pc1RleHQobikgfHwgRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbiksXG4gICAgICBtb2RlOiAnaGlnaGVzdCcsXG4gICAgICB2b2lkcyxcbiAgICAgIGJhdGNoRGlydHlcbiAgICB9KTtcbiAgICBpZiAoaXNCbG9ja0VtcHR5ICYmICFzdGFydHMubGVuZ3RoICYmIG1pZGRsZXMubGVuZ3RoICYmICFlbmRzLmxlbmd0aCkge1xuICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBibG9ja1BhdGgsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICB9XG4gICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIG1pZGRsZXMsIHtcbiAgICAgIGF0OiBtaWRkbGVSZWYuY3VycmVudCxcbiAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbiksXG4gICAgICBtb2RlOiAnbG93ZXN0JyxcbiAgICAgIHZvaWRzLFxuICAgICAgYmF0Y2hEaXJ0eVxuICAgIH0pO1xuICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBlbmRzLCB7XG4gICAgICBhdDogZW5kUmVmLmN1cnJlbnQsXG4gICAgICBtYXRjaDogbiA9PiBUZXh0LmlzVGV4dChuKSB8fCBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKSxcbiAgICAgIG1vZGU6ICdoaWdoZXN0JyxcbiAgICAgIHZvaWRzLFxuICAgICAgYmF0Y2hEaXJ0eVxuICAgIH0pO1xuICAgIGlmICghb3B0aW9ucy5hdCkge1xuICAgICAgdmFyIF9wYXRoO1xuICAgICAgaWYgKGVuZHMubGVuZ3RoID4gMCAmJiBlbmRSZWYuY3VycmVudCkge1xuICAgICAgICBfcGF0aCA9IFBhdGgucHJldmlvdXMoZW5kUmVmLmN1cnJlbnQpO1xuICAgICAgfSBlbHNlIGlmIChtaWRkbGVzLmxlbmd0aCA+IDAgJiYgbWlkZGxlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgX3BhdGggPSBQYXRoLnByZXZpb3VzKG1pZGRsZVJlZi5jdXJyZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnRSZWYuY3VycmVudCkge1xuICAgICAgICBfcGF0aCA9IFBhdGgucHJldmlvdXMoc3RhcnRSZWYuY3VycmVudCk7XG4gICAgICB9XG4gICAgICBpZiAoX3BhdGgpIHtcbiAgICAgICAgdmFyIF9lbmQgPSBFZGl0b3IuZW5kKGVkaXRvciwgX3BhdGgpO1xuICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIF9lbmQpO1xuICAgICAgfVxuICAgIH1cbiAgICBzdGFydFJlZi51bnJlZigpO1xuICAgIG1pZGRsZVJlZi51bnJlZigpO1xuICAgIGVuZFJlZi51bnJlZigpO1xuICB9KTtcbn07XG5cbnZhciBjb2xsYXBzZSA9IGZ1bmN0aW9uIGNvbGxhcHNlKGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciB7XG4gICAgZWRnZSA9ICdhbmNob3InXG4gIH0gPSBvcHRpb25zO1xuICB2YXIge1xuICAgIHNlbGVjdGlvblxuICB9ID0gZWRpdG9yO1xuICBpZiAoIXNlbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChlZGdlID09PSAnYW5jaG9yJykge1xuICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgc2VsZWN0aW9uLmFuY2hvcik7XG4gIH0gZWxzZSBpZiAoZWRnZSA9PT0gJ2ZvY3VzJykge1xuICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgc2VsZWN0aW9uLmZvY3VzKTtcbiAgfSBlbHNlIGlmIChlZGdlID09PSAnc3RhcnQnKSB7XG4gICAgdmFyIFtzdGFydF0gPSBSYW5nZS5lZGdlcyhzZWxlY3Rpb24pO1xuICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgc3RhcnQpO1xuICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdlbmQnKSB7XG4gICAgdmFyIFssIGVuZF0gPSBSYW5nZS5lZGdlcyhzZWxlY3Rpb24pO1xuICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgZW5kKTtcbiAgfVxufTtcblxudmFyIGRlc2VsZWN0ID0gZWRpdG9yID0+IHtcbiAgdmFyIHtcbiAgICBzZWxlY3Rpb25cbiAgfSA9IGVkaXRvcjtcbiAgaWYgKHNlbGVjdGlvbikge1xuICAgIGVkaXRvci5hcHBseSh7XG4gICAgICB0eXBlOiAnc2V0X3NlbGVjdGlvbicsXG4gICAgICBwcm9wZXJ0aWVzOiBzZWxlY3Rpb24sXG4gICAgICBuZXdQcm9wZXJ0aWVzOiBudWxsXG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBtb3ZlID0gZnVuY3Rpb24gbW92ZShlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIge1xuICAgIHNlbGVjdGlvblxuICB9ID0gZWRpdG9yO1xuICB2YXIge1xuICAgIGRpc3RhbmNlID0gMSxcbiAgICB1bml0ID0gJ2NoYXJhY3RlcicsXG4gICAgcmV2ZXJzZSA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICB2YXIge1xuICAgIGVkZ2UgPSBudWxsXG4gIH0gPSBvcHRpb25zO1xuICBpZiAoIXNlbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWRnZSA9PT0gJ3N0YXJ0Jykge1xuICAgIGVkZ2UgPSBSYW5nZS5pc0JhY2t3YXJkKHNlbGVjdGlvbikgPyAnZm9jdXMnIDogJ2FuY2hvcic7XG4gIH1cbiAgaWYgKGVkZ2UgPT09ICdlbmQnKSB7XG4gICAgZWRnZSA9IFJhbmdlLmlzQmFja3dhcmQoc2VsZWN0aW9uKSA/ICdhbmNob3InIDogJ2ZvY3VzJztcbiAgfVxuICB2YXIge1xuICAgIGFuY2hvcixcbiAgICBmb2N1c1xuICB9ID0gc2VsZWN0aW9uO1xuICB2YXIgb3B0cyA9IHtcbiAgICBkaXN0YW5jZSxcbiAgICB1bml0XG4gIH07XG4gIHZhciBwcm9wcyA9IHt9O1xuICBpZiAoZWRnZSA9PSBudWxsIHx8IGVkZ2UgPT09ICdhbmNob3InKSB7XG4gICAgdmFyIHBvaW50ID0gcmV2ZXJzZSA/IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBhbmNob3IsIG9wdHMpIDogRWRpdG9yLmFmdGVyKGVkaXRvciwgYW5jaG9yLCBvcHRzKTtcbiAgICBpZiAocG9pbnQpIHtcbiAgICAgIHByb3BzLmFuY2hvciA9IHBvaW50O1xuICAgIH1cbiAgfVxuICBpZiAoZWRnZSA9PSBudWxsIHx8IGVkZ2UgPT09ICdmb2N1cycpIHtcbiAgICB2YXIgX3BvaW50ID0gcmV2ZXJzZSA/IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBmb2N1cywgb3B0cykgOiBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBmb2N1cywgb3B0cyk7XG4gICAgaWYgKF9wb2ludCkge1xuICAgICAgcHJvcHMuZm9jdXMgPSBfcG9pbnQ7XG4gICAgfVxuICB9XG4gIFRyYW5zZm9ybXMuc2V0U2VsZWN0aW9uKGVkaXRvciwgcHJvcHMpO1xufTtcblxudmFyIHNlbGVjdCA9IChlZGl0b3IsIHRhcmdldCkgPT4ge1xuICB2YXIge1xuICAgIHNlbGVjdGlvblxuICB9ID0gZWRpdG9yO1xuICB0YXJnZXQgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCB0YXJnZXQpO1xuICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgVHJhbnNmb3Jtcy5zZXRTZWxlY3Rpb24oZWRpdG9yLCB0YXJnZXQpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIVJhbmdlLmlzUmFuZ2UodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIldoZW4gc2V0dGluZyB0aGUgc2VsZWN0aW9uIGFuZCB0aGUgY3VycmVudCBzZWxlY3Rpb24gaXMgYG51bGxgIHlvdSBtdXN0IHByb3ZpZGUgYXQgbGVhc3QgYW4gYGFuY2hvcmAgYW5kIGBmb2N1c2AsIGJ1dCB5b3UgcGFzc2VkOiBcIi5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KHRhcmdldCkpKTtcbiAgfVxuICBlZGl0b3IuYXBwbHkoe1xuICAgIHR5cGU6ICdzZXRfc2VsZWN0aW9uJyxcbiAgICBwcm9wZXJ0aWVzOiBzZWxlY3Rpb24sXG4gICAgbmV3UHJvcGVydGllczogdGFyZ2V0XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gb3duS2V5cyQxKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMShlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJDEoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJDEoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbnZhciBzZXRQb2ludCA9IGZ1bmN0aW9uIHNldFBvaW50KGVkaXRvciwgcHJvcHMpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICB2YXIge1xuICAgIHNlbGVjdGlvblxuICB9ID0gZWRpdG9yO1xuICB2YXIge1xuICAgIGVkZ2UgPSAnYm90aCdcbiAgfSA9IG9wdGlvbnM7XG4gIGlmICghc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChlZGdlID09PSAnc3RhcnQnKSB7XG4gICAgZWRnZSA9IFJhbmdlLmlzQmFja3dhcmQoc2VsZWN0aW9uKSA/ICdmb2N1cycgOiAnYW5jaG9yJztcbiAgfVxuICBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICBlZGdlID0gUmFuZ2UuaXNCYWNrd2FyZChzZWxlY3Rpb24pID8gJ2FuY2hvcicgOiAnZm9jdXMnO1xuICB9XG4gIHZhciB7XG4gICAgYW5jaG9yLFxuICAgIGZvY3VzXG4gIH0gPSBzZWxlY3Rpb247XG4gIHZhciBwb2ludCA9IGVkZ2UgPT09ICdhbmNob3InID8gYW5jaG9yIDogZm9jdXM7XG4gIFRyYW5zZm9ybXMuc2V0U2VsZWN0aW9uKGVkaXRvciwge1xuICAgIFtlZGdlID09PSAnYW5jaG9yJyA/ICdhbmNob3InIDogJ2ZvY3VzJ106IF9vYmplY3RTcHJlYWQkMShfb2JqZWN0U3ByZWFkJDEoe30sIHBvaW50KSwgcHJvcHMpXG4gIH0pO1xufTtcblxudmFyIHNldFNlbGVjdGlvbiA9IChlZGl0b3IsIHByb3BzKSA9PiB7XG4gIHZhciB7XG4gICAgc2VsZWN0aW9uXG4gIH0gPSBlZGl0b3I7XG4gIHZhciBvbGRQcm9wcyA9IHt9O1xuICB2YXIgbmV3UHJvcHMgPSB7fTtcbiAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yICh2YXIgayBpbiBwcm9wcykge1xuICAgIGlmIChrID09PSAnYW5jaG9yJyAmJiBwcm9wcy5hbmNob3IgIT0gbnVsbCAmJiAhUG9pbnQuZXF1YWxzKHByb3BzLmFuY2hvciwgc2VsZWN0aW9uLmFuY2hvcikgfHwgayA9PT0gJ2ZvY3VzJyAmJiBwcm9wcy5mb2N1cyAhPSBudWxsICYmICFQb2ludC5lcXVhbHMocHJvcHMuZm9jdXMsIHNlbGVjdGlvbi5mb2N1cykgfHwgayAhPT0gJ2FuY2hvcicgJiYgayAhPT0gJ2ZvY3VzJyAmJiBwcm9wc1trXSAhPT0gc2VsZWN0aW9uW2tdKSB7XG4gICAgICBvbGRQcm9wc1trXSA9IHNlbGVjdGlvbltrXTtcbiAgICAgIG5ld1Byb3BzW2tdID0gcHJvcHNba107XG4gICAgfVxuICB9XG4gIGlmIChPYmplY3Qua2V5cyhvbGRQcm9wcykubGVuZ3RoID4gMCkge1xuICAgIGVkaXRvci5hcHBseSh7XG4gICAgICB0eXBlOiAnc2V0X3NlbGVjdGlvbicsXG4gICAgICBwcm9wZXJ0aWVzOiBvbGRQcm9wcyxcbiAgICAgIG5ld1Byb3BlcnRpZXM6IG5ld1Byb3BzXG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBpbnNlcnROb2RlcyA9IGZ1bmN0aW9uIGluc2VydE5vZGVzKGVkaXRvciwgbm9kZXMpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgIHZhciB7XG4gICAgICBoYW5naW5nID0gZmFsc2UsXG4gICAgICB2b2lkcyA9IGZhbHNlLFxuICAgICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgICAgYmF0Y2hEaXJ0eSA9IHRydWVcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgYXQsXG4gICAgICBtYXRjaCxcbiAgICAgIHNlbGVjdFxuICAgIH0gPSBvcHRpb25zO1xuICAgIGlmIChOb2RlLmlzTm9kZShub2RlcykpIHtcbiAgICAgIG5vZGVzID0gW25vZGVzXTtcbiAgICB9XG4gICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgW25vZGVdID0gbm9kZXM7XG4gICAgaWYgKCFhdCkge1xuICAgICAgYXQgPSBnZXREZWZhdWx0SW5zZXJ0TG9jYXRpb24oZWRpdG9yKTtcbiAgICAgIGlmIChzZWxlY3QgIT09IGZhbHNlKSB7XG4gICAgICAgIHNlbGVjdCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzZWxlY3QgPT0gbnVsbCkge1xuICAgICAgc2VsZWN0ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgaWYgKCFoYW5naW5nKSB7XG4gICAgICAgIGF0ID0gRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgYXQsIHtcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChhdCkpIHtcbiAgICAgICAgYXQgPSBhdC5hbmNob3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgWywgZW5kXSA9IFJhbmdlLmVkZ2VzKGF0KTtcbiAgICAgICAgdmFyIHBvaW50UmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgICAgYXRcbiAgICAgICAgfSk7XG4gICAgICAgIGF0ID0gcG9pbnRSZWYudW5yZWYoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKFBvaW50LmlzUG9pbnQoYXQpKSB7XG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgICBtYXRjaCA9IG4gPT4gVGV4dC5pc1RleHQobik7XG4gICAgICAgIH0gZWxzZSBpZiAoZWRpdG9yLmlzSW5saW5lKG5vZGUpKSB7XG4gICAgICAgICAgbWF0Y2ggPSBuID0+IFRleHQuaXNUZXh0KG4pIHx8IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdGNoID0gbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgW2VudHJ5XSA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGF0LnBhdGgsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBtb2RlLFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgdmFyIFssIG1hdGNoUGF0aF0gPSBlbnRyeTtcbiAgICAgICAgdmFyIHBhdGhSZWYgPSBFZGl0b3IucGF0aFJlZihlZGl0b3IsIG1hdGNoUGF0aCk7XG4gICAgICAgIHZhciBpc0F0RW5kID0gRWRpdG9yLmlzRW5kKGVkaXRvciwgYXQsIG1hdGNoUGF0aCk7XG4gICAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBtb2RlLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcGF0aCA9IHBhdGhSZWYudW5yZWYoKTtcbiAgICAgICAgYXQgPSBpc0F0RW5kID8gUGF0aC5uZXh0KHBhdGgpIDogcGF0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHBhcmVudFBhdGggPSBQYXRoLnBhcmVudChhdCk7XG4gICAgdmFyIGluZGV4ID0gYXRbYXQubGVuZ3RoIC0gMV07XG4gICAgaWYgKCF2b2lkcyAmJiBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgIGF0OiBwYXJlbnRQYXRoXG4gICAgfSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGJhdGNoRGlydHkpIHtcbiAgICAgIC8vIFBFUkY6IGJhdGNoIHVwZGF0ZSBkaXJ0eSBwYXRoc1xuICAgICAgLy8gYmF0Y2hlZCBvcHMgdXNlZCB0byB0cmFuc2Zvcm0gZXhpc3RpbmcgZGlydHkgcGF0aHNcbiAgICAgIHZhciBiYXRjaGVkT3BzID0gW107XG4gICAgICB2YXIgbmV3RGlydHlQYXRocyA9IFBhdGgubGV2ZWxzKHBhcmVudFBhdGgpO1xuICAgICAgYmF0Y2hEaXJ0eVBhdGhzKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgICAgICB2YXIgcGF0aCA9IHBhcmVudFBhdGguY29uY2F0KGluZGV4KTtcbiAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgIHZhciBvcCA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdpbnNlcnRfbm9kZScsXG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgbm9kZTogX25vZGVcbiAgICAgICAgICB9O1xuICAgICAgICAgIGVkaXRvci5hcHBseShvcCk7XG4gICAgICAgICAgYXQgPSBQYXRoLm5leHQoYXQpO1xuICAgICAgICAgIGJhdGNoZWRPcHMucHVzaChvcCk7XG4gICAgICAgICAgaWYgKFRleHQuaXNUZXh0KF9ub2RlKSkge1xuICAgICAgICAgICAgbmV3RGlydHlQYXRocy5wdXNoKHBhdGgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdEaXJ0eVBhdGhzLnB1c2goLi4uQXJyYXkuZnJvbShOb2RlLm5vZGVzKF9ub2RlKSwgX3JlZiA9PiB7XG4gICAgICAgICAgICAgIHZhciBbLCBwXSA9IF9yZWY7XG4gICAgICAgICAgICAgIHJldHVybiBwYXRoLmNvbmNhdChwKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIF9ub2RlIG9mIG5vZGVzKSB7XG4gICAgICAgICAgX2xvb3AoKTtcbiAgICAgICAgfVxuICAgICAgfSwgKCkgPT4ge1xuICAgICAgICB1cGRhdGVEaXJ0eVBhdGhzKGVkaXRvciwgbmV3RGlydHlQYXRocywgcCA9PiB7XG4gICAgICAgICAgdmFyIG5ld1BhdGggPSBwO1xuICAgICAgICAgIGZvciAodmFyIG9wIG9mIGJhdGNoZWRPcHMpIHtcbiAgICAgICAgICAgIGlmIChQYXRoLm9wZXJhdGlvbkNhblRyYW5zZm9ybVBhdGgob3ApKSB7XG4gICAgICAgICAgICAgIG5ld1BhdGggPSBQYXRoLnRyYW5zZm9ybShuZXdQYXRoLCBvcCk7XG4gICAgICAgICAgICAgIGlmICghbmV3UGF0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXdQYXRoO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBfbm9kZTIgb2Ygbm9kZXMpIHtcbiAgICAgICAgdmFyIF9wYXRoID0gcGFyZW50UGF0aC5jb25jYXQoaW5kZXgpO1xuICAgICAgICBpbmRleCsrO1xuICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgIHR5cGU6ICdpbnNlcnRfbm9kZScsXG4gICAgICAgICAgcGF0aDogX3BhdGgsXG4gICAgICAgICAgbm9kZTogX25vZGUyXG4gICAgICAgIH0pO1xuICAgICAgICBhdCA9IFBhdGgubmV4dChhdCk7XG4gICAgICB9XG4gICAgfVxuICAgIGF0ID0gUGF0aC5wcmV2aW91cyhhdCk7XG4gICAgaWYgKHNlbGVjdCkge1xuICAgICAgdmFyIHBvaW50ID0gRWRpdG9yLmVuZChlZGl0b3IsIGF0KTtcbiAgICAgIGlmIChwb2ludCkge1xuICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHBvaW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxudmFyIGxpZnROb2RlcyA9IGZ1bmN0aW9uIGxpZnROb2RlcyhlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgIHZhciB7XG4gICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICBtb2RlID0gJ2xvd2VzdCcsXG4gICAgICB2b2lkcyA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHtcbiAgICAgIG1hdGNoXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgIG1hdGNoID0gUGF0aC5pc1BhdGgoYXQpID8gbWF0Y2hQYXRoKGVkaXRvciwgYXQpIDogbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgIH1cbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBtYXRjaGVzID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgYXQsXG4gICAgICBtYXRjaCxcbiAgICAgIG1vZGUsXG4gICAgICB2b2lkc1xuICAgIH0pO1xuICAgIHZhciBwYXRoUmVmcyA9IEFycmF5LmZyb20obWF0Y2hlcywgX3JlZiA9PiB7XG4gICAgICB2YXIgWywgcF0gPSBfcmVmO1xuICAgICAgcmV0dXJuIEVkaXRvci5wYXRoUmVmKGVkaXRvciwgcCk7XG4gICAgfSk7XG4gICAgZm9yICh2YXIgcGF0aFJlZiBvZiBwYXRoUmVmcykge1xuICAgICAgdmFyIHBhdGggPSBwYXRoUmVmLnVucmVmKCk7XG4gICAgICBpZiAocGF0aC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBsaWZ0IG5vZGUgYXQgYSBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgaXQgaGFzIGEgZGVwdGggb2YgbGVzcyB0aGFuIGAyYC5cIikpO1xuICAgICAgfVxuICAgICAgdmFyIHBhcmVudE5vZGVFbnRyeSA9IEVkaXRvci5ub2RlKGVkaXRvciwgUGF0aC5wYXJlbnQocGF0aCkpO1xuICAgICAgdmFyIFtwYXJlbnQsIHBhcmVudFBhdGhdID0gcGFyZW50Tm9kZUVudHJ5O1xuICAgICAgdmFyIGluZGV4ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIHtcbiAgICAgICAgbGVuZ3RoXG4gICAgICB9ID0gcGFyZW50LmNoaWxkcmVuO1xuICAgICAgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgICAgICB2YXIgdG9QYXRoID0gUGF0aC5uZXh0KHBhcmVudFBhdGgpO1xuICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgICB0bzogdG9QYXRoLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBwYXJlbnRQYXRoLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgICB0bzogcGFyZW50UGF0aCxcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IGxlbmd0aCAtIDEpIHtcbiAgICAgICAgdmFyIF90b1BhdGggPSBQYXRoLm5leHQocGFyZW50UGF0aCk7XG4gICAgICAgIFRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBwYXRoLFxuICAgICAgICAgIHRvOiBfdG9QYXRoLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNwbGl0UGF0aCA9IFBhdGgubmV4dChwYXRoKTtcbiAgICAgICAgdmFyIF90b1BhdGgyID0gUGF0aC5uZXh0KHBhcmVudFBhdGgpO1xuICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHNwbGl0UGF0aCxcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgICAgdG86IF90b1BhdGgyLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgX2V4Y2x1ZGVkID0gW1widGV4dFwiXSxcbiAgX2V4Y2x1ZGVkMiA9IFtcImNoaWxkcmVuXCJdO1xudmFyIGhhc1NpbmdsZUNoaWxkTmVzdCA9IChlZGl0b3IsIG5vZGUpID0+IHtcbiAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBub2RlO1xuICAgIGlmIChFZGl0b3IuaXNWb2lkKGVkaXRvciwgbm9kZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZWxlbWVudC5jaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBoYXNTaW5nbGVDaGlsZE5lc3QoZWRpdG9yLCBlbGVtZW50LmNoaWxkcmVuWzBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChFZGl0b3IuaXNFZGl0b3Iobm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG52YXIgbWVyZ2VOb2RlcyA9IGZ1bmN0aW9uIG1lcmdlTm9kZXMoZWRpdG9yKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICB2YXIge1xuICAgICAgbWF0Y2gsXG4gICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb25cbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgaGFuZ2luZyA9IGZhbHNlLFxuICAgICAgdm9pZHMgPSBmYWxzZSxcbiAgICAgIG1vZGUgPSAnbG93ZXN0J1xuICAgIH0gPSBvcHRpb25zO1xuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgICAgdmFyIFtwYXJlbnRdID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIGF0KTtcbiAgICAgICAgbWF0Y2ggPSBuID0+IHBhcmVudC5jaGlsZHJlbi5pbmNsdWRlcyhuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hdGNoID0gbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWhhbmdpbmcgJiYgUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgIGF0ID0gRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgYXQsIHtcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChhdCkpIHtcbiAgICAgICAgYXQgPSBhdC5hbmNob3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgWywgZW5kXSA9IFJhbmdlLmVkZ2VzKGF0KTtcbiAgICAgICAgdmFyIHBvaW50UmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgICAgYXRcbiAgICAgICAgfSk7XG4gICAgICAgIGF0ID0gcG9pbnRSZWYudW5yZWYoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuYXQgPT0gbnVsbCkge1xuICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgYXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBbY3VycmVudF0gPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdCxcbiAgICAgIG1hdGNoLFxuICAgICAgdm9pZHMsXG4gICAgICBtb2RlXG4gICAgfSk7XG4gICAgdmFyIHByZXYgPSBFZGl0b3IucHJldmlvdXMoZWRpdG9yLCB7XG4gICAgICBhdCxcbiAgICAgIG1hdGNoLFxuICAgICAgdm9pZHMsXG4gICAgICBtb2RlXG4gICAgfSk7XG4gICAgaWYgKCFjdXJyZW50IHx8ICFwcmV2KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBbbm9kZSwgcGF0aF0gPSBjdXJyZW50O1xuICAgIHZhciBbcHJldk5vZGUsIHByZXZQYXRoXSA9IHByZXY7XG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwIHx8IHByZXZQYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbmV3UGF0aCA9IFBhdGgubmV4dChwcmV2UGF0aCk7XG4gICAgdmFyIGNvbW1vblBhdGggPSBQYXRoLmNvbW1vbihwYXRoLCBwcmV2UGF0aCk7XG4gICAgdmFyIGlzUHJldmlvdXNTaWJsaW5nID0gUGF0aC5pc1NpYmxpbmcocGF0aCwgcHJldlBhdGgpO1xuICAgIHZhciBsZXZlbHMgPSBBcnJheS5mcm9tKEVkaXRvci5sZXZlbHMoZWRpdG9yLCB7XG4gICAgICBhdDogcGF0aFxuICAgIH0pLCBfcmVmID0+IHtcbiAgICAgIHZhciBbbl0gPSBfcmVmO1xuICAgICAgcmV0dXJuIG47XG4gICAgfSkuc2xpY2UoY29tbW9uUGF0aC5sZW5ndGgpLnNsaWNlKDAsIC0xKTtcbiAgICAvLyBEZXRlcm1pbmUgaWYgdGhlIG1lcmdlIHdpbGwgbGVhdmUgYW4gYW5jZXN0b3Igb2YgdGhlIHBhdGggZW1wdHkgYXMgYVxuICAgIC8vIHJlc3VsdCwgaW4gd2hpY2ggY2FzZSB3ZSdsbCB3YW50IHRvIHJlbW92ZSBpdCBhZnRlciBtZXJnaW5nLlxuICAgIHZhciBlbXB0eUFuY2VzdG9yID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgYXQ6IHBhdGgsXG4gICAgICBtb2RlOiAnaGlnaGVzdCcsXG4gICAgICBtYXRjaDogbiA9PiBsZXZlbHMuaW5jbHVkZXMobikgJiYgaGFzU2luZ2xlQ2hpbGROZXN0KGVkaXRvciwgbilcbiAgICB9KTtcbiAgICB2YXIgZW1wdHlSZWYgPSBlbXB0eUFuY2VzdG9yICYmIEVkaXRvci5wYXRoUmVmKGVkaXRvciwgZW1wdHlBbmNlc3RvclsxXSk7XG4gICAgdmFyIHByb3BlcnRpZXM7XG4gICAgdmFyIHBvc2l0aW9uO1xuICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBub2RlcyBhcmUgZXF1aXZhbGVudCwgYW5kIGZpZ3VyZSBvdXQgd2hhdCB0aGUgcG9zaXRpb25cbiAgICAvLyBhbmQgZXh0cmEgcHJvcGVydGllcyBvZiB0aGUgbWVyZ2Ugd2lsbCBiZS5cbiAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkgJiYgVGV4dC5pc1RleHQocHJldk5vZGUpKSB7XG4gICAgICB2YXIgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhub2RlLCBfZXhjbHVkZWQpO1xuICAgICAgcG9zaXRpb24gPSBwcmV2Tm9kZS50ZXh0Lmxlbmd0aDtcbiAgICAgIHByb3BlcnRpZXMgPSByZXN0O1xuICAgIH0gZWxzZSBpZiAoRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgRWxlbWVudC5pc0VsZW1lbnQocHJldk5vZGUpKSB7XG4gICAgICB2YXIgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhub2RlLCBfZXhjbHVkZWQyKTtcbiAgICAgIHBvc2l0aW9uID0gcHJldk5vZGUuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgcHJvcGVydGllcyA9IHJlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBtZXJnZSB0aGUgbm9kZSBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIHdpdGggdGhlIHByZXZpb3VzIHNpYmxpbmcgYmVjYXVzZSBpdCBpcyBub3QgdGhlIHNhbWUga2luZDogXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkobm9kZSksIFwiIFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KHByZXZOb2RlKSkpO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgbm9kZSBpc24ndCBhbHJlYWR5IHRoZSBuZXh0IHNpYmxpbmcgb2YgdGhlIHByZXZpb3VzIG5vZGUsIG1vdmVcbiAgICAvLyBpdCBzbyB0aGF0IGl0IGlzIGJlZm9yZSBtZXJnaW5nLlxuICAgIGlmICghaXNQcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgIFRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgdG86IG5ld1BhdGgsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gSWYgdGhlcmUgd2FzIGdvaW5nIHRvIGJlIGFuIGVtcHR5IGFuY2VzdG9yIG9mIHRoZSBub2RlIHRoYXQgd2FzIG1lcmdlZCxcbiAgICAvLyB3ZSByZW1vdmUgaXQgZnJvbSB0aGUgdHJlZS5cbiAgICBpZiAoZW1wdHlSZWYpIHtcbiAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBlbXB0eVJlZi5jdXJyZW50LFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChFZGl0b3Iuc2hvdWxkTWVyZ2VOb2Rlc1JlbW92ZVByZXZOb2RlKGVkaXRvciwgcHJldiwgY3VycmVudCkpIHtcbiAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBwcmV2UGF0aCxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICB0eXBlOiAnbWVyZ2Vfbm9kZScsXG4gICAgICAgIHBhdGg6IG5ld1BhdGgsXG4gICAgICAgIHBvc2l0aW9uLFxuICAgICAgICBwcm9wZXJ0aWVzXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVtcHR5UmVmKSB7XG4gICAgICBlbXB0eVJlZi51bnJlZigpO1xuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgbW92ZU5vZGVzID0gKGVkaXRvciwgb3B0aW9ucykgPT4ge1xuICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgIHZhciB7XG4gICAgICB0byxcbiAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgIG1vZGUgPSAnbG93ZXN0JyxcbiAgICAgIHZvaWRzID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgbWF0Y2hcbiAgICB9ID0gb3B0aW9ucztcbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICBtYXRjaCA9IFBhdGguaXNQYXRoKGF0KSA/IG1hdGNoUGF0aChlZGl0b3IsIGF0KSA6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICB9XG4gICAgdmFyIHRvUmVmID0gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCB0byk7XG4gICAgdmFyIHRhcmdldHMgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdCxcbiAgICAgIG1hdGNoLFxuICAgICAgbW9kZSxcbiAgICAgIHZvaWRzXG4gICAgfSk7XG4gICAgdmFyIHBhdGhSZWZzID0gQXJyYXkuZnJvbSh0YXJnZXRzLCBfcmVmID0+IHtcbiAgICAgIHZhciBbLCBwXSA9IF9yZWY7XG4gICAgICByZXR1cm4gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBwKTtcbiAgICB9KTtcbiAgICBmb3IgKHZhciBwYXRoUmVmIG9mIHBhdGhSZWZzKSB7XG4gICAgICB2YXIgcGF0aCA9IHBhdGhSZWYudW5yZWYoKTtcbiAgICAgIHZhciBuZXdQYXRoID0gdG9SZWYuY3VycmVudDtcbiAgICAgIGlmIChwYXRoLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgIHR5cGU6ICdtb3ZlX25vZGUnLFxuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgbmV3UGF0aFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICh0b1JlZi5jdXJyZW50ICYmIFBhdGguaXNTaWJsaW5nKG5ld1BhdGgsIHBhdGgpICYmIFBhdGguaXNBZnRlcihuZXdQYXRoLCBwYXRoKSkge1xuICAgICAgICAvLyBXaGVuIHBlcmZvcm1pbmcgYSBzaWJsaW5nIG1vdmUgdG8gYSBsYXRlciBpbmRleCwgdGhlIHBhdGggYXQgdGhlIGRlc3RpbmF0aW9uIGlzIHNoaWZ0ZWRcbiAgICAgICAgLy8gdG8gYmVmb3JlIHRoZSBpbnNlcnRpb24gcG9pbnQgaW5zdGVhZCBvZiBhZnRlci4gVG8gZW5zdXJlIG91ciBncm91cCBvZiBub2RlcyBhcmUgaW5zZXJ0ZWRcbiAgICAgICAgLy8gaW4gdGhlIGNvcnJlY3Qgb3JkZXIgd2UgaW5jcmVtZW50IHRvUmVmIHRvIGFjY291bnQgZm9yIHRoYXRcbiAgICAgICAgdG9SZWYuY3VycmVudCA9IFBhdGgubmV4dCh0b1JlZi5jdXJyZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdG9SZWYudW5yZWYoKTtcbiAgfSk7XG59O1xuXG52YXIgcmVtb3ZlTm9kZXMgPSBmdW5jdGlvbiByZW1vdmVOb2RlcyhlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgIHZhciB7XG4gICAgICBoYW5naW5nID0gZmFsc2UsXG4gICAgICB2b2lkcyA9IGZhbHNlLFxuICAgICAgbW9kZSA9ICdsb3dlc3QnXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHtcbiAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgIG1hdGNoXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgbWF0Y2ggPSBQYXRoLmlzUGF0aChhdCkgPyBtYXRjaFBhdGgoZWRpdG9yLCBhdCkgOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgfVxuICAgIGlmICghaGFuZ2luZyAmJiBSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgYXQgPSBFZGl0b3IudW5oYW5nUmFuZ2UoZWRpdG9yLCBhdCwge1xuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBkZXB0aHMgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdCxcbiAgICAgIG1hdGNoLFxuICAgICAgbW9kZSxcbiAgICAgIHZvaWRzXG4gICAgfSk7XG4gICAgdmFyIHBhdGhSZWZzID0gQXJyYXkuZnJvbShkZXB0aHMsIF9yZWYgPT4ge1xuICAgICAgdmFyIFssIHBdID0gX3JlZjtcbiAgICAgIHJldHVybiBFZGl0b3IucGF0aFJlZihlZGl0b3IsIHApO1xuICAgIH0pO1xuICAgIGZvciAodmFyIHBhdGhSZWYgb2YgcGF0aFJlZnMpIHtcbiAgICAgIHZhciBwYXRoID0gcGF0aFJlZi51bnJlZigpO1xuICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgdmFyIFtub2RlXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgcGF0aCk7XG4gICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgdHlwZTogJ3JlbW92ZV9ub2RlJyxcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIG5vZGVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBzZXROb2RlcyA9IGZ1bmN0aW9uIHNldE5vZGVzKGVkaXRvciwgcHJvcHMpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgIHZhciB7XG4gICAgICBtYXRjaCxcbiAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgIGNvbXBhcmUsXG4gICAgICBtZXJnZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBoYW5naW5nID0gZmFsc2UsXG4gICAgICBtb2RlID0gJ2xvd2VzdCcsXG4gICAgICBzcGxpdCA9IGZhbHNlLFxuICAgICAgdm9pZHMgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgIG1hdGNoID0gUGF0aC5pc1BhdGgoYXQpID8gbWF0Y2hQYXRoKGVkaXRvciwgYXQpIDogbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgIH1cbiAgICBpZiAoIWhhbmdpbmcgJiYgUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgIGF0ID0gRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgYXQsIHtcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc3BsaXQgJiYgUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChhdCkgJiYgRWRpdG9yLmxlYWYoZWRpdG9yLCBhdC5hbmNob3IpWzBdLnRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBJZiB0aGUgcmFuZ2UgaXMgY29sbGFwc2VkIGluIGEgbm9uLWVtcHR5IG5vZGUgYW5kICdzcGxpdCcgaXMgdHJ1ZSwgdGhlcmUncyBub3RoaW5nIHRvXG4gICAgICAgIC8vIHNldCB0aGF0IHdvbid0IGdldCBub3JtYWxpemVkIGF3YXlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHJhbmdlUmVmID0gRWRpdG9yLnJhbmdlUmVmKGVkaXRvciwgYXQsIHtcbiAgICAgICAgYWZmaW5pdHk6ICdpbndhcmQnXG4gICAgICB9KTtcbiAgICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhhdCk7XG4gICAgICB2YXIgc3BsaXRNb2RlID0gbW9kZSA9PT0gJ2xvd2VzdCcgPyAnbG93ZXN0JyA6ICdoaWdoZXN0JztcbiAgICAgIHZhciBlbmRBdEVuZE9mTm9kZSA9IEVkaXRvci5pc0VuZChlZGl0b3IsIGVuZCwgZW5kLnBhdGgpO1xuICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogZW5kLFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgbW9kZTogc3BsaXRNb2RlLFxuICAgICAgICB2b2lkcyxcbiAgICAgICAgYWx3YXlzOiAhZW5kQXRFbmRPZk5vZGVcbiAgICAgIH0pO1xuICAgICAgdmFyIHN0YXJ0QXRTdGFydE9mTm9kZSA9IEVkaXRvci5pc1N0YXJ0KGVkaXRvciwgc3RhcnQsIHN0YXJ0LnBhdGgpO1xuICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogc3RhcnQsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBtb2RlOiBzcGxpdE1vZGUsXG4gICAgICAgIHZvaWRzLFxuICAgICAgICBhbHdheXM6ICFzdGFydEF0U3RhcnRPZk5vZGVcbiAgICAgIH0pO1xuICAgICAgYXQgPSByYW5nZVJlZi51bnJlZigpO1xuICAgICAgaWYgKG9wdGlvbnMuYXQgPT0gbnVsbCkge1xuICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIGF0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFjb21wYXJlKSB7XG4gICAgICBjb21wYXJlID0gKHByb3AsIG5vZGVQcm9wKSA9PiBwcm9wICE9PSBub2RlUHJvcDtcbiAgICB9XG4gICAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0LFxuICAgICAgbWF0Y2gsXG4gICAgICBtb2RlLFxuICAgICAgdm9pZHNcbiAgICB9KSkge1xuICAgICAgdmFyIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgIC8vIEZJWE1FOiBpcyB0aGlzIGNvcnJlY3Q/XG4gICAgICB2YXIgbmV3UHJvcGVydGllcyA9IHt9O1xuICAgICAgLy8gWW91IGNhbid0IHNldCBwcm9wZXJ0aWVzIG9uIHRoZSBlZGl0b3Igbm9kZS5cbiAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBoYXNDaGFuZ2VzID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBrIGluIHByb3BzKSB7XG4gICAgICAgIGlmIChrID09PSAnY2hpbGRyZW4nIHx8IGsgPT09ICd0ZXh0Jykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wYXJlKHByb3BzW2tdLCBub2RlW2tdKSkge1xuICAgICAgICAgIGhhc0NoYW5nZXMgPSB0cnVlO1xuICAgICAgICAgIC8vIE9taXQgbmV3IHByb3BlcnRpZXMgZnJvbSB0aGUgb2xkIHByb3BlcnRpZXMgbGlzdFxuICAgICAgICAgIGlmIChub2RlLmhhc093blByb3BlcnR5KGspKSBwcm9wZXJ0aWVzW2tdID0gbm9kZVtrXTtcbiAgICAgICAgICAvLyBPbWl0IHByb3BlcnRpZXMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBuZXcgcHJvcGVydGllcyBsaXN0XG4gICAgICAgICAgaWYgKG1lcmdlKSB7XG4gICAgICAgICAgICBpZiAocHJvcHNba10gIT0gbnVsbCkgbmV3UHJvcGVydGllc1trXSA9IG1lcmdlKG5vZGVba10sIHByb3BzW2tdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHByb3BzW2tdICE9IG51bGwpIG5ld1Byb3BlcnRpZXNba10gPSBwcm9wc1trXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChoYXNDaGFuZ2VzKSB7XG4gICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgdHlwZTogJ3NldF9ub2RlJyxcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIHByb3BlcnRpZXMsXG4gICAgICAgICAgbmV3UHJvcGVydGllc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgcmFuZ2UgaW50byBhIHBvaW50IGJ5IGRlbGV0aW5nIGl0J3MgY29udGVudC5cbiAqL1xudmFyIGRlbGV0ZVJhbmdlID0gKGVkaXRvciwgcmFuZ2UpID0+IHtcbiAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKHJhbmdlKSkge1xuICAgIHJldHVybiByYW5nZS5hbmNob3I7XG4gIH0gZWxzZSB7XG4gICAgdmFyIFssIGVuZF0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gICAgdmFyIHBvaW50UmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgIGF0OiByYW5nZVxuICAgIH0pO1xuICAgIHJldHVybiBwb2ludFJlZi51bnJlZigpO1xuICB9XG59O1xudmFyIHNwbGl0Tm9kZXMgPSBmdW5jdGlvbiBzcGxpdE5vZGVzKGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgdmFyIHtcbiAgICAgIG1vZGUgPSAnbG93ZXN0JyxcbiAgICAgIHZvaWRzID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgbWF0Y2gsXG4gICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICBoZWlnaHQgPSAwLFxuICAgICAgYWx3YXlzID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgbWF0Y2ggPSBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgfVxuICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgYXQgPSBkZWxldGVSYW5nZShlZGl0b3IsIGF0KTtcbiAgICB9XG4gICAgLy8gSWYgdGhlIHRhcmdldCBpcyBhIHBhdGgsIHRoZSBkZWZhdWx0IGhlaWdodC1za2lwcGluZyBhbmQgcG9zaXRpb25cbiAgICAvLyBjb3VudGVycyBuZWVkIHRvIGFjY291bnQgZm9yIHVzIHBvdGVudGlhbGx5IHNwbGl0dGluZyBhdCBhIG5vbi1sZWFmLlxuICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgIHZhciBwYXRoID0gYXQ7XG4gICAgICB2YXIgcG9pbnQgPSBFZGl0b3IucG9pbnQoZWRpdG9yLCBwYXRoKTtcbiAgICAgIHZhciBbcGFyZW50XSA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBwYXRoKTtcbiAgICAgIG1hdGNoID0gbiA9PiBuID09PSBwYXJlbnQ7XG4gICAgICBoZWlnaHQgPSBwb2ludC5wYXRoLmxlbmd0aCAtIHBhdGgubGVuZ3RoICsgMTtcbiAgICAgIGF0ID0gcG9pbnQ7XG4gICAgICBhbHdheXMgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBiZWZvcmVSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBhdCwge1xuICAgICAgYWZmaW5pdHk6ICdiYWNrd2FyZCdcbiAgICB9KTtcbiAgICB2YXIgYWZ0ZXJSZWY7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBbaGlnaGVzdF0gPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0LFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgICAgaWYgKCFoaWdoZXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB2b2lkTWF0Y2ggPSBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgICAgYXQsXG4gICAgICAgIG1vZGU6ICdoaWdoZXN0J1xuICAgICAgfSk7XG4gICAgICB2YXIgbnVkZ2UgPSAwO1xuICAgICAgaWYgKCF2b2lkcyAmJiB2b2lkTWF0Y2gpIHtcbiAgICAgICAgdmFyIFt2b2lkTm9kZSwgdm9pZFBhdGhdID0gdm9pZE1hdGNoO1xuICAgICAgICBpZiAoRWxlbWVudC5pc0VsZW1lbnQodm9pZE5vZGUpICYmIGVkaXRvci5pc0lubGluZSh2b2lkTm9kZSkpIHtcbiAgICAgICAgICB2YXIgYWZ0ZXIgPSBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCB2b2lkUGF0aCk7XG4gICAgICAgICAgaWYgKCFhZnRlcikge1xuICAgICAgICAgICAgdmFyIHRleHQgPSB7XG4gICAgICAgICAgICAgIHRleHQ6ICcnXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGFmdGVyUGF0aCA9IFBhdGgubmV4dCh2b2lkUGF0aCk7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgdGV4dCwge1xuICAgICAgICAgICAgICBhdDogYWZ0ZXJQYXRoLFxuICAgICAgICAgICAgICB2b2lkc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhZnRlciA9IEVkaXRvci5wb2ludChlZGl0b3IsIGFmdGVyUGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF0ID0gYWZ0ZXI7XG4gICAgICAgICAgYWx3YXlzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2libGluZ0hlaWdodCA9IGF0LnBhdGgubGVuZ3RoIC0gdm9pZFBhdGgubGVuZ3RoO1xuICAgICAgICBoZWlnaHQgPSBzaWJsaW5nSGVpZ2h0ICsgMTtcbiAgICAgICAgYWx3YXlzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGFmdGVyUmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgYXQpO1xuICAgICAgdmFyIGRlcHRoID0gYXQucGF0aC5sZW5ndGggLSBoZWlnaHQ7XG4gICAgICB2YXIgWywgaGlnaGVzdFBhdGhdID0gaGlnaGVzdDtcbiAgICAgIHZhciBsb3dlc3RQYXRoID0gYXQucGF0aC5zbGljZSgwLCBkZXB0aCk7XG4gICAgICB2YXIgcG9zaXRpb24gPSBoZWlnaHQgPT09IDAgPyBhdC5vZmZzZXQgOiBhdC5wYXRoW2RlcHRoXSArIG51ZGdlO1xuICAgICAgZm9yICh2YXIgW25vZGUsIF9wYXRoXSBvZiBFZGl0b3IubGV2ZWxzKGVkaXRvciwge1xuICAgICAgICBhdDogbG93ZXN0UGF0aCxcbiAgICAgICAgcmV2ZXJzZTogdHJ1ZSxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pKSB7XG4gICAgICAgIHZhciBzcGxpdCA9IGZhbHNlO1xuICAgICAgICBpZiAoX3BhdGgubGVuZ3RoIDwgaGlnaGVzdFBhdGgubGVuZ3RoIHx8IF9wYXRoLmxlbmd0aCA9PT0gMCB8fCAhdm9pZHMgJiYgRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9wb2ludCA9IGJlZm9yZVJlZi5jdXJyZW50O1xuICAgICAgICB2YXIgaXNFbmQgPSBFZGl0b3IuaXNFbmQoZWRpdG9yLCBfcG9pbnQsIF9wYXRoKTtcbiAgICAgICAgaWYgKGFsd2F5cyB8fCAhYmVmb3JlUmVmIHx8ICFFZGl0b3IuaXNFZGdlKGVkaXRvciwgX3BvaW50LCBfcGF0aCkpIHtcbiAgICAgICAgICBzcGxpdCA9IHRydWU7XG4gICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBOb2RlLmV4dHJhY3RQcm9wcyhub2RlKTtcbiAgICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgICAgdHlwZTogJ3NwbGl0X25vZGUnLFxuICAgICAgICAgICAgcGF0aDogX3BhdGgsXG4gICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgIHByb3BlcnRpZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBwb3NpdGlvbiA9IF9wYXRoW19wYXRoLmxlbmd0aCAtIDFdICsgKHNwbGl0IHx8IGlzRW5kID8gMSA6IDApO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuYXQgPT0gbnVsbCkge1xuICAgICAgICB2YXIgX3BvaW50MiA9IGFmdGVyUmVmLmN1cnJlbnQgfHwgRWRpdG9yLmVuZChlZGl0b3IsIFtdKTtcbiAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBfcG9pbnQyKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdmFyIF9hZnRlclJlZjtcbiAgICAgIGJlZm9yZVJlZi51bnJlZigpO1xuICAgICAgKF9hZnRlclJlZiA9IGFmdGVyUmVmKSA9PT0gbnVsbCB8fCBfYWZ0ZXJSZWYgPT09IHZvaWQgMCB8fCBfYWZ0ZXJSZWYudW5yZWYoKTtcbiAgICB9XG4gIH0pO1xufTtcblxudmFyIHVuc2V0Tm9kZXMgPSBmdW5jdGlvbiB1bnNldE5vZGVzKGVkaXRvciwgcHJvcHMpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgcHJvcHMgPSBbcHJvcHNdO1xuICB9XG4gIHZhciBvYmogPSB7fTtcbiAgZm9yICh2YXIga2V5IG9mIHByb3BzKSB7XG4gICAgb2JqW2tleV0gPSBudWxsO1xuICB9XG4gIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCBvYmosIG9wdGlvbnMpO1xufTtcblxudmFyIHVud3JhcE5vZGVzID0gZnVuY3Rpb24gdW53cmFwTm9kZXMoZWRpdG9yKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICB2YXIge1xuICAgICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgICAgc3BsaXQgPSBmYWxzZSxcbiAgICAgIHZvaWRzID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgbWF0Y2hcbiAgICB9ID0gb3B0aW9ucztcbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICBtYXRjaCA9IFBhdGguaXNQYXRoKGF0KSA/IG1hdGNoUGF0aChlZGl0b3IsIGF0KSA6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICB9XG4gICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgYXQgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBhdCk7XG4gICAgfVxuICAgIHZhciByYW5nZVJlZiA9IFJhbmdlLmlzUmFuZ2UoYXQpID8gRWRpdG9yLnJhbmdlUmVmKGVkaXRvciwgYXQpIDogbnVsbDtcbiAgICB2YXIgbWF0Y2hlcyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0LFxuICAgICAgbWF0Y2gsXG4gICAgICBtb2RlLFxuICAgICAgdm9pZHNcbiAgICB9KTtcbiAgICB2YXIgcGF0aFJlZnMgPSBBcnJheS5mcm9tKG1hdGNoZXMsIF9yZWYgPT4ge1xuICAgICAgdmFyIFssIHBdID0gX3JlZjtcbiAgICAgIHJldHVybiBFZGl0b3IucGF0aFJlZihlZGl0b3IsIHApO1xuICAgIH1cbiAgICAvLyB1bndyYXBOb2RlIHdpbGwgY2FsbCBsaWZ0Tm9kZSB3aGljaCBkb2VzIG5vdCBzdXBwb3J0IHNwbGl0dGluZyB0aGUgbm9kZSB3aGVuIG5lc3RlZC5cbiAgICAvLyBJZiB3ZSBkbyBub3QgcmV2ZXJzZSB0aGUgb3JkZXIgYW5kIGNhbGwgaXQgZnJvbSB0b3AgdG8gdGhlIGJvdHRvbSwgaXQgd2lsbCByZW1vdmUgYWxsIGJsb2Nrc1xuICAgIC8vIHRoYXQgd3JhcCB0YXJnZXQgbm9kZS4gU28gd2UgcmV2ZXJzZSB0aGUgb3JkZXIuXG4gICAgKS5yZXZlcnNlKCk7XG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICB2YXIgcGF0aCA9IHBhdGhSZWYudW5yZWYoKTtcbiAgICAgIHZhciBbbm9kZV0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIHBhdGgpO1xuICAgICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgcGF0aCk7XG4gICAgICBpZiAoc3BsaXQgJiYgcmFuZ2VSZWYpIHtcbiAgICAgICAgcmFuZ2UgPSBSYW5nZS5pbnRlcnNlY3Rpb24ocmFuZ2VSZWYuY3VycmVudCwgcmFuZ2UpO1xuICAgICAgfVxuICAgICAgVHJhbnNmb3Jtcy5saWZ0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiByYW5nZSxcbiAgICAgICAgbWF0Y2g6IG4gPT4gRWxlbWVudC5pc0FuY2VzdG9yKG5vZGUpICYmIG5vZGUuY2hpbGRyZW4uaW5jbHVkZXMobiksXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGZvciAodmFyIHBhdGhSZWYgb2YgcGF0aFJlZnMpIHtcbiAgICAgIF9sb29wKCk7XG4gICAgfVxuICAgIGlmIChyYW5nZVJlZikge1xuICAgICAgcmFuZ2VSZWYudW5yZWYoKTtcbiAgICB9XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG52YXIgd3JhcE5vZGVzID0gZnVuY3Rpb24gd3JhcE5vZGVzKGVkaXRvciwgZWxlbWVudCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgdmFyIHtcbiAgICAgIG1vZGUgPSAnbG93ZXN0JyxcbiAgICAgIHNwbGl0ID0gZmFsc2UsXG4gICAgICB2b2lkcyA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHtcbiAgICAgIG1hdGNoLFxuICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICBtYXRjaCA9IG1hdGNoUGF0aChlZGl0b3IsIGF0KTtcbiAgICAgIH0gZWxzZSBpZiAoZWRpdG9yLmlzSW5saW5lKGVsZW1lbnQpKSB7XG4gICAgICAgIG1hdGNoID0gbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKSB8fCBUZXh0LmlzVGV4dChuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hdGNoID0gbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3BsaXQgJiYgUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhhdCk7XG4gICAgICB2YXIgcmFuZ2VSZWYgPSBFZGl0b3IucmFuZ2VSZWYoZWRpdG9yLCBhdCwge1xuICAgICAgICBhZmZpbml0eTogJ2lud2FyZCdcbiAgICAgIH0pO1xuICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogZW5kLFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogc3RhcnQsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgICBhdCA9IHJhbmdlUmVmLnVucmVmKCk7XG4gICAgICBpZiAob3B0aW9ucy5hdCA9PSBudWxsKSB7XG4gICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgYXQpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgcm9vdHMgPSBBcnJheS5mcm9tKEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0LFxuICAgICAgbWF0Y2g6IGVkaXRvci5pc0lubGluZShlbGVtZW50KSA/IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKSA6IG4gPT4gRWRpdG9yLmlzRWRpdG9yKG4pLFxuICAgICAgbW9kZTogJ2xvd2VzdCcsXG4gICAgICB2b2lkc1xuICAgIH0pKTtcbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgICAgdmFyIGEgPSBSYW5nZS5pc1JhbmdlKGF0KSA/IFJhbmdlLmludGVyc2VjdGlvbihhdCwgRWRpdG9yLnJhbmdlKGVkaXRvciwgcm9vdFBhdGgpKSA6IGF0O1xuICAgICAgICBpZiAoIWEpIHtcbiAgICAgICAgICByZXR1cm4gMDsgLy8gY29udGludWVcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF0Y2hlcyA9IEFycmF5LmZyb20oRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBhLFxuICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSkpO1xuICAgICAgICBpZiAobWF0Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIFtmaXJzdF0gPSBtYXRjaGVzO1xuICAgICAgICAgIHZhciBsYXN0ID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIHZhciBbLCBmaXJzdFBhdGhdID0gZmlyc3Q7XG4gICAgICAgICAgdmFyIFssIGxhc3RQYXRoXSA9IGxhc3Q7XG4gICAgICAgICAgaWYgKGZpcnN0UGF0aC5sZW5ndGggPT09IDAgJiYgbGFzdFBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGVyZSdzIG5vIG1hdGNoaW5nIHBhcmVudCAtIHVzdWFsbHkgbWVhbnMgdGhlIG5vZGUgaXMgYW4gZWRpdG9yIC0gZG9uJ3QgZG8gYW55dGhpbmdcbiAgICAgICAgICAgIHJldHVybiAwOyAvLyBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY29tbW9uUGF0aCA9IFBhdGguZXF1YWxzKGZpcnN0UGF0aCwgbGFzdFBhdGgpID8gUGF0aC5wYXJlbnQoZmlyc3RQYXRoKSA6IFBhdGguY29tbW9uKGZpcnN0UGF0aCwgbGFzdFBhdGgpO1xuICAgICAgICAgIHZhciByYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIGZpcnN0UGF0aCwgbGFzdFBhdGgpO1xuICAgICAgICAgIHZhciBjb21tb25Ob2RlRW50cnkgPSBFZGl0b3Iubm9kZShlZGl0b3IsIGNvbW1vblBhdGgpO1xuICAgICAgICAgIHZhciBbY29tbW9uTm9kZV0gPSBjb21tb25Ob2RlRW50cnk7XG4gICAgICAgICAgdmFyIGRlcHRoID0gY29tbW9uUGF0aC5sZW5ndGggKyAxO1xuICAgICAgICAgIHZhciB3cmFwcGVyUGF0aCA9IFBhdGgubmV4dChsYXN0UGF0aC5zbGljZSgwLCBkZXB0aCkpO1xuICAgICAgICAgIHZhciB3cmFwcGVyID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBlbGVtZW50KSwge30sIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCB3cmFwcGVyLCB7XG4gICAgICAgICAgICBhdDogd3JhcHBlclBhdGgsXG4gICAgICAgICAgICB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IHJhbmdlLFxuICAgICAgICAgICAgbWF0Y2g6IG4gPT4gRWxlbWVudC5pc0FuY2VzdG9yKGNvbW1vbk5vZGUpICYmIGNvbW1vbk5vZGUuY2hpbGRyZW4uaW5jbHVkZXMobiksXG4gICAgICAgICAgICB0bzogd3JhcHBlclBhdGguY29uY2F0KDApLFxuICAgICAgICAgICAgdm9pZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9yZXQ7XG4gICAgZm9yICh2YXIgWywgcm9vdFBhdGhdIG9mIHJvb3RzKSB7XG4gICAgICBfcmV0ID0gX2xvb3AoKTtcbiAgICAgIGlmIChfcmV0ID09PSAwKSBjb250aW51ZTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgU2xhdGUgYEVkaXRvcmAgb2JqZWN0LlxuICovXG52YXIgY3JlYXRlRWRpdG9yID0gKCkgPT4ge1xuICB2YXIgZWRpdG9yID0ge1xuICAgIGNoaWxkcmVuOiBbXSxcbiAgICBvcGVyYXRpb25zOiBbXSxcbiAgICBzZWxlY3Rpb246IG51bGwsXG4gICAgbWFya3M6IG51bGwsXG4gICAgaXNFbGVtZW50UmVhZE9ubHk6ICgpID0+IGZhbHNlLFxuICAgIGlzSW5saW5lOiAoKSA9PiBmYWxzZSxcbiAgICBpc1NlbGVjdGFibGU6ICgpID0+IHRydWUsXG4gICAgaXNWb2lkOiAoKSA9PiBmYWxzZSxcbiAgICBtYXJrYWJsZVZvaWQ6ICgpID0+IGZhbHNlLFxuICAgIG9uQ2hhbmdlOiAoKSA9PiB7fSxcbiAgICAvLyBDb3JlXG4gICAgYXBwbHk6IGZ1bmN0aW9uIGFwcGx5JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcHBseShlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgLy8gRWRpdG9yXG4gICAgYWRkTWFyazogZnVuY3Rpb24gYWRkTWFyayQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhZGRNYXJrKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBkZWxldGVCYWNrd2FyZDogZnVuY3Rpb24gZGVsZXRlQmFja3dhcmQkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgICBhcmdzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVsZXRlQmFja3dhcmQoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGRlbGV0ZUZvcndhcmQ6IGZ1bmN0aW9uIGRlbGV0ZUZvcndhcmQkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNCksIF9rZXk0ID0gMDsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykge1xuICAgICAgICBhcmdzW19rZXk0XSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVsZXRlRm9yd2FyZChlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgZGVsZXRlRnJhZ21lbnQ6IGZ1bmN0aW9uIGRlbGV0ZUZyYWdtZW50JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjUpLCBfa2V5NSA9IDA7IF9rZXk1IDwgX2xlbjU7IF9rZXk1KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NV0gPSBhcmd1bWVudHNbX2tleTVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlbGV0ZUZyYWdtZW50KGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBnZXRGcmFnbWVudDogZnVuY3Rpb24gZ2V0RnJhZ21lbnQkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW42ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNiksIF9rZXk2ID0gMDsgX2tleTYgPCBfbGVuNjsgX2tleTYrKykge1xuICAgICAgICBhcmdzW19rZXk2XSA9IGFyZ3VtZW50c1tfa2V5Nl07XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0RnJhZ21lbnQoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGluc2VydEJyZWFrOiBmdW5jdGlvbiBpbnNlcnRCcmVhayQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjcgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW43KSwgX2tleTcgPSAwOyBfa2V5NyA8IF9sZW43OyBfa2V5NysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTddID0gYXJndW1lbnRzW19rZXk3XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnNlcnRCcmVhayhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgaW5zZXJ0U29mdEJyZWFrOiBmdW5jdGlvbiBpbnNlcnRTb2Z0QnJlYWskMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW44ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuOCksIF9rZXk4ID0gMDsgX2tleTggPCBfbGVuODsgX2tleTgrKykge1xuICAgICAgICBhcmdzW19rZXk4XSA9IGFyZ3VtZW50c1tfa2V5OF07XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5zZXJ0U29mdEJyZWFrKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBpbnNlcnRGcmFnbWVudDogZnVuY3Rpb24gaW5zZXJ0RnJhZ21lbnQkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW45ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuOSksIF9rZXk5ID0gMDsgX2tleTkgPCBfbGVuOTsgX2tleTkrKykge1xuICAgICAgICBhcmdzW19rZXk5XSA9IGFyZ3VtZW50c1tfa2V5OV07XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5zZXJ0RnJhZ21lbnQoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGluc2VydE5vZGU6IGZ1bmN0aW9uIGluc2VydE5vZGUkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4xMCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjEwKSwgX2tleTEwID0gMDsgX2tleTEwIDwgX2xlbjEwOyBfa2V5MTArKykge1xuICAgICAgICBhcmdzW19rZXkxMF0gPSBhcmd1bWVudHNbX2tleTEwXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnNlcnROb2RlKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBpbnNlcnRUZXh0OiBmdW5jdGlvbiBpbnNlcnRUZXh0JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMTEgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4xMSksIF9rZXkxMSA9IDA7IF9rZXkxMSA8IF9sZW4xMTsgX2tleTExKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MTFdID0gYXJndW1lbnRzW19rZXkxMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5zZXJ0VGV4dChlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgbm9ybWFsaXplTm9kZTogZnVuY3Rpb24gbm9ybWFsaXplTm9kZSQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjEyID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMTIpLCBfa2V5MTIgPSAwOyBfa2V5MTIgPCBfbGVuMTI7IF9rZXkxMisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTEyXSA9IGFyZ3VtZW50c1tfa2V5MTJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vcm1hbGl6ZU5vZGUoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHJlbW92ZU1hcms6IGZ1bmN0aW9uIHJlbW92ZU1hcmskMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4xMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjEzKSwgX2tleTEzID0gMDsgX2tleTEzIDwgX2xlbjEzOyBfa2V5MTMrKykge1xuICAgICAgICBhcmdzW19rZXkxM10gPSBhcmd1bWVudHNbX2tleTEzXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZW1vdmVNYXJrKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBnZXREaXJ0eVBhdGhzOiBmdW5jdGlvbiBnZXREaXJ0eVBhdGhzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMTQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4xNCksIF9rZXkxNCA9IDA7IF9rZXkxNCA8IF9sZW4xNDsgX2tleTE0KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MTRdID0gYXJndW1lbnRzW19rZXkxNF07XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0RGlydHlQYXRocyhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgc2hvdWxkTm9ybWFsaXplOiBmdW5jdGlvbiBzaG91bGROb3JtYWxpemUkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4xNSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjE1KSwgX2tleTE1ID0gMDsgX2tleTE1IDwgX2xlbjE1OyBfa2V5MTUrKykge1xuICAgICAgICBhcmdzW19rZXkxNV0gPSBhcmd1bWVudHNbX2tleTE1XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzaG91bGROb3JtYWxpemUoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIC8vIEVkaXRvciBpbnRlcmZhY2VcbiAgICBhYm92ZTogZnVuY3Rpb24gYWJvdmUkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4xNiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjE2KSwgX2tleTE2ID0gMDsgX2tleTE2IDwgX2xlbjE2OyBfa2V5MTYrKykge1xuICAgICAgICBhcmdzW19rZXkxNl0gPSBhcmd1bWVudHNbX2tleTE2XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhYm92ZShlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgYWZ0ZXI6IGZ1bmN0aW9uIGFmdGVyJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMTcgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4xNyksIF9rZXkxNyA9IDA7IF9rZXkxNyA8IF9sZW4xNzsgX2tleTE3KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MTddID0gYXJndW1lbnRzW19rZXkxN107XG4gICAgICB9XG4gICAgICByZXR1cm4gYWZ0ZXIoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGJlZm9yZTogZnVuY3Rpb24gYmVmb3JlJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMTggPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4xOCksIF9rZXkxOCA9IDA7IF9rZXkxOCA8IF9sZW4xODsgX2tleTE4KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MThdID0gYXJndW1lbnRzW19rZXkxOF07XG4gICAgICB9XG4gICAgICByZXR1cm4gYmVmb3JlKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBjb2xsYXBzZTogZnVuY3Rpb24gY29sbGFwc2UkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4xOSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjE5KSwgX2tleTE5ID0gMDsgX2tleTE5IDwgX2xlbjE5OyBfa2V5MTkrKykge1xuICAgICAgICBhcmdzW19rZXkxOV0gPSBhcmd1bWVudHNbX2tleTE5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2xsYXBzZShlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgZGVsZXRlOiBmdW5jdGlvbiBfZGVsZXRlKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIwID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMjApLCBfa2V5MjAgPSAwOyBfa2V5MjAgPCBfbGVuMjA7IF9rZXkyMCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIwXSA9IGFyZ3VtZW50c1tfa2V5MjBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlbGV0ZVRleHQoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGRlc2VsZWN0OiBmdW5jdGlvbiBkZXNlbGVjdCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIxID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMjEpLCBfa2V5MjEgPSAwOyBfa2V5MjEgPCBfbGVuMjE7IF9rZXkyMSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIxXSA9IGFyZ3VtZW50c1tfa2V5MjFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlc2VsZWN0KGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBlZGdlczogZnVuY3Rpb24gZWRnZXMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIyKSwgX2tleTIyID0gMDsgX2tleTIyIDwgX2xlbjIyOyBfa2V5MjIrKykge1xuICAgICAgICBhcmdzW19rZXkyMl0gPSBhcmd1bWVudHNbX2tleTIyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlZGdlcyhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgZWxlbWVudFJlYWRPbmx5OiBmdW5jdGlvbiBlbGVtZW50UmVhZE9ubHkkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIzKSwgX2tleTIzID0gMDsgX2tleTIzIDwgX2xlbjIzOyBfa2V5MjMrKykge1xuICAgICAgICBhcmdzW19rZXkyM10gPSBhcmd1bWVudHNbX2tleTIzXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGVtZW50UmVhZE9ubHkoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGVuZDogZnVuY3Rpb24gZW5kJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yNCksIF9rZXkyNCA9IDA7IF9rZXkyNCA8IF9sZW4yNDsgX2tleTI0KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MjRdID0gYXJndW1lbnRzW19rZXkyNF07XG4gICAgICB9XG4gICAgICByZXR1cm4gZW5kKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBmaXJzdDogZnVuY3Rpb24gZmlyc3QkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yNSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjI1KSwgX2tleTI1ID0gMDsgX2tleTI1IDwgX2xlbjI1OyBfa2V5MjUrKykge1xuICAgICAgICBhcmdzW19rZXkyNV0gPSBhcmd1bWVudHNbX2tleTI1XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmaXJzdChlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgZnJhZ21lbnQ6IGZ1bmN0aW9uIGZyYWdtZW50JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMjYgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yNiksIF9rZXkyNiA9IDA7IF9rZXkyNiA8IF9sZW4yNjsgX2tleTI2KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MjZdID0gYXJndW1lbnRzW19rZXkyNl07XG4gICAgICB9XG4gICAgICByZXR1cm4gZnJhZ21lbnQoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGdldE1hcmtzOiBmdW5jdGlvbiBnZXRNYXJrcygpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yNyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjI3KSwgX2tleTI3ID0gMDsgX2tleTI3IDwgX2xlbjI3OyBfa2V5MjcrKykge1xuICAgICAgICBhcmdzW19rZXkyN10gPSBhcmd1bWVudHNbX2tleTI3XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXJrcyhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgaGFzQmxvY2tzOiBmdW5jdGlvbiBoYXNCbG9ja3MkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yOCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjI4KSwgX2tleTI4ID0gMDsgX2tleTI4IDwgX2xlbjI4OyBfa2V5MjgrKykge1xuICAgICAgICBhcmdzW19rZXkyOF0gPSBhcmd1bWVudHNbX2tleTI4XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNCbG9ja3MoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGhhc0lubGluZXM6IGZ1bmN0aW9uIGhhc0lubGluZXMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yOSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjI5KSwgX2tleTI5ID0gMDsgX2tleTI5IDwgX2xlbjI5OyBfa2V5MjkrKykge1xuICAgICAgICBhcmdzW19rZXkyOV0gPSBhcmd1bWVudHNbX2tleTI5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNJbmxpbmVzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBoYXNQYXRoOiBmdW5jdGlvbiBoYXNQYXRoJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMzAgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zMCksIF9rZXkzMCA9IDA7IF9rZXkzMCA8IF9sZW4zMDsgX2tleTMwKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MzBdID0gYXJndW1lbnRzW19rZXkzMF07XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzUGF0aChlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgaGFzVGV4dHM6IGZ1bmN0aW9uIGhhc1RleHRzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMzEgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zMSksIF9rZXkzMSA9IDA7IF9rZXkzMSA8IF9sZW4zMTsgX2tleTMxKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MzFdID0gYXJndW1lbnRzW19rZXkzMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzVGV4dHMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGluc2VydE5vZGVzOiBmdW5jdGlvbiBpbnNlcnROb2RlcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjMyID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMzIpLCBfa2V5MzIgPSAwOyBfa2V5MzIgPCBfbGVuMzI7IF9rZXkzMisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTMyXSA9IGFyZ3VtZW50c1tfa2V5MzJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluc2VydE5vZGVzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBpc0Jsb2NrOiBmdW5jdGlvbiBpc0Jsb2NrJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMzMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zMyksIF9rZXkzMyA9IDA7IF9rZXkzMyA8IF9sZW4zMzsgX2tleTMzKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MzNdID0gYXJndW1lbnRzW19rZXkzM107XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNCbG9jayhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgaXNFZGdlOiBmdW5jdGlvbiBpc0VkZ2UkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjM0KSwgX2tleTM0ID0gMDsgX2tleTM0IDwgX2xlbjM0OyBfa2V5MzQrKykge1xuICAgICAgICBhcmdzW19rZXkzNF0gPSBhcmd1bWVudHNbX2tleTM0XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0VkZ2UoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGlzRW1wdHk6IGZ1bmN0aW9uIGlzRW1wdHkkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zNSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjM1KSwgX2tleTM1ID0gMDsgX2tleTM1IDwgX2xlbjM1OyBfa2V5MzUrKykge1xuICAgICAgICBhcmdzW19rZXkzNV0gPSBhcmd1bWVudHNbX2tleTM1XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0VtcHR5KGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBpc0VuZDogZnVuY3Rpb24gaXNFbmQkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zNiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjM2KSwgX2tleTM2ID0gMDsgX2tleTM2IDwgX2xlbjM2OyBfa2V5MzYrKykge1xuICAgICAgICBhcmdzW19rZXkzNl0gPSBhcmd1bWVudHNbX2tleTM2XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0VuZChlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgaXNOb3JtYWxpemluZzogZnVuY3Rpb24gaXNOb3JtYWxpemluZyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjM3ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMzcpLCBfa2V5MzcgPSAwOyBfa2V5MzcgPCBfbGVuMzc7IF9rZXkzNysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTM3XSA9IGFyZ3VtZW50c1tfa2V5MzddO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzTm9ybWFsaXppbmcoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGlzU3RhcnQ6IGZ1bmN0aW9uIGlzU3RhcnQkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zOCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjM4KSwgX2tleTM4ID0gMDsgX2tleTM4IDwgX2xlbjM4OyBfa2V5MzgrKykge1xuICAgICAgICBhcmdzW19rZXkzOF0gPSBhcmd1bWVudHNbX2tleTM4XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc1N0YXJ0KGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBsYXN0OiBmdW5jdGlvbiBsYXN0JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMzkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zOSksIF9rZXkzOSA9IDA7IF9rZXkzOSA8IF9sZW4zOTsgX2tleTM5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MzldID0gYXJndW1lbnRzW19rZXkzOV07XG4gICAgICB9XG4gICAgICByZXR1cm4gbGFzdChlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgbGVhZjogZnVuY3Rpb24gbGVhZiQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjQwID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNDApLCBfa2V5NDAgPSAwOyBfa2V5NDAgPCBfbGVuNDA7IF9rZXk0MCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTQwXSA9IGFyZ3VtZW50c1tfa2V5NDBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxlYWYoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGxldmVsczogZnVuY3Rpb24gbGV2ZWxzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNDEgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40MSksIF9rZXk0MSA9IDA7IF9rZXk0MSA8IF9sZW40MTsgX2tleTQxKyspIHtcbiAgICAgICAgYXJnc1tfa2V5NDFdID0gYXJndW1lbnRzW19rZXk0MV07XG4gICAgICB9XG4gICAgICByZXR1cm4gbGV2ZWxzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBsaWZ0Tm9kZXM6IGZ1bmN0aW9uIGxpZnROb2RlcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjQyID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNDIpLCBfa2V5NDIgPSAwOyBfa2V5NDIgPCBfbGVuNDI7IF9rZXk0MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTQyXSA9IGFyZ3VtZW50c1tfa2V5NDJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpZnROb2RlcyhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgbWVyZ2VOb2RlczogZnVuY3Rpb24gbWVyZ2VOb2RlcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjQzID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNDMpLCBfa2V5NDMgPSAwOyBfa2V5NDMgPCBfbGVuNDM7IF9rZXk0MysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTQzXSA9IGFyZ3VtZW50c1tfa2V5NDNdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lcmdlTm9kZXMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIG1vdmU6IGZ1bmN0aW9uIG1vdmUkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW40NCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQ0KSwgX2tleTQ0ID0gMDsgX2tleTQ0IDwgX2xlbjQ0OyBfa2V5NDQrKykge1xuICAgICAgICBhcmdzW19rZXk0NF0gPSBhcmd1bWVudHNbX2tleTQ0XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtb3ZlKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBtb3ZlTm9kZXM6IGZ1bmN0aW9uIG1vdmVOb2RlcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjQ1ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNDUpLCBfa2V5NDUgPSAwOyBfa2V5NDUgPCBfbGVuNDU7IF9rZXk0NSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTQ1XSA9IGFyZ3VtZW50c1tfa2V5NDVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1vdmVOb2RlcyhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgbmV4dDogZnVuY3Rpb24gbmV4dCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjQ2ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNDYpLCBfa2V5NDYgPSAwOyBfa2V5NDYgPCBfbGVuNDY7IF9rZXk0NisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTQ2XSA9IGFyZ3VtZW50c1tfa2V5NDZdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5leHQoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIG5vZGU6IGZ1bmN0aW9uIG5vZGUkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW40NyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQ3KSwgX2tleTQ3ID0gMDsgX2tleTQ3IDwgX2xlbjQ3OyBfa2V5NDcrKykge1xuICAgICAgICBhcmdzW19rZXk0N10gPSBhcmd1bWVudHNbX2tleTQ3XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBub2RlczogZnVuY3Rpb24gbm9kZXMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW40OCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQ4KSwgX2tleTQ4ID0gMDsgX2tleTQ4IDwgX2xlbjQ4OyBfa2V5NDgrKykge1xuICAgICAgICBhcmdzW19rZXk0OF0gPSBhcmd1bWVudHNbX2tleTQ4XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlcyhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgbm9ybWFsaXplOiBmdW5jdGlvbiBub3JtYWxpemUkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW40OSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQ5KSwgX2tleTQ5ID0gMDsgX2tleTQ5IDwgX2xlbjQ5OyBfa2V5NDkrKykge1xuICAgICAgICBhcmdzW19rZXk0OV0gPSBhcmd1bWVudHNbX2tleTQ5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub3JtYWxpemUoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHBhcmVudDogZnVuY3Rpb24gcGFyZW50JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNTAgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41MCksIF9rZXk1MCA9IDA7IF9rZXk1MCA8IF9sZW41MDsgX2tleTUwKyspIHtcbiAgICAgICAgYXJnc1tfa2V5NTBdID0gYXJndW1lbnRzW19rZXk1MF07XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyZW50KGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBwYXRoOiBmdW5jdGlvbiBwYXRoJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNTEgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41MSksIF9rZXk1MSA9IDA7IF9rZXk1MSA8IF9sZW41MTsgX2tleTUxKyspIHtcbiAgICAgICAgYXJnc1tfa2V5NTFdID0gYXJndW1lbnRzW19rZXk1MV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcGF0aChlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgcGF0aFJlZjogZnVuY3Rpb24gcGF0aFJlZiQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjUyID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNTIpLCBfa2V5NTIgPSAwOyBfa2V5NTIgPCBfbGVuNTI7IF9rZXk1MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTUyXSA9IGFyZ3VtZW50c1tfa2V5NTJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhdGhSZWYoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHBhdGhSZWZzOiBmdW5jdGlvbiBwYXRoUmVmcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjUzID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNTMpLCBfa2V5NTMgPSAwOyBfa2V5NTMgPCBfbGVuNTM7IF9rZXk1MysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTUzXSA9IGFyZ3VtZW50c1tfa2V5NTNdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhdGhSZWZzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBwb2ludDogZnVuY3Rpb24gcG9pbnQkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW41NCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjU0KSwgX2tleTU0ID0gMDsgX2tleTU0IDwgX2xlbjU0OyBfa2V5NTQrKykge1xuICAgICAgICBhcmdzW19rZXk1NF0gPSBhcmd1bWVudHNbX2tleTU0XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwb2ludChlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgcG9pbnRSZWY6IGZ1bmN0aW9uIHBvaW50UmVmJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNTUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41NSksIF9rZXk1NSA9IDA7IF9rZXk1NSA8IF9sZW41NTsgX2tleTU1KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NTVdID0gYXJndW1lbnRzW19rZXk1NV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcG9pbnRSZWYoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHBvaW50UmVmczogZnVuY3Rpb24gcG9pbnRSZWZzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNTYgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41NiksIF9rZXk1NiA9IDA7IF9rZXk1NiA8IF9sZW41NjsgX2tleTU2KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NTZdID0gYXJndW1lbnRzW19rZXk1Nl07XG4gICAgICB9XG4gICAgICByZXR1cm4gcG9pbnRSZWZzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBwb3NpdGlvbnM6IGZ1bmN0aW9uIHBvc2l0aW9ucyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjU3ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNTcpLCBfa2V5NTcgPSAwOyBfa2V5NTcgPCBfbGVuNTc7IF9rZXk1NysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTU3XSA9IGFyZ3VtZW50c1tfa2V5NTddO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBvc2l0aW9ucyhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgcHJldmlvdXM6IGZ1bmN0aW9uIHByZXZpb3VzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNTggPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41OCksIF9rZXk1OCA9IDA7IF9rZXk1OCA8IF9sZW41ODsgX2tleTU4KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NThdID0gYXJndW1lbnRzW19rZXk1OF07XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJldmlvdXMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHJhbmdlOiBmdW5jdGlvbiByYW5nZSQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjU5ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNTkpLCBfa2V5NTkgPSAwOyBfa2V5NTkgPCBfbGVuNTk7IF9rZXk1OSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTU5XSA9IGFyZ3VtZW50c1tfa2V5NTldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJhbmdlKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICByYW5nZVJlZjogZnVuY3Rpb24gcmFuZ2VSZWYkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW42MCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjYwKSwgX2tleTYwID0gMDsgX2tleTYwIDwgX2xlbjYwOyBfa2V5NjArKykge1xuICAgICAgICBhcmdzW19rZXk2MF0gPSBhcmd1bWVudHNbX2tleTYwXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByYW5nZVJlZihlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgcmFuZ2VSZWZzOiBmdW5jdGlvbiByYW5nZVJlZnMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW42MSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjYxKSwgX2tleTYxID0gMDsgX2tleTYxIDwgX2xlbjYxOyBfa2V5NjErKykge1xuICAgICAgICBhcmdzW19rZXk2MV0gPSBhcmd1bWVudHNbX2tleTYxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByYW5nZVJlZnMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHJlbW92ZU5vZGVzOiBmdW5jdGlvbiByZW1vdmVOb2RlcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjYyID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNjIpLCBfa2V5NjIgPSAwOyBfa2V5NjIgPCBfbGVuNjI7IF9rZXk2MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTYyXSA9IGFyZ3VtZW50c1tfa2V5NjJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlbW92ZU5vZGVzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBzZWxlY3Q6IGZ1bmN0aW9uIHNlbGVjdCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjYzID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNjMpLCBfa2V5NjMgPSAwOyBfa2V5NjMgPCBfbGVuNjM7IF9rZXk2MysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTYzXSA9IGFyZ3VtZW50c1tfa2V5NjNdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGVjdChlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgc2V0Tm9kZXM6IGZ1bmN0aW9uIHNldE5vZGVzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42NCksIF9rZXk2NCA9IDA7IF9rZXk2NCA8IF9sZW42NDsgX2tleTY0KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NjRdID0gYXJndW1lbnRzW19rZXk2NF07XG4gICAgICB9XG4gICAgICByZXR1cm4gc2V0Tm9kZXMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHNldE5vcm1hbGl6aW5nOiBmdW5jdGlvbiBzZXROb3JtYWxpemluZyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjY1ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNjUpLCBfa2V5NjUgPSAwOyBfa2V5NjUgPCBfbGVuNjU7IF9rZXk2NSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTY1XSA9IGFyZ3VtZW50c1tfa2V5NjVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNldE5vcm1hbGl6aW5nKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBzZXRQb2ludDogZnVuY3Rpb24gc2V0UG9pbnQkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW42NiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjY2KSwgX2tleTY2ID0gMDsgX2tleTY2IDwgX2xlbjY2OyBfa2V5NjYrKykge1xuICAgICAgICBhcmdzW19rZXk2Nl0gPSBhcmd1bWVudHNbX2tleTY2XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXRQb2ludChlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgc2V0U2VsZWN0aW9uOiBmdW5jdGlvbiBzZXRTZWxlY3Rpb24kMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW42NyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjY3KSwgX2tleTY3ID0gMDsgX2tleTY3IDwgX2xlbjY3OyBfa2V5NjcrKykge1xuICAgICAgICBhcmdzW19rZXk2N10gPSBhcmd1bWVudHNbX2tleTY3XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXRTZWxlY3Rpb24oZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHNwbGl0Tm9kZXM6IGZ1bmN0aW9uIHNwbGl0Tm9kZXMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW42OCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjY4KSwgX2tleTY4ID0gMDsgX2tleTY4IDwgX2xlbjY4OyBfa2V5NjgrKykge1xuICAgICAgICBhcmdzW19rZXk2OF0gPSBhcmd1bWVudHNbX2tleTY4XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzcGxpdE5vZGVzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW42OSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjY5KSwgX2tleTY5ID0gMDsgX2tleTY5IDwgX2xlbjY5OyBfa2V5NjkrKykge1xuICAgICAgICBhcmdzW19rZXk2OV0gPSBhcmd1bWVudHNbX2tleTY5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGFydChlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgc3RyaW5nOiBmdW5jdGlvbiBzdHJpbmckMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW43MCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjcwKSwgX2tleTcwID0gMDsgX2tleTcwIDwgX2xlbjcwOyBfa2V5NzArKykge1xuICAgICAgICBhcmdzW19rZXk3MF0gPSBhcmd1bWVudHNbX2tleTcwXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJpbmcoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHVuaGFuZ1JhbmdlOiBmdW5jdGlvbiB1bmhhbmdSYW5nZSQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjcxID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNzEpLCBfa2V5NzEgPSAwOyBfa2V5NzEgPCBfbGVuNzE7IF9rZXk3MSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTcxXSA9IGFyZ3VtZW50c1tfa2V5NzFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVuaGFuZ1JhbmdlKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICB1bnNldE5vZGVzOiBmdW5jdGlvbiB1bnNldE5vZGVzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNzIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW43MiksIF9rZXk3MiA9IDA7IF9rZXk3MiA8IF9sZW43MjsgX2tleTcyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5NzJdID0gYXJndW1lbnRzW19rZXk3Ml07XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5zZXROb2RlcyhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgdW53cmFwTm9kZXM6IGZ1bmN0aW9uIHVud3JhcE5vZGVzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNzMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW43MyksIF9rZXk3MyA9IDA7IF9rZXk3MyA8IF9sZW43MzsgX2tleTczKyspIHtcbiAgICAgICAgYXJnc1tfa2V5NzNdID0gYXJndW1lbnRzW19rZXk3M107XG4gICAgICB9XG4gICAgICByZXR1cm4gdW53cmFwTm9kZXMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHZvaWQ6IGZ1bmN0aW9uIF92b2lkKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjc0ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNzQpLCBfa2V5NzQgPSAwOyBfa2V5NzQgPCBfbGVuNzQ7IF9rZXk3NCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTc0XSA9IGFyZ3VtZW50c1tfa2V5NzRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldFZvaWQoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHdpdGhvdXROb3JtYWxpemluZzogZnVuY3Rpb24gd2l0aG91dE5vcm1hbGl6aW5nJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNzUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW43NSksIF9rZXk3NSA9IDA7IF9rZXk3NSA8IF9sZW43NTsgX2tleTc1KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NzVdID0gYXJndW1lbnRzW19rZXk3NV07XG4gICAgICB9XG4gICAgICByZXR1cm4gd2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICB3cmFwTm9kZXM6IGZ1bmN0aW9uIHdyYXBOb2RlcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjc2ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNzYpLCBfa2V5NzYgPSAwOyBfa2V5NzYgPCBfbGVuNzY7IF9rZXk3NisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTc2XSA9IGFyZ3VtZW50c1tfa2V5NzZdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBOb2RlcyhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgc2hvdWxkTWVyZ2VOb2Rlc1JlbW92ZVByZXZOb2RlOiBmdW5jdGlvbiBzaG91bGRNZXJnZU5vZGVzUmVtb3ZlUHJldk5vZGUkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW43NyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjc3KSwgX2tleTc3ID0gMDsgX2tleTc3IDwgX2xlbjc3OyBfa2V5NzcrKykge1xuICAgICAgICBhcmdzW19rZXk3N10gPSBhcmd1bWVudHNbX2tleTc3XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzaG91bGRNZXJnZU5vZGVzUmVtb3ZlUHJldk5vZGUoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBlZGl0b3I7XG59O1xuXG5leHBvcnQgeyBFZGl0b3IsIEVsZW1lbnQsIExvY2F0aW9uLCBOb2RlLCBPcGVyYXRpb24sIFBhdGgsIFBhdGhSZWYsIFBvaW50LCBQb2ludFJlZiwgUmFuZ2UsIFJhbmdlUmVmLCBTY3J1YmJlciwgU3BhbiwgVGV4dCwgVHJhbnNmb3JtcywgYWJvdmUsIGFkZE1hcmssIGFmdGVyLCBhcHBseSwgYmVmb3JlLCBjb2xsYXBzZSwgY3JlYXRlRWRpdG9yLCBkZWxldGVCYWNrd2FyZCwgZGVsZXRlRm9yd2FyZCwgZGVsZXRlRnJhZ21lbnQsIGRlbGV0ZVRleHQsIGRlc2VsZWN0LCBlZGdlcywgZWxlbWVudFJlYWRPbmx5LCBlbmQsIGZpcnN0LCBmcmFnbWVudCwgZ2V0RGlydHlQYXRocywgZ2V0RnJhZ21lbnQsIGdldFZvaWQsIGhhc0Jsb2NrcywgaGFzSW5saW5lcywgaGFzUGF0aCwgaGFzVGV4dHMsIGluc2VydEJyZWFrLCBpbnNlcnRGcmFnbWVudCwgaW5zZXJ0Tm9kZSwgaW5zZXJ0Tm9kZXMsIGluc2VydFNvZnRCcmVhaywgaW5zZXJ0VGV4dCwgaXNCbG9jaywgaXNFZGdlLCBpc0VkaXRvciwgaXNFbXB0eSwgaXNFbmQsIGlzTm9ybWFsaXppbmcsIGlzT2JqZWN0LCBpc1N0YXJ0LCBsYXN0LCBsZWFmLCBsZXZlbHMsIGxpZnROb2RlcywgbWFya3MsIG1lcmdlTm9kZXMsIG1vdmUsIG1vdmVOb2RlcywgbmV4dCwgbm9kZSwgbm9kZXMsIG5vcm1hbGl6ZSwgbm9ybWFsaXplTm9kZSwgcGFyZW50LCBwYXRoLCBwYXRoUmVmLCBwYXRoUmVmcywgcG9pbnQsIHBvaW50UmVmLCBwb2ludFJlZnMsIHBvc2l0aW9ucywgcHJldmlvdXMsIHJhbmdlLCByYW5nZVJlZiwgcmFuZ2VSZWZzLCByZW1vdmVNYXJrLCByZW1vdmVOb2Rlcywgc2VsZWN0LCBzZXROb2Rlcywgc2V0Tm9ybWFsaXppbmcsIHNldFBvaW50LCBzZXRTZWxlY3Rpb24sIHNob3VsZE1lcmdlTm9kZXNSZW1vdmVQcmV2Tm9kZSwgc2hvdWxkTm9ybWFsaXplLCBzcGxpdE5vZGVzLCBzdGFydCwgc3RyaW5nLCB1bmhhbmdSYW5nZSwgdW5zZXROb2RlcywgdW53cmFwTm9kZXMsIHdpdGhvdXROb3JtYWxpemluZywgd3JhcE5vZGVzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lcy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJwcm9kdWNlIiwiUGF0aFJlZiIsInRyYW5zZm9ybSIsInJlZiIsIm9wIiwiY3VycmVudCIsImFmZmluaXR5IiwicGF0aCIsIlBhdGgiLCJ1bnJlZiIsIlBvaW50UmVmIiwicG9pbnQiLCJQb2ludCIsIlJhbmdlUmVmIiwiUmFuZ2UiLCJESVJUWV9QQVRIUyIsIldlYWtNYXAiLCJESVJUWV9QQVRIX0tFWVMiLCJGTFVTSElORyIsIk5PUk1BTElaSU5HIiwiUEFUSF9SRUZTIiwiUE9JTlRfUkVGUyIsIlJBTkdFX1JFRlMiLCJhbmNlc3RvcnMiLCJvcHRpb25zIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwicmV2ZXJzZSIsInBhdGhzIiwibGV2ZWxzIiwic2xpY2UiLCJjb21tb24iLCJhbm90aGVyIiwiaSIsImF2IiwiYnYiLCJwdXNoIiwiY29tcGFyZSIsIm1pbiIsIk1hdGgiLCJlbmRzQWZ0ZXIiLCJhcyIsImJzIiwiZXF1YWxzIiwiZW5kc0F0IiwiZW5kc0JlZm9yZSIsImV2ZXJ5IiwibiIsImhhc1ByZXZpb3VzIiwiaXNBZnRlciIsImlzQW5jZXN0b3IiLCJpc0JlZm9yZSIsImlzQ2hpbGQiLCJpc0NvbW1vbiIsImlzRGVzY2VuZGFudCIsImlzUGFyZW50IiwiaXNQYXRoIiwidmFsdWUiLCJBcnJheSIsImlzQXJyYXkiLCJpc1NpYmxpbmciLCJhbCIsImJsIiwibGlzdCIsIm5leHQiLCJFcnJvciIsImNvbmNhdCIsImxhc3QiLCJvcGVyYXRpb25DYW5UcmFuc2Zvcm1QYXRoIiwib3BlcmF0aW9uIiwidHlwZSIsInBhcmVudCIsInByZXZpb3VzIiwicmVsYXRpdmUiLCJhbmNlc3RvciIsInAiLCJfb3AiLCJfb3AyIiwicG9zaXRpb24iLCJfb3AzIiwiX3Bvc2l0aW9uIiwiX29wNCIsIm5ld1BhdGgiLCJvbnAiLCJjb3B5IiwiX3R5cGVvZiIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiX3RvUHJpbWl0aXZlIiwiaW5wdXQiLCJoaW50IiwicHJpbSIsInRvUHJpbWl0aXZlIiwicmVzIiwiY2FsbCIsIlR5cGVFcnJvciIsIlN0cmluZyIsIk51bWJlciIsIl90b1Byb3BlcnR5S2V5IiwiYXJnIiwia2V5IiwiX2RlZmluZVByb3BlcnR5Iiwib2JqIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJvd25LZXlzJGUiLCJlIiwiciIsInQiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZmlsdGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkJGUiLCJmb3JFYWNoIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJpbnNlcnRDaGlsZHJlbiIsInhzIiwiaW5kZXgiLCJfbGVuIiwibmV3VmFsdWVzIiwiX2tleSIsInJlcGxhY2VDaGlsZHJlbiIsInJlbW92ZUNvdW50IiwiX2xlbjIiLCJfa2V5MiIsInJlbW92ZUNoaWxkcmVuIiwibW9kaWZ5RGVzY2VuZGFudCIsImVkaXRvciIsImYiLCJub2RlIiwiTm9kZSIsImdldCIsInNsaWNlZFBhdGgiLCJtb2RpZmllZE5vZGUiLCJfaW5kZXgiLCJwb3AiLCJhbmNlc3Rvck5vZGUiLCJjaGlsZHJlbiIsIm1vZGlmeUNoaWxkcmVuIiwiVGV4dCIsImlzVGV4dCIsIlNjcnViYmVyIiwic3RyaW5naWZ5IiwibW9kaWZ5TGVhZiIsIkdlbmVyYWxUcmFuc2Zvcm1zIiwidHJhbnNmb3JtU2VsZWN0aW9uIiwiX3BhdGgiLCJvZmZzZXQiLCJ0ZXh0IiwiYmVmb3JlIiwiYWZ0ZXIiLCJfcGF0aDIiLCJwcmV2UGF0aCIsInByZXZJbmRleCIsInByZXYiLCJuZXdOb2RlIiwiX3BhdGgzIiwiX2luZGV4MiIsIl9ub2RlIiwidHJ1ZVBhdGgiLCJuZXdJbmRleCIsIl9wYXRoNCIsIl9pbmRleDMiLCJzZWxlY3Rpb24iLCJwb2ludHMiLCJyZXN1bHQiLCJ0ZXh0cyIsInByZWZlck5leHQiLCJfcGF0aDUiLCJfb2Zmc2V0IiwiX3RleHQiLCJfcGF0aDYiLCJwcm9wZXJ0aWVzIiwibmV3UHJvcGVydGllcyIsIl9rZXkzIiwiX2tleTQiLCJoYXNPd25Qcm9wZXJ0eSIsIl9uZXdQcm9wZXJ0aWVzIiwiaXNSYW5nZSIsIl9zZWxlY3Rpb24iLCJfa2V5NSIsIl9wYXRoNyIsIl9wcm9wZXJ0aWVzIiwiX2luZGV4NCIsIm5leHROb2RlIiwiX2JlZm9yZSIsIl9hZnRlciIsIl9zZWxlY3Rpb24yIiwiX3BvaW50IiwiX2tleTYiLCJOb2RlVHJhbnNmb3JtcyIsImluc2VydE5vZGVzIiwibm9kZXMiLCJsaWZ0Tm9kZXMiLCJtZXJnZU5vZGVzIiwibW92ZU5vZGVzIiwicmVtb3ZlTm9kZXMiLCJzZXROb2RlcyIsInByb3BzIiwic3BsaXROb2RlcyIsInVuc2V0Tm9kZXMiLCJ1bndyYXBOb2RlcyIsIndyYXBOb2RlcyIsImVsZW1lbnQiLCJTZWxlY3Rpb25UcmFuc2Zvcm1zIiwiY29sbGFwc2UiLCJkZXNlbGVjdCIsIm1vdmUiLCJzZWxlY3QiLCJ0YXJnZXQiLCJzZXRQb2ludCIsInNldFNlbGVjdGlvbiIsImlzT2JqZWN0IiwiaXNEZWVwRXF1YWwiLCJhIiwiYiIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwic291cmNlIiwiZXhjbHVkZWQiLCJzb3VyY2VLZXlzIiwiaW5kZXhPZiIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsInNvdXJjZVN5bWJvbEtleXMiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIl9leGNsdWRlZCQ0Iiwib3duS2V5cyRkIiwiX29iamVjdFNwcmVhZCRkIiwiZWRnZXMiLCJyYW5nZSIsImFuY2hvciIsImZvY3VzIiwiaXNCYWNrd2FyZCIsImVuZCIsInN1cnJvdW5kcyIsImludGVyc2VjdGlvblJhbmdlIiwiaW50ZXJzZWN0aW9uIiwiaW5jbHVkZXMiLCJycyIsInJlIiwidHMiLCJ0ZSIsInN0YXJ0IiwiaXNBZnRlclN0YXJ0IiwiaXNCZWZvcmVFbmQiLCJpc1BvaW50IiwicmVzdCIsInMxIiwiZTEiLCJzMiIsImUyIiwiaXNDb2xsYXBzZWQiLCJpc0V4cGFuZGVkIiwiaXNGb3J3YXJkIiwiYWZmaW5pdHlBbmNob3IiLCJhZmZpbml0eUZvY3VzIiwiaXNFbGVtZW50IiwiZGVlcCIsImlzRWRpdG9yIiwiaXNDaGlsZHJlblZhbGlkIiwiaXNOb2RlTGlzdCIsIkVsZW1lbnQiLCJpc0VsZW1lbnRMaXN0IiwidmFsIiwiaXNFbGVtZW50UHJvcHMiLCJpc0VsZW1lbnRUeXBlIiwiZWxlbWVudFZhbCIsImVsZW1lbnRLZXkiLCJtYXRjaGVzIiwiX2V4Y2x1ZGVkJDMiLCJfZXhjbHVkZWQyJDMiLCJyb290IiwiZW50cnkiLCJjaGlsZCIsImMiLCJjaGlsZFBhdGgiLCJkZXNjZW5kYW50IiwiRWRpdG9yIiwiZGVzY2VuZGFudHMiLCJlbGVtZW50cyIsImV4dHJhY3RQcm9wcyIsImZpcnN0IiwiZnJhZ21lbnQiLCJuZXdSb290Iiwibm9kZUVudHJpZXMiLCJwYXNzIiwiX3JlZiIsInNwbGljZSIsImxlYWYiLCJfbGVhZiIsImdldElmIiwiaGFzIiwiaXNOb2RlIiwiaXNUZXh0UHJvcHMiLCJmcm9tIiwidG8iLCJ2aXNpdGVkIiwiU2V0IiwiYWRkIiwibmV4dEluZGV4IiwiX25ld1BhdGgiLCJwYXJlbnRQYXRoIiwic3RyaW5nIiwibWFwIiwiam9pbiIsIm93bktleXMkYyIsIl9vYmplY3RTcHJlYWQkYyIsIk9wZXJhdGlvbiIsImlzTm9kZU9wZXJhdGlvbiIsImlzT3BlcmF0aW9uIiwiZW5kc1dpdGgiLCJpc09wZXJhdGlvbkxpc3QiLCJpc1NlbGVjdGlvbk9wZXJhdGlvbiIsImlzVGV4dE9wZXJhdGlvbiIsImludmVyc2UiLCJpbnZlcnNlUGF0aCIsImludmVyc2VOZXdQYXRoIiwiYWRkTWFyayIsImRlbGV0ZUZyYWdtZW50IiwiaW5zZXJ0QnJlYWsiLCJpbnNlcnRTb2Z0QnJlYWsiLCJpbnNlcnRGcmFnbWVudCIsImluc2VydE5vZGUiLCJpbnNlcnRUZXh0IiwiaXNFbGVtZW50UmVhZE9ubHkiLCJpc0lubGluZSIsImlzU2VsZWN0YWJsZSIsImlzVm9pZCIsIm5vcm1hbGl6ZU5vZGUiLCJvbkNoYW5nZSIsInJlbW92ZU1hcmsiLCJnZXREaXJ0eVBhdGhzIiwibWFya3MiLCJvcGVyYXRpb25zIiwiYWJvdmUiLCJhdCIsImRlbGV0ZUJhY2t3YXJkIiwidW5pdCIsImRlbGV0ZUZvcndhcmQiLCJlbGVtZW50UmVhZE9ubHkiLCJoYXNCbG9ja3MiLCJoYXNJbmxpbmVzIiwiaGFzUGF0aCIsImhhc1RleHRzIiwiaXNCbG9jayIsImlzRWRnZSIsImlzRW1wdHkiLCJpc0VuZCIsImlzTm9ybWFsaXppbmciLCJpc1N0YXJ0IiwiZ2V0TWFya3MiLCJub3JtYWxpemUiLCJwYXRoUmVmIiwicGF0aFJlZnMiLCJwb2ludFJlZiIsInBvaW50UmVmcyIsInBvc2l0aW9ucyIsInJhbmdlUmVmIiwicmFuZ2VSZWZzIiwic2V0Tm9ybWFsaXppbmciLCJ1bmhhbmdSYW5nZSIsInZvaWQiLCJ3aXRob3V0Tm9ybWFsaXppbmciLCJmbiIsInNob3VsZE1lcmdlTm9kZXNSZW1vdmVQcmV2Tm9kZSIsInByZXZOb2RlIiwiY3VyTm9kZSIsIkxvY2F0aW9uIiwiaXNMb2NhdGlvbiIsIlNwYW4iLCJpc1NwYW4iLCJvd25LZXlzJGIiLCJfb2JqZWN0U3ByZWFkJGIiLCJfc2NydWJiZXIiLCJzZXRTY3J1YmJlciIsInNjcnViYmVyIiwiSlNPTiIsIl9leGNsdWRlZCQyIiwiX2V4Y2x1ZGVkMiQyIiwib3duS2V5cyRhIiwiX29iamVjdFNwcmVhZCRhIiwibG9vc2UiLCJvbWl0VGV4dCIsImlzVGV4dExpc3QiLCJkZWNvcmF0aW9ucyIsImxlYXZlcyIsImRlYyIsIm1lcmdlIiwibWVyZ2VEZWNvcmF0aW9uIiwibGVhZkVuZCIsImRlY29yYXRpb25TdGFydCIsImRlY29yYXRpb25FbmQiLCJhc3NpZ24iLCJsZWFmU3RhcnQiLCJtaWRkbGUiLCJvZmYiLCJfb2ZmIiwiY3VycmVudE9mZnNldCIsIml0ZW0iLCJlbnRyaWVzIiwiX3N0YXJ0IiwiX2VuZCIsImlzRmlyc3QiLCJpc0xhc3QiLCJnZXREZWZhdWx0SW5zZXJ0TG9jYXRpb24iLCJtYXRjaFBhdGgiLCJnZXRDaGFyYWN0ZXJEaXN0YW5jZSIsInN0ciIsImlzUlRMIiwiaXNMVFIiLCJjb2RlcG9pbnRzIiwiY29kZXBvaW50c0l0ZXJhdG9yUlRMIiwibGVmdCIsIkNvZGVwb2ludFR5cGUiLCJOb25lIiwicmlnaHQiLCJkaXN0YW5jZSIsImdiMTEiLCJnYjEyT3IxMyIsImNoYXIiLCJjb2RlIiwiY29kZVBvaW50QXQiLCJnZXRDb2RlcG9pbnRUeXBlIiwiaW50ZXJzZWN0cyIsIlpXSiIsIkV4dFBpY3QiLCJlbmRzV2l0aEVtb2ppWldKIiwic3Vic3RyaW5nIiwiUkkiLCJlbmRzV2l0aE9kZE51bWJlck9mUklzIiwiaXNCb3VuZGFyeVBhaXIiLCJTUEFDRSIsIlBVTkNUVUFUSU9OIiwiQ0hBTUVMRU9OIiwiZ2V0V29yZERpc3RhbmNlIiwiZGlzdCIsInN0YXJ0ZWQiLCJjaGFyRGlzdCIsInJlbWFpbmluZyIsInNwbGl0QnlDaGFyYWN0ZXJEaXN0YW5jZSIsImlzV29yZENoYXJhY3RlciIsInRlc3QiLCJuZXh0Q2hhciIsIm5leHRSZW1haW5pbmciLCJjaGFyMSIsImNoYXJBdCIsImlzTG93U3Vycm9nYXRlIiwiY2hhckNvZGVBdCIsImNoYXIyIiwiaXNIaWdoU3Vycm9nYXRlIiwiY2hhckNvZGUiLCJyZUV4dGVuZCIsInJlUHJlcGVuZCIsInJlU3BhY2luZ01hcmsiLCJyZUwiLCJyZVYiLCJyZVQiLCJyZUxWIiwicmVMVlQiLCJyZUV4dFBpY3QiLCJBbnkiLCJzZWFyY2giLCJFeHRlbmQiLCJQcmVwZW5kIiwiU3BhY2luZ01hcmsiLCJMIiwiViIsIlQiLCJMViIsIkxWVCIsIngiLCJ5IiwiTm9uQm91bmRhcnlQYWlycyIsImZpbmRJbmRleCIsImVuZGluZ0Vtb2ppWldKIiwiZW5kaW5nUklzIiwibWF0Y2giLCJudW1SSXMiLCJUZXh0VHJhbnNmb3JtcyIsImRlbGV0ZSIsInZvaWRzIiwic3RhcnRSZWYiLCJlbmRSZWYiLCJUcmFuc2Zvcm1zIiwic3RhcnRQb2ludCIsImVuZFBvaW50Iiwib3duS2V5cyQ5IiwiX29iamVjdFNwcmVhZCQ5IiwiQkFUQ0hJTkdfRElSVFlfUEFUSFMiLCJpc0JhdGNoaW5nRGlydHlQYXRocyIsImJhdGNoRGlydHlQYXRocyIsInVwZGF0ZSIsInNldCIsInVwZGF0ZURpcnR5UGF0aHMiLCJuZXdEaXJ0eVBhdGhzIiwib2xkRGlydHlQYXRocyIsIm9sZERpcnR5UGF0aEtleXMiLCJkaXJ0eVBhdGhzIiwiZGlydHlQYXRoS2V5cyIsIl9yZWYyIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwicHJldmlvdXNQYXRoIiwib2xkQW5jZXN0b3JzIiwibmV3QW5jZXN0b3JzIiwiX2FuY2VzdG9yIiwiX3AiLCJuZXdQYXJlbnQiLCJyZXN1bHRQYXRoIiwiX2FuY2VzdG9ycyIsIl9sZXZlbHMiLCJuZXh0UGF0aCIsImdldEZyYWdtZW50Iiwic2hvdWxkSGF2ZUlubGluZXMiLCJjdXJyZW50Tm9kZSIsIl9jaGlsZCIsImlzSW5saW5lT3JUZXh0IiwiZmFsbGJhY2tFbGVtZW50IiwibmV3Q2hpbGQiLCJfbmV3Q2hpbGQiLCJlbGVtZW50Q2hpbGQiLCJzaG91bGROb3JtYWxpemUiLCJpdGVyYXRpb24iLCJpbml0aWFsRGlydHlQYXRoc0xlbmd0aCIsIm1heEl0ZXJhdGlvbnMiLCJtb2RlIiwiZmlyc3RNYXRjaCIsIm93bktleXMkOCIsIl9vYmplY3RTcHJlYWQkOCIsInBhcmVudE5vZGUiLCJtYXJrYWJsZVZvaWQiLCJleHBhbmRlZFNlbGVjdGlvbiIsIm1hcmtBY2NlcHRpbmdWb2lkU2VsZWN0ZWQiLCJzZWxlY3RlZE5vZGUiLCJzZWxlY3RlZFBhdGgiLCJzcGxpdCIsIm93bktleXMkNyIsIl9vYmplY3RTcHJlYWQkNyIsImVkZ2UiLCJkIiwib3duS2V5cyQ2IiwiX29iamVjdFNwcmVhZCQ2IiwiZGlyZWN0aW9uIiwib3duS2V5cyQ1IiwiX29iamVjdFNwcmVhZCQ1Iiwib3duS2V5cyQ0IiwiX29iamVjdFNwcmVhZCQ0IiwiZ2V0Vm9pZCIsInNvbWUiLCJhbHdheXMiLCJvd25LZXlzJDMiLCJfb2JqZWN0U3ByZWFkJDMiLCJfZXhjbHVkZWQkMSIsIl9leGNsdWRlZDIkMSIsIl9yZXN0IiwibWFya2VkVm9pZCIsImJsb2NrIiwiYmxvY2tQYXRoIiwicG9pbnRBZnRlckxvY2F0aW9uIiwic3BhbiIsInVuaXZlcnNhbCIsIl9wYXNzIiwiaGl0IiwiaXNMb3dlciIsImVtaXQiLCJmb3JjZSIsImdldERpcnR5UGF0aEtleXMiLCJwb3BEaXJ0eVBhdGgiLCJhbGxQYXRocyIsImFsbFBhdGhLZXlzIiwiZGlydHlQYXRoIiwiXyIsIl9kaXJ0eVBhdGgiLCJfZW50cnkiLCJyZWZzIiwiZGVwdGgiLCJmaXJzdFBhdGgiLCJsYXN0UGF0aCIsImlzTmV3QmxvY2siLCJibG9ja1RleHQiLCJsZWFmVGV4dFJlbWFpbmluZyIsImxlYWZUZXh0T2Zmc2V0IiwicyIsImNhbGNEaXN0YW5jZSIsInBvaW50QmVmb3JlTG9jYXRpb24iLCJvd25LZXlzJDIiLCJfb2JqZWN0U3ByZWFkJDIiLCJlbmRCbG9jayIsInNraXAiLCJkZWxldGVUZXh0IiwiX0VkaXRvciR2b2lkIiwiX0VkaXRvciR2b2lkMiIsImhhbmdpbmciLCJmdXJ0aGVzdFZvaWQiLCJ2b2lkUGF0aCIsIm9wdHMiLCJlbmRPZkRvYyIsInN0YXJ0QmxvY2siLCJpc0Fjcm9zc0Jsb2NrcyIsImlzU2luZ2xlVGV4dCIsInN0YXJ0Tm9uRWRpdGFibGUiLCJlbmROb25FZGl0YWJsZSIsInJlbW92ZWRUZXh0IiwiX3BvaW50MiIsIl9ub2RlMiIsInN0YXJ0VW5yZWYiLCJlbmRVbnJlZiIsImJhdGNoRGlydHkiLCJpbmxpbmVFbGVtZW50TWF0Y2giLCJfaW5saW5lUGF0aCIsImJsb2NrTWF0Y2giLCJpc0Jsb2NrU3RhcnQiLCJpc0Jsb2NrRW5kIiwiaXNCbG9ja0VtcHR5IiwiZmlyc3RMZWFmUGF0aCIsImxhc3RMZWFmUGF0aCIsInNob3VsZEluc2VydCIsImlzUm9vdCIsInN0YXJ0aW5nIiwic3RhcnRzIiwibWlkZGxlcyIsImVuZHMiLCJpbmxpbmVNYXRjaCIsImlubGluZVBhdGgiLCJpc0lubGluZVN0YXJ0IiwiaXNJbmxpbmVFbmQiLCJtaWRkbGVSZWYiLCJzcGxpdEJsb2NrIiwib3duS2V5cyQxIiwiX29iamVjdFNwcmVhZCQxIiwib2xkUHJvcHMiLCJuZXdQcm9wcyIsImsiLCJpc0F0RW5kIiwiYmF0Y2hlZE9wcyIsIl9sb29wIiwicGFyZW50Tm9kZUVudHJ5IiwidG9QYXRoIiwiX3RvUGF0aCIsInNwbGl0UGF0aCIsIl90b1BhdGgyIiwiX2V4Y2x1ZGVkIiwiX2V4Y2x1ZGVkMiIsImhhc1NpbmdsZUNoaWxkTmVzdCIsImNvbW1vblBhdGgiLCJpc1ByZXZpb3VzU2libGluZyIsImVtcHR5QW5jZXN0b3IiLCJlbXB0eVJlZiIsInRvUmVmIiwidGFyZ2V0cyIsImRlcHRocyIsInNwbGl0TW9kZSIsImVuZEF0RW5kT2ZOb2RlIiwic3RhcnRBdFN0YXJ0T2ZOb2RlIiwicHJvcCIsIm5vZGVQcm9wIiwiaGFzQ2hhbmdlcyIsImRlbGV0ZVJhbmdlIiwiaGVpZ2h0IiwiYmVmb3JlUmVmIiwiYWZ0ZXJSZWYiLCJoaWdoZXN0Iiwidm9pZE1hdGNoIiwibnVkZ2UiLCJ2b2lkTm9kZSIsImFmdGVyUGF0aCIsInNpYmxpbmdIZWlnaHQiLCJoaWdoZXN0UGF0aCIsImxvd2VzdFBhdGgiLCJfYWZ0ZXJSZWYiLCJvd25LZXlzIiwiX29iamVjdFNwcmVhZCIsInJvb3RzIiwicm9vdFBhdGgiLCJjb21tb25Ob2RlRW50cnkiLCJjb21tb25Ob2RlIiwid3JhcHBlclBhdGgiLCJ3cmFwcGVyIiwiX3JldCIsImNyZWF0ZUVkaXRvciIsImFwcGx5JDEiLCJhcmdzIiwiYWRkTWFyayQxIiwiZGVsZXRlQmFja3dhcmQkMSIsIl9sZW4zIiwiZGVsZXRlRm9yd2FyZCQxIiwiX2xlbjQiLCJkZWxldGVGcmFnbWVudCQxIiwiX2xlbjUiLCJnZXRGcmFnbWVudCQxIiwiX2xlbjYiLCJpbnNlcnRCcmVhayQxIiwiX2xlbjciLCJfa2V5NyIsImluc2VydFNvZnRCcmVhayQxIiwiX2xlbjgiLCJfa2V5OCIsImluc2VydEZyYWdtZW50JDEiLCJfbGVuOSIsIl9rZXk5IiwiaW5zZXJ0Tm9kZSQxIiwiX2xlbjEwIiwiX2tleTEwIiwiaW5zZXJ0VGV4dCQxIiwiX2xlbjExIiwiX2tleTExIiwibm9ybWFsaXplTm9kZSQxIiwiX2xlbjEyIiwiX2tleTEyIiwicmVtb3ZlTWFyayQxIiwiX2xlbjEzIiwiX2tleTEzIiwiZ2V0RGlydHlQYXRocyQxIiwiX2xlbjE0IiwiX2tleTE0Iiwic2hvdWxkTm9ybWFsaXplJDEiLCJfbGVuMTUiLCJfa2V5MTUiLCJhYm92ZSQxIiwiX2xlbjE2IiwiX2tleTE2IiwiYWZ0ZXIkMSIsIl9sZW4xNyIsIl9rZXkxNyIsImJlZm9yZSQxIiwiX2xlbjE4IiwiX2tleTE4IiwiY29sbGFwc2UkMSIsIl9sZW4xOSIsIl9rZXkxOSIsIl9kZWxldGUiLCJfbGVuMjAiLCJfa2V5MjAiLCJkZXNlbGVjdCQxIiwiX2xlbjIxIiwiX2tleTIxIiwiZWRnZXMkMSIsIl9sZW4yMiIsIl9rZXkyMiIsImVsZW1lbnRSZWFkT25seSQxIiwiX2xlbjIzIiwiX2tleTIzIiwiZW5kJDEiLCJfbGVuMjQiLCJfa2V5MjQiLCJmaXJzdCQxIiwiX2xlbjI1IiwiX2tleTI1IiwiZnJhZ21lbnQkMSIsIl9sZW4yNiIsIl9rZXkyNiIsIl9sZW4yNyIsIl9rZXkyNyIsImhhc0Jsb2NrcyQxIiwiX2xlbjI4IiwiX2tleTI4IiwiaGFzSW5saW5lcyQxIiwiX2xlbjI5IiwiX2tleTI5IiwiaGFzUGF0aCQxIiwiX2xlbjMwIiwiX2tleTMwIiwiaGFzVGV4dHMkMSIsIl9sZW4zMSIsIl9rZXkzMSIsImluc2VydE5vZGVzJDEiLCJfbGVuMzIiLCJfa2V5MzIiLCJpc0Jsb2NrJDEiLCJfbGVuMzMiLCJfa2V5MzMiLCJpc0VkZ2UkMSIsIl9sZW4zNCIsIl9rZXkzNCIsImlzRW1wdHkkMSIsIl9sZW4zNSIsIl9rZXkzNSIsImlzRW5kJDEiLCJfbGVuMzYiLCJfa2V5MzYiLCJpc05vcm1hbGl6aW5nJDEiLCJfbGVuMzciLCJfa2V5MzciLCJpc1N0YXJ0JDEiLCJfbGVuMzgiLCJfa2V5MzgiLCJsYXN0JDEiLCJfbGVuMzkiLCJfa2V5MzkiLCJsZWFmJDEiLCJfbGVuNDAiLCJfa2V5NDAiLCJsZXZlbHMkMSIsIl9sZW40MSIsIl9rZXk0MSIsImxpZnROb2RlcyQxIiwiX2xlbjQyIiwiX2tleTQyIiwibWVyZ2VOb2RlcyQxIiwiX2xlbjQzIiwiX2tleTQzIiwibW92ZSQxIiwiX2xlbjQ0IiwiX2tleTQ0IiwibW92ZU5vZGVzJDEiLCJfbGVuNDUiLCJfa2V5NDUiLCJuZXh0JDEiLCJfbGVuNDYiLCJfa2V5NDYiLCJub2RlJDEiLCJfbGVuNDciLCJfa2V5NDciLCJub2RlcyQxIiwiX2xlbjQ4IiwiX2tleTQ4Iiwibm9ybWFsaXplJDEiLCJfbGVuNDkiLCJfa2V5NDkiLCJwYXJlbnQkMSIsIl9sZW41MCIsIl9rZXk1MCIsInBhdGgkMSIsIl9sZW41MSIsIl9rZXk1MSIsInBhdGhSZWYkMSIsIl9sZW41MiIsIl9rZXk1MiIsInBhdGhSZWZzJDEiLCJfbGVuNTMiLCJfa2V5NTMiLCJwb2ludCQxIiwiX2xlbjU0IiwiX2tleTU0IiwicG9pbnRSZWYkMSIsIl9sZW41NSIsIl9rZXk1NSIsInBvaW50UmVmcyQxIiwiX2xlbjU2IiwiX2tleTU2IiwicG9zaXRpb25zJDEiLCJfbGVuNTciLCJfa2V5NTciLCJwcmV2aW91cyQxIiwiX2xlbjU4IiwiX2tleTU4IiwicmFuZ2UkMSIsIl9sZW41OSIsIl9rZXk1OSIsInJhbmdlUmVmJDEiLCJfbGVuNjAiLCJfa2V5NjAiLCJyYW5nZVJlZnMkMSIsIl9sZW42MSIsIl9rZXk2MSIsInJlbW92ZU5vZGVzJDEiLCJfbGVuNjIiLCJfa2V5NjIiLCJzZWxlY3QkMSIsIl9sZW42MyIsIl9rZXk2MyIsInNldE5vZGVzJDEiLCJfbGVuNjQiLCJfa2V5NjQiLCJzZXROb3JtYWxpemluZyQxIiwiX2xlbjY1IiwiX2tleTY1Iiwic2V0UG9pbnQkMSIsIl9sZW42NiIsIl9rZXk2NiIsInNldFNlbGVjdGlvbiQxIiwiX2xlbjY3IiwiX2tleTY3Iiwic3BsaXROb2RlcyQxIiwiX2xlbjY4IiwiX2tleTY4Iiwic3RhcnQkMSIsIl9sZW42OSIsIl9rZXk2OSIsInN0cmluZyQxIiwiX2xlbjcwIiwiX2tleTcwIiwidW5oYW5nUmFuZ2UkMSIsIl9sZW43MSIsIl9rZXk3MSIsInVuc2V0Tm9kZXMkMSIsIl9sZW43MiIsIl9rZXk3MiIsInVud3JhcE5vZGVzJDEiLCJfbGVuNzMiLCJfa2V5NzMiLCJfdm9pZCIsIl9sZW43NCIsIl9rZXk3NCIsIndpdGhvdXROb3JtYWxpemluZyQxIiwiX2xlbjc1IiwiX2tleTc1Iiwid3JhcE5vZGVzJDEiLCJfbGVuNzYiLCJfa2V5NzYiLCJzaG91bGRNZXJnZU5vZGVzUmVtb3ZlUHJldk5vZGUkMSIsIl9sZW43NyIsIl9rZXk3NyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/slate/dist/index.es.js\n");

/***/ })

};
;