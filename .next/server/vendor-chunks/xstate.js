"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/xstate";
exports.ids = ["vendor-chunks/xstate"];
exports.modules = {

/***/ "(ssr)/./node_modules/xstate/actors/dist/xstate-actors.development.esm.js":
/*!**************************************************************************!*\
  !*** ./node_modules/xstate/actors/dist/xstate-actors.development.esm.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createEmptyActor: () => (/* binding */ createEmptyActor),\n/* harmony export */   fromCallback: () => (/* binding */ fromCallback),\n/* harmony export */   fromEventObservable: () => (/* binding */ fromEventObservable),\n/* harmony export */   fromObservable: () => (/* binding */ fromObservable),\n/* harmony export */   fromPromise: () => (/* binding */ fromPromise),\n/* harmony export */   fromTransition: () => (/* binding */ fromTransition)\n/* harmony export */ });\n/* harmony import */ var _dist_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dist/raise-78b8dcb8.development.esm.js */ \"(ssr)/./node_modules/xstate/dist/raise-78b8dcb8.development.esm.js\");\n/* harmony import */ var _dev_dist_xstate_dev_development_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../dev/dist/xstate-dev.development.esm.js */ \"(ssr)/./node_modules/xstate/dev/dist/xstate-dev.development.esm.js\");\n\n\n/**\n * Represents an actor created by `fromTransition`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import {\n *   fromTransition,\n *   createActor,\n *   type AnyActorSystem\n * } from 'xstate';\n *\n * //* The actor's stored context.\n * type Context = {\n *   // The current count.\n *   count: number;\n *   // The amount to increase `count` by.\n *   step: number;\n * };\n * // The events the actor receives.\n * type Event = { type: 'increment' };\n * // The actor's input.\n * type Input = { step?: number };\n *\n * // Actor logic that increments `count` by `step` when it receives an event of\n * // type `increment`.\n * const logic = fromTransition<Context, Event, AnyActorSystem, Input>(\n *   (state, event, actorScope) => {\n *     actorScope.self;\n *     //         ^? TransitionActorRef<Context, Event>\n *\n *     if (event.type === 'increment') {\n *       return {\n *         ...state,\n *         count: state.count + state.step\n *       };\n *     }\n *     return state;\n *   },\n *   ({ input, self }) => {\n *     self;\n *     // ^? TransitionActorRef<Context, Event>\n *\n *     return {\n *       count: 0,\n *       step: input.step ?? 1\n *     };\n *   }\n * );\n *\n * const actor = createActor(logic, { input: { step: 10 } });\n * //    ^? TransitionActorRef<Context, Event>\n * ```\n *\n * @see {@link fromTransition}\n */ /**\n * Returns actor logic given a transition function and its initial state.\n *\n * A “transition function” is a function that takes the current `state` and\n * received `event` object as arguments, and returns the next state, similar to\n * a reducer.\n *\n * Actors created from transition logic (“transition actors”) can:\n *\n * - Receive events\n * - Emit snapshots of its state\n *\n * The transition function’s `state` is used as its transition actor’s\n * `context`.\n *\n * Note that the \"state\" for a transition function is provided by the initial\n * state argument, and is not the same as the State object of an actor or a\n * state within a machine configuration.\n *\n * @example\n *\n * ```ts\n * const transitionLogic = fromTransition(\n *   (state, event) => {\n *     if (event.type === 'increment') {\n *       return {\n *         ...state,\n *         count: state.count + 1\n *       };\n *     }\n *     return state;\n *   },\n *   { count: 0 }\n * );\n *\n * const transitionActor = createActor(transitionLogic);\n * transitionActor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n * transitionActor.start();\n * // => {\n * //   status: 'active',\n * //   context: { count: 0 },\n * //   ...\n * // }\n *\n * transitionActor.send({ type: 'increment' });\n * // => {\n * //   status: 'active',\n * //   context: { count: 1 },\n * //   ...\n * // }\n * ```\n *\n * @param transition The transition function used to describe the transition\n *   logic. It should return the next state given the current state and event.\n *   It receives the following arguments:\n *\n *   - `state` - the current state.\n *   - `event` - the received event.\n *   - `actorScope` - the actor scope object, with properties like `self` and\n *       `system`.\n *\n * @param initialContext The initial state of the transition function, either an\n *   object representing the state, or a function which returns a state object.\n *   If a function, it will receive as its only argument an object with the\n *   following properties:\n *\n *   - `input` - the `input` provided to its parent transition actor.\n *   - `self` - a reference to its parent transition actor.\n *\n * @returns Actor logic\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n */ function fromTransition(transition, initialContext) {\n    return {\n        config: transition,\n        transition: (snapshot, event, actorScope)=>{\n            return {\n                ...snapshot,\n                context: transition(snapshot.context, event, actorScope)\n            };\n        },\n        getInitialSnapshot: (_, input)=>{\n            return {\n                status: \"active\",\n                output: undefined,\n                error: undefined,\n                context: typeof initialContext === \"function\" ? initialContext({\n                    input\n                }) : initialContext\n            };\n        },\n        getPersistedSnapshot: (snapshot)=>snapshot,\n        restoreSnapshot: (snapshot)=>snapshot\n    };\n}\nconst instanceStates = /* #__PURE__ */ new WeakMap();\n/**\n * Represents an actor created by `fromCallback`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import { fromCallback, createActor } from 'xstate';\n *\n * // The events the actor receives.\n * type Event = { type: 'someEvent' };\n * // The actor's input.\n * type Input = { name: string };\n *\n * // Actor logic that logs whenever it receives an event of type `someEvent`.\n * const logic = fromCallback<Event, Input>(({ self, input, receive }) => {\n *   self;\n *   // ^? CallbackActorRef<Event, Input>\n *\n *   receive((event) => {\n *     if (event.type === 'someEvent') {\n *       console.log(`${input.name}: received \"someEvent\" event`);\n *       // logs 'myActor: received \"someEvent\" event'\n *     }\n *   });\n * });\n *\n * const actor = createActor(logic, { input: { name: 'myActor' } });\n * //    ^? CallbackActorRef<Event, Input>\n * ```\n *\n * @see {@link fromCallback}\n */ /**\n * An actor logic creator which returns callback logic as defined by a callback\n * function.\n *\n * @remarks\n * Useful for subscription-based or other free-form logic that can send events\n * back to the parent actor.\n *\n * Actors created from callback logic (“callback actors”) can:\n *\n * - Receive events via the `receive` function\n * - Send events to the parent actor via the `sendBack` function\n *\n * Callback actors are a bit different from other actors in that they:\n *\n * - Do not work with `onDone`\n * - Do not produce a snapshot using `.getSnapshot()`\n * - Do not emit values when used with `.subscribe()`\n * - Can not be stopped with `.stop()`\n *\n * @example\n *\n * ```typescript\n * const callbackLogic = fromCallback(({ sendBack, receive }) => {\n *   let lockStatus = 'unlocked';\n *\n *   const handler = (event) => {\n *     if (lockStatus === 'locked') {\n *       return;\n *     }\n *     sendBack(event);\n *   };\n *\n *   receive((event) => {\n *     if (event.type === 'lock') {\n *       lockStatus = 'locked';\n *     } else if (event.type === 'unlock') {\n *       lockStatus = 'unlocked';\n *     }\n *   });\n *\n *   document.body.addEventListener('click', handler);\n *\n *   return () => {\n *     document.body.removeEventListener('click', handler);\n *   };\n * });\n * ```\n *\n * @param callback - The callback function used to describe the callback logic\n *   The callback function is passed an object with the following properties:\n *\n *   - `receive` - A function that can send events back to the parent actor; the\n *       listener is then called whenever events are received by the callback\n *       actor\n *   - `sendBack` - A function that can send events back to the parent actor\n *   - `input` - Data that was provided to the callback actor\n *   - `self` - The parent actor of the callback actor\n *   - `system` - The actor system to which the callback actor belongs The callback\n *       function can (optionally) return a cleanup function, which is called\n *       when the actor is stopped.\n *\n * @returns Callback logic\n * @see {@link CallbackLogicFunction} for more information about the callback function and its object argument\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n */ function fromCallback(callback) {\n    const logic = {\n        config: callback,\n        start: (state, actorScope)=>{\n            const { self, system, emit } = actorScope;\n            const callbackState = {\n                receivers: undefined,\n                dispose: undefined\n            };\n            instanceStates.set(self, callbackState);\n            callbackState.dispose = callback({\n                input: state.input,\n                system,\n                self,\n                sendBack: (event)=>{\n                    if (self.getSnapshot().status === \"stopped\") {\n                        return;\n                    }\n                    if (self._parent) {\n                        system._relay(self, self._parent, event);\n                    }\n                },\n                receive: (listener)=>{\n                    callbackState.receivers ??= new Set();\n                    callbackState.receivers.add(listener);\n                },\n                emit\n            });\n        },\n        transition: (state, event, actorScope)=>{\n            const callbackState = instanceStates.get(actorScope.self);\n            if (event.type === _dist_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.X) {\n                state = {\n                    ...state,\n                    status: \"stopped\",\n                    error: undefined\n                };\n                callbackState.dispose?.();\n                return state;\n            }\n            callbackState.receivers?.forEach((receiver)=>receiver(event));\n            return state;\n        },\n        getInitialSnapshot: (_, input)=>{\n            return {\n                status: \"active\",\n                output: undefined,\n                error: undefined,\n                input\n            };\n        },\n        getPersistedSnapshot: (snapshot)=>snapshot,\n        restoreSnapshot: (snapshot)=>snapshot\n    };\n    return logic;\n}\nconst XSTATE_OBSERVABLE_NEXT = \"xstate.observable.next\";\nconst XSTATE_OBSERVABLE_ERROR = \"xstate.observable.error\";\nconst XSTATE_OBSERVABLE_COMPLETE = \"xstate.observable.complete\";\n/**\n * Represents an actor created by `fromObservable` or `fromEventObservable`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import { fromObservable, createActor } from 'xstate';\n * import { interval } from 'rxjs';\n *\n * // The type of the value observed by the actor's logic.\n * type Context = number;\n * // The actor's input.\n * type Input = { period?: number };\n *\n * // Actor logic that observes a number incremented every `input.period`\n * // milliseconds (default: 1_000).\n * const logic = fromObservable<Context, Input>(({ input, self }) => {\n *   self;\n *   // ^? ObservableActorRef<Event, Input>\n *\n *   return interval(input.period ?? 1_000);\n * });\n *\n * const actor = createActor(logic, { input: { period: 2_000 } });\n * //    ^? ObservableActorRef<Event, Input>\n * ```\n *\n * @see {@link fromObservable}\n * @see {@link fromEventObservable}\n */ /**\n * Observable actor logic is described by an observable stream of values. Actors\n * created from observable logic (“observable actors”) can:\n *\n * - Emit snapshots of the observable’s emitted value\n *\n * The observable’s emitted value is used as its observable actor’s `context`.\n *\n * Sending events to observable actors will have no effect.\n *\n * @example\n *\n * ```ts\n * import { fromObservable, createActor } from 'xstate';\n * import { interval } from 'rxjs';\n *\n * const logic = fromObservable((obj) => interval(1000));\n *\n * const actor = createActor(logic);\n *\n * actor.subscribe((snapshot) => {\n *   console.log(snapshot.context);\n * });\n *\n * actor.start();\n * // At every second:\n * // Logs 0\n * // Logs 1\n * // Logs 2\n * // ...\n * ```\n *\n * @param observableCreator A function that creates an observable. It receives\n *   one argument, an object with the following properties:\n *\n *   - `input` - Data that was provided to the observable actor\n *   - `self` - The parent actor\n *   - `system` - The actor system to which the observable actor belongs\n *\n *   It should return a {@link Subscribable}, which is compatible with an RxJS\n *   Observable, although RxJS is not required to create them.\n * @see {@link https://rxjs.dev} for documentation on RxJS Observable and observable creators.\n * @see {@link Subscribable} interface in XState, which is based on and compatible with RxJS Observable.\n */ function fromObservable(observableCreator) {\n    // TODO: add event types\n    const logic = {\n        config: observableCreator,\n        transition: (snapshot, event)=>{\n            if (snapshot.status !== \"active\") {\n                return snapshot;\n            }\n            switch(event.type){\n                case XSTATE_OBSERVABLE_NEXT:\n                    {\n                        const newSnapshot = {\n                            ...snapshot,\n                            context: event.data\n                        };\n                        return newSnapshot;\n                    }\n                case XSTATE_OBSERVABLE_ERROR:\n                    return {\n                        ...snapshot,\n                        status: \"error\",\n                        error: event.data,\n                        input: undefined,\n                        _subscription: undefined\n                    };\n                case XSTATE_OBSERVABLE_COMPLETE:\n                    return {\n                        ...snapshot,\n                        status: \"done\",\n                        input: undefined,\n                        _subscription: undefined\n                    };\n                case _dist_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.X:\n                    snapshot._subscription.unsubscribe();\n                    return {\n                        ...snapshot,\n                        status: \"stopped\",\n                        input: undefined,\n                        _subscription: undefined\n                    };\n                default:\n                    return snapshot;\n            }\n        },\n        getInitialSnapshot: (_, input)=>{\n            return {\n                status: \"active\",\n                output: undefined,\n                error: undefined,\n                context: undefined,\n                input,\n                _subscription: undefined\n            };\n        },\n        start: (state, { self, system, emit })=>{\n            if (state.status === \"done\") {\n                // Do not restart a completed observable\n                return;\n            }\n            state._subscription = observableCreator({\n                input: state.input,\n                system,\n                self,\n                emit\n            }).subscribe({\n                next: (value)=>{\n                    system._relay(self, self, {\n                        type: XSTATE_OBSERVABLE_NEXT,\n                        data: value\n                    });\n                },\n                error: (err)=>{\n                    system._relay(self, self, {\n                        type: XSTATE_OBSERVABLE_ERROR,\n                        data: err\n                    });\n                },\n                complete: ()=>{\n                    system._relay(self, self, {\n                        type: XSTATE_OBSERVABLE_COMPLETE\n                    });\n                }\n            });\n        },\n        getPersistedSnapshot: ({ _subscription, ...state })=>state,\n        restoreSnapshot: (state)=>({\n                ...state,\n                _subscription: undefined\n            })\n    };\n    return logic;\n}\n/**\n * Creates event observable logic that listens to an observable that delivers\n * event objects.\n *\n * Event observable actor logic is described by an observable stream of\n * {@link https://stately.ai/docs/transitions#event-objects | event objects}.\n * Actors created from event observable logic (“event observable actors”) can:\n *\n * - Implicitly send events to its parent actor\n * - Emit snapshots of its emitted event objects\n *\n * Sending events to event observable actors will have no effect.\n *\n * @example\n *\n * ```ts\n * import {\n *   fromEventObservable,\n *   Subscribable,\n *   EventObject,\n *   createMachine,\n *   createActor\n * } from 'xstate';\n * import { fromEvent } from 'rxjs';\n *\n * const mouseClickLogic = fromEventObservable(\n *   () => fromEvent(document.body, 'click') as Subscribable<EventObject>\n * );\n *\n * const canvasMachine = createMachine({\n *   invoke: {\n *     // Will send mouse `click` events to the canvas actor\n *     src: mouseClickLogic\n *   }\n * });\n *\n * const canvasActor = createActor(canvasMachine);\n * canvasActor.start();\n * ```\n *\n * @param lazyObservable A function that creates an observable that delivers\n *   event objects. It receives one argument, an object with the following\n *   properties:\n *\n *   - `input` - Data that was provided to the event observable actor\n *   - `self` - The parent actor\n *   - `system` - The actor system to which the event observable actor belongs.\n *\n *   It should return a {@link Subscribable}, which is compatible with an RxJS\n *   Observable, although RxJS is not required to create them.\n */ function fromEventObservable(lazyObservable) {\n    // TODO: event types\n    const logic = {\n        config: lazyObservable,\n        transition: (state, event)=>{\n            if (state.status !== \"active\") {\n                return state;\n            }\n            switch(event.type){\n                case XSTATE_OBSERVABLE_ERROR:\n                    return {\n                        ...state,\n                        status: \"error\",\n                        error: event.data,\n                        input: undefined,\n                        _subscription: undefined\n                    };\n                case XSTATE_OBSERVABLE_COMPLETE:\n                    return {\n                        ...state,\n                        status: \"done\",\n                        input: undefined,\n                        _subscription: undefined\n                    };\n                case _dist_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.X:\n                    state._subscription.unsubscribe();\n                    return {\n                        ...state,\n                        status: \"stopped\",\n                        input: undefined,\n                        _subscription: undefined\n                    };\n                default:\n                    return state;\n            }\n        },\n        getInitialSnapshot: (_, input)=>{\n            return {\n                status: \"active\",\n                output: undefined,\n                error: undefined,\n                context: undefined,\n                input,\n                _subscription: undefined\n            };\n        },\n        start: (state, { self, system, emit })=>{\n            if (state.status === \"done\") {\n                // Do not restart a completed observable\n                return;\n            }\n            state._subscription = lazyObservable({\n                input: state.input,\n                system,\n                self,\n                emit\n            }).subscribe({\n                next: (value)=>{\n                    if (self._parent) {\n                        system._relay(self, self._parent, value);\n                    }\n                },\n                error: (err)=>{\n                    system._relay(self, self, {\n                        type: XSTATE_OBSERVABLE_ERROR,\n                        data: err\n                    });\n                },\n                complete: ()=>{\n                    system._relay(self, self, {\n                        type: XSTATE_OBSERVABLE_COMPLETE\n                    });\n                }\n            });\n        },\n        getPersistedSnapshot: ({ _subscription, ...snapshot })=>snapshot,\n        restoreSnapshot: (snapshot)=>({\n                ...snapshot,\n                _subscription: undefined\n            })\n    };\n    return logic;\n}\nconst XSTATE_PROMISE_RESOLVE = \"xstate.promise.resolve\";\nconst XSTATE_PROMISE_REJECT = \"xstate.promise.reject\";\n/**\n * Represents an actor created by `fromPromise`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import { fromPromise, createActor } from 'xstate';\n *\n * // The actor's resolved output\n * type Output = string;\n * // The actor's input.\n * type Input = { message: string };\n *\n * // Actor logic that fetches the url of an image of a cat saying `input.message`.\n * const logic = fromPromise<Output, Input>(async ({ input, self }) => {\n *   self;\n *   // ^? PromiseActorRef<Output, Input>\n *\n *   const data = await fetch(\n *     `https://cataas.com/cat/says/${input.message}`\n *   );\n *   const url = await data.json();\n *   return url;\n * });\n *\n * const actor = createActor(logic, { input: { message: 'hello world' } });\n * //    ^? PromiseActorRef<Output, Input>\n * ```\n *\n * @see {@link fromPromise}\n */ const controllerMap = new WeakMap();\n/**\n * An actor logic creator which returns promise logic as defined by an async\n * process that resolves or rejects after some time.\n *\n * Actors created from promise actor logic (“promise actors”) can:\n *\n * - Emit the resolved value of the promise\n * - Output the resolved value of the promise\n *\n * Sending events to promise actors will have no effect.\n *\n * @example\n *\n * ```ts\n * const promiseLogic = fromPromise(async () => {\n *   const result = await fetch('https://example.com/...').then((data) =>\n *     data.json()\n *   );\n *\n *   return result;\n * });\n *\n * const promiseActor = createActor(promiseLogic);\n * promiseActor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n * promiseActor.start();\n * // => {\n * //   output: undefined,\n * //   status: 'active'\n * //   ...\n * // }\n *\n * // After promise resolves\n * // => {\n * //   output: { ... },\n * //   status: 'done',\n * //   ...\n * // }\n * ```\n *\n * @param promiseCreator A function which returns a Promise, and accepts an\n *   object with the following properties:\n *\n *   - `input` - Data that was provided to the promise actor\n *   - `self` - The parent actor of the promise actor\n *   - `system` - The actor system to which the promise actor belongs\n *\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n */ function fromPromise(promiseCreator) {\n    const logic = {\n        config: promiseCreator,\n        transition: (state, event, scope)=>{\n            if (state.status !== \"active\") {\n                return state;\n            }\n            switch(event.type){\n                case XSTATE_PROMISE_RESOLVE:\n                    {\n                        const resolvedValue = event.data;\n                        return {\n                            ...state,\n                            status: \"done\",\n                            output: resolvedValue,\n                            input: undefined\n                        };\n                    }\n                case XSTATE_PROMISE_REJECT:\n                    return {\n                        ...state,\n                        status: \"error\",\n                        error: event.data,\n                        input: undefined\n                    };\n                case _dist_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.X:\n                    {\n                        controllerMap.get(scope.self)?.abort();\n                        return {\n                            ...state,\n                            status: \"stopped\",\n                            input: undefined\n                        };\n                    }\n                default:\n                    return state;\n            }\n        },\n        start: (state, { self, system, emit })=>{\n            // TODO: determine how to allow customizing this so that promises\n            // can be restarted if necessary\n            if (state.status !== \"active\") {\n                return;\n            }\n            const controller = new AbortController();\n            controllerMap.set(self, controller);\n            const resolvedPromise = Promise.resolve(promiseCreator({\n                input: state.input,\n                system,\n                self,\n                signal: controller.signal,\n                emit\n            }));\n            resolvedPromise.then((response)=>{\n                if (self.getSnapshot().status !== \"active\") {\n                    return;\n                }\n                controllerMap.delete(self);\n                system._relay(self, self, {\n                    type: XSTATE_PROMISE_RESOLVE,\n                    data: response\n                });\n            }, (errorData)=>{\n                if (self.getSnapshot().status !== \"active\") {\n                    return;\n                }\n                controllerMap.delete(self);\n                system._relay(self, self, {\n                    type: XSTATE_PROMISE_REJECT,\n                    data: errorData\n                });\n            });\n        },\n        getInitialSnapshot: (_, input)=>{\n            return {\n                status: \"active\",\n                output: undefined,\n                error: undefined,\n                input\n            };\n        },\n        getPersistedSnapshot: (snapshot)=>snapshot,\n        restoreSnapshot: (snapshot)=>snapshot\n    };\n    return logic;\n}\nconst emptyLogic = fromTransition((_)=>undefined, undefined);\nfunction createEmptyActor() {\n    return (0,_dist_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.c)(emptyLogic);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHN0YXRlL2FjdG9ycy9kaXN0L3hzdGF0ZS1hY3RvcnMuZGV2ZWxvcG1lbnQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWtHO0FBQzVDO0FBRXREOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F5REMsR0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXlFQyxHQUNELFNBQVNJLGVBQWVDLFVBQVUsRUFBRUMsY0FBYztJQUNoRCxPQUFPO1FBQ0xDLFFBQVFGO1FBQ1JBLFlBQVksQ0FBQ0csVUFBVUMsT0FBT0M7WUFDNUIsT0FBTztnQkFDTCxHQUFHRixRQUFRO2dCQUNYRyxTQUFTTixXQUFXRyxTQUFTRyxPQUFPLEVBQUVGLE9BQU9DO1lBQy9DO1FBQ0Y7UUFDQUUsb0JBQW9CLENBQUNDLEdBQUdDO1lBQ3RCLE9BQU87Z0JBQ0xDLFFBQVE7Z0JBQ1JDLFFBQVFDO2dCQUNSQyxPQUFPRDtnQkFDUE4sU0FBUyxPQUFPTCxtQkFBbUIsYUFBYUEsZUFBZTtvQkFDN0RRO2dCQUNGLEtBQUtSO1lBQ1A7UUFDRjtRQUNBYSxzQkFBc0JYLENBQUFBLFdBQVlBO1FBQ2xDWSxpQkFBaUJaLENBQUFBLFdBQVlBO0lBQy9CO0FBQ0Y7QUFFQSxNQUFNYSxpQkFBaUIsYUFBYSxHQUFFLElBQUlDO0FBRTFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQ0MsR0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpRUMsR0FDRCxTQUFTQyxhQUFhQyxRQUFRO0lBQzVCLE1BQU1DLFFBQVE7UUFDWmxCLFFBQVFpQjtRQUNSRSxPQUFPLENBQUNDLE9BQU9qQjtZQUNiLE1BQU0sRUFDSmtCLElB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QjtBQUNUO0FBRUEsTUFBTXdELGFBQWE3RSxlQUFlUyxDQUFBQSxJQUFLSSxXQUFXQTtBQUNsRCxTQUFTaUU7SUFDUCxPQUFPL0UsMEVBQVdBLENBQUM4RTtBQUNyQjtBQUU0RyIsInNvdXJjZXMiOlsid2VicGFjazovL2VyYS1wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMveHN0YXRlL2FjdG9ycy9kaXN0L3hzdGF0ZS1hY3RvcnMuZGV2ZWxvcG1lbnQuZXNtLmpzPzJiZjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgWCBhcyBYU1RBVEVfU1RPUCwgYyBhcyBjcmVhdGVBY3RvciB9IGZyb20gJy4uLy4uL2Rpc3QvcmFpc2UtNzhiOGRjYjguZGV2ZWxvcG1lbnQuZXNtLmpzJztcbmltcG9ydCAnLi4vLi4vZGV2L2Rpc3QveHN0YXRlLWRldi5kZXZlbG9wbWVudC5lc20uanMnO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gYWN0b3IgY3JlYXRlZCBieSBgZnJvbVRyYW5zaXRpb25gLlxuICpcbiAqIFRoZSB0eXBlIG9mIGBzZWxmYCB3aXRoaW4gdGhlIGFjdG9yJ3MgbG9naWMuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHtcbiAqICAgZnJvbVRyYW5zaXRpb24sXG4gKiAgIGNyZWF0ZUFjdG9yLFxuICogICB0eXBlIEFueUFjdG9yU3lzdGVtXG4gKiB9IGZyb20gJ3hzdGF0ZSc7XG4gKlxuICogLy8qIFRoZSBhY3RvcidzIHN0b3JlZCBjb250ZXh0LlxuICogdHlwZSBDb250ZXh0ID0ge1xuICogICAvLyBUaGUgY3VycmVudCBjb3VudC5cbiAqICAgY291bnQ6IG51bWJlcjtcbiAqICAgLy8gVGhlIGFtb3VudCB0byBpbmNyZWFzZSBgY291bnRgIGJ5LlxuICogICBzdGVwOiBudW1iZXI7XG4gKiB9O1xuICogLy8gVGhlIGV2ZW50cyB0aGUgYWN0b3IgcmVjZWl2ZXMuXG4gKiB0eXBlIEV2ZW50ID0geyB0eXBlOiAnaW5jcmVtZW50JyB9O1xuICogLy8gVGhlIGFjdG9yJ3MgaW5wdXQuXG4gKiB0eXBlIElucHV0ID0geyBzdGVwPzogbnVtYmVyIH07XG4gKlxuICogLy8gQWN0b3IgbG9naWMgdGhhdCBpbmNyZW1lbnRzIGBjb3VudGAgYnkgYHN0ZXBgIHdoZW4gaXQgcmVjZWl2ZXMgYW4gZXZlbnQgb2ZcbiAqIC8vIHR5cGUgYGluY3JlbWVudGAuXG4gKiBjb25zdCBsb2dpYyA9IGZyb21UcmFuc2l0aW9uPENvbnRleHQsIEV2ZW50LCBBbnlBY3RvclN5c3RlbSwgSW5wdXQ+KFxuICogICAoc3RhdGUsIGV2ZW50LCBhY3RvclNjb3BlKSA9PiB7XG4gKiAgICAgYWN0b3JTY29wZS5zZWxmO1xuICogICAgIC8vICAgICAgICAgXj8gVHJhbnNpdGlvbkFjdG9yUmVmPENvbnRleHQsIEV2ZW50PlxuICpcbiAqICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2luY3JlbWVudCcpIHtcbiAqICAgICAgIHJldHVybiB7XG4gKiAgICAgICAgIC4uLnN0YXRlLFxuICogICAgICAgICBjb3VudDogc3RhdGUuY291bnQgKyBzdGF0ZS5zdGVwXG4gKiAgICAgICB9O1xuICogICAgIH1cbiAqICAgICByZXR1cm4gc3RhdGU7XG4gKiAgIH0sXG4gKiAgICh7IGlucHV0LCBzZWxmIH0pID0+IHtcbiAqICAgICBzZWxmO1xuICogICAgIC8vIF4/IFRyYW5zaXRpb25BY3RvclJlZjxDb250ZXh0LCBFdmVudD5cbiAqXG4gKiAgICAgcmV0dXJuIHtcbiAqICAgICAgIGNvdW50OiAwLFxuICogICAgICAgc3RlcDogaW5wdXQuc3RlcCA/PyAxXG4gKiAgICAgfTtcbiAqICAgfVxuICogKTtcbiAqXG4gKiBjb25zdCBhY3RvciA9IGNyZWF0ZUFjdG9yKGxvZ2ljLCB7IGlucHV0OiB7IHN0ZXA6IDEwIH0gfSk7XG4gKiAvLyAgICBePyBUcmFuc2l0aW9uQWN0b3JSZWY8Q29udGV4dCwgRXZlbnQ+XG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayBmcm9tVHJhbnNpdGlvbn1cbiAqL1xuXG4vKipcbiAqIFJldHVybnMgYWN0b3IgbG9naWMgZ2l2ZW4gYSB0cmFuc2l0aW9uIGZ1bmN0aW9uIGFuZCBpdHMgaW5pdGlhbCBzdGF0ZS5cbiAqXG4gKiBBIOKAnHRyYW5zaXRpb24gZnVuY3Rpb27igJ0gaXMgYSBmdW5jdGlvbiB0aGF0IHRha2VzIHRoZSBjdXJyZW50IGBzdGF0ZWAgYW5kXG4gKiByZWNlaXZlZCBgZXZlbnRgIG9iamVjdCBhcyBhcmd1bWVudHMsIGFuZCByZXR1cm5zIHRoZSBuZXh0IHN0YXRlLCBzaW1pbGFyIHRvXG4gKiBhIHJlZHVjZXIuXG4gKlxuICogQWN0b3JzIGNyZWF0ZWQgZnJvbSB0cmFuc2l0aW9uIGxvZ2ljICjigJx0cmFuc2l0aW9uIGFjdG9yc+KAnSkgY2FuOlxuICpcbiAqIC0gUmVjZWl2ZSBldmVudHNcbiAqIC0gRW1pdCBzbmFwc2hvdHMgb2YgaXRzIHN0YXRlXG4gKlxuICogVGhlIHRyYW5zaXRpb24gZnVuY3Rpb27igJlzIGBzdGF0ZWAgaXMgdXNlZCBhcyBpdHMgdHJhbnNpdGlvbiBhY3RvcuKAmXNcbiAqIGBjb250ZXh0YC5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIFwic3RhdGVcIiBmb3IgYSB0cmFuc2l0aW9uIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIGJ5IHRoZSBpbml0aWFsXG4gKiBzdGF0ZSBhcmd1bWVudCwgYW5kIGlzIG5vdCB0aGUgc2FtZSBhcyB0aGUgU3RhdGUgb2JqZWN0IG9mIGFuIGFjdG9yIG9yIGFcbiAqIHN0YXRlIHdpdGhpbiBhIG1hY2hpbmUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCB0cmFuc2l0aW9uTG9naWMgPSBmcm9tVHJhbnNpdGlvbihcbiAqICAgKHN0YXRlLCBldmVudCkgPT4ge1xuICogICAgIGlmIChldmVudC50eXBlID09PSAnaW5jcmVtZW50Jykge1xuICogICAgICAgcmV0dXJuIHtcbiAqICAgICAgICAgLi4uc3RhdGUsXG4gKiAgICAgICAgIGNvdW50OiBzdGF0ZS5jb3VudCArIDFcbiAqICAgICAgIH07XG4gKiAgICAgfVxuICogICAgIHJldHVybiBzdGF0ZTtcbiAqICAgfSxcbiAqICAgeyBjb3VudDogMCB9XG4gKiApO1xuICpcbiAqIGNvbnN0IHRyYW5zaXRpb25BY3RvciA9IGNyZWF0ZUFjdG9yKHRyYW5zaXRpb25Mb2dpYyk7XG4gKiB0cmFuc2l0aW9uQWN0b3Iuc3Vic2NyaWJlKChzbmFwc2hvdCkgPT4ge1xuICogICBjb25zb2xlLmxvZyhzbmFwc2hvdCk7XG4gKiB9KTtcbiAqIHRyYW5zaXRpb25BY3Rvci5zdGFydCgpO1xuICogLy8gPT4ge1xuICogLy8gICBzdGF0dXM6ICdhY3RpdmUnLFxuICogLy8gICBjb250ZXh0OiB7IGNvdW50OiAwIH0sXG4gKiAvLyAgIC4uLlxuICogLy8gfVxuICpcbiAqIHRyYW5zaXRpb25BY3Rvci5zZW5kKHsgdHlwZTogJ2luY3JlbWVudCcgfSk7XG4gKiAvLyA9PiB7XG4gKiAvLyAgIHN0YXR1czogJ2FjdGl2ZScsXG4gKiAvLyAgIGNvbnRleHQ6IHsgY291bnQ6IDEgfSxcbiAqIC8vICAgLi4uXG4gKiAvLyB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdHJhbnNpdGlvbiBUaGUgdHJhbnNpdGlvbiBmdW5jdGlvbiB1c2VkIHRvIGRlc2NyaWJlIHRoZSB0cmFuc2l0aW9uXG4gKiAgIGxvZ2ljLiBJdCBzaG91bGQgcmV0dXJuIHRoZSBuZXh0IHN0YXRlIGdpdmVuIHRoZSBjdXJyZW50IHN0YXRlIGFuZCBldmVudC5cbiAqICAgSXQgcmVjZWl2ZXMgdGhlIGZvbGxvd2luZyBhcmd1bWVudHM6XG4gKlxuICogICAtIGBzdGF0ZWAgLSB0aGUgY3VycmVudCBzdGF0ZS5cbiAqICAgLSBgZXZlbnRgIC0gdGhlIHJlY2VpdmVkIGV2ZW50LlxuICogICAtIGBhY3RvclNjb3BlYCAtIHRoZSBhY3RvciBzY29wZSBvYmplY3QsIHdpdGggcHJvcGVydGllcyBsaWtlIGBzZWxmYCBhbmRcbiAqICAgICAgIGBzeXN0ZW1gLlxuICpcbiAqIEBwYXJhbSBpbml0aWFsQ29udGV4dCBUaGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgdHJhbnNpdGlvbiBmdW5jdGlvbiwgZWl0aGVyIGFuXG4gKiAgIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHN0YXRlLCBvciBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYSBzdGF0ZSBvYmplY3QuXG4gKiAgIElmIGEgZnVuY3Rpb24sIGl0IHdpbGwgcmVjZWl2ZSBhcyBpdHMgb25seSBhcmd1bWVudCBhbiBvYmplY3Qgd2l0aCB0aGVcbiAqICAgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGBpbnB1dGAgLSB0aGUgYGlucHV0YCBwcm92aWRlZCB0byBpdHMgcGFyZW50IHRyYW5zaXRpb24gYWN0b3IuXG4gKiAgIC0gYHNlbGZgIC0gYSByZWZlcmVuY2UgdG8gaXRzIHBhcmVudCB0cmFuc2l0aW9uIGFjdG9yLlxuICpcbiAqIEByZXR1cm5zIEFjdG9yIGxvZ2ljXG4gKiBAc2VlIHtAbGluayBodHRwczovL3N0YXRlbHkuYWkvZG9jcy9pbnB1dCB8IElucHV0IGRvY3N9IGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IGhvdyBpbnB1dCBpcyBwYXNzZWRcbiAqL1xuZnVuY3Rpb24gZnJvbVRyYW5zaXRpb24odHJhbnNpdGlvbiwgaW5pdGlhbENvbnRleHQpIHtcbiAgcmV0dXJuIHtcbiAgICBjb25maWc6IHRyYW5zaXRpb24sXG4gICAgdHJhbnNpdGlvbjogKHNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc25hcHNob3QsXG4gICAgICAgIGNvbnRleHQ6IHRyYW5zaXRpb24oc25hcHNob3QuY29udGV4dCwgZXZlbnQsIGFjdG9yU2NvcGUpXG4gICAgICB9O1xuICAgIH0sXG4gICAgZ2V0SW5pdGlhbFNuYXBzaG90OiAoXywgaW5wdXQpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogJ2FjdGl2ZScsXG4gICAgICAgIG91dHB1dDogdW5kZWZpbmVkLFxuICAgICAgICBlcnJvcjogdW5kZWZpbmVkLFxuICAgICAgICBjb250ZXh0OiB0eXBlb2YgaW5pdGlhbENvbnRleHQgPT09ICdmdW5jdGlvbicgPyBpbml0aWFsQ29udGV4dCh7XG4gICAgICAgICAgaW5wdXRcbiAgICAgICAgfSkgOiBpbml0aWFsQ29udGV4dFxuICAgICAgfTtcbiAgICB9LFxuICAgIGdldFBlcnNpc3RlZFNuYXBzaG90OiBzbmFwc2hvdCA9PiBzbmFwc2hvdCxcbiAgICByZXN0b3JlU25hcHNob3Q6IHNuYXBzaG90ID0+IHNuYXBzaG90XG4gIH07XG59XG5cbmNvbnN0IGluc3RhbmNlU3RhdGVzID0gLyogI19fUFVSRV9fICovbmV3IFdlYWtNYXAoKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGFjdG9yIGNyZWF0ZWQgYnkgYGZyb21DYWxsYmFja2AuXG4gKlxuICogVGhlIHR5cGUgb2YgYHNlbGZgIHdpdGhpbiB0aGUgYWN0b3IncyBsb2dpYy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBmcm9tQ2FsbGJhY2ssIGNyZWF0ZUFjdG9yIH0gZnJvbSAneHN0YXRlJztcbiAqXG4gKiAvLyBUaGUgZXZlbnRzIHRoZSBhY3RvciByZWNlaXZlcy5cbiAqIHR5cGUgRXZlbnQgPSB7IHR5cGU6ICdzb21lRXZlbnQnIH07XG4gKiAvLyBUaGUgYWN0b3IncyBpbnB1dC5cbiAqIHR5cGUgSW5wdXQgPSB7IG5hbWU6IHN0cmluZyB9O1xuICpcbiAqIC8vIEFjdG9yIGxvZ2ljIHRoYXQgbG9ncyB3aGVuZXZlciBpdCByZWNlaXZlcyBhbiBldmVudCBvZiB0eXBlIGBzb21lRXZlbnRgLlxuICogY29uc3QgbG9naWMgPSBmcm9tQ2FsbGJhY2s8RXZlbnQsIElucHV0PigoeyBzZWxmLCBpbnB1dCwgcmVjZWl2ZSB9KSA9PiB7XG4gKiAgIHNlbGY7XG4gKiAgIC8vIF4/IENhbGxiYWNrQWN0b3JSZWY8RXZlbnQsIElucHV0PlxuICpcbiAqICAgcmVjZWl2ZSgoZXZlbnQpID0+IHtcbiAqICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ3NvbWVFdmVudCcpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKGAke2lucHV0Lm5hbWV9OiByZWNlaXZlZCBcInNvbWVFdmVudFwiIGV2ZW50YCk7XG4gKiAgICAgICAvLyBsb2dzICdteUFjdG9yOiByZWNlaXZlZCBcInNvbWVFdmVudFwiIGV2ZW50J1xuICogICAgIH1cbiAqICAgfSk7XG4gKiB9KTtcbiAqXG4gKiBjb25zdCBhY3RvciA9IGNyZWF0ZUFjdG9yKGxvZ2ljLCB7IGlucHV0OiB7IG5hbWU6ICdteUFjdG9yJyB9IH0pO1xuICogLy8gICAgXj8gQ2FsbGJhY2tBY3RvclJlZjxFdmVudCwgSW5wdXQ+XG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayBmcm9tQ2FsbGJhY2t9XG4gKi9cblxuLyoqXG4gKiBBbiBhY3RvciBsb2dpYyBjcmVhdG9yIHdoaWNoIHJldHVybnMgY2FsbGJhY2sgbG9naWMgYXMgZGVmaW5lZCBieSBhIGNhbGxiYWNrXG4gKiBmdW5jdGlvbi5cbiAqXG4gKiBAcmVtYXJrc1xuICogVXNlZnVsIGZvciBzdWJzY3JpcHRpb24tYmFzZWQgb3Igb3RoZXIgZnJlZS1mb3JtIGxvZ2ljIHRoYXQgY2FuIHNlbmQgZXZlbnRzXG4gKiBiYWNrIHRvIHRoZSBwYXJlbnQgYWN0b3IuXG4gKlxuICogQWN0b3JzIGNyZWF0ZWQgZnJvbSBjYWxsYmFjayBsb2dpYyAo4oCcY2FsbGJhY2sgYWN0b3Jz4oCdKSBjYW46XG4gKlxuICogLSBSZWNlaXZlIGV2ZW50cyB2aWEgdGhlIGByZWNlaXZlYCBmdW5jdGlvblxuICogLSBTZW5kIGV2ZW50cyB0byB0aGUgcGFyZW50IGFjdG9yIHZpYSB0aGUgYHNlbmRCYWNrYCBmdW5jdGlvblxuICpcbiAqIENhbGxiYWNrIGFjdG9ycyBhcmUgYSBiaXQgZGlmZmVyZW50IGZyb20gb3RoZXIgYWN0b3JzIGluIHRoYXQgdGhleTpcbiAqXG4gKiAtIERvIG5vdCB3b3JrIHdpdGggYG9uRG9uZWBcbiAqIC0gRG8gbm90IHByb2R1Y2UgYSBzbmFwc2hvdCB1c2luZyBgLmdldFNuYXBzaG90KClgXG4gKiAtIERvIG5vdCBlbWl0IHZhbHVlcyB3aGVuIHVzZWQgd2l0aCBgLnN1YnNjcmliZSgpYFxuICogLSBDYW4gbm90IGJlIHN0b3BwZWQgd2l0aCBgLnN0b3AoKWBcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IGNhbGxiYWNrTG9naWMgPSBmcm9tQ2FsbGJhY2soKHsgc2VuZEJhY2ssIHJlY2VpdmUgfSkgPT4ge1xuICogICBsZXQgbG9ja1N0YXR1cyA9ICd1bmxvY2tlZCc7XG4gKlxuICogICBjb25zdCBoYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gKiAgICAgaWYgKGxvY2tTdGF0dXMgPT09ICdsb2NrZWQnKSB7XG4gKiAgICAgICByZXR1cm47XG4gKiAgICAgfVxuICogICAgIHNlbmRCYWNrKGV2ZW50KTtcbiAqICAgfTtcbiAqXG4gKiAgIHJlY2VpdmUoKGV2ZW50KSA9PiB7XG4gKiAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdsb2NrJykge1xuICogICAgICAgbG9ja1N0YXR1cyA9ICdsb2NrZWQnO1xuICogICAgIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ3VubG9jaycpIHtcbiAqICAgICAgIGxvY2tTdGF0dXMgPSAndW5sb2NrZWQnO1xuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlcik7XG4gKlxuICogICByZXR1cm4gKCkgPT4ge1xuICogICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVyKTtcbiAqICAgfTtcbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHBhcmFtIGNhbGxiYWNrIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHVzZWQgdG8gZGVzY3JpYmUgdGhlIGNhbGxiYWNrIGxvZ2ljXG4gKiAgIFRoZSBjYWxsYmFjayBmdW5jdGlvbiBpcyBwYXNzZWQgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBgcmVjZWl2ZWAgLSBBIGZ1bmN0aW9uIHRoYXQgY2FuIHNlbmQgZXZlbnRzIGJhY2sgdG8gdGhlIHBhcmVudCBhY3RvcjsgdGhlXG4gKiAgICAgICBsaXN0ZW5lciBpcyB0aGVuIGNhbGxlZCB3aGVuZXZlciBldmVudHMgYXJlIHJlY2VpdmVkIGJ5IHRoZSBjYWxsYmFja1xuICogICAgICAgYWN0b3JcbiAqICAgLSBgc2VuZEJhY2tgIC0gQSBmdW5jdGlvbiB0aGF0IGNhbiBzZW5kIGV2ZW50cyBiYWNrIHRvIHRoZSBwYXJlbnQgYWN0b3JcbiAqICAgLSBgaW5wdXRgIC0gRGF0YSB0aGF0IHdhcyBwcm92aWRlZCB0byB0aGUgY2FsbGJhY2sgYWN0b3JcbiAqICAgLSBgc2VsZmAgLSBUaGUgcGFyZW50IGFjdG9yIG9mIHRoZSBjYWxsYmFjayBhY3RvclxuICogICAtIGBzeXN0ZW1gIC0gVGhlIGFjdG9yIHN5c3RlbSB0byB3aGljaCB0aGUgY2FsbGJhY2sgYWN0b3IgYmVsb25ncyBUaGUgY2FsbGJhY2tcbiAqICAgICAgIGZ1bmN0aW9uIGNhbiAob3B0aW9uYWxseSkgcmV0dXJuIGEgY2xlYW51cCBmdW5jdGlvbiwgd2hpY2ggaXMgY2FsbGVkXG4gKiAgICAgICB3aGVuIHRoZSBhY3RvciBpcyBzdG9wcGVkLlxuICpcbiAqIEByZXR1cm5zIENhbGxiYWNrIGxvZ2ljXG4gKiBAc2VlIHtAbGluayBDYWxsYmFja0xvZ2ljRnVuY3Rpb259IGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjYWxsYmFjayBmdW5jdGlvbiBhbmQgaXRzIG9iamVjdCBhcmd1bWVudFxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9zdGF0ZWx5LmFpL2RvY3MvaW5wdXQgfCBJbnB1dCBkb2NzfSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBob3cgaW5wdXQgaXMgcGFzc2VkXG4gKi9cbmZ1bmN0aW9uIGZyb21DYWxsYmFjayhjYWxsYmFjaykge1xuICBjb25zdCBsb2dpYyA9IHtcbiAgICBjb25maWc6IGNhbGxiYWNrLFxuICAgIHN0YXJ0OiAoc3RhdGUsIGFjdG9yU2NvcGUpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2VsZixcbiAgICAgICAgc3lzdGVtLFxuICAgICAgICBlbWl0XG4gICAgICB9ID0gYWN0b3JTY29wZTtcbiAgICAgIGNvbnN0IGNhbGxiYWNrU3RhdGUgPSB7XG4gICAgICAgIHJlY2VpdmVyczogdW5kZWZpbmVkLFxuICAgICAgICBkaXNwb3NlOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgICBpbnN0YW5jZVN0YXRlcy5zZXQoc2VsZiwgY2FsbGJhY2tTdGF0ZSk7XG4gICAgICBjYWxsYmFja1N0YXRlLmRpc3Bvc2UgPSBjYWxsYmFjayh7XG4gICAgICAgIGlucHV0OiBzdGF0ZS5pbnB1dCxcbiAgICAgICAgc3lzdGVtLFxuICAgICAgICBzZWxmLFxuICAgICAgICBzZW5kQmFjazogZXZlbnQgPT4ge1xuICAgICAgICAgIGlmIChzZWxmLmdldFNuYXBzaG90KCkuc3RhdHVzID09PSAnc3RvcHBlZCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNlbGYuX3BhcmVudCkge1xuICAgICAgICAgICAgc3lzdGVtLl9yZWxheShzZWxmLCBzZWxmLl9wYXJlbnQsIGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlY2VpdmU6IGxpc3RlbmVyID0+IHtcbiAgICAgICAgICBjYWxsYmFja1N0YXRlLnJlY2VpdmVycyA/Pz0gbmV3IFNldCgpO1xuICAgICAgICAgIGNhbGxiYWNrU3RhdGUucmVjZWl2ZXJzLmFkZChsaXN0ZW5lcik7XG4gICAgICAgIH0sXG4gICAgICAgIGVtaXRcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgdHJhbnNpdGlvbjogKHN0YXRlLCBldmVudCwgYWN0b3JTY29wZSkgPT4ge1xuICAgICAgY29uc3QgY2FsbGJhY2tTdGF0ZSA9IGluc3RhbmNlU3RhdGVzLmdldChhY3RvclNjb3BlLnNlbGYpO1xuICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IFhTVEFURV9TVE9QKSB7XG4gICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgIHN0YXR1czogJ3N0b3BwZWQnLFxuICAgICAgICAgIGVycm9yOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICAgICAgY2FsbGJhY2tTdGF0ZS5kaXNwb3NlPy4oKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2tTdGF0ZS5yZWNlaXZlcnM/LmZvckVhY2gocmVjZWl2ZXIgPT4gcmVjZWl2ZXIoZXZlbnQpKTtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9LFxuICAgIGdldEluaXRpYWxTbmFwc2hvdDogKF8sIGlucHV0KSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6ICdhY3RpdmUnLFxuICAgICAgICBvdXRwdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgZXJyb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgaW5wdXRcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXRQZXJzaXN0ZWRTbmFwc2hvdDogc25hcHNob3QgPT4gc25hcHNob3QsXG4gICAgcmVzdG9yZVNuYXBzaG90OiBzbmFwc2hvdCA9PiBzbmFwc2hvdFxuICB9O1xuICByZXR1cm4gbG9naWM7XG59XG5cbmNvbnN0IFhTVEFURV9PQlNFUlZBQkxFX05FWFQgPSAneHN0YXRlLm9ic2VydmFibGUubmV4dCc7XG5jb25zdCBYU1RBVEVfT0JTRVJWQUJMRV9FUlJPUiA9ICd4c3RhdGUub2JzZXJ2YWJsZS5lcnJvcic7XG5jb25zdCBYU1RBVEVfT0JTRVJWQUJMRV9DT01QTEVURSA9ICd4c3RhdGUub2JzZXJ2YWJsZS5jb21wbGV0ZSc7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBhY3RvciBjcmVhdGVkIGJ5IGBmcm9tT2JzZXJ2YWJsZWAgb3IgYGZyb21FdmVudE9ic2VydmFibGVgLlxuICpcbiAqIFRoZSB0eXBlIG9mIGBzZWxmYCB3aXRoaW4gdGhlIGFjdG9yJ3MgbG9naWMuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgZnJvbU9ic2VydmFibGUsIGNyZWF0ZUFjdG9yIH0gZnJvbSAneHN0YXRlJztcbiAqIGltcG9ydCB7IGludGVydmFsIH0gZnJvbSAncnhqcyc7XG4gKlxuICogLy8gVGhlIHR5cGUgb2YgdGhlIHZhbHVlIG9ic2VydmVkIGJ5IHRoZSBhY3RvcidzIGxvZ2ljLlxuICogdHlwZSBDb250ZXh0ID0gbnVtYmVyO1xuICogLy8gVGhlIGFjdG9yJ3MgaW5wdXQuXG4gKiB0eXBlIElucHV0ID0geyBwZXJpb2Q/OiBudW1iZXIgfTtcbiAqXG4gKiAvLyBBY3RvciBsb2dpYyB0aGF0IG9ic2VydmVzIGEgbnVtYmVyIGluY3JlbWVudGVkIGV2ZXJ5IGBpbnB1dC5wZXJpb2RgXG4gKiAvLyBtaWxsaXNlY29uZHMgKGRlZmF1bHQ6IDFfMDAwKS5cbiAqIGNvbnN0IGxvZ2ljID0gZnJvbU9ic2VydmFibGU8Q29udGV4dCwgSW5wdXQ+KCh7IGlucHV0LCBzZWxmIH0pID0+IHtcbiAqICAgc2VsZjtcbiAqICAgLy8gXj8gT2JzZXJ2YWJsZUFjdG9yUmVmPEV2ZW50LCBJbnB1dD5cbiAqXG4gKiAgIHJldHVybiBpbnRlcnZhbChpbnB1dC5wZXJpb2QgPz8gMV8wMDApO1xuICogfSk7XG4gKlxuICogY29uc3QgYWN0b3IgPSBjcmVhdGVBY3Rvcihsb2dpYywgeyBpbnB1dDogeyBwZXJpb2Q6IDJfMDAwIH0gfSk7XG4gKiAvLyAgICBePyBPYnNlcnZhYmxlQWN0b3JSZWY8RXZlbnQsIElucHV0PlxuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgZnJvbU9ic2VydmFibGV9XG4gKiBAc2VlIHtAbGluayBmcm9tRXZlbnRPYnNlcnZhYmxlfVxuICovXG5cbi8qKlxuICogT2JzZXJ2YWJsZSBhY3RvciBsb2dpYyBpcyBkZXNjcmliZWQgYnkgYW4gb2JzZXJ2YWJsZSBzdHJlYW0gb2YgdmFsdWVzLiBBY3RvcnNcbiAqIGNyZWF0ZWQgZnJvbSBvYnNlcnZhYmxlIGxvZ2ljICjigJxvYnNlcnZhYmxlIGFjdG9yc+KAnSkgY2FuOlxuICpcbiAqIC0gRW1pdCBzbmFwc2hvdHMgb2YgdGhlIG9ic2VydmFibGXigJlzIGVtaXR0ZWQgdmFsdWVcbiAqXG4gKiBUaGUgb2JzZXJ2YWJsZeKAmXMgZW1pdHRlZCB2YWx1ZSBpcyB1c2VkIGFzIGl0cyBvYnNlcnZhYmxlIGFjdG9y4oCZcyBgY29udGV4dGAuXG4gKlxuICogU2VuZGluZyBldmVudHMgdG8gb2JzZXJ2YWJsZSBhY3RvcnMgd2lsbCBoYXZlIG5vIGVmZmVjdC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBmcm9tT2JzZXJ2YWJsZSwgY3JlYXRlQWN0b3IgfSBmcm9tICd4c3RhdGUnO1xuICogaW1wb3J0IHsgaW50ZXJ2YWwgfSBmcm9tICdyeGpzJztcbiAqXG4gKiBjb25zdCBsb2dpYyA9IGZyb21PYnNlcnZhYmxlKChvYmopID0+IGludGVydmFsKDEwMDApKTtcbiAqXG4gKiBjb25zdCBhY3RvciA9IGNyZWF0ZUFjdG9yKGxvZ2ljKTtcbiAqXG4gKiBhY3Rvci5zdWJzY3JpYmUoKHNuYXBzaG90KSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKHNuYXBzaG90LmNvbnRleHQpO1xuICogfSk7XG4gKlxuICogYWN0b3Iuc3RhcnQoKTtcbiAqIC8vIEF0IGV2ZXJ5IHNlY29uZDpcbiAqIC8vIExvZ3MgMFxuICogLy8gTG9ncyAxXG4gKiAvLyBMb2dzIDJcbiAqIC8vIC4uLlxuICogYGBgXG4gKlxuICogQHBhcmFtIG9ic2VydmFibGVDcmVhdG9yIEEgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGFuIG9ic2VydmFibGUuIEl0IHJlY2VpdmVzXG4gKiAgIG9uZSBhcmd1bWVudCwgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBgaW5wdXRgIC0gRGF0YSB0aGF0IHdhcyBwcm92aWRlZCB0byB0aGUgb2JzZXJ2YWJsZSBhY3RvclxuICogICAtIGBzZWxmYCAtIFRoZSBwYXJlbnQgYWN0b3JcbiAqICAgLSBgc3lzdGVtYCAtIFRoZSBhY3RvciBzeXN0ZW0gdG8gd2hpY2ggdGhlIG9ic2VydmFibGUgYWN0b3IgYmVsb25nc1xuICpcbiAqICAgSXQgc2hvdWxkIHJldHVybiBhIHtAbGluayBTdWJzY3JpYmFibGV9LCB3aGljaCBpcyBjb21wYXRpYmxlIHdpdGggYW4gUnhKU1xuICogICBPYnNlcnZhYmxlLCBhbHRob3VnaCBSeEpTIGlzIG5vdCByZXF1aXJlZCB0byBjcmVhdGUgdGhlbS5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vcnhqcy5kZXZ9IGZvciBkb2N1bWVudGF0aW9uIG9uIFJ4SlMgT2JzZXJ2YWJsZSBhbmQgb2JzZXJ2YWJsZSBjcmVhdG9ycy5cbiAqIEBzZWUge0BsaW5rIFN1YnNjcmliYWJsZX0gaW50ZXJmYWNlIGluIFhTdGF0ZSwgd2hpY2ggaXMgYmFzZWQgb24gYW5kIGNvbXBhdGlibGUgd2l0aCBSeEpTIE9ic2VydmFibGUuXG4gKi9cbmZ1bmN0aW9uIGZyb21PYnNlcnZhYmxlKG9ic2VydmFibGVDcmVhdG9yKSB7XG4gIC8vIFRPRE86IGFkZCBldmVudCB0eXBlc1xuICBjb25zdCBsb2dpYyA9IHtcbiAgICBjb25maWc6IG9ic2VydmFibGVDcmVhdG9yLFxuICAgIHRyYW5zaXRpb246IChzbmFwc2hvdCwgZXZlbnQpID0+IHtcbiAgICAgIGlmIChzbmFwc2hvdC5zdGF0dXMgIT09ICdhY3RpdmUnKSB7XG4gICAgICAgIHJldHVybiBzbmFwc2hvdDtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICBjYXNlIFhTVEFURV9PQlNFUlZBQkxFX05FWFQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgbmV3U25hcHNob3QgPSB7XG4gICAgICAgICAgICAgIC4uLnNuYXBzaG90LFxuICAgICAgICAgICAgICBjb250ZXh0OiBldmVudC5kYXRhXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIG5ld1NuYXBzaG90O1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBYU1RBVEVfT0JTRVJWQUJMRV9FUlJPUjpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc25hcHNob3QsXG4gICAgICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgICAgICBlcnJvcjogZXZlbnQuZGF0YSxcbiAgICAgICAgICAgIGlucHV0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBfc3Vic2NyaXB0aW9uOiB1bmRlZmluZWRcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFhTVEFURV9PQlNFUlZBQkxFX0NPTVBMRVRFOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zbmFwc2hvdCxcbiAgICAgICAgICAgIHN0YXR1czogJ2RvbmUnLFxuICAgICAgICAgICAgaW5wdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIF9zdWJzY3JpcHRpb246IHVuZGVmaW5lZFxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgWFNUQVRFX1NUT1A6XG4gICAgICAgICAgc25hcHNob3QuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zbmFwc2hvdCxcbiAgICAgICAgICAgIHN0YXR1czogJ3N0b3BwZWQnLFxuICAgICAgICAgICAgaW5wdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIF9zdWJzY3JpcHRpb246IHVuZGVmaW5lZFxuICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHNuYXBzaG90O1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0SW5pdGlhbFNuYXBzaG90OiAoXywgaW5wdXQpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogJ2FjdGl2ZScsXG4gICAgICAgIG91dHB1dDogdW5kZWZpbmVkLFxuICAgICAgICBlcnJvcjogdW5kZWZpbmVkLFxuICAgICAgICBjb250ZXh0OiB1bmRlZmluZWQsXG4gICAgICAgIGlucHV0LFxuICAgICAgICBfc3Vic2NyaXB0aW9uOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgfSxcbiAgICBzdGFydDogKHN0YXRlLCB7XG4gICAgICBzZWxmLFxuICAgICAgc3lzdGVtLFxuICAgICAgZW1pdFxuICAgIH0pID0+IHtcbiAgICAgIGlmIChzdGF0ZS5zdGF0dXMgPT09ICdkb25lJykge1xuICAgICAgICAvLyBEbyBub3QgcmVzdGFydCBhIGNvbXBsZXRlZCBvYnNlcnZhYmxlXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN0YXRlLl9zdWJzY3JpcHRpb24gPSBvYnNlcnZhYmxlQ3JlYXRvcih7XG4gICAgICAgIGlucHV0OiBzdGF0ZS5pbnB1dCxcbiAgICAgICAgc3lzdGVtLFxuICAgICAgICBzZWxmLFxuICAgICAgICBlbWl0XG4gICAgICB9KS5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiB2YWx1ZSA9PiB7XG4gICAgICAgICAgc3lzdGVtLl9yZWxheShzZWxmLCBzZWxmLCB7XG4gICAgICAgICAgICB0eXBlOiBYU1RBVEVfT0JTRVJWQUJMRV9ORVhULFxuICAgICAgICAgICAgZGF0YTogdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IGVyciA9PiB7XG4gICAgICAgICAgc3lzdGVtLl9yZWxheShzZWxmLCBzZWxmLCB7XG4gICAgICAgICAgICB0eXBlOiBYU1RBVEVfT0JTRVJWQUJMRV9FUlJPUixcbiAgICAgICAgICAgIGRhdGE6IGVyclxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAgIHN5c3RlbS5fcmVsYXkoc2VsZiwgc2VsZiwge1xuICAgICAgICAgICAgdHlwZTogWFNUQVRFX09CU0VSVkFCTEVfQ09NUExFVEVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXRQZXJzaXN0ZWRTbmFwc2hvdDogKHtcbiAgICAgIF9zdWJzY3JpcHRpb24sXG4gICAgICAuLi5zdGF0ZVxuICAgIH0pID0+IHN0YXRlLFxuICAgIHJlc3RvcmVTbmFwc2hvdDogc3RhdGUgPT4gKHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgX3N1YnNjcmlwdGlvbjogdW5kZWZpbmVkXG4gICAgfSlcbiAgfTtcbiAgcmV0dXJuIGxvZ2ljO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgZXZlbnQgb2JzZXJ2YWJsZSBsb2dpYyB0aGF0IGxpc3RlbnMgdG8gYW4gb2JzZXJ2YWJsZSB0aGF0IGRlbGl2ZXJzXG4gKiBldmVudCBvYmplY3RzLlxuICpcbiAqIEV2ZW50IG9ic2VydmFibGUgYWN0b3IgbG9naWMgaXMgZGVzY3JpYmVkIGJ5IGFuIG9ic2VydmFibGUgc3RyZWFtIG9mXG4gKiB7QGxpbmsgaHR0cHM6Ly9zdGF0ZWx5LmFpL2RvY3MvdHJhbnNpdGlvbnMjZXZlbnQtb2JqZWN0cyB8IGV2ZW50IG9iamVjdHN9LlxuICogQWN0b3JzIGNyZWF0ZWQgZnJvbSBldmVudCBvYnNlcnZhYmxlIGxvZ2ljICjigJxldmVudCBvYnNlcnZhYmxlIGFjdG9yc+KAnSkgY2FuOlxuICpcbiAqIC0gSW1wbGljaXRseSBzZW5kIGV2ZW50cyB0byBpdHMgcGFyZW50IGFjdG9yXG4gKiAtIEVtaXQgc25hcHNob3RzIG9mIGl0cyBlbWl0dGVkIGV2ZW50IG9iamVjdHNcbiAqXG4gKiBTZW5kaW5nIGV2ZW50cyB0byBldmVudCBvYnNlcnZhYmxlIGFjdG9ycyB3aWxsIGhhdmUgbm8gZWZmZWN0LlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7XG4gKiAgIGZyb21FdmVudE9ic2VydmFibGUsXG4gKiAgIFN1YnNjcmliYWJsZSxcbiAqICAgRXZlbnRPYmplY3QsXG4gKiAgIGNyZWF0ZU1hY2hpbmUsXG4gKiAgIGNyZWF0ZUFjdG9yXG4gKiB9IGZyb20gJ3hzdGF0ZSc7XG4gKiBpbXBvcnQgeyBmcm9tRXZlbnQgfSBmcm9tICdyeGpzJztcbiAqXG4gKiBjb25zdCBtb3VzZUNsaWNrTG9naWMgPSBmcm9tRXZlbnRPYnNlcnZhYmxlKFxuICogICAoKSA9PiBmcm9tRXZlbnQoZG9jdW1lbnQuYm9keSwgJ2NsaWNrJykgYXMgU3Vic2NyaWJhYmxlPEV2ZW50T2JqZWN0PlxuICogKTtcbiAqXG4gKiBjb25zdCBjYW52YXNNYWNoaW5lID0gY3JlYXRlTWFjaGluZSh7XG4gKiAgIGludm9rZToge1xuICogICAgIC8vIFdpbGwgc2VuZCBtb3VzZSBgY2xpY2tgIGV2ZW50cyB0byB0aGUgY2FudmFzIGFjdG9yXG4gKiAgICAgc3JjOiBtb3VzZUNsaWNrTG9naWNcbiAqICAgfVxuICogfSk7XG4gKlxuICogY29uc3QgY2FudmFzQWN0b3IgPSBjcmVhdGVBY3RvcihjYW52YXNNYWNoaW5lKTtcbiAqIGNhbnZhc0FjdG9yLnN0YXJ0KCk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gbGF6eU9ic2VydmFibGUgQSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYW4gb2JzZXJ2YWJsZSB0aGF0IGRlbGl2ZXJzXG4gKiAgIGV2ZW50IG9iamVjdHMuIEl0IHJlY2VpdmVzIG9uZSBhcmd1bWVudCwgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZ1xuICogICBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBgaW5wdXRgIC0gRGF0YSB0aGF0IHdhcyBwcm92aWRlZCB0byB0aGUgZXZlbnQgb2JzZXJ2YWJsZSBhY3RvclxuICogICAtIGBzZWxmYCAtIFRoZSBwYXJlbnQgYWN0b3JcbiAqICAgLSBgc3lzdGVtYCAtIFRoZSBhY3RvciBzeXN0ZW0gdG8gd2hpY2ggdGhlIGV2ZW50IG9ic2VydmFibGUgYWN0b3IgYmVsb25ncy5cbiAqXG4gKiAgIEl0IHNob3VsZCByZXR1cm4gYSB7QGxpbmsgU3Vic2NyaWJhYmxlfSwgd2hpY2ggaXMgY29tcGF0aWJsZSB3aXRoIGFuIFJ4SlNcbiAqICAgT2JzZXJ2YWJsZSwgYWx0aG91Z2ggUnhKUyBpcyBub3QgcmVxdWlyZWQgdG8gY3JlYXRlIHRoZW0uXG4gKi9cbmZ1bmN0aW9uIGZyb21FdmVudE9ic2VydmFibGUobGF6eU9ic2VydmFibGUpIHtcbiAgLy8gVE9ETzogZXZlbnQgdHlwZXNcbiAgY29uc3QgbG9naWMgPSB7XG4gICAgY29uZmlnOiBsYXp5T2JzZXJ2YWJsZSxcbiAgICB0cmFuc2l0aW9uOiAoc3RhdGUsIGV2ZW50KSA9PiB7XG4gICAgICBpZiAoc3RhdGUuc3RhdHVzICE9PSAnYWN0aXZlJykge1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgY2FzZSBYU1RBVEVfT0JTRVJWQUJMRV9FUlJPUjpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgICAgICBlcnJvcjogZXZlbnQuZGF0YSxcbiAgICAgICAgICAgIGlucHV0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBfc3Vic2NyaXB0aW9uOiB1bmRlZmluZWRcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFhTVEFURV9PQlNFUlZBQkxFX0NPTVBMRVRFOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgIHN0YXR1czogJ2RvbmUnLFxuICAgICAgICAgICAgaW5wdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIF9zdWJzY3JpcHRpb246IHVuZGVmaW5lZFxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgWFNUQVRFX1NUT1A6XG4gICAgICAgICAgc3RhdGUuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgIHN0YXR1czogJ3N0b3BwZWQnLFxuICAgICAgICAgICAgaW5wdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIF9zdWJzY3JpcHRpb246IHVuZGVmaW5lZFxuICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0SW5pdGlhbFNuYXBzaG90OiAoXywgaW5wdXQpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogJ2FjdGl2ZScsXG4gICAgICAgIG91dHB1dDogdW5kZWZpbmVkLFxuICAgICAgICBlcnJvcjogdW5kZWZpbmVkLFxuICAgICAgICBjb250ZXh0OiB1bmRlZmluZWQsXG4gICAgICAgIGlucHV0LFxuICAgICAgICBfc3Vic2NyaXB0aW9uOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgfSxcbiAgICBzdGFydDogKHN0YXRlLCB7XG4gICAgICBzZWxmLFxuICAgICAgc3lzdGVtLFxuICAgICAgZW1pdFxuICAgIH0pID0+IHtcbiAgICAgIGlmIChzdGF0ZS5zdGF0dXMgPT09ICdkb25lJykge1xuICAgICAgICAvLyBEbyBub3QgcmVzdGFydCBhIGNvbXBsZXRlZCBvYnNlcnZhYmxlXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN0YXRlLl9zdWJzY3JpcHRpb24gPSBsYXp5T2JzZXJ2YWJsZSh7XG4gICAgICAgIGlucHV0OiBzdGF0ZS5pbnB1dCxcbiAgICAgICAgc3lzdGVtLFxuICAgICAgICBzZWxmLFxuICAgICAgICBlbWl0XG4gICAgICB9KS5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiB2YWx1ZSA9PiB7XG4gICAgICAgICAgaWYgKHNlbGYuX3BhcmVudCkge1xuICAgICAgICAgICAgc3lzdGVtLl9yZWxheShzZWxmLCBzZWxmLl9wYXJlbnQsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBlcnIgPT4ge1xuICAgICAgICAgIHN5c3RlbS5fcmVsYXkoc2VsZiwgc2VsZiwge1xuICAgICAgICAgICAgdHlwZTogWFNUQVRFX09CU0VSVkFCTEVfRVJST1IsXG4gICAgICAgICAgICBkYXRhOiBlcnJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICBzeXN0ZW0uX3JlbGF5KHNlbGYsIHNlbGYsIHtcbiAgICAgICAgICAgIHR5cGU6IFhTVEFURV9PQlNFUlZBQkxFX0NPTVBMRVRFXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0UGVyc2lzdGVkU25hcHNob3Q6ICh7XG4gICAgICBfc3Vic2NyaXB0aW9uLFxuICAgICAgLi4uc25hcHNob3RcbiAgICB9KSA9PiBzbmFwc2hvdCxcbiAgICByZXN0b3JlU25hcHNob3Q6IHNuYXBzaG90ID0+ICh7XG4gICAgICAuLi5zbmFwc2hvdCxcbiAgICAgIF9zdWJzY3JpcHRpb246IHVuZGVmaW5lZFxuICAgIH0pXG4gIH07XG4gIHJldHVybiBsb2dpYztcbn1cblxuY29uc3QgWFNUQVRFX1BST01JU0VfUkVTT0xWRSA9ICd4c3RhdGUucHJvbWlzZS5yZXNvbHZlJztcbmNvbnN0IFhTVEFURV9QUk9NSVNFX1JFSkVDVCA9ICd4c3RhdGUucHJvbWlzZS5yZWplY3QnO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gYWN0b3IgY3JlYXRlZCBieSBgZnJvbVByb21pc2VgLlxuICpcbiAqIFRoZSB0eXBlIG9mIGBzZWxmYCB3aXRoaW4gdGhlIGFjdG9yJ3MgbG9naWMuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgZnJvbVByb21pc2UsIGNyZWF0ZUFjdG9yIH0gZnJvbSAneHN0YXRlJztcbiAqXG4gKiAvLyBUaGUgYWN0b3IncyByZXNvbHZlZCBvdXRwdXRcbiAqIHR5cGUgT3V0cHV0ID0gc3RyaW5nO1xuICogLy8gVGhlIGFjdG9yJ3MgaW5wdXQuXG4gKiB0eXBlIElucHV0ID0geyBtZXNzYWdlOiBzdHJpbmcgfTtcbiAqXG4gKiAvLyBBY3RvciBsb2dpYyB0aGF0IGZldGNoZXMgdGhlIHVybCBvZiBhbiBpbWFnZSBvZiBhIGNhdCBzYXlpbmcgYGlucHV0Lm1lc3NhZ2VgLlxuICogY29uc3QgbG9naWMgPSBmcm9tUHJvbWlzZTxPdXRwdXQsIElucHV0Pihhc3luYyAoeyBpbnB1dCwgc2VsZiB9KSA9PiB7XG4gKiAgIHNlbGY7XG4gKiAgIC8vIF4/IFByb21pc2VBY3RvclJlZjxPdXRwdXQsIElucHV0PlxuICpcbiAqICAgY29uc3QgZGF0YSA9IGF3YWl0IGZldGNoKFxuICogICAgIGBodHRwczovL2NhdGFhcy5jb20vY2F0L3NheXMvJHtpbnB1dC5tZXNzYWdlfWBcbiAqICAgKTtcbiAqICAgY29uc3QgdXJsID0gYXdhaXQgZGF0YS5qc29uKCk7XG4gKiAgIHJldHVybiB1cmw7XG4gKiB9KTtcbiAqXG4gKiBjb25zdCBhY3RvciA9IGNyZWF0ZUFjdG9yKGxvZ2ljLCB7IGlucHV0OiB7IG1lc3NhZ2U6ICdoZWxsbyB3b3JsZCcgfSB9KTtcbiAqIC8vICAgIF4/IFByb21pc2VBY3RvclJlZjxPdXRwdXQsIElucHV0PlxuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgZnJvbVByb21pc2V9XG4gKi9cblxuY29uc3QgY29udHJvbGxlck1hcCA9IG5ldyBXZWFrTWFwKCk7XG5cbi8qKlxuICogQW4gYWN0b3IgbG9naWMgY3JlYXRvciB3aGljaCByZXR1cm5zIHByb21pc2UgbG9naWMgYXMgZGVmaW5lZCBieSBhbiBhc3luY1xuICogcHJvY2VzcyB0aGF0IHJlc29sdmVzIG9yIHJlamVjdHMgYWZ0ZXIgc29tZSB0aW1lLlxuICpcbiAqIEFjdG9ycyBjcmVhdGVkIGZyb20gcHJvbWlzZSBhY3RvciBsb2dpYyAo4oCccHJvbWlzZSBhY3RvcnPigJ0pIGNhbjpcbiAqXG4gKiAtIEVtaXQgdGhlIHJlc29sdmVkIHZhbHVlIG9mIHRoZSBwcm9taXNlXG4gKiAtIE91dHB1dCB0aGUgcmVzb2x2ZWQgdmFsdWUgb2YgdGhlIHByb21pc2VcbiAqXG4gKiBTZW5kaW5nIGV2ZW50cyB0byBwcm9taXNlIGFjdG9ycyB3aWxsIGhhdmUgbm8gZWZmZWN0LlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IHByb21pc2VMb2dpYyA9IGZyb21Qcm9taXNlKGFzeW5jICgpID0+IHtcbiAqICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZmV0Y2goJ2h0dHBzOi8vZXhhbXBsZS5jb20vLi4uJykudGhlbigoZGF0YSkgPT5cbiAqICAgICBkYXRhLmpzb24oKVxuICogICApO1xuICpcbiAqICAgcmV0dXJuIHJlc3VsdDtcbiAqIH0pO1xuICpcbiAqIGNvbnN0IHByb21pc2VBY3RvciA9IGNyZWF0ZUFjdG9yKHByb21pc2VMb2dpYyk7XG4gKiBwcm9taXNlQWN0b3Iuc3Vic2NyaWJlKChzbmFwc2hvdCkgPT4ge1xuICogICBjb25zb2xlLmxvZyhzbmFwc2hvdCk7XG4gKiB9KTtcbiAqIHByb21pc2VBY3Rvci5zdGFydCgpO1xuICogLy8gPT4ge1xuICogLy8gICBvdXRwdXQ6IHVuZGVmaW5lZCxcbiAqIC8vICAgc3RhdHVzOiAnYWN0aXZlJ1xuICogLy8gICAuLi5cbiAqIC8vIH1cbiAqXG4gKiAvLyBBZnRlciBwcm9taXNlIHJlc29sdmVzXG4gKiAvLyA9PiB7XG4gKiAvLyAgIG91dHB1dDogeyAuLi4gfSxcbiAqIC8vICAgc3RhdHVzOiAnZG9uZScsXG4gKiAvLyAgIC4uLlxuICogLy8gfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHByb21pc2VDcmVhdG9yIEEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhIFByb21pc2UsIGFuZCBhY2NlcHRzIGFuXG4gKiAgIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gYGlucHV0YCAtIERhdGEgdGhhdCB3YXMgcHJvdmlkZWQgdG8gdGhlIHByb21pc2UgYWN0b3JcbiAqICAgLSBgc2VsZmAgLSBUaGUgcGFyZW50IGFjdG9yIG9mIHRoZSBwcm9taXNlIGFjdG9yXG4gKiAgIC0gYHN5c3RlbWAgLSBUaGUgYWN0b3Igc3lzdGVtIHRvIHdoaWNoIHRoZSBwcm9taXNlIGFjdG9yIGJlbG9uZ3NcbiAqXG4gKiBAc2VlIHtAbGluayBodHRwczovL3N0YXRlbHkuYWkvZG9jcy9pbnB1dCB8IElucHV0IGRvY3N9IGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IGhvdyBpbnB1dCBpcyBwYXNzZWRcbiAqL1xuZnVuY3Rpb24gZnJvbVByb21pc2UocHJvbWlzZUNyZWF0b3IpIHtcbiAgY29uc3QgbG9naWMgPSB7XG4gICAgY29uZmlnOiBwcm9taXNlQ3JlYXRvcixcbiAgICB0cmFuc2l0aW9uOiAoc3RhdGUsIGV2ZW50LCBzY29wZSkgPT4ge1xuICAgICAgaWYgKHN0YXRlLnN0YXR1cyAhPT0gJ2FjdGl2ZScpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgIGNhc2UgWFNUQVRFX1BST01JU0VfUkVTT0xWRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZFZhbHVlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICBzdGF0dXM6ICdkb25lJyxcbiAgICAgICAgICAgICAgb3V0cHV0OiByZXNvbHZlZFZhbHVlLFxuICAgICAgICAgICAgICBpbnB1dDogdW5kZWZpbmVkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBYU1RBVEVfUFJPTUlTRV9SRUpFQ1Q6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgICAgICAgZXJyb3I6IGV2ZW50LmRhdGEsXG4gICAgICAgICAgICBpbnB1dDogdW5kZWZpbmVkXG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBYU1RBVEVfU1RPUDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb250cm9sbGVyTWFwLmdldChzY29wZS5zZWxmKT8uYWJvcnQoKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICBzdGF0dXM6ICdzdG9wcGVkJyxcbiAgICAgICAgICAgICAgaW5wdXQ6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfVxuICAgIH0sXG4gICAgc3RhcnQ6IChzdGF0ZSwge1xuICAgICAgc2VsZixcbiAgICAgIHN5c3RlbSxcbiAgICAgIGVtaXRcbiAgICB9KSA9PiB7XG4gICAgICAvLyBUT0RPOiBkZXRlcm1pbmUgaG93IHRvIGFsbG93IGN1c3RvbWl6aW5nIHRoaXMgc28gdGhhdCBwcm9taXNlc1xuICAgICAgLy8gY2FuIGJlIHJlc3RhcnRlZCBpZiBuZWNlc3NhcnlcbiAgICAgIGlmIChzdGF0ZS5zdGF0dXMgIT09ICdhY3RpdmUnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICBjb250cm9sbGVyTWFwLnNldChzZWxmLCBjb250cm9sbGVyKTtcbiAgICAgIGNvbnN0IHJlc29sdmVkUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShwcm9taXNlQ3JlYXRvcih7XG4gICAgICAgIGlucHV0OiBzdGF0ZS5pbnB1dCxcbiAgICAgICAgc3lzdGVtLFxuICAgICAgICBzZWxmLFxuICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICBlbWl0XG4gICAgICB9KSk7XG4gICAgICByZXNvbHZlZFByb21pc2UudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgIGlmIChzZWxmLmdldFNuYXBzaG90KCkuc3RhdHVzICE9PSAnYWN0aXZlJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sbGVyTWFwLmRlbGV0ZShzZWxmKTtcbiAgICAgICAgc3lzdGVtLl9yZWxheShzZWxmLCBzZWxmLCB7XG4gICAgICAgICAgdHlwZTogWFNUQVRFX1BST01JU0VfUkVTT0xWRSxcbiAgICAgICAgICBkYXRhOiByZXNwb25zZVxuICAgICAgICB9KTtcbiAgICAgIH0sIGVycm9yRGF0YSA9PiB7XG4gICAgICAgIGlmIChzZWxmLmdldFNuYXBzaG90KCkuc3RhdHVzICE9PSAnYWN0aXZlJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sbGVyTWFwLmRlbGV0ZShzZWxmKTtcbiAgICAgICAgc3lzdGVtLl9yZWxheShzZWxmLCBzZWxmLCB7XG4gICAgICAgICAgdHlwZTogWFNUQVRFX1BST01JU0VfUkVKRUNULFxuICAgICAgICAgIGRhdGE6IGVycm9yRGF0YVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0SW5pdGlhbFNuYXBzaG90OiAoXywgaW5wdXQpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogJ2FjdGl2ZScsXG4gICAgICAgIG91dHB1dDogdW5kZWZpbmVkLFxuICAgICAgICBlcnJvcjogdW5kZWZpbmVkLFxuICAgICAgICBpbnB1dFxuICAgICAgfTtcbiAgICB9LFxuICAgIGdldFBlcnNpc3RlZFNuYXBzaG90OiBzbmFwc2hvdCA9PiBzbmFwc2hvdCxcbiAgICByZXN0b3JlU25hcHNob3Q6IHNuYXBzaG90ID0+IHNuYXBzaG90XG4gIH07XG4gIHJldHVybiBsb2dpYztcbn1cblxuY29uc3QgZW1wdHlMb2dpYyA9IGZyb21UcmFuc2l0aW9uKF8gPT4gdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuZnVuY3Rpb24gY3JlYXRlRW1wdHlBY3RvcigpIHtcbiAgcmV0dXJuIGNyZWF0ZUFjdG9yKGVtcHR5TG9naWMpO1xufVxuXG5leHBvcnQgeyBjcmVhdGVFbXB0eUFjdG9yLCBmcm9tQ2FsbGJhY2ssIGZyb21FdmVudE9ic2VydmFibGUsIGZyb21PYnNlcnZhYmxlLCBmcm9tUHJvbWlzZSwgZnJvbVRyYW5zaXRpb24gfTtcbiJdLCJuYW1lcyI6WyJYIiwiWFNUQVRFX1NUT1AiLCJjIiwiY3JlYXRlQWN0b3IiLCJmcm9tVHJhbnNpdGlvbiIsInRyYW5zaXRpb24iLCJpbml0aWFsQ29udGV4dCIsImNvbmZpZyIsInNuYXBzaG90IiwiZXZlbnQiLCJhY3RvclNjb3BlIiwiY29udGV4dCIsImdldEluaXRpYWxTbmFwc2hvdCIsIl8iLCJpbnB1dCIsInN0YXR1cyIsIm91dHB1dCIsInVuZGVmaW5lZCIsImVycm9yIiwiZ2V0UGVyc2lzdGVkU25hcHNob3QiLCJyZXN0b3JlU25hcHNob3QiLCJpbnN0YW5jZVN0YXRlcyIsIldlYWtNYXAiLCJmcm9tQ2FsbGJhY2siLCJjYWxsYmFjayIsImxvZ2ljIiwic3RhcnQiLCJzdGF0ZSIsInNlbGYiLCJzeXN0ZW0iLCJlbWl0IiwiY2FsbGJhY2tTdGF0ZSIsInJlY2VpdmVycyIsImRpc3Bvc2UiLCJzZXQiLCJzZW5kQmFjayIsImdldFNuYXBzaG90IiwiX3BhcmVudCIsIl9yZWxheSIsInJlY2VpdmUiLCJsaXN0ZW5lciIsIlNldCIsImFkZCIsImdldCIsInR5cGUiLCJmb3JFYWNoIiwicmVjZWl2ZXIiLCJYU1RBVEVfT0JTRVJWQUJMRV9ORVhUIiwiWFNUQVRFX09CU0VSVkFCTEVfRVJST1IiLCJYU1RBVEVfT0JTRVJWQUJMRV9DT01QTEVURSIsImZyb21PYnNlcnZhYmxlIiwib2JzZXJ2YWJsZUNyZWF0b3IiLCJuZXdTbmFwc2hvdCIsImRhdGEiLCJfc3Vic2NyaXB0aW9uIiwidW5zdWJzY3JpYmUiLCJzdWJzY3JpYmUiLCJuZXh0IiwidmFsdWUiLCJlcnIiLCJjb21wbGV0ZSIsImZyb21FdmVudE9ic2VydmFibGUiLCJsYXp5T2JzZXJ2YWJsZSIsIlhTVEFURV9QUk9NSVNFX1JFU09MVkUiLCJYU1RBVEVfUFJPTUlTRV9SRUpFQ1QiLCJjb250cm9sbGVyTWFwIiwiZnJvbVByb21pc2UiLCJwcm9taXNlQ3JlYXRvciIsInNjb3BlIiwicmVzb2x2ZWRWYWx1ZSIsImFib3J0IiwiY29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsInJlc29sdmVkUHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwic2lnbmFsIiwidGhlbiIsInJlc3BvbnNlIiwiZGVsZXRlIiwiZXJyb3JEYXRhIiwiZW1wdHlMb2dpYyIsImNyZWF0ZUVtcHR5QWN0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xstate/actors/dist/xstate-actors.development.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/xstate/dev/dist/xstate-dev.development.esm.js":
/*!********************************************************************!*\
  !*** ./node_modules/xstate/dev/dist/xstate-dev.development.esm.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   devToolsAdapter: () => (/* binding */ devToolsAdapter),\n/* harmony export */   getGlobal: () => (/* binding */ getGlobal),\n/* harmony export */   registerService: () => (/* binding */ registerService)\n/* harmony export */ });\n// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis\nfunction getGlobal() {\n    if (typeof globalThis !== \"undefined\") {\n        return globalThis;\n    }\n    if (typeof self !== \"undefined\") {\n        return self;\n    }\n    if (false) {}\n    if (typeof global !== \"undefined\") {\n        return global;\n    }\n    {\n        console.warn(\"XState could not find a global object in this environment. Please let the maintainers know and raise an issue here: https://github.com/statelyai/xstate/issues\");\n    }\n}\nfunction getDevTools() {\n    const w = getGlobal();\n    if (w.__xstate__) {\n        return w.__xstate__;\n    }\n    return undefined;\n}\nfunction registerService(service) {\n    if (true) {\n        return;\n    }\n    const devTools = getDevTools();\n    if (devTools) {\n        devTools.register(service);\n    }\n}\nconst devToolsAdapter = (service)=>{\n    if (true) {\n        return;\n    }\n    const devTools = getDevTools();\n    if (devTools) {\n        devTools.register(service);\n    }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHN0YXRlL2Rldi9kaXN0L3hzdGF0ZS1kZXYuZGV2ZWxvcG1lbnQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLG1HQUFtRztBQUNuRyxTQUFTQTtJQUNQLElBQUksT0FBT0MsZUFBZSxhQUFhO1FBQ3JDLE9BQU9BO0lBQ1Q7SUFDQSxJQUFJLE9BQU9DLFNBQVMsYUFBYTtRQUMvQixPQUFPQTtJQUNUO0lBQ0EsSUFBSSxLQUFrQixFQUFhLEVBRWxDO0lBQ0QsSUFBSSxPQUFPRSxXQUFXLGFBQWE7UUFDakMsT0FBT0E7SUFDVDtJQUNBO1FBQ0VDLFFBQVFDLElBQUksQ0FBQztJQUNmO0FBQ0Y7QUFDQSxTQUFTQztJQUNQLE1BQU1DLElBQUlSO0lBQ1YsSUFBSVEsRUFBRUMsVUFBVSxFQUFFO1FBQ2hCLE9BQU9ELEVBQUVDLFVBQVU7SUFDckI7SUFDQSxPQUFPQztBQUNUO0FBQ0EsU0FBU0MsZ0JBQWdCQyxPQUFPO0lBQzlCLElBQUksSUFBa0IsRUFBYTtRQUNqQztJQUNGO0lBQ0EsTUFBTUMsV0FBV047SUFDakIsSUFBSU0sVUFBVTtRQUNaQSxTQUFTQyxRQUFRLENBQUNGO0lBQ3BCO0FBQ0Y7QUFDQSxNQUFNRyxrQkFBa0JILENBQUFBO0lBQ3RCLElBQUksSUFBa0IsRUFBYTtRQUNqQztJQUNGO0lBQ0EsTUFBTUMsV0FBV047SUFDakIsSUFBSU0sVUFBVTtRQUNaQSxTQUFTQyxRQUFRLENBQUNGO0lBQ3BCO0FBQ0Y7QUFFdUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lcmEtcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL3hzdGF0ZS9kZXYvZGlzdC94c3RhdGUtZGV2LmRldmVsb3BtZW50LmVzbS5qcz80ZmY2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvZ2xvYmFsVGhpc1xuZnVuY3Rpb24gZ2V0R2xvYmFsKCkge1xuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGdsb2JhbFRoaXM7XG4gIH1cbiAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cbiAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGdsb2JhbDtcbiAgfVxuICB7XG4gICAgY29uc29sZS53YXJuKCdYU3RhdGUgY291bGQgbm90IGZpbmQgYSBnbG9iYWwgb2JqZWN0IGluIHRoaXMgZW52aXJvbm1lbnQuIFBsZWFzZSBsZXQgdGhlIG1haW50YWluZXJzIGtub3cgYW5kIHJhaXNlIGFuIGlzc3VlIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9zdGF0ZWx5YWkveHN0YXRlL2lzc3VlcycpO1xuICB9XG59XG5mdW5jdGlvbiBnZXREZXZUb29scygpIHtcbiAgY29uc3QgdyA9IGdldEdsb2JhbCgpO1xuICBpZiAody5fX3hzdGF0ZV9fKSB7XG4gICAgcmV0dXJuIHcuX194c3RhdGVfXztcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJTZXJ2aWNlKHNlcnZpY2UpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGRldlRvb2xzID0gZ2V0RGV2VG9vbHMoKTtcbiAgaWYgKGRldlRvb2xzKSB7XG4gICAgZGV2VG9vbHMucmVnaXN0ZXIoc2VydmljZSk7XG4gIH1cbn1cbmNvbnN0IGRldlRvb2xzQWRhcHRlciA9IHNlcnZpY2UgPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZGV2VG9vbHMgPSBnZXREZXZUb29scygpO1xuICBpZiAoZGV2VG9vbHMpIHtcbiAgICBkZXZUb29scy5yZWdpc3RlcihzZXJ2aWNlKTtcbiAgfVxufTtcblxuZXhwb3J0IHsgZGV2VG9vbHNBZGFwdGVyLCBnZXRHbG9iYWwsIHJlZ2lzdGVyU2VydmljZSB9O1xuIl0sIm5hbWVzIjpbImdldEdsb2JhbCIsImdsb2JhbFRoaXMiLCJzZWxmIiwid2luZG93IiwiZ2xvYmFsIiwiY29uc29sZSIsIndhcm4iLCJnZXREZXZUb29scyIsInciLCJfX3hzdGF0ZV9fIiwidW5kZWZpbmVkIiwicmVnaXN0ZXJTZXJ2aWNlIiwic2VydmljZSIsImRldlRvb2xzIiwicmVnaXN0ZXIiLCJkZXZUb29sc0FkYXB0ZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xstate/dev/dist/xstate-dev.development.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/xstate/dist/StateMachine-b4e94439.development.esm.js":
/*!***************************************************************************!*\
  !*** ./node_modules/xstate/dist/StateMachine-b4e94439.development.esm.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   S: () => (/* binding */ StateMachine),\n/* harmony export */   a: () => (/* binding */ StateNode)\n/* harmony export */ });\n/* harmony import */ var _raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./raise-78b8dcb8.development.esm.js */ \"(ssr)/./node_modules/xstate/dist/raise-78b8dcb8.development.esm.js\");\n/* harmony import */ var _assign_6313ccb3_development_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assign-6313ccb3.development.esm.js */ \"(ssr)/./node_modules/xstate/dist/assign-6313ccb3.development.esm.js\");\n\n\nconst cache = new WeakMap();\nfunction memo(object, key, fn) {\n    let memoizedData = cache.get(object);\n    if (!memoizedData) {\n        memoizedData = {\n            [key]: fn()\n        };\n        cache.set(object, memoizedData);\n    } else if (!(key in memoizedData)) {\n        memoizedData[key] = fn();\n    }\n    return memoizedData[key];\n}\nconst EMPTY_OBJECT = {};\nconst toSerializableAction = (action)=>{\n    if (typeof action === \"string\") {\n        return {\n            type: action\n        };\n    }\n    if (typeof action === \"function\") {\n        if (\"resolve\" in action) {\n            return {\n                type: action.type\n            };\n        }\n        return {\n            type: action.name\n        };\n    }\n    return action;\n};\nclass StateNode {\n    constructor(/** The raw config used to create the machine. */ config, options){\n        this.config = config;\n        /**\n     * The relative key of the state node, which represents its location in the\n     * overall state value.\n     */ this.key = void 0;\n        /** The unique ID of the state node. */ this.id = void 0;\n        /**\n     * The type of this state node:\n     *\n     * - `'atomic'` - no child state nodes\n     * - `'compound'` - nested child state nodes (XOR)\n     * - `'parallel'` - orthogonal nested child state nodes (AND)\n     * - `'history'` - history state node\n     * - `'final'` - final state node\n     */ this.type = void 0;\n        /** The string path from the root machine node to this node. */ this.path = void 0;\n        /** The child state nodes. */ this.states = void 0;\n        /**\n     * The type of history on this state node. Can be:\n     *\n     * - `'shallow'` - recalls only top-level historical state value\n     * - `'deep'` - recalls historical state value at all levels\n     */ this.history = void 0;\n        /** The action(s) to be executed upon entering the state node. */ this.entry = void 0;\n        /** The action(s) to be executed upon exiting the state node. */ this.exit = void 0;\n        /** The parent state node. */ this.parent = void 0;\n        /** The root machine node. */ this.machine = void 0;\n        /**\n     * The meta data associated with this state node, which will be returned in\n     * State instances.\n     */ this.meta = void 0;\n        /**\n     * The output data sent with the \"xstate.done.state._id_\" event if this is a\n     * final state node.\n     */ this.output = void 0;\n        /**\n     * The order this state node appears. Corresponds to the implicit document\n     * order.\n     */ this.order = -1;\n        this.description = void 0;\n        this.tags = [];\n        this.transitions = void 0;\n        this.always = void 0;\n        this.parent = options._parent;\n        this.key = options._key;\n        this.machine = options._machine;\n        this.path = this.parent ? this.parent.path.concat(this.key) : [];\n        this.id = this.config.id || [\n            this.machine.id,\n            ...this.path\n        ].join(_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.S);\n        this.type = this.config.type || (this.config.states && Object.keys(this.config.states).length ? \"compound\" : this.config.history ? \"history\" : \"atomic\");\n        this.description = this.config.description;\n        this.order = this.machine.idMap.size;\n        this.machine.idMap.set(this.id, this);\n        this.states = this.config.states ? (0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.l)(this.config.states, (stateConfig, key)=>{\n            const stateNode = new StateNode(stateConfig, {\n                _parent: this,\n                _key: key,\n                _machine: this.machine\n            });\n            return stateNode;\n        }) : EMPTY_OBJECT;\n        if (this.type === \"compound\" && !this.config.initial) {\n            throw new Error(`No initial state specified for compound state node \"#${this.id}\". Try adding { initial: \"${Object.keys(this.states)[0]}\" } to the state config.`);\n        }\n        // History config\n        this.history = this.config.history === true ? \"shallow\" : this.config.history || false;\n        this.entry = (0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.config.entry).slice();\n        this.exit = (0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.config.exit).slice();\n        this.meta = this.config.meta;\n        this.output = this.type === \"final\" || !this.parent ? this.config.output : undefined;\n        this.tags = (0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.t)(config.tags).slice();\n    }\n    /** @internal */ _initialize() {\n        this.transitions = (0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.q)(this);\n        if (this.config.always) {\n            this.always = (0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.u)(this.config.always).map((t)=>(0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.v)(this, _raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.N, t));\n        }\n        Object.keys(this.states).forEach((key)=>{\n            this.states[key]._initialize();\n        });\n    }\n    /** The well-structured state node definition. */ get definition() {\n        return {\n            id: this.id,\n            key: this.key,\n            version: this.machine.version,\n            type: this.type,\n            initial: this.initial ? {\n                target: this.initial.target,\n                source: this,\n                actions: this.initial.actions.map(toSerializableAction),\n                eventType: null,\n                reenter: false,\n                toJSON: ()=>({\n                        target: this.initial.target.map((t)=>`#${t.id}`),\n                        source: `#${this.id}`,\n                        actions: this.initial.actions.map(toSerializableAction),\n                        eventType: null\n                    })\n            } : undefined,\n            history: this.history,\n            states: (0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.l)(this.states, (state)=>{\n                return state.definition;\n            }),\n            on: this.on,\n            transitions: [\n                ...this.transitions.values()\n            ].flat().map((t)=>({\n                    ...t,\n                    actions: t.actions.map(toSerializableAction)\n                })),\n            entry: this.entry.map(toSerializableAction),\n            exit: this.exit.map(toSerializableAction),\n            meta: this.meta,\n            order: this.order || -1,\n            output: this.output,\n            invoke: this.invoke,\n            description: this.description,\n            tags: this.tags\n        };\n    }\n    /** @internal */ toJSON() {\n        return this.definition;\n    }\n    /** The logic invoked as actors by this state node. */ get invoke() {\n        return memo(this, \"invoke\", ()=>(0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.config.invoke).map((invokeConfig, i)=>{\n                const { src, systemId } = invokeConfig;\n                const resolvedId = invokeConfig.id ?? (0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.x)(this.id, i);\n                const sourceName = typeof src === \"string\" ? src : `xstate.invoke.${(0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.x)(this.id, i)}`;\n                return {\n                    ...invokeConfig,\n                    src: sourceName,\n                    id: resolvedId,\n                    systemId: systemId,\n                    toJSON () {\n                        const { onDone, onError, ...invokeDefValues } = invokeConfig;\n                        return {\n                            ...invokeDefValues,\n                            type: \"xstate.invoke\",\n                            src: sourceName,\n                            id: resolvedId\n                        };\n                    }\n                };\n            }));\n    }\n    /** The mapping of events to transitions. */ get on() {\n        return memo(this, \"on\", ()=>{\n            const transitions = this.transitions;\n            return [\n                ...transitions\n            ].flatMap(([descriptor, t])=>t.map((t)=>[\n                        descriptor,\n                        t\n                    ])).reduce((map, [descriptor, transition])=>{\n                map[descriptor] = map[descriptor] || [];\n                map[descriptor].push(transition);\n                return map;\n            }, {});\n        });\n    }\n    get after() {\n        return memo(this, \"delayedTransitions\", ()=>(0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.y)(this));\n    }\n    get initial() {\n        return memo(this, \"initial\", ()=>(0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.z)(this, this.config.initial));\n    }\n    /** @internal */ next(snapshot, event) {\n        const eventType = event.type;\n        const actions = [];\n        let selectedTransition;\n        const candidates = memo(this, `candidates-${eventType}`, ()=>(0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.B)(this, eventType));\n        for (const candidate of candidates){\n            const { guard } = candidate;\n            const resolvedContext = snapshot.context;\n            let guardPassed = false;\n            try {\n                guardPassed = !guard || (0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.w)(guard, resolvedContext, event, snapshot);\n            } catch (err) {\n                const guardType = typeof guard === \"string\" ? guard : typeof guard === \"object\" ? guard.type : undefined;\n                throw new Error(`Unable to evaluate guard ${guardType ? `'${guardType}' ` : \"\"}in transition for event '${eventType}' in state node '${this.id}':\\n${err.message}`);\n            }\n            if (guardPassed) {\n                actions.push(...candidate.actions);\n                selectedTransition = candidate;\n                break;\n            }\n        }\n        return selectedTransition ? [\n            selectedTransition\n        ] : undefined;\n    }\n    /** All the event types accepted by this state node and its descendants. */ get events() {\n        return memo(this, \"events\", ()=>{\n            const { states } = this;\n            const events = new Set(this.ownEvents);\n            if (states) {\n                for (const stateId of Object.keys(states)){\n                    const state = states[stateId];\n                    if (state.states) {\n                        for (const event of state.events){\n                            events.add(`${event}`);\n                        }\n                    }\n                }\n            }\n            return Array.from(events);\n        });\n    }\n    /**\n   * All the events that have transitions directly from this state node.\n   *\n   * Excludes any inert events.\n   */ get ownEvents() {\n        const events = new Set([\n            ...this.transitions.keys()\n        ].filter((descriptor)=>{\n            return this.transitions.get(descriptor).some((transition)=>!(!transition.target && !transition.actions.length && !transition.reenter));\n        }));\n        return Array.from(events);\n    }\n}\nconst STATE_IDENTIFIER = \"#\";\nclass StateMachine {\n    constructor(/** The raw config used to create the machine. */ config, implementations){\n        this.config = config;\n        /** The machine's own version. */ this.version = void 0;\n        this.schemas = void 0;\n        this.implementations = void 0;\n        /** @internal */ this.__xstatenode = true;\n        /** @internal */ this.idMap = new Map();\n        this.root = void 0;\n        this.id = void 0;\n        this.states = void 0;\n        this.events = void 0;\n        this.id = config.id || \"(machine)\";\n        this.implementations = {\n            actors: implementations?.actors ?? {},\n            actions: implementations?.actions ?? {},\n            delays: implementations?.delays ?? {},\n            guards: implementations?.guards ?? {}\n        };\n        this.version = this.config.version;\n        this.schemas = this.config.schemas;\n        this.transition = this.transition.bind(this);\n        this.getInitialSnapshot = this.getInitialSnapshot.bind(this);\n        this.getPersistedSnapshot = this.getPersistedSnapshot.bind(this);\n        this.restoreSnapshot = this.restoreSnapshot.bind(this);\n        this.start = this.start.bind(this);\n        this.root = new StateNode(config, {\n            _key: this.id,\n            _machine: this\n        });\n        this.root._initialize();\n        this.states = this.root.states; // TODO: remove!\n        this.events = this.root.events;\n        if (!(\"output\" in this.root) && Object.values(this.states).some((state)=>state.type === \"final\" && \"output\" in state)) {\n            console.warn(\"Missing `machine.output` declaration (top-level final state with output detected)\");\n        }\n    }\n    /**\n   * Clones this state machine with the provided implementations.\n   *\n   * @param implementations Options (`actions`, `guards`, `actors`, `delays`) to\n   *   recursively merge with the existing options.\n   * @returns A new `StateMachine` instance with the provided implementations.\n   */ provide(implementations) {\n        const { actions, guards, actors, delays } = this.implementations;\n        return new StateMachine(this.config, {\n            actions: {\n                ...actions,\n                ...implementations.actions\n            },\n            guards: {\n                ...guards,\n                ...implementations.guards\n            },\n            actors: {\n                ...actors,\n                ...implementations.actors\n            },\n            delays: {\n                ...delays,\n                ...implementations.delays\n            }\n        });\n    }\n    resolveState(config) {\n        const resolvedStateValue = (0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.C)(this.root, config.value);\n        const nodeSet = (0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.D)((0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.g)(this.root, resolvedStateValue));\n        return (0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.E)({\n            _nodes: [\n                ...nodeSet\n            ],\n            context: config.context || {},\n            children: {},\n            status: (0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.F)(nodeSet, this.root) ? \"done\" : config.status || \"active\",\n            output: config.output,\n            error: config.error,\n            historyValue: config.historyValue\n        }, this);\n    }\n    /**\n   * Determines the next snapshot given the current `snapshot` and received\n   * `event`. Calculates a full macrostep from all microsteps.\n   *\n   * @param snapshot The current snapshot\n   * @param event The received event\n   */ transition(snapshot, event, actorScope) {\n        return (0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.G)(snapshot, event, actorScope, []).snapshot;\n    }\n    /**\n   * Determines the next state given the current `state` and `event`. Calculates\n   * a microstep.\n   *\n   * @param state The current state\n   * @param event The received event\n   */ microstep(snapshot, event, actorScope) {\n        return (0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.G)(snapshot, event, actorScope, []).microstates;\n    }\n    getTransitionData(snapshot, event) {\n        return (0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.H)(this.root, snapshot.value, snapshot, event) || [];\n    }\n    /**\n   * The initial state _before_ evaluating any microsteps. This \"pre-initial\"\n   * state is provided to initial actions executed in the initial state.\n   */ getPreInitialState(actorScope, initEvent, internalQueue) {\n        const { context } = this.config;\n        const preInitial = (0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.E)({\n            context: typeof context !== \"function\" && context ? context : {},\n            _nodes: [\n                this.root\n            ],\n            children: {},\n            status: \"active\"\n        }, this);\n        if (typeof context === \"function\") {\n            const assignment = ({ spawn, event, self })=>context({\n                    spawn,\n                    input: event.input,\n                    self\n                });\n            return (0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.I)(preInitial, initEvent, actorScope, [\n                (0,_assign_6313ccb3_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)(assignment)\n            ], internalQueue, undefined);\n        }\n        return preInitial;\n    }\n    /**\n   * Returns the initial `State` instance, with reference to `self` as an\n   * `ActorRef`.\n   */ getInitialSnapshot(actorScope, input) {\n        const initEvent = (0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.J)(input); // TODO: fix;\n        const internalQueue = [];\n        const preInitialState = this.getPreInitialState(actorScope, initEvent, internalQueue);\n        const nextState = (0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.K)([\n            {\n                target: [\n                    ...(0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.L)(this.root)\n                ],\n                source: this.root,\n                reenter: true,\n                actions: [],\n                eventType: null,\n                toJSON: null // TODO: fix\n            }\n        ], preInitialState, actorScope, initEvent, true, internalQueue);\n        const { snapshot: macroState } = (0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.G)(nextState, initEvent, actorScope, internalQueue);\n        return macroState;\n    }\n    start(snapshot) {\n        Object.values(snapshot.children).forEach((child)=>{\n            if (child.getSnapshot().status === \"active\") {\n                child.start();\n            }\n        });\n    }\n    getStateNodeById(stateId) {\n        const fullPath = (0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.M)(stateId);\n        const relativePath = fullPath.slice(1);\n        const resolvedStateId = (0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.O)(fullPath[0]) ? fullPath[0].slice(STATE_IDENTIFIER.length) : fullPath[0];\n        const stateNode = this.idMap.get(resolvedStateId);\n        if (!stateNode) {\n            throw new Error(`Child state node '#${resolvedStateId}' does not exist on machine '${this.id}'`);\n        }\n        return (0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.P)(stateNode, relativePath);\n    }\n    get definition() {\n        return this.root.definition;\n    }\n    toJSON() {\n        return this.definition;\n    }\n    getPersistedSnapshot(snapshot, options) {\n        return (0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.Q)(snapshot, options);\n    }\n    restoreSnapshot(snapshot, _actorScope) {\n        const children = {};\n        const snapshotChildren = snapshot.children;\n        Object.keys(snapshotChildren).forEach((actorId)=>{\n            const actorData = snapshotChildren[actorId];\n            const childState = actorData.snapshot;\n            const src = actorData.src;\n            const logic = typeof src === \"string\" ? (0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.R)(this, src) : src;\n            if (!logic) {\n                return;\n            }\n            const actorRef = (0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(logic, {\n                id: actorId,\n                parent: _actorScope.self,\n                syncSnapshot: actorData.syncSnapshot,\n                snapshot: childState,\n                src,\n                systemId: actorData.systemId\n            });\n            children[actorId] = actorRef;\n        });\n        function resolveHistoryReferencedState(root, referenced) {\n            if (referenced instanceof StateNode) {\n                return referenced;\n            }\n            try {\n                return root.machine.getStateNodeById(referenced.id);\n            } catch  {\n                {\n                    console.warn(`Could not resolve StateNode for id: ${referenced.id}`);\n                }\n            }\n        }\n        function reviveHistoryValue(root, historyValue) {\n            if (!historyValue || typeof historyValue !== \"object\") {\n                return {};\n            }\n            const revived = {};\n            for(const key in historyValue){\n                const arr = historyValue[key];\n                for (const item of arr){\n                    const resolved = resolveHistoryReferencedState(root, item);\n                    if (!resolved) {\n                        continue;\n                    }\n                    revived[key] ??= [];\n                    revived[key].push(resolved);\n                }\n            }\n            return revived;\n        }\n        const revivedHistoryValue = reviveHistoryValue(this.root, snapshot.historyValue);\n        const restoredSnapshot = (0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.E)({\n            ...snapshot,\n            children,\n            _nodes: Array.from((0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.D)((0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.g)(this.root, snapshot.value))),\n            historyValue: revivedHistoryValue\n        }, this);\n        const seen = new Set();\n        function reviveContext(contextPart, children) {\n            if (seen.has(contextPart)) {\n                return;\n            }\n            seen.add(contextPart);\n            for(const key in contextPart){\n                const value = contextPart[key];\n                if (value && typeof value === \"object\") {\n                    if (\"xstate$$type\" in value && value.xstate$$type === _raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.$) {\n                        contextPart[key] = children[value.id];\n                        continue;\n                    }\n                    reviveContext(value, children);\n                }\n            }\n        }\n        reviveContext(restoredSnapshot.context, children);\n        return restoredSnapshot;\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHN0YXRlL2Rpc3QvU3RhdGVNYWNoaW5lLWI0ZTk0NDM5LmRldmVsb3BtZW50LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQStzQjtBQUM1b0I7QUFFbkUsTUFBTThELFFBQVEsSUFBSUM7QUFDbEIsU0FBU0MsS0FBS0MsTUFBTSxFQUFFQyxHQUFHLEVBQUVDLEVBQUU7SUFDM0IsSUFBSUMsZUFBZU4sTUFBTU8sR0FBRyxDQUFDSjtJQUM3QixJQUFJLENBQUNHLGNBQWM7UUFDakJBLGVBQWU7WUFDYixDQUFDRixJQUFJLEVBQUVDO1FBQ1Q7UUFDQUwsTUFBTVEsR0FBRyxDQUFDTCxRQUFRRztJQUNwQixPQUFPLElBQUksQ0FBRUYsQ0FBQUEsT0FBT0UsWUFBVyxHQUFJO1FBQ2pDQSxZQUFZLENBQUNGLElBQUksR0FBR0M7SUFDdEI7SUFDQSxPQUFPQyxZQUFZLENBQUNGLElBQUk7QUFDMUI7QUFFQSxNQUFNSyxlQUFlLENBQUM7QUFDdEIsTUFBTUMsdUJBQXVCQyxDQUFBQTtJQUMzQixJQUFJLE9BQU9BLFdBQVcsVUFBVTtRQUM5QixPQUFPO1lBQ0xDLE1BQU1EO1FBQ1I7SUFDRjtJQUNBLElBQUksT0FBT0EsV0FBVyxZQUFZO1FBQ2hDLElBQUksYUFBYUEsUUFBUTtZQUN2QixPQUFPO2dCQUNMQyxNQUFNRCxPQUFPQyxJQUFJO1lBQ25CO1FBQ0Y7UUFDQSxPQUFPO1lBQ0xBLE1BQU1ELE9BQU9FLElBQUk7UUFDbkI7SUFDRjtJQUNBLE9BQU9GO0FBQ1Q7QUFDQSxNQUFNRztJQUNKQyxZQUFZLCtDQUErQyxHQUMzREMsTUFBTSxFQUFFQyxPQUFPLENBQUU7UUFDZixJQUFJLENBQUNELE1BQU0sR0FBR0E7UUFDZDs7O0tBR0MsR0FDRCxJQUFJLENBQUNaLEdBQUcsR0FBRyxLQUFLO1FBQ2hCLHFDQUFxQyxHQUNyQyxJQUFJLENBQUNjLEVBQUUsR0FBRyxLQUFLO1FBQ2Y7Ozs7Ozs7O0tBUUMsR0FDRCxJQUFJLENBQUNOLElBQUksR0FBRyxLQUFLO1FBQ2pCLDZEQUE2RCxHQUM3RCxJQUFJLENBQUNPLElBQUksR0FBRyxLQUFLO1FBQ2pCLDJCQUEyQixHQUMzQixJQUFJLENBQUNDLE1BQU0sR0FBRyxLQUFLO1FBQ25COzs7OztLQUtDLEdBQ0QsSUFBSSxDQUFDQyxPQUFPLEdBQUcsS0FBSztRQUNwQiwrREFBK0QsR0FDL0QsSUFBSSxDQUFDQyxLQUFLLEdBQUcsS0FBSztRQUNsQiw4REFBOEQsR0FDOUQsSUFBSSxDQUFDQyxJQUFJLEdBQUcsS0FBSztRQUNqQiwyQkFBMkIsR0FDM0IsSUFBSSxDQUFDQyxNQUFNLEdBQUcsS0FBSztRQUNuQiwyQkFBMkIsR0FDM0IsSUFBSSxDQUFDQyxPQUFPLEdBQUcsS0FBSztRQUNwQjs7O0tBR0MsR0FDRCxJQUFJLENBQUNDLElBQUksR0FBRyxLQUFLO1FBQ2pCOzs7S0FHQyxHQUNELElBQUksQ0FBQ0MsTUFBTSxHQUFHLEtBQUs7UUFDbkI7OztLQUdDLEdBQ0QsSUFBSSxDQUFDQyxLQUFLLEdBQUcsQ0FBQztRQUNkLElBQUksQ0FBQ0MsV0FBVyxHQUFHLEtBQUs7UUFDeEIsSUFBSSxDQUFDQyxJQUFJLEdBQUcsRUFBRTtRQUNkLElBQUksQ0FBQ0MsV0FBVyxHQUFHLEtBQUs7UUFDeEIsSUFBSSxDQUFDQyxNQUFNLEdBQUcsS0FBSztRQUNuQixJQUFJLENBQUNSLE1BQU0sR0FBR1AsUUFBUWdCLE9BQU87UUFDN0IsSUFBSSxDQUFDN0IsR0FBRyxHQUFHYSxRQUFRaUIsSUFBSTtRQUN2QixJQUFJLENBQUNULE9BQU8sR0FBR1IsUUFBUWtCLFFBQVE7UUFDL0IsSUFBSSxDQUFDaEIsSUFBSSxHQUFHLElBQUksQ0FBQ0ssTUFBTSxHQUFHLElBQUksQ0FBQ0EsTUFBTSxDQUFDTCxJQUFJLENBQUNpQixNQUFNLENBQUMsSUFBSSxDQUFDaEMsR0FBRyxJQUFJLEVBQUU7UUFDaEUsSUFBSSxDQUFDYyxFQUFFLEdBQUcsSUFBSSxDQUFDRixNQUFNLENBQUNFLEVBQUUsSUFBSTtZQUFDLElBQUksQ0FBQ08sT0FBTyxDQUFDUCxFQUFFO2VBQUssSUFBSSxDQUFDQyxJQUFJO1NBQUMsQ0FBQ2tCLElBQUksQ0FBQ2xHLGlFQUFlQTtRQUNoRixJQUFJLENBQUN5RSxJQUFJLEdBQUcsSUFBSSxDQUFDSSxNQUFNLENBQUNKLElBQUksSUFBSyxLQUFJLENBQUNJLE1BQU0sQ0FBQ0ksTUFBTSxJQUFJa0IsT0FBT0MsSUFBSSxDQUFDLElBQUksQ0FBQ3ZCLE1BQU0sQ0FBQ0ksTUFBTSxFQUFFb0IsTUFBTSxHQUFHLGFBQWEsSUFBSSxDQUFDeEIsTUFBTSxDQUFDSyxPQUFPLEdBQUcsWUFBWSxRQUFPO1FBQ3RKLElBQUksQ0FBQ1EsV0FBVyxHQUFHLElBQUksQ0FBQ2IsTUFBTSxDQUFDYSxXQUFXO1FBQzFDLElBQUksQ0FBQ0QsS0FBSyxHQUFHLElBQUksQ0FBQ0gsT0FBTyxDQUFDZ0IsS0FBSyxDQUFDQyxJQUFJO1FBQ3BDLElBQUksQ0FBQ2pCLE9BQU8sQ0FBQ2dCLEtBQUssQ0FBQ2pDLEdBQUcsQ0FBQyxJQUFJLENBQUNVLEVBQUUsRUFBRSxJQUFJO1FBQ3BDLElBQUksQ0FBQ0UsTUFBTSxHQUFHLElBQUksQ0FBQ0osTUFBTSxDQUFDSSxNQUFNLEdBQUcvRSxxRUFBU0EsQ0FBQyxJQUFJLENBQUMyRSxNQUFNLENBQUNJLE1BQU0sRUFBRSxDQUFDdUIsYUFBYXZDO1lBQzdFLE1BQU13QyxZQUFZLElBQUk5QixVQUFVNkIsYUFBYTtnQkFDM0NWLFNBQVMsSUFBSTtnQkFDYkMsTUFBTTlCO2dCQUNOK0IsVUFBVSxJQUFJLENBQUNWLE9BQU87WUFDeEI7WUFDQSxPQUFPbUI7UUFDVCxLQUFLbkM7UUFDTCxJQUFJLElBQUksQ0FBQ0csSUFBSSxLQUFLLGNBQWMsQ0FBQyxJQUFJLENBQUNJLE1BQU0sQ0FBQzZCLE9BQU8sRUFBRTtZQUNwRCxNQUFNLElBQUlDLE1BQU0sQ0FBQyxxREFBcUQsRUFBRSxJQUFJLENBQUM1QixFQUFFLENBQUMsMEJBQTBCLEVBQUVvQixPQUFPQyxJQUFJLENBQUMsSUFBSSxDQUFDbkIsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLHdCQUF3QixDQUFDO1FBQ25LO1FBRUEsaUJBQWlCO1FBQ2pCLElBQUksQ0FBQ0MsT0FBTyxHQUFHLElBQUksQ0FBQ0wsTUFBTSxDQUFDSyxPQUFPLEtBQUssT0FBTyxZQUFZLElBQUksQ0FBQ0wsTUFBTSxDQUFDSyxPQUFPLElBQUk7UUFDakYsSUFBSSxDQUFDQyxLQUFLLEdBQUcvRSxxRUFBT0EsQ0FBQyxJQUFJLENBQUN5RSxNQUFNLENBQUNNLEtBQUssRUFBRXlCLEtBQUs7UUFDN0MsSUFBSSxDQUFDeEIsSUFBSSxHQUFHaEYscUVBQU9BLENBQUMsSUFBSSxDQUFDeUUsTUFBTSxDQUFDTyxJQUFJLEVBQUV3QixLQUFLO1FBQzNDLElBQUksQ0FBQ3JCLElBQUksR0FBRyxJQUFJLENBQUNWLE1BQU0sQ0FBQ1UsSUFBSTtRQUM1QixJQUFJLENBQUNDLE1BQU0sR0FBRyxJQUFJLENBQUNmLElBQUksS0FBSyxXQUFXLENBQUMsSUFBSSxDQUFDWSxNQUFNLEdBQUcsSUFBSSxDQUFDUixNQUFNLENBQUNXLE1BQU0sR0FBR3FCO1FBQzNFLElBQUksQ0FBQ2xCLElBQUksR0FBR3ZGLHFFQUFPQSxDQUFDeUUsT0FBT2MsSUFBSSxFQUFFaUIsS0FBSztJQUN4QztJQUVBLGNBQWMsR0FDZEUsY0FBYztRQUNaLElBQUksQ0FBQ2xCLFdBQVcsR0FBR3RGLHFFQUFpQkEsQ0FBQyxJQUFJO1FBQ3pDLElBQUksSUFBSSxDQUFDdUUsTUFBTSxDQUFDZ0IsTUFBTSxFQUFFO1lBQ3RCLElBQUksQ0FBQ0EsTUFBTSxHQUFHckYscUVBQXVCQSxDQUFDLElBQUksQ0FBQ3FFLE1BQU0sQ0FBQ2dCLE1BQU0sRUFBRWtCLEdBQUcsQ0FBQzVHLENBQUFBLElBQUtPLHFFQUFnQkEsQ0FBQyxJQUFJLEVBQUVFLGlFQUFVQSxFQUFFVDtRQUN4RztRQUNBZ0csT0FBT0MsSUFBSSxDQUFDLElBQUksQ0FBQ25CLE1BQU0sRUFBRStCLE9BQU8sQ0FBQy9DLENBQUFBO1lBQy9CLElBQUksQ0FBQ2dCLE1BQU0sQ0FBQ2hCLElBQUksQ0FBQzZDLFdBQVc7UUFDOUI7SUFDRjtJQUVBLCtDQUErQyxHQUMvQyxJQUFJRyxhQUFhO1FBQ2YsT0FBTztZQUNMbEMsSUFBSSxJQUFJLENBQUNBLEVBQUU7WUFDWGQsS0FBSyxJQUFJLENBQUNBLEdBQUc7WUFDYmlELFNBQVMsSUFBSSxDQUFDNUIsT0FBTyxDQUFDNEIsT0FBTztZQUM3QnpDLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ2ZpQyxTQUFTLElBQUksQ0FBQ0EsT0FBTyxHQUFHO2dCQUN0QlMsUUFBUSxJQUFJLENBQUNULE9BQU8sQ0FBQ1MsTUFBTTtnQkFDM0JDLFFBQVEsSUFBSTtnQkFDWkMsU0FBUyxJQUFJLENBQUNYLE9BQU8sQ0FBQ1csT0FBTyxDQUFDTixHQUFHLENBQUN4QztnQkFDbEMrQyxXQUFXO2dCQUNYQyxTQUFTO2dCQUNUQyxRQUFRLElBQU87d0JBQ2JMLFFBQVEsSUFBSSxDQUFDVCxPQUFPLENBQUNTLE1BQU0sQ0FBQ0osR0FBRyxDQUFDNUcsQ0FBQUEsSUFBSyxDQUFDLENBQUMsRUFBRUEsRUFBRTRFLEVBQUUsQ0FBQyxDQUFDO3dCQUMvQ3FDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDckMsRUFBRSxDQUFDLENBQUM7d0JBQ3JCc0MsU0FBUyxJQUFJLENBQUNYLE9BQU8sQ0FBQ1csT0FBTyxDQUFDTixHQUFHLENBQUN4Qzt3QkFDbEMrQyxXQUFXO29CQUNiO1lBQ0YsSUFBSVQ7WUFDSjNCLFNBQVMsSUFBSSxDQUFDQSxPQUFPO1lBQ3JCRCxRQUFRL0UscUVBQVNBLENBQUMsSUFBSSxDQUFDK0UsTUFBTSxFQUFFd0MsQ0FBQUE7Z0JBQzdCLE9BQU9BLE1BQU1SLFVBQVU7WUFDekI7WUFDQVMsSUFBSSxJQUFJLENBQUNBLEVBQUU7WUFDWDlCLGFBQWE7bUJBQUksSUFBSSxDQUFDQSxXQUFXLENBQUMrQixNQUFNO2FBQUcsQ0FBQ0MsSUFBSSxHQUFHYixHQUFHLENBQUM1RyxDQUFBQSxJQUFNO29CQUMzRCxHQUFHQSxDQUFDO29CQUNKa0gsU0FBU2xILEVBQUVrSCxPQUFPLENBQUNOLEdBQUcsQ0FBQ3hDO2dCQUN6QjtZQUNBWSxPQUFPLElBQUksQ0FBQ0EsS0FBSyxDQUFDNEIsR0FBRyxDQUFDeEM7WUFDdEJhLE1BQU0sSUFBSSxDQUFDQSxJQUFJLENBQUMyQixHQUFHLENBQUN4QztZQUNwQmdCLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ2ZFLE9BQU8sSUFBSSxDQUFDQSxLQUFLLElBQUksQ0FBQztZQUN0QkQsUUFBUSxJQUFJLENBQUNBLE1BQU07WUFDbkJxQyxRQUFRLElBQUksQ0FBQ0EsTUFBTTtZQUNuQm5DLGFBQWEsSUFBSSxDQUFDQSxXQUFXO1lBQzdCQyxNQUFNLElBQUksQ0FBQ0EsSUFBSTtRQUNqQjtJQUNGO0lBRUEsY0FBYyxHQUNkNkIsU0FBUztRQUNQLE9BQU8sSUFBSSxDQUFDUCxVQUFVO0lBQ3hCO0lBRUEsb0RBQW9ELEdBQ3BELElBQUlZLFNBQVM7UUFDWCxPQUFPOUQsS0FBSyxJQUFJLEVBQUUsVUFBVSxJQUFNM0QscUVBQU9BLENBQUMsSUFBSSxDQUFDeUUsTUFBTSxDQUFDZ0QsTUFBTSxFQUFFZCxHQUFHLENBQUMsQ0FBQ2UsY0FBY0M7Z0JBQy9FLE1BQU0sRUFDSkMsR0FBRyxFQUNIQyxRQUFRLEVBQ1QsR0FBR0g7Z0JBQ0osTUFBTUksYUFBYUosYUFBYS9DLEVBQUUsSUFBSS9ELHFFQUFjQSxDQUFDLElBQUksQ0FBQytELEVBQUUsRUFBRWdEO2dCQUM5RCxNQUFNSSxhQUFhLE9BQU9ILFFBQVEsV0FBV0EsTUFBTSxDQUFDLGNBQWMsRUFBRWhILHFFQUFjQSxDQUFDLElBQUksQ0FBQytELEVBQUUsRUFBRWdELEdBQUcsQ0FBQztnQkFDaEcsT0FBTztvQkFDTCxHQUFHRCxZQUFZO29CQUNmRSxLQUFLRztvQkFDTHBELElBQUltRDtvQkFDSkQsVUFBVUE7b0JBQ1ZUO3dCQUNFLE1BQU0sRUFDSlksTUFBTSxFQUNOQyxPQUFPLEVBQ1AsR0FBR0MsaUJBQ0osR0FBR1I7d0JBQ0osT0FBTzs0QkFDTCxHQUFHUSxlQUFlOzRCQUNsQjdELE1BQU07NEJBQ051RCxLQUFLRzs0QkFDTHBELElBQUltRDt3QkFDTjtvQkFDRjtnQkFDRjtZQUNGO0lBQ0Y7SUFFQSwwQ0FBMEMsR0FDMUMsSUFBSVIsS0FBSztRQUNQLE9BQU8zRCxLQUFLLElBQUksRUFBRSxNQUFNO1lBQ3RCLE1BQU02QixjQUFjLElBQUksQ0FBQ0EsV0FBVztZQUNwQyxPQUFPO21CQUFJQTthQUFZLENBQUMyQyxPQUFPLENBQUMsQ0FBQyxDQUFDQyxZQUFZckksRUFBRSxHQUFLQSxFQUFFNEcsR0FBRyxDQUFDNUcsQ0FBQUEsSUFBSzt3QkFBQ3FJO3dCQUFZckk7cUJBQUUsR0FBR3NJLE1BQU0sQ0FBQyxDQUFDMUIsS0FBSyxDQUFDeUIsWUFBWUUsV0FBVztnQkFDckgzQixHQUFHLENBQUN5QixXQUFXLEdBQUd6QixHQUFHLENBQUN5QixXQUFXLElBQUksRUFBRTtnQkFDdkN6QixHQUFHLENBQUN5QixXQUFXLENBQUNHLElBQUksQ0FBQ0Q7Z0JBQ3JCLE9BQU8zQjtZQUNULEdBQUcsQ0FBQztRQUNOO0lBQ0Y7SUFDQSxJQUFJNkIsUUFBUTtRQUNWLE9BQU83RSxLQUFLLElBQUksRUFBRSxzQkFBc0IsSUFBTTdDLHFFQUFxQkEsQ0FBQyxJQUFJO0lBQzFFO0lBQ0EsSUFBSXdGLFVBQVU7UUFDWixPQUFPM0MsS0FBSyxJQUFJLEVBQUUsV0FBVyxJQUFNM0MscUVBQXVCQSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUN5RCxNQUFNLENBQUM2QixPQUFPO0lBQ3RGO0lBRUEsY0FBYyxHQUNkbUMsS0FBS0MsUUFBUSxFQUFFQyxLQUFLLEVBQUU7UUFDcEIsTUFBTXpCLFlBQVl5QixNQUFNdEUsSUFBSTtRQUM1QixNQUFNNEMsVUFBVSxFQUFFO1FBQ2xCLElBQUkyQjtRQUNKLE1BQU1DLGFBQWFsRixLQUFLLElBQUksRUFBRSxDQUFDLFdBQVcsRUFBRXVELFVBQVUsQ0FBQyxFQUFFLElBQU1oRyxxRUFBYUEsQ0FBQyxJQUFJLEVBQUVnRztRQUNuRixLQUFLLE1BQU00QixhQUFhRCxXQUFZO1lBQ2xDLE1BQU0sRUFDSkUsS0FBSyxFQUNOLEdBQUdEO1lBQ0osTUFBTUUsa0JBQWtCTixTQUFTTyxPQUFPO1lBQ3hDLElBQUlDLGNBQWM7WUFDbEIsSUFBSTtnQkFDRkEsY0FBYyxDQUFDSCxTQUFTckkscUVBQWFBLENBQUNxSSxPQUFPQyxpQkFBaUJMLE9BQU9EO1lBQ3ZFLEVBQUUsT0FBT1MsS0FBSztnQkFDWixNQUFNQyxZQUFZLE9BQU9MLFVBQVUsV0FBV0EsUUFBUSxPQUFPQSxVQUFVLFdBQVdBLE1BQU0xRSxJQUFJLEdBQUdvQztnQkFDL0YsTUFBTSxJQUFJRixNQUFNLENBQUMseUJBQXlCLEVBQUU2QyxZQUFZLENBQUMsQ0FBQyxFQUFFQSxVQUFVLEVBQUUsQ0FBQyxHQUFHLEdBQUcseUJBQXlCLEVBQUVsQyxVQUFVLGlCQUFpQixFQUFFLElBQUksQ0FBQ3ZDLEVBQUUsQ0FBQyxJQUFJLEVBQUV3RSxJQUFJRSxPQUFPLENBQUMsQ0FBQztZQUNwSztZQUNBLElBQUlILGFBQWE7Z0JBQ2ZqQyxRQUFRc0IsSUFBSSxJQUFJTyxVQUFVN0IsT0FBTztnQkFDakMyQixxQkFBcUJFO2dCQUNyQjtZQUNGO1FBQ0Y7UUFDQSxPQUFPRixxQkFBcUI7WUFBQ0E7U0FBbUIsR0FBR25DO0lBQ3JEO0lBRUEseUVBQXlFLEdBQ3pFLElBQUk2QyxTQUFTO1FBQ1gsT0FBTzNGLEtBQUssSUFBSSxFQUFFLFVBQVU7WUFDMUIsTUFBTSxFQUNKa0IsTUFBTSxFQUNQLEdBQUcsSUFBSTtZQUNSLE1BQU15RSxTQUFTLElBQUlDLElBQUksSUFBSSxDQUFDQyxTQUFTO1lBQ3JDLElBQUkzRSxRQUFRO2dCQUNWLEtBQUssTUFBTTRFLFdBQVcxRCxPQUFPQyxJQUFJLENBQUNuQixRQUFTO29CQUN6QyxNQUFNd0MsUUFBUXhDLE1BQU0sQ0FBQzRFLFFBQVE7b0JBQzdCLElBQUlwQyxNQUFNeEMsTUFBTSxFQUFFO3dCQUNoQixLQUFLLE1BQU04RCxTQUFTdEIsTUFBTWlDLE1BQU0sQ0FBRTs0QkFDaENBLE9BQU9JLEdBQUcsQ0FBQyxDQUFDLEVBQUVmLE1BQU0sQ0FBQzt3QkFDdkI7b0JBQ0Y7Z0JBQ0Y7WUFDRjtZQUNBLE9BQU9nQixNQUFNQyxJQUFJLENBQUNOO1FBQ3BCO0lBQ0Y7SUFFQTs7OztHQUlDLEdBQ0QsSUFBSUUsWUFBWTtRQUNkLE1BQU1GLFNBQVMsSUFBSUMsSUFBSTtlQUFJLElBQUksQ0FBQy9ELFdBQVcsQ0FBQ1EsSUFBSTtTQUFHLENBQUM2RCxNQUFNLENBQUN6QixDQUFBQTtZQUN6RCxPQUFPLElBQUksQ0FBQzVDLFdBQVcsQ0FBQ3hCLEdBQUcsQ0FBQ29FLFlBQVkwQixJQUFJLENBQUN4QixDQUFBQSxhQUFjLENBQUUsRUFBQ0EsV0FBV3ZCLE1BQU0sSUFBSSxDQUFDdUIsV0FBV3JCLE9BQU8sQ0FBQ2hCLE1BQU0sSUFBSSxDQUFDcUMsV0FBV25CLE9BQU87UUFDdEk7UUFDQSxPQUFPd0MsTUFBTUMsSUFBSSxDQUFDTjtJQUNwQjtBQUNGO0FBRUEsTUFBTVMsbUJBQW1CO0FBQ3pCLE1BQU1DO0lBQ0p4RixZQUFZLCtDQUErQyxHQUMzREMsTUFBTSxFQUFFd0YsZUFBZSxDQUFFO1FBQ3ZCLElBQUksQ0FBQ3hGLE1BQU0sR0FBR0E7UUFDZCwrQkFBK0IsR0FDL0IsSUFBSSxDQUFDcUMsT0FBTyxHQUFHLEtBQUs7UUFDcEIsSUFBSSxDQUFDb0QsT0FBTyxHQUFHLEtBQUs7UUFDcEIsSUFBSSxDQUFDRCxlQUFlLEdBQUcsS0FBSztRQUM1QixjQUFjLEdBQ2QsSUFBSSxDQUFDRSxZQUFZLEdBQUc7UUFDcEIsY0FBYyxHQUNkLElBQUksQ0FBQ2pFLEtBQUssR0FBRyxJQUFJa0U7UUFDakIsSUFBSSxDQUFDQyxJQUFJLEdBQUcsS0FBSztRQUNqQixJQUFJLENBQUMxRixFQUFFLEdBQUcsS0FBSztRQUNmLElBQUksQ0FBQ0UsTUFBTSxHQUFHLEtBQUs7UUFDbkIsSUFBSSxDQUFDeUUsTUFBTSxHQUFHLEtBQUs7UUFDbkIsSUFBSSxDQUFDM0UsRUFBRSxHQUFHRixPQUFPRSxFQUFFLElBQUk7UUFDdkIsSUFBSSxDQUFDc0YsZUFBZSxHQUFHO1lBQ3JCSyxRQUFRTCxpQkFBaUJLLFVBQVUsQ0FBQztZQUNwQ3JELFNBQVNnRCxpQkFBaUJoRCxXQUFXLENBQUM7WUFDdENzRCxRQUFRTixpQkFBaUJNLFVBQVUsQ0FBQztZQUNwQ0MsUUFBUVAsaUJBQWlCTyxVQUFVLENBQUM7UUFDdEM7UUFDQSxJQUFJLENBQUMxRCxPQUFPLEdBQUcsSUFBSSxDQUFDckMsTUFBTSxDQUFDcUMsT0FBTztRQUNsQyxJQUFJLENBQUNvRCxPQUFPLEdBQUcsSUFBSSxDQUFDekYsTUFBTSxDQUFDeUYsT0FBTztRQUNsQyxJQUFJLENBQUM1QixVQUFVLEdBQUcsSUFBSSxDQUFDQSxVQUFVLENBQUNtQyxJQUFJLENBQUMsSUFBSTtRQUMzQyxJQUFJLENBQUNDLGtCQUFrQixHQUFHLElBQUksQ0FBQ0Esa0JBQWtCLENBQUNELElBQUksQ0FBQyxJQUFJO1FBQzNELElBQUksQ0FBQ3pILG9CQUFvQixHQUFHLElBQUksQ0FBQ0Esb0JBQW9CLENBQUN5SCxJQUFJLENBQUMsSUFBSTtRQUMvRCxJQUFJLENBQUNFLGVBQWUsR0FBRyxJQUFJLENBQUNBLGVBQWUsQ0FBQ0YsSUFBSSxDQUFDLElBQUk7UUFDckQsSUFBSSxDQUFDRyxLQUFLLEdBQUcsSUFBSSxDQUFDQSxLQUFLLENBQUNILElBQUksQ0FBQyxJQUFJO1FBQ2pDLElBQUksQ0FBQ0osSUFBSSxHQUFHLElBQUk5RixVQUFVRSxRQUFRO1lBQ2hDa0IsTUFBTSxJQUFJLENBQUNoQixFQUFFO1lBQ2JpQixVQUFVLElBQUk7UUFDaEI7UUFDQSxJQUFJLENBQUN5RSxJQUFJLENBQUMzRCxXQUFXO1FBQ3JCLElBQUksQ0FBQzdCLE1BQU0sR0FBRyxJQUFJLENBQUN3RixJQUFJLENBQUN4RixNQUFNLEVBQUUsZ0JBQWdCO1FBQ2hELElBQUksQ0FBQ3lFLE1BQU0sR0FBRyxJQUFJLENBQUNlLElBQUksQ0FBQ2YsTUFBTTtRQUM5QixJQUFJLENBQUUsYUFBWSxJQUFJLENBQUNlLElBQUksS0FBS3RFLE9BQU93QixNQUFNLENBQUMsSUFBSSxDQUFDMUMsTUFBTSxFQUFFaUYsSUFBSSxDQUFDekMsQ0FBQUEsUUFBU0EsTUFBTWhELElBQUksS0FBSyxXQUFXLFlBQVlnRCxRQUFRO1lBQ3JId0QsUUFBUUMsSUFBSSxDQUFDO1FBQ2Y7SUFDRjtJQUVBOzs7Ozs7R0FNQyxHQUNEQyxRQUFRZCxlQUFlLEVBQUU7UUFDdkIsTUFBTSxFQUNKaEQsT0FBTyxFQUNQdUQsTUFBTSxFQUNORixNQUFNLEVBQ05DLE1BQU0sRUFDUCxHQUFHLElBQUksQ0FBQ04sZUFBZTtRQUN4QixPQUFPLElBQUlELGFBQWEsSUFBSSxDQUFDdkYsTUFBTSxFQUFFO1lBQ25Dd0MsU0FBUztnQkFDUCxHQUFHQSxPQUFPO2dCQUNWLEdBQUdnRCxnQkFBZ0JoRCxPQUFPO1lBQzVCO1lBQ0F1RCxRQUFRO2dCQUNOLEdBQUdBLE1BQU07Z0JBQ1QsR0FBR1AsZ0JBQWdCTyxNQUFNO1lBQzNCO1lBQ0FGLFFBQVE7Z0JBQ04sR0FBR0EsTUFBTTtnQkFDVCxHQUFHTCxnQkFBZ0JLLE1BQU07WUFDM0I7WUFDQUMsUUFBUTtnQkFDTixHQUFHQSxNQUFNO2dCQUNULEdBQUdOLGdCQUFnQk0sTUFBTTtZQUMzQjtRQUNGO0lBQ0Y7SUFDQVMsYUFBYXZHLE1BQU0sRUFBRTtRQUNuQixNQUFNd0cscUJBQXFCN0oscUVBQWlCQSxDQUFDLElBQUksQ0FBQ2lKLElBQUksRUFBRTVGLE9BQU95RyxLQUFLO1FBQ3BFLE1BQU1DLFVBQVU3SixxRUFBZ0JBLENBQUNFLHFFQUFhQSxDQUFDLElBQUksQ0FBQzZJLElBQUksRUFBRVk7UUFDMUQsT0FBT3ZKLHFFQUFxQkEsQ0FBQztZQUMzQjBKLFFBQVE7bUJBQUlEO2FBQVE7WUFDcEJsQyxTQUFTeEUsT0FBT3dFLE9BQU8sSUFBSSxDQUFDO1lBQzVCb0MsVUFBVSxDQUFDO1lBQ1hDLFFBQVExSixxRUFBY0EsQ0FBQ3VKLFNBQVMsSUFBSSxDQUFDZCxJQUFJLElBQUksU0FBUzVGLE9BQU82RyxNQUFNLElBQUk7WUFDdkVsRyxRQUFRWCxPQUFPVyxNQUFNO1lBQ3JCbUcsT0FBTzlHLE9BQU84RyxLQUFLO1lBQ25CQyxjQUFjL0csT0FBTytHLFlBQVk7UUFDbkMsR0FBRyxJQUFJO0lBQ1Q7SUFFQTs7Ozs7O0dBTUMsR0FDRGxELFdBQVdJLFFBQVEsRUFBRUMsS0FBSyxFQUFFOEMsVUFBVSxFQUFFO1FBQ3RDLE9BQU8zSixxRUFBU0EsQ0FBQzRHLFVBQVVDLE9BQU84QyxZQUFZLEVBQUUsRUFBRS9DLFFBQVE7SUFDNUQ7SUFFQTs7Ozs7O0dBTUMsR0FDRHBHLFVBQVVvRyxRQUFRLEVBQUVDLEtBQUssRUFBRThDLFVBQVUsRUFBRTtRQUNyQyxPQUFPM0oscUVBQVNBLENBQUM0RyxVQUFVQyxPQUFPOEMsWUFBWSxFQUFFLEVBQUVDLFdBQVc7SUFDL0Q7SUFDQUMsa0JBQWtCakQsUUFBUSxFQUFFQyxLQUFLLEVBQUU7UUFDakMsT0FBTzNHLHFFQUFjQSxDQUFDLElBQUksQ0FBQ3FJLElBQUksRUFBRTNCLFNBQVN3QyxLQUFLLEVBQUV4QyxVQUFVQyxVQUFVLEVBQUU7SUFDekU7SUFFQTs7O0dBR0MsR0FDRGlELG1CQUFtQkgsVUFBVSxFQUFFSSxTQUFTLEVBQUVDLGFBQWEsRUFBRTtRQUN2RCxNQUFNLEVBQ0o3QyxPQUFPLEVBQ1IsR0FBRyxJQUFJLENBQUN4RSxNQUFNO1FBQ2YsTUFBTXNILGFBQWFySyxxRUFBcUJBLENBQUM7WUFDdkN1SCxTQUFTLE9BQU9BLFlBQVksY0FBY0EsVUFBVUEsVUFBVSxDQUFDO1lBQy9EbUMsUUFBUTtnQkFBQyxJQUFJLENBQUNmLElBQUk7YUFBQztZQUNuQmdCLFVBQVUsQ0FBQztZQUNYQyxRQUFRO1FBQ1YsR0FBRyxJQUFJO1FBQ1AsSUFBSSxPQUFPckMsWUFBWSxZQUFZO1lBQ2pDLE1BQU0rQyxhQUFhLENBQUMsRUFDbEJDLEtBQUssRUFDTHRELEtBQUssRUFDTHVELElBQUksRUFDTCxHQUFLakQsUUFBUTtvQkFDWmdEO29CQUNBRSxPQUFPeEQsTUFBTXdELEtBQUs7b0JBQ2xCRDtnQkFDRjtZQUNBLE9BQU9oSyxxRUFBd0JBLENBQUM2SixZQUFZRixXQUFXSixZQUFZO2dCQUFDakksc0VBQU1BLENBQUN3STthQUFZLEVBQUVGLGVBQWVyRjtRQUMxRztRQUNBLE9BQU9zRjtJQUNUO0lBRUE7OztHQUdDLEdBQ0RyQixtQkFBbUJlLFVBQVUsRUFBRVUsS0FBSyxFQUFFO1FBQ3BDLE1BQU1OLFlBQVl6SixxRUFBZUEsQ0FBQytKLFFBQVEsYUFBYTtRQUN2RCxNQUFNTCxnQkFBZ0IsRUFBRTtRQUN4QixNQUFNTSxrQkFBa0IsSUFBSSxDQUFDUixrQkFBa0IsQ0FBQ0gsWUFBWUksV0FBV0M7UUFDdkUsTUFBTU8sWUFBWS9KLHFFQUFTQSxDQUFDO1lBQUM7Z0JBQzNCeUUsUUFBUTt1QkFBSXZFLHFFQUFvQkEsQ0FBQyxJQUFJLENBQUM2SCxJQUFJO2lCQUFFO2dCQUM1Q3JELFFBQVEsSUFBSSxDQUFDcUQsSUFBSTtnQkFDakJsRCxTQUFTO2dCQUNURixTQUFTLEVBQUU7Z0JBQ1hDLFdBQVc7Z0JBQ1hFLFFBQVEsS0FBSyxZQUFZO1lBQzNCO1NBQUUsRUFBRWdGLGlCQUFpQlgsWUFBWUksV0FBVyxNQUFNQztRQUNsRCxNQUFNLEVBQ0pwRCxVQUFVNEQsVUFBVSxFQUNyQixHQUFHeEsscUVBQVNBLENBQUN1SyxXQUFXUixXQUFXSixZQUFZSztRQUNoRCxPQUFPUTtJQUNUO0lBQ0ExQixNQUFNbEMsUUFBUSxFQUFFO1FBQ2QzQyxPQUFPd0IsTUFBTSxDQUFDbUIsU0FBUzJDLFFBQVEsRUFBRXpFLE9BQU8sQ0FBQzJGLENBQUFBO1lBQ3ZDLElBQUlBLE1BQU1DLFdBQVcsR0FBR2xCLE1BQU0sS0FBSyxVQUFVO2dCQUMzQ2lCLE1BQU0zQixLQUFLO1lBQ2I7UUFDRjtJQUNGO0lBQ0E2QixpQkFBaUJoRCxPQUFPLEVBQUU7UUFDeEIsTUFBTWlELFdBQVdoSyxxRUFBV0EsQ0FBQytHO1FBQzdCLE1BQU1rRCxlQUFlRCxTQUFTbEcsS0FBSyxDQUFDO1FBQ3BDLE1BQU1vRyxrQkFBa0JoSyxxRUFBU0EsQ0FBQzhKLFFBQVEsQ0FBQyxFQUFFLElBQUlBLFFBQVEsQ0FBQyxFQUFFLENBQUNsRyxLQUFLLENBQUN1RCxpQkFBaUI5RCxNQUFNLElBQUl5RyxRQUFRLENBQUMsRUFBRTtRQUN6RyxNQUFNckcsWUFBWSxJQUFJLENBQUNILEtBQUssQ0FBQ2xDLEdBQUcsQ0FBQzRJO1FBQ2pDLElBQUksQ0FBQ3ZHLFdBQVc7WUFDZCxNQUFNLElBQUlFLE1BQU0sQ0FBQyxtQkFBbUIsRUFBRXFHLGdCQUFnQiw2QkFBNkIsRUFBRSxJQUFJLENBQUNqSSxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ2pHO1FBQ0EsT0FBTzdCLHFFQUFrQkEsQ0FBQ3VELFdBQVdzRztJQUN2QztJQUNBLElBQUk5RixhQUFhO1FBQ2YsT0FBTyxJQUFJLENBQUN3RCxJQUFJLENBQUN4RCxVQUFVO0lBQzdCO0lBQ0FPLFNBQVM7UUFDUCxPQUFPLElBQUksQ0FBQ1AsVUFBVTtJQUN4QjtJQUNBN0QscUJBQXFCMEYsUUFBUSxFQUFFaEUsT0FBTyxFQUFFO1FBQ3RDLE9BQU8xQixxRUFBb0JBLENBQUMwRixVQUFVaEU7SUFDeEM7SUFDQWlHLGdCQUFnQmpDLFFBQVEsRUFBRW1FLFdBQVcsRUFBRTtRQUNyQyxNQUFNeEIsV0FBVyxDQUFDO1FBQ2xCLE1BQU15QixtQkFBbUJwRSxTQUFTMkMsUUFBUTtRQUMxQ3RGLE9BQU9DLElBQUksQ0FBQzhHLGtCQUFrQmxHLE9BQU8sQ0FBQ21HLENBQUFBO1lBQ3BDLE1BQU1DLFlBQVlGLGdCQUFnQixDQUFDQyxRQUFRO1lBQzNDLE1BQU1FLGFBQWFELFVBQVV0RSxRQUFRO1lBQ3JDLE1BQU1kLE1BQU1vRixVQUFVcEYsR0FBRztZQUN6QixNQUFNc0YsUUFBUSxPQUFPdEYsUUFBUSxXQUFXMUUscUVBQXNCQSxDQUFDLElBQUksRUFBRTBFLE9BQU9BO1lBQzVFLElBQUksQ0FBQ3NGLE9BQU87Z0JBQ1Y7WUFDRjtZQUNBLE1BQU1DLFdBQVcvSixxRUFBV0EsQ0FBQzhKLE9BQU87Z0JBQ2xDdkksSUFBSW9JO2dCQUNKOUgsUUFBUTRILFlBQVlYLElBQUk7Z0JBQ3hCa0IsY0FBY0osVUFBVUksWUFBWTtnQkFDcEMxRSxVQUFVdUU7Z0JBQ1ZyRjtnQkFDQUMsVUFBVW1GLFVBQVVuRixRQUFRO1lBQzlCO1lBQ0F3RCxRQUFRLENBQUMwQixRQUFRLEdBQUdJO1FBQ3RCO1FBQ0EsU0FBU0UsOEJBQThCaEQsSUFBSSxFQUFFaUQsVUFBVTtZQUNyRCxJQUFJQSxzQkFBc0IvSSxXQUFXO2dCQUNuQyxPQUFPK0k7WUFDVDtZQUNBLElBQUk7Z0JBQ0YsT0FBT2pELEtBQUtuRixPQUFPLENBQUN1SCxnQkFBZ0IsQ0FBQ2EsV0FBVzNJLEVBQUU7WUFDcEQsRUFBRSxPQUFNO2dCQUNOO29CQUNFa0csUUFBUUMsSUFBSSxDQUFDLENBQUMsb0NBQW9DLEVBQUV3QyxXQUFXM0ksRUFBRSxDQUFDLENBQUM7Z0JBQ3JFO1lBQ0Y7UUFDRjtRQUNBLFNBQVM0SSxtQkFBbUJsRCxJQUFJLEVBQUVtQixZQUFZO1lBQzVDLElBQUksQ0FBQ0EsZ0JBQWdCLE9BQU9BLGlCQUFpQixVQUFVO2dCQUNyRCxPQUFPLENBQUM7WUFDVjtZQUNBLE1BQU1nQyxVQUFVLENBQUM7WUFDakIsSUFBSyxNQUFNM0osT0FBTzJILGFBQWM7Z0JBQzlCLE1BQU1pQyxNQUFNakMsWUFBWSxDQUFDM0gsSUFBSTtnQkFDN0IsS0FBSyxNQUFNNkosUUFBUUQsSUFBSztvQkFDdEIsTUFBTUUsV0FBV04sOEJBQThCaEQsTUFBTXFEO29CQUNyRCxJQUFJLENBQUNDLFVBQVU7d0JBQ2I7b0JBQ0Y7b0JBQ0FILE9BQU8sQ0FBQzNKLElBQUksS0FBSyxFQUFFO29CQUNuQjJKLE9BQU8sQ0FBQzNKLElBQUksQ0FBQzBFLElBQUksQ0FBQ29GO2dCQUNwQjtZQUNGO1lBQ0EsT0FBT0g7UUFDVDtRQUNBLE1BQU1JLHNCQUFzQkwsbUJBQW1CLElBQUksQ0FBQ2xELElBQUksRUFBRTNCLFNBQVM4QyxZQUFZO1FBQy9FLE1BQU1xQyxtQkFBbUJuTSxxRUFBcUJBLENBQUM7WUFDN0MsR0FBR2dILFFBQVE7WUFDWDJDO1lBQ0FELFFBQVF6QixNQUFNQyxJQUFJLENBQUN0SSxxRUFBZ0JBLENBQUNFLHFFQUFhQSxDQUFDLElBQUksQ0FBQzZJLElBQUksRUFBRTNCLFNBQVN3QyxLQUFLO1lBQzNFTSxjQUFjb0M7UUFDaEIsR0FBRyxJQUFJO1FBQ1AsTUFBTUUsT0FBTyxJQUFJdkU7UUFDakIsU0FBU3dFLGNBQWNDLFdBQVcsRUFBRTNDLFFBQVE7WUFDMUMsSUFBSXlDLEtBQUtHLEdBQUcsQ0FBQ0QsY0FBYztnQkFDekI7WUFDRjtZQUNBRixLQUFLcEUsR0FBRyxDQUFDc0U7WUFDVCxJQUFLLE1BQU1uSyxPQUFPbUssWUFBYTtnQkFDN0IsTUFBTTlDLFFBQVE4QyxXQUFXLENBQUNuSyxJQUFJO2dCQUM5QixJQUFJcUgsU0FBUyxPQUFPQSxVQUFVLFVBQVU7b0JBQ3RDLElBQUksa0JBQWtCQSxTQUFTQSxNQUFNZ0QsWUFBWSxLQUFLNUssaUVBQVlBLEVBQUU7d0JBQ2xFMEssV0FBVyxDQUFDbkssSUFBSSxHQUFHd0gsUUFBUSxDQUFDSCxNQUFNdkcsRUFBRSxDQUFDO3dCQUNyQztvQkFDRjtvQkFDQW9KLGNBQWM3QyxPQUFPRztnQkFDdkI7WUFDRjtRQUNGO1FBQ0EwQyxjQUFjRixpQkFBaUI1RSxPQUFPLEVBQUVvQztRQUN4QyxPQUFPd0M7SUFDVDtBQUNGO0FBRTZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXJhLXBvcnRmb2xpby8uL25vZGVfbW9kdWxlcy94c3RhdGUvZGlzdC9TdGF0ZU1hY2hpbmUtYjRlOTQ0MzkuZGV2ZWxvcG1lbnQuZXNtLmpzP2NkNjMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUyBhcyBTVEFURV9ERUxJTUlURVIsIGwgYXMgbWFwVmFsdWVzLCB0IGFzIHRvQXJyYXksIHEgYXMgZm9ybWF0VHJhbnNpdGlvbnMsIHUgYXMgdG9UcmFuc2l0aW9uQ29uZmlnQXJyYXksIHYgYXMgZm9ybWF0VHJhbnNpdGlvbiwgTiBhcyBOVUxMX0VWRU5ULCB3IGFzIGV2YWx1YXRlR3VhcmQsIHggYXMgY3JlYXRlSW52b2tlSWQsIHkgYXMgZ2V0RGVsYXllZFRyYW5zaXRpb25zLCB6IGFzIGZvcm1hdEluaXRpYWxUcmFuc2l0aW9uLCBCIGFzIGdldENhbmRpZGF0ZXMsIEMgYXMgcmVzb2x2ZVN0YXRlVmFsdWUsIEQgYXMgZ2V0QWxsU3RhdGVOb2RlcywgZyBhcyBnZXRTdGF0ZU5vZGVzLCBFIGFzIGNyZWF0ZU1hY2hpbmVTbmFwc2hvdCwgRiBhcyBpc0luRmluYWxTdGF0ZSwgRyBhcyBtYWNyb3N0ZXAsIEggYXMgdHJhbnNpdGlvbk5vZGUsIEkgYXMgcmVzb2x2ZUFjdGlvbnNBbmRDb250ZXh0LCBKIGFzIGNyZWF0ZUluaXRFdmVudCwgSyBhcyBtaWNyb3N0ZXAsIEwgYXMgZ2V0SW5pdGlhbFN0YXRlTm9kZXMsIE0gYXMgdG9TdGF0ZVBhdGgsIE8gYXMgaXNTdGF0ZUlkLCBQIGFzIGdldFN0YXRlTm9kZUJ5UGF0aCwgUSBhcyBnZXRQZXJzaXN0ZWRTbmFwc2hvdCwgUiBhcyByZXNvbHZlUmVmZXJlbmNlZEFjdG9yLCBjIGFzIGNyZWF0ZUFjdG9yLCAkIGFzICQkQUNUT1JfVFlQRSB9IGZyb20gJy4vcmFpc2UtNzhiOGRjYjguZGV2ZWxvcG1lbnQuZXNtLmpzJztcbmltcG9ydCB7IGEgYXMgYXNzaWduIH0gZnJvbSAnLi9hc3NpZ24tNjMxM2NjYjMuZGV2ZWxvcG1lbnQuZXNtLmpzJztcblxuY29uc3QgY2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gbWVtbyhvYmplY3QsIGtleSwgZm4pIHtcbiAgbGV0IG1lbW9pemVkRGF0YSA9IGNhY2hlLmdldChvYmplY3QpO1xuICBpZiAoIW1lbW9pemVkRGF0YSkge1xuICAgIG1lbW9pemVkRGF0YSA9IHtcbiAgICAgIFtrZXldOiBmbigpXG4gICAgfTtcbiAgICBjYWNoZS5zZXQob2JqZWN0LCBtZW1vaXplZERhdGEpO1xuICB9IGVsc2UgaWYgKCEoa2V5IGluIG1lbW9pemVkRGF0YSkpIHtcbiAgICBtZW1vaXplZERhdGFba2V5XSA9IGZuKCk7XG4gIH1cbiAgcmV0dXJuIG1lbW9pemVkRGF0YVtrZXldO1xufVxuXG5jb25zdCBFTVBUWV9PQkpFQ1QgPSB7fTtcbmNvbnN0IHRvU2VyaWFsaXphYmxlQWN0aW9uID0gYWN0aW9uID0+IHtcbiAgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IGFjdGlvblxuICAgIH07XG4gIH1cbiAgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoJ3Jlc29sdmUnIGluIGFjdGlvbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogYWN0aW9uLnR5cGVcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBhY3Rpb24ubmFtZVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGFjdGlvbjtcbn07XG5jbGFzcyBTdGF0ZU5vZGUge1xuICBjb25zdHJ1Y3RvcigvKiogVGhlIHJhdyBjb25maWcgdXNlZCB0byBjcmVhdGUgdGhlIG1hY2hpbmUuICovXG4gIGNvbmZpZywgb3B0aW9ucykge1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIC8qKlxuICAgICAqIFRoZSByZWxhdGl2ZSBrZXkgb2YgdGhlIHN0YXRlIG5vZGUsIHdoaWNoIHJlcHJlc2VudHMgaXRzIGxvY2F0aW9uIGluIHRoZVxuICAgICAqIG92ZXJhbGwgc3RhdGUgdmFsdWUuXG4gICAgICovXG4gICAgdGhpcy5rZXkgPSB2b2lkIDA7XG4gICAgLyoqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIHN0YXRlIG5vZGUuICovXG4gICAgdGhpcy5pZCA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGlzIHN0YXRlIG5vZGU6XG4gICAgICpcbiAgICAgKiAtIGAnYXRvbWljJ2AgLSBubyBjaGlsZCBzdGF0ZSBub2Rlc1xuICAgICAqIC0gYCdjb21wb3VuZCdgIC0gbmVzdGVkIGNoaWxkIHN0YXRlIG5vZGVzIChYT1IpXG4gICAgICogLSBgJ3BhcmFsbGVsJ2AgLSBvcnRob2dvbmFsIG5lc3RlZCBjaGlsZCBzdGF0ZSBub2RlcyAoQU5EKVxuICAgICAqIC0gYCdoaXN0b3J5J2AgLSBoaXN0b3J5IHN0YXRlIG5vZGVcbiAgICAgKiAtIGAnZmluYWwnYCAtIGZpbmFsIHN0YXRlIG5vZGVcbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSB2b2lkIDA7XG4gICAgLyoqIFRoZSBzdHJpbmcgcGF0aCBmcm9tIHRoZSByb290IG1hY2hpbmUgbm9kZSB0byB0aGlzIG5vZGUuICovXG4gICAgdGhpcy5wYXRoID0gdm9pZCAwO1xuICAgIC8qKiBUaGUgY2hpbGQgc3RhdGUgbm9kZXMuICovXG4gICAgdGhpcy5zdGF0ZXMgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgaGlzdG9yeSBvbiB0aGlzIHN0YXRlIG5vZGUuIENhbiBiZTpcbiAgICAgKlxuICAgICAqIC0gYCdzaGFsbG93J2AgLSByZWNhbGxzIG9ubHkgdG9wLWxldmVsIGhpc3RvcmljYWwgc3RhdGUgdmFsdWVcbiAgICAgKiAtIGAnZGVlcCdgIC0gcmVjYWxscyBoaXN0b3JpY2FsIHN0YXRlIHZhbHVlIGF0IGFsbCBsZXZlbHNcbiAgICAgKi9cbiAgICB0aGlzLmhpc3RvcnkgPSB2b2lkIDA7XG4gICAgLyoqIFRoZSBhY3Rpb24ocykgdG8gYmUgZXhlY3V0ZWQgdXBvbiBlbnRlcmluZyB0aGUgc3RhdGUgbm9kZS4gKi9cbiAgICB0aGlzLmVudHJ5ID0gdm9pZCAwO1xuICAgIC8qKiBUaGUgYWN0aW9uKHMpIHRvIGJlIGV4ZWN1dGVkIHVwb24gZXhpdGluZyB0aGUgc3RhdGUgbm9kZS4gKi9cbiAgICB0aGlzLmV4aXQgPSB2b2lkIDA7XG4gICAgLyoqIFRoZSBwYXJlbnQgc3RhdGUgbm9kZS4gKi9cbiAgICB0aGlzLnBhcmVudCA9IHZvaWQgMDtcbiAgICAvKiogVGhlIHJvb3QgbWFjaGluZSBub2RlLiAqL1xuICAgIHRoaXMubWFjaGluZSA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBUaGUgbWV0YSBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHN0YXRlIG5vZGUsIHdoaWNoIHdpbGwgYmUgcmV0dXJuZWQgaW5cbiAgICAgKiBTdGF0ZSBpbnN0YW5jZXMuXG4gICAgICovXG4gICAgdGhpcy5tZXRhID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIFRoZSBvdXRwdXQgZGF0YSBzZW50IHdpdGggdGhlIFwieHN0YXRlLmRvbmUuc3RhdGUuX2lkX1wiIGV2ZW50IGlmIHRoaXMgaXMgYVxuICAgICAqIGZpbmFsIHN0YXRlIG5vZGUuXG4gICAgICovXG4gICAgdGhpcy5vdXRwdXQgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogVGhlIG9yZGVyIHRoaXMgc3RhdGUgbm9kZSBhcHBlYXJzLiBDb3JyZXNwb25kcyB0byB0aGUgaW1wbGljaXQgZG9jdW1lbnRcbiAgICAgKiBvcmRlci5cbiAgICAgKi9cbiAgICB0aGlzLm9yZGVyID0gLTE7XG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IHZvaWQgMDtcbiAgICB0aGlzLnRhZ3MgPSBbXTtcbiAgICB0aGlzLnRyYW5zaXRpb25zID0gdm9pZCAwO1xuICAgIHRoaXMuYWx3YXlzID0gdm9pZCAwO1xuICAgIHRoaXMucGFyZW50ID0gb3B0aW9ucy5fcGFyZW50O1xuICAgIHRoaXMua2V5ID0gb3B0aW9ucy5fa2V5O1xuICAgIHRoaXMubWFjaGluZSA9IG9wdGlvbnMuX21hY2hpbmU7XG4gICAgdGhpcy5wYXRoID0gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5wYXRoLmNvbmNhdCh0aGlzLmtleSkgOiBbXTtcbiAgICB0aGlzLmlkID0gdGhpcy5jb25maWcuaWQgfHwgW3RoaXMubWFjaGluZS5pZCwgLi4udGhpcy5wYXRoXS5qb2luKFNUQVRFX0RFTElNSVRFUik7XG4gICAgdGhpcy50eXBlID0gdGhpcy5jb25maWcudHlwZSB8fCAodGhpcy5jb25maWcuc3RhdGVzICYmIE9iamVjdC5rZXlzKHRoaXMuY29uZmlnLnN0YXRlcykubGVuZ3RoID8gJ2NvbXBvdW5kJyA6IHRoaXMuY29uZmlnLmhpc3RvcnkgPyAnaGlzdG9yeScgOiAnYXRvbWljJyk7XG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IHRoaXMuY29uZmlnLmRlc2NyaXB0aW9uO1xuICAgIHRoaXMub3JkZXIgPSB0aGlzLm1hY2hpbmUuaWRNYXAuc2l6ZTtcbiAgICB0aGlzLm1hY2hpbmUuaWRNYXAuc2V0KHRoaXMuaWQsIHRoaXMpO1xuICAgIHRoaXMuc3RhdGVzID0gdGhpcy5jb25maWcuc3RhdGVzID8gbWFwVmFsdWVzKHRoaXMuY29uZmlnLnN0YXRlcywgKHN0YXRlQ29uZmlnLCBrZXkpID0+IHtcbiAgICAgIGNvbnN0IHN0YXRlTm9kZSA9IG5ldyBTdGF0ZU5vZGUoc3RhdGVDb25maWcsIHtcbiAgICAgICAgX3BhcmVudDogdGhpcyxcbiAgICAgICAgX2tleToga2V5LFxuICAgICAgICBfbWFjaGluZTogdGhpcy5tYWNoaW5lXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzdGF0ZU5vZGU7XG4gICAgfSkgOiBFTVBUWV9PQkpFQ1Q7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gJ2NvbXBvdW5kJyAmJiAhdGhpcy5jb25maWcuaW5pdGlhbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBpbml0aWFsIHN0YXRlIHNwZWNpZmllZCBmb3IgY29tcG91bmQgc3RhdGUgbm9kZSBcIiMke3RoaXMuaWR9XCIuIFRyeSBhZGRpbmcgeyBpbml0aWFsOiBcIiR7T2JqZWN0LmtleXModGhpcy5zdGF0ZXMpWzBdfVwiIH0gdG8gdGhlIHN0YXRlIGNvbmZpZy5gKTtcbiAgICB9XG5cbiAgICAvLyBIaXN0b3J5IGNvbmZpZ1xuICAgIHRoaXMuaGlzdG9yeSA9IHRoaXMuY29uZmlnLmhpc3RvcnkgPT09IHRydWUgPyAnc2hhbGxvdycgOiB0aGlzLmNvbmZpZy5oaXN0b3J5IHx8IGZhbHNlO1xuICAgIHRoaXMuZW50cnkgPSB0b0FycmF5KHRoaXMuY29uZmlnLmVudHJ5KS5zbGljZSgpO1xuICAgIHRoaXMuZXhpdCA9IHRvQXJyYXkodGhpcy5jb25maWcuZXhpdCkuc2xpY2UoKTtcbiAgICB0aGlzLm1ldGEgPSB0aGlzLmNvbmZpZy5tZXRhO1xuICAgIHRoaXMub3V0cHV0ID0gdGhpcy50eXBlID09PSAnZmluYWwnIHx8ICF0aGlzLnBhcmVudCA/IHRoaXMuY29uZmlnLm91dHB1dCA6IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRhZ3MgPSB0b0FycmF5KGNvbmZpZy50YWdzKS5zbGljZSgpO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLnRyYW5zaXRpb25zID0gZm9ybWF0VHJhbnNpdGlvbnModGhpcyk7XG4gICAgaWYgKHRoaXMuY29uZmlnLmFsd2F5cykge1xuICAgICAgdGhpcy5hbHdheXMgPSB0b1RyYW5zaXRpb25Db25maWdBcnJheSh0aGlzLmNvbmZpZy5hbHdheXMpLm1hcCh0ID0+IGZvcm1hdFRyYW5zaXRpb24odGhpcywgTlVMTF9FVkVOVCwgdCkpO1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyh0aGlzLnN0YXRlcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgdGhpcy5zdGF0ZXNba2V5XS5faW5pdGlhbGl6ZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIFRoZSB3ZWxsLXN0cnVjdHVyZWQgc3RhdGUgbm9kZSBkZWZpbml0aW9uLiAqL1xuICBnZXQgZGVmaW5pdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICBrZXk6IHRoaXMua2V5LFxuICAgICAgdmVyc2lvbjogdGhpcy5tYWNoaW5lLnZlcnNpb24sXG4gICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICBpbml0aWFsOiB0aGlzLmluaXRpYWwgPyB7XG4gICAgICAgIHRhcmdldDogdGhpcy5pbml0aWFsLnRhcmdldCxcbiAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICBhY3Rpb25zOiB0aGlzLmluaXRpYWwuYWN0aW9ucy5tYXAodG9TZXJpYWxpemFibGVBY3Rpb24pLFxuICAgICAgICBldmVudFR5cGU6IG51bGwsXG4gICAgICAgIHJlZW50ZXI6IGZhbHNlLFxuICAgICAgICB0b0pTT046ICgpID0+ICh7XG4gICAgICAgICAgdGFyZ2V0OiB0aGlzLmluaXRpYWwudGFyZ2V0Lm1hcCh0ID0+IGAjJHt0LmlkfWApLFxuICAgICAgICAgIHNvdXJjZTogYCMke3RoaXMuaWR9YCxcbiAgICAgICAgICBhY3Rpb25zOiB0aGlzLmluaXRpYWwuYWN0aW9ucy5tYXAodG9TZXJpYWxpemFibGVBY3Rpb24pLFxuICAgICAgICAgIGV2ZW50VHlwZTogbnVsbFxuICAgICAgICB9KVxuICAgICAgfSA6IHVuZGVmaW5lZCxcbiAgICAgIGhpc3Rvcnk6IHRoaXMuaGlzdG9yeSxcbiAgICAgIHN0YXRlczogbWFwVmFsdWVzKHRoaXMuc3RhdGVzLCBzdGF0ZSA9PiB7XG4gICAgICAgIHJldHVybiBzdGF0ZS5kZWZpbml0aW9uO1xuICAgICAgfSksXG4gICAgICBvbjogdGhpcy5vbixcbiAgICAgIHRyYW5zaXRpb25zOiBbLi4udGhpcy50cmFuc2l0aW9ucy52YWx1ZXMoKV0uZmxhdCgpLm1hcCh0ID0+ICh7XG4gICAgICAgIC4uLnQsXG4gICAgICAgIGFjdGlvbnM6IHQuYWN0aW9ucy5tYXAodG9TZXJpYWxpemFibGVBY3Rpb24pXG4gICAgICB9KSksXG4gICAgICBlbnRyeTogdGhpcy5lbnRyeS5tYXAodG9TZXJpYWxpemFibGVBY3Rpb24pLFxuICAgICAgZXhpdDogdGhpcy5leGl0Lm1hcCh0b1NlcmlhbGl6YWJsZUFjdGlvbiksXG4gICAgICBtZXRhOiB0aGlzLm1ldGEsXG4gICAgICBvcmRlcjogdGhpcy5vcmRlciB8fCAtMSxcbiAgICAgIG91dHB1dDogdGhpcy5vdXRwdXQsXG4gICAgICBpbnZva2U6IHRoaXMuaW52b2tlLFxuICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24sXG4gICAgICB0YWdzOiB0aGlzLnRhZ3NcbiAgICB9O1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmaW5pdGlvbjtcbiAgfVxuXG4gIC8qKiBUaGUgbG9naWMgaW52b2tlZCBhcyBhY3RvcnMgYnkgdGhpcyBzdGF0ZSBub2RlLiAqL1xuICBnZXQgaW52b2tlKCkge1xuICAgIHJldHVybiBtZW1vKHRoaXMsICdpbnZva2UnLCAoKSA9PiB0b0FycmF5KHRoaXMuY29uZmlnLmludm9rZSkubWFwKChpbnZva2VDb25maWcsIGkpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3JjLFxuICAgICAgICBzeXN0ZW1JZFxuICAgICAgfSA9IGludm9rZUNvbmZpZztcbiAgICAgIGNvbnN0IHJlc29sdmVkSWQgPSBpbnZva2VDb25maWcuaWQgPz8gY3JlYXRlSW52b2tlSWQodGhpcy5pZCwgaSk7XG4gICAgICBjb25zdCBzb3VyY2VOYW1lID0gdHlwZW9mIHNyYyA9PT0gJ3N0cmluZycgPyBzcmMgOiBgeHN0YXRlLmludm9rZS4ke2NyZWF0ZUludm9rZUlkKHRoaXMuaWQsIGkpfWA7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5pbnZva2VDb25maWcsXG4gICAgICAgIHNyYzogc291cmNlTmFtZSxcbiAgICAgICAgaWQ6IHJlc29sdmVkSWQsXG4gICAgICAgIHN5c3RlbUlkOiBzeXN0ZW1JZCxcbiAgICAgICAgdG9KU09OKCkge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIG9uRG9uZSxcbiAgICAgICAgICAgIG9uRXJyb3IsXG4gICAgICAgICAgICAuLi5pbnZva2VEZWZWYWx1ZXNcbiAgICAgICAgICB9ID0gaW52b2tlQ29uZmlnO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5pbnZva2VEZWZWYWx1ZXMsXG4gICAgICAgICAgICB0eXBlOiAneHN0YXRlLmludm9rZScsXG4gICAgICAgICAgICBzcmM6IHNvdXJjZU5hbWUsXG4gICAgICAgICAgICBpZDogcmVzb2x2ZWRJZFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSkpO1xuICB9XG5cbiAgLyoqIFRoZSBtYXBwaW5nIG9mIGV2ZW50cyB0byB0cmFuc2l0aW9ucy4gKi9cbiAgZ2V0IG9uKCkge1xuICAgIHJldHVybiBtZW1vKHRoaXMsICdvbicsICgpID0+IHtcbiAgICAgIGNvbnN0IHRyYW5zaXRpb25zID0gdGhpcy50cmFuc2l0aW9ucztcbiAgICAgIHJldHVybiBbLi4udHJhbnNpdGlvbnNdLmZsYXRNYXAoKFtkZXNjcmlwdG9yLCB0XSkgPT4gdC5tYXAodCA9PiBbZGVzY3JpcHRvciwgdF0pKS5yZWR1Y2UoKG1hcCwgW2Rlc2NyaXB0b3IsIHRyYW5zaXRpb25dKSA9PiB7XG4gICAgICAgIG1hcFtkZXNjcmlwdG9yXSA9IG1hcFtkZXNjcmlwdG9yXSB8fCBbXTtcbiAgICAgICAgbWFwW2Rlc2NyaXB0b3JdLnB1c2godHJhbnNpdGlvbik7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgICB9LCB7fSk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0IGFmdGVyKCkge1xuICAgIHJldHVybiBtZW1vKHRoaXMsICdkZWxheWVkVHJhbnNpdGlvbnMnLCAoKSA9PiBnZXREZWxheWVkVHJhbnNpdGlvbnModGhpcykpO1xuICB9XG4gIGdldCBpbml0aWFsKCkge1xuICAgIHJldHVybiBtZW1vKHRoaXMsICdpbml0aWFsJywgKCkgPT4gZm9ybWF0SW5pdGlhbFRyYW5zaXRpb24odGhpcywgdGhpcy5jb25maWcuaW5pdGlhbCkpO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBuZXh0KHNuYXBzaG90LCBldmVudCkge1xuICAgIGNvbnN0IGV2ZW50VHlwZSA9IGV2ZW50LnR5cGU7XG4gICAgY29uc3QgYWN0aW9ucyA9IFtdO1xuICAgIGxldCBzZWxlY3RlZFRyYW5zaXRpb247XG4gICAgY29uc3QgY2FuZGlkYXRlcyA9IG1lbW8odGhpcywgYGNhbmRpZGF0ZXMtJHtldmVudFR5cGV9YCwgKCkgPT4gZ2V0Q2FuZGlkYXRlcyh0aGlzLCBldmVudFR5cGUpKTtcbiAgICBmb3IgKGNvbnN0IGNhbmRpZGF0ZSBvZiBjYW5kaWRhdGVzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGd1YXJkXG4gICAgICB9ID0gY2FuZGlkYXRlO1xuICAgICAgY29uc3QgcmVzb2x2ZWRDb250ZXh0ID0gc25hcHNob3QuY29udGV4dDtcbiAgICAgIGxldCBndWFyZFBhc3NlZCA9IGZhbHNlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZ3VhcmRQYXNzZWQgPSAhZ3VhcmQgfHwgZXZhbHVhdGVHdWFyZChndWFyZCwgcmVzb2x2ZWRDb250ZXh0LCBldmVudCwgc25hcHNob3QpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IGd1YXJkVHlwZSA9IHR5cGVvZiBndWFyZCA9PT0gJ3N0cmluZycgPyBndWFyZCA6IHR5cGVvZiBndWFyZCA9PT0gJ29iamVjdCcgPyBndWFyZC50eXBlIDogdW5kZWZpbmVkO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBldmFsdWF0ZSBndWFyZCAke2d1YXJkVHlwZSA/IGAnJHtndWFyZFR5cGV9JyBgIDogJyd9aW4gdHJhbnNpdGlvbiBmb3IgZXZlbnQgJyR7ZXZlbnRUeXBlfScgaW4gc3RhdGUgbm9kZSAnJHt0aGlzLmlkfSc6XFxuJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICAgIGlmIChndWFyZFBhc3NlZCkge1xuICAgICAgICBhY3Rpb25zLnB1c2goLi4uY2FuZGlkYXRlLmFjdGlvbnMpO1xuICAgICAgICBzZWxlY3RlZFRyYW5zaXRpb24gPSBjYW5kaWRhdGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0ZWRUcmFuc2l0aW9uID8gW3NlbGVjdGVkVHJhbnNpdGlvbl0gOiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKiogQWxsIHRoZSBldmVudCB0eXBlcyBhY2NlcHRlZCBieSB0aGlzIHN0YXRlIG5vZGUgYW5kIGl0cyBkZXNjZW5kYW50cy4gKi9cbiAgZ2V0IGV2ZW50cygpIHtcbiAgICByZXR1cm4gbWVtbyh0aGlzLCAnZXZlbnRzJywgKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzdGF0ZXNcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgY29uc3QgZXZlbnRzID0gbmV3IFNldCh0aGlzLm93bkV2ZW50cyk7XG4gICAgICBpZiAoc3RhdGVzKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc3RhdGVJZCBvZiBPYmplY3Qua2V5cyhzdGF0ZXMpKSB7XG4gICAgICAgICAgY29uc3Qgc3RhdGUgPSBzdGF0ZXNbc3RhdGVJZF07XG4gICAgICAgICAgaWYgKHN0YXRlLnN0YXRlcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiBzdGF0ZS5ldmVudHMpIHtcbiAgICAgICAgICAgICAgZXZlbnRzLmFkZChgJHtldmVudH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBBcnJheS5mcm9tKGV2ZW50cyk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQWxsIHRoZSBldmVudHMgdGhhdCBoYXZlIHRyYW5zaXRpb25zIGRpcmVjdGx5IGZyb20gdGhpcyBzdGF0ZSBub2RlLlxuICAgKlxuICAgKiBFeGNsdWRlcyBhbnkgaW5lcnQgZXZlbnRzLlxuICAgKi9cbiAgZ2V0IG93bkV2ZW50cygpIHtcbiAgICBjb25zdCBldmVudHMgPSBuZXcgU2V0KFsuLi50aGlzLnRyYW5zaXRpb25zLmtleXMoKV0uZmlsdGVyKGRlc2NyaXB0b3IgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvbnMuZ2V0KGRlc2NyaXB0b3IpLnNvbWUodHJhbnNpdGlvbiA9PiAhKCF0cmFuc2l0aW9uLnRhcmdldCAmJiAhdHJhbnNpdGlvbi5hY3Rpb25zLmxlbmd0aCAmJiAhdHJhbnNpdGlvbi5yZWVudGVyKSk7XG4gICAgfSkpO1xuICAgIHJldHVybiBBcnJheS5mcm9tKGV2ZW50cyk7XG4gIH1cbn1cblxuY29uc3QgU1RBVEVfSURFTlRJRklFUiA9ICcjJztcbmNsYXNzIFN0YXRlTWFjaGluZSB7XG4gIGNvbnN0cnVjdG9yKC8qKiBUaGUgcmF3IGNvbmZpZyB1c2VkIHRvIGNyZWF0ZSB0aGUgbWFjaGluZS4gKi9cbiAgY29uZmlnLCBpbXBsZW1lbnRhdGlvbnMpIHtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAvKiogVGhlIG1hY2hpbmUncyBvd24gdmVyc2lvbi4gKi9cbiAgICB0aGlzLnZlcnNpb24gPSB2b2lkIDA7XG4gICAgdGhpcy5zY2hlbWFzID0gdm9pZCAwO1xuICAgIHRoaXMuaW1wbGVtZW50YXRpb25zID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9feHN0YXRlbm9kZSA9IHRydWU7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuaWRNYXAgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5yb290ID0gdm9pZCAwO1xuICAgIHRoaXMuaWQgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGF0ZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5ldmVudHMgPSB2b2lkIDA7XG4gICAgdGhpcy5pZCA9IGNvbmZpZy5pZCB8fCAnKG1hY2hpbmUpJztcbiAgICB0aGlzLmltcGxlbWVudGF0aW9ucyA9IHtcbiAgICAgIGFjdG9yczogaW1wbGVtZW50YXRpb25zPy5hY3RvcnMgPz8ge30sXG4gICAgICBhY3Rpb25zOiBpbXBsZW1lbnRhdGlvbnM/LmFjdGlvbnMgPz8ge30sXG4gICAgICBkZWxheXM6IGltcGxlbWVudGF0aW9ucz8uZGVsYXlzID8/IHt9LFxuICAgICAgZ3VhcmRzOiBpbXBsZW1lbnRhdGlvbnM/Lmd1YXJkcyA/PyB7fVxuICAgIH07XG4gICAgdGhpcy52ZXJzaW9uID0gdGhpcy5jb25maWcudmVyc2lvbjtcbiAgICB0aGlzLnNjaGVtYXMgPSB0aGlzLmNvbmZpZy5zY2hlbWFzO1xuICAgIHRoaXMudHJhbnNpdGlvbiA9IHRoaXMudHJhbnNpdGlvbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZ2V0SW5pdGlhbFNuYXBzaG90ID0gdGhpcy5nZXRJbml0aWFsU25hcHNob3QuYmluZCh0aGlzKTtcbiAgICB0aGlzLmdldFBlcnNpc3RlZFNuYXBzaG90ID0gdGhpcy5nZXRQZXJzaXN0ZWRTbmFwc2hvdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMucmVzdG9yZVNuYXBzaG90ID0gdGhpcy5yZXN0b3JlU25hcHNob3QuYmluZCh0aGlzKTtcbiAgICB0aGlzLnN0YXJ0ID0gdGhpcy5zdGFydC5iaW5kKHRoaXMpO1xuICAgIHRoaXMucm9vdCA9IG5ldyBTdGF0ZU5vZGUoY29uZmlnLCB7XG4gICAgICBfa2V5OiB0aGlzLmlkLFxuICAgICAgX21hY2hpbmU6IHRoaXNcbiAgICB9KTtcbiAgICB0aGlzLnJvb3QuX2luaXRpYWxpemUoKTtcbiAgICB0aGlzLnN0YXRlcyA9IHRoaXMucm9vdC5zdGF0ZXM7IC8vIFRPRE86IHJlbW92ZSFcbiAgICB0aGlzLmV2ZW50cyA9IHRoaXMucm9vdC5ldmVudHM7XG4gICAgaWYgKCEoJ291dHB1dCcgaW4gdGhpcy5yb290KSAmJiBPYmplY3QudmFsdWVzKHRoaXMuc3RhdGVzKS5zb21lKHN0YXRlID0+IHN0YXRlLnR5cGUgPT09ICdmaW5hbCcgJiYgJ291dHB1dCcgaW4gc3RhdGUpKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ01pc3NpbmcgYG1hY2hpbmUub3V0cHV0YCBkZWNsYXJhdGlvbiAodG9wLWxldmVsIGZpbmFsIHN0YXRlIHdpdGggb3V0cHV0IGRldGVjdGVkKScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9uZXMgdGhpcyBzdGF0ZSBtYWNoaW5lIHdpdGggdGhlIHByb3ZpZGVkIGltcGxlbWVudGF0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIGltcGxlbWVudGF0aW9ucyBPcHRpb25zIChgYWN0aW9uc2AsIGBndWFyZHNgLCBgYWN0b3JzYCwgYGRlbGF5c2ApIHRvXG4gICAqICAgcmVjdXJzaXZlbHkgbWVyZ2Ugd2l0aCB0aGUgZXhpc3Rpbmcgb3B0aW9ucy5cbiAgICogQHJldHVybnMgQSBuZXcgYFN0YXRlTWFjaGluZWAgaW5zdGFuY2Ugd2l0aCB0aGUgcHJvdmlkZWQgaW1wbGVtZW50YXRpb25zLlxuICAgKi9cbiAgcHJvdmlkZShpbXBsZW1lbnRhdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBhY3Rpb25zLFxuICAgICAgZ3VhcmRzLFxuICAgICAgYWN0b3JzLFxuICAgICAgZGVsYXlzXG4gICAgfSA9IHRoaXMuaW1wbGVtZW50YXRpb25zO1xuICAgIHJldHVybiBuZXcgU3RhdGVNYWNoaW5lKHRoaXMuY29uZmlnLCB7XG4gICAgICBhY3Rpb25zOiB7XG4gICAgICAgIC4uLmFjdGlvbnMsXG4gICAgICAgIC4uLmltcGxlbWVudGF0aW9ucy5hY3Rpb25zXG4gICAgICB9LFxuICAgICAgZ3VhcmRzOiB7XG4gICAgICAgIC4uLmd1YXJkcyxcbiAgICAgICAgLi4uaW1wbGVtZW50YXRpb25zLmd1YXJkc1xuICAgICAgfSxcbiAgICAgIGFjdG9yczoge1xuICAgICAgICAuLi5hY3RvcnMsXG4gICAgICAgIC4uLmltcGxlbWVudGF0aW9ucy5hY3RvcnNcbiAgICAgIH0sXG4gICAgICBkZWxheXM6IHtcbiAgICAgICAgLi4uZGVsYXlzLFxuICAgICAgICAuLi5pbXBsZW1lbnRhdGlvbnMuZGVsYXlzXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmVzb2x2ZVN0YXRlKGNvbmZpZykge1xuICAgIGNvbnN0IHJlc29sdmVkU3RhdGVWYWx1ZSA9IHJlc29sdmVTdGF0ZVZhbHVlKHRoaXMucm9vdCwgY29uZmlnLnZhbHVlKTtcbiAgICBjb25zdCBub2RlU2V0ID0gZ2V0QWxsU3RhdGVOb2RlcyhnZXRTdGF0ZU5vZGVzKHRoaXMucm9vdCwgcmVzb2x2ZWRTdGF0ZVZhbHVlKSk7XG4gICAgcmV0dXJuIGNyZWF0ZU1hY2hpbmVTbmFwc2hvdCh7XG4gICAgICBfbm9kZXM6IFsuLi5ub2RlU2V0XSxcbiAgICAgIGNvbnRleHQ6IGNvbmZpZy5jb250ZXh0IHx8IHt9LFxuICAgICAgY2hpbGRyZW46IHt9LFxuICAgICAgc3RhdHVzOiBpc0luRmluYWxTdGF0ZShub2RlU2V0LCB0aGlzLnJvb3QpID8gJ2RvbmUnIDogY29uZmlnLnN0YXR1cyB8fCAnYWN0aXZlJyxcbiAgICAgIG91dHB1dDogY29uZmlnLm91dHB1dCxcbiAgICAgIGVycm9yOiBjb25maWcuZXJyb3IsXG4gICAgICBoaXN0b3J5VmFsdWU6IGNvbmZpZy5oaXN0b3J5VmFsdWVcbiAgICB9LCB0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBuZXh0IHNuYXBzaG90IGdpdmVuIHRoZSBjdXJyZW50IGBzbmFwc2hvdGAgYW5kIHJlY2VpdmVkXG4gICAqIGBldmVudGAuIENhbGN1bGF0ZXMgYSBmdWxsIG1hY3Jvc3RlcCBmcm9tIGFsbCBtaWNyb3N0ZXBzLlxuICAgKlxuICAgKiBAcGFyYW0gc25hcHNob3QgVGhlIGN1cnJlbnQgc25hcHNob3RcbiAgICogQHBhcmFtIGV2ZW50IFRoZSByZWNlaXZlZCBldmVudFxuICAgKi9cbiAgdHJhbnNpdGlvbihzbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUpIHtcbiAgICByZXR1cm4gbWFjcm9zdGVwKHNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSwgW10pLnNuYXBzaG90O1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgdGhlIG5leHQgc3RhdGUgZ2l2ZW4gdGhlIGN1cnJlbnQgYHN0YXRlYCBhbmQgYGV2ZW50YC4gQ2FsY3VsYXRlc1xuICAgKiBhIG1pY3Jvc3RlcC5cbiAgICpcbiAgICogQHBhcmFtIHN0YXRlIFRoZSBjdXJyZW50IHN0YXRlXG4gICAqIEBwYXJhbSBldmVudCBUaGUgcmVjZWl2ZWQgZXZlbnRcbiAgICovXG4gIG1pY3Jvc3RlcChzbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUpIHtcbiAgICByZXR1cm4gbWFjcm9zdGVwKHNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSwgW10pLm1pY3Jvc3RhdGVzO1xuICB9XG4gIGdldFRyYW5zaXRpb25EYXRhKHNuYXBzaG90LCBldmVudCkge1xuICAgIHJldHVybiB0cmFuc2l0aW9uTm9kZSh0aGlzLnJvb3QsIHNuYXBzaG90LnZhbHVlLCBzbmFwc2hvdCwgZXZlbnQpIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBpbml0aWFsIHN0YXRlIF9iZWZvcmVfIGV2YWx1YXRpbmcgYW55IG1pY3Jvc3RlcHMuIFRoaXMgXCJwcmUtaW5pdGlhbFwiXG4gICAqIHN0YXRlIGlzIHByb3ZpZGVkIHRvIGluaXRpYWwgYWN0aW9ucyBleGVjdXRlZCBpbiB0aGUgaW5pdGlhbCBzdGF0ZS5cbiAgICovXG4gIGdldFByZUluaXRpYWxTdGF0ZShhY3RvclNjb3BlLCBpbml0RXZlbnQsIGludGVybmFsUXVldWUpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250ZXh0XG4gICAgfSA9IHRoaXMuY29uZmlnO1xuICAgIGNvbnN0IHByZUluaXRpYWwgPSBjcmVhdGVNYWNoaW5lU25hcHNob3Qoe1xuICAgICAgY29udGV4dDogdHlwZW9mIGNvbnRleHQgIT09ICdmdW5jdGlvbicgJiYgY29udGV4dCA/IGNvbnRleHQgOiB7fSxcbiAgICAgIF9ub2RlczogW3RoaXMucm9vdF0sXG4gICAgICBjaGlsZHJlbjoge30sXG4gICAgICBzdGF0dXM6ICdhY3RpdmUnXG4gICAgfSwgdGhpcyk7XG4gICAgaWYgKHR5cGVvZiBjb250ZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zdCBhc3NpZ25tZW50ID0gKHtcbiAgICAgICAgc3Bhd24sXG4gICAgICAgIGV2ZW50LFxuICAgICAgICBzZWxmXG4gICAgICB9KSA9PiBjb250ZXh0KHtcbiAgICAgICAgc3Bhd24sXG4gICAgICAgIGlucHV0OiBldmVudC5pbnB1dCxcbiAgICAgICAgc2VsZlxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzb2x2ZUFjdGlvbnNBbmRDb250ZXh0KHByZUluaXRpYWwsIGluaXRFdmVudCwgYWN0b3JTY29wZSwgW2Fzc2lnbihhc3NpZ25tZW50KV0sIGludGVybmFsUXVldWUsIHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIHJldHVybiBwcmVJbml0aWFsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGluaXRpYWwgYFN0YXRlYCBpbnN0YW5jZSwgd2l0aCByZWZlcmVuY2UgdG8gYHNlbGZgIGFzIGFuXG4gICAqIGBBY3RvclJlZmAuXG4gICAqL1xuICBnZXRJbml0aWFsU25hcHNob3QoYWN0b3JTY29wZSwgaW5wdXQpIHtcbiAgICBjb25zdCBpbml0RXZlbnQgPSBjcmVhdGVJbml0RXZlbnQoaW5wdXQpOyAvLyBUT0RPOiBmaXg7XG4gICAgY29uc3QgaW50ZXJuYWxRdWV1ZSA9IFtdO1xuICAgIGNvbnN0IHByZUluaXRpYWxTdGF0ZSA9IHRoaXMuZ2V0UHJlSW5pdGlhbFN0YXRlKGFjdG9yU2NvcGUsIGluaXRFdmVudCwgaW50ZXJuYWxRdWV1ZSk7XG4gICAgY29uc3QgbmV4dFN0YXRlID0gbWljcm9zdGVwKFt7XG4gICAgICB0YXJnZXQ6IFsuLi5nZXRJbml0aWFsU3RhdGVOb2Rlcyh0aGlzLnJvb3QpXSxcbiAgICAgIHNvdXJjZTogdGhpcy5yb290LFxuICAgICAgcmVlbnRlcjogdHJ1ZSxcbiAgICAgIGFjdGlvbnM6IFtdLFxuICAgICAgZXZlbnRUeXBlOiBudWxsLFxuICAgICAgdG9KU09OOiBudWxsIC8vIFRPRE86IGZpeFxuICAgIH1dLCBwcmVJbml0aWFsU3RhdGUsIGFjdG9yU2NvcGUsIGluaXRFdmVudCwgdHJ1ZSwgaW50ZXJuYWxRdWV1ZSk7XG4gICAgY29uc3Qge1xuICAgICAgc25hcHNob3Q6IG1hY3JvU3RhdGVcbiAgICB9ID0gbWFjcm9zdGVwKG5leHRTdGF0ZSwgaW5pdEV2ZW50LCBhY3RvclNjb3BlLCBpbnRlcm5hbFF1ZXVlKTtcbiAgICByZXR1cm4gbWFjcm9TdGF0ZTtcbiAgfVxuICBzdGFydChzbmFwc2hvdCkge1xuICAgIE9iamVjdC52YWx1ZXMoc25hcHNob3QuY2hpbGRyZW4pLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgaWYgKGNoaWxkLmdldFNuYXBzaG90KCkuc3RhdHVzID09PSAnYWN0aXZlJykge1xuICAgICAgICBjaGlsZC5zdGFydCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldFN0YXRlTm9kZUJ5SWQoc3RhdGVJZCkge1xuICAgIGNvbnN0IGZ1bGxQYXRoID0gdG9TdGF0ZVBhdGgoc3RhdGVJZCk7XG4gICAgY29uc3QgcmVsYXRpdmVQYXRoID0gZnVsbFBhdGguc2xpY2UoMSk7XG4gICAgY29uc3QgcmVzb2x2ZWRTdGF0ZUlkID0gaXNTdGF0ZUlkKGZ1bGxQYXRoWzBdKSA/IGZ1bGxQYXRoWzBdLnNsaWNlKFNUQVRFX0lERU5USUZJRVIubGVuZ3RoKSA6IGZ1bGxQYXRoWzBdO1xuICAgIGNvbnN0IHN0YXRlTm9kZSA9IHRoaXMuaWRNYXAuZ2V0KHJlc29sdmVkU3RhdGVJZCk7XG4gICAgaWYgKCFzdGF0ZU5vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2hpbGQgc3RhdGUgbm9kZSAnIyR7cmVzb2x2ZWRTdGF0ZUlkfScgZG9lcyBub3QgZXhpc3Qgb24gbWFjaGluZSAnJHt0aGlzLmlkfSdgKTtcbiAgICB9XG4gICAgcmV0dXJuIGdldFN0YXRlTm9kZUJ5UGF0aChzdGF0ZU5vZGUsIHJlbGF0aXZlUGF0aCk7XG4gIH1cbiAgZ2V0IGRlZmluaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucm9vdC5kZWZpbml0aW9uO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZpbml0aW9uO1xuICB9XG4gIGdldFBlcnNpc3RlZFNuYXBzaG90KHNuYXBzaG90LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGdldFBlcnNpc3RlZFNuYXBzaG90KHNuYXBzaG90LCBvcHRpb25zKTtcbiAgfVxuICByZXN0b3JlU25hcHNob3Qoc25hcHNob3QsIF9hY3RvclNjb3BlKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB7fTtcbiAgICBjb25zdCBzbmFwc2hvdENoaWxkcmVuID0gc25hcHNob3QuY2hpbGRyZW47XG4gICAgT2JqZWN0LmtleXMoc25hcHNob3RDaGlsZHJlbikuZm9yRWFjaChhY3RvcklkID0+IHtcbiAgICAgIGNvbnN0IGFjdG9yRGF0YSA9IHNuYXBzaG90Q2hpbGRyZW5bYWN0b3JJZF07XG4gICAgICBjb25zdCBjaGlsZFN0YXRlID0gYWN0b3JEYXRhLnNuYXBzaG90O1xuICAgICAgY29uc3Qgc3JjID0gYWN0b3JEYXRhLnNyYztcbiAgICAgIGNvbnN0IGxvZ2ljID0gdHlwZW9mIHNyYyA9PT0gJ3N0cmluZycgPyByZXNvbHZlUmVmZXJlbmNlZEFjdG9yKHRoaXMsIHNyYykgOiBzcmM7XG4gICAgICBpZiAoIWxvZ2ljKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFjdG9yUmVmID0gY3JlYXRlQWN0b3IobG9naWMsIHtcbiAgICAgICAgaWQ6IGFjdG9ySWQsXG4gICAgICAgIHBhcmVudDogX2FjdG9yU2NvcGUuc2VsZixcbiAgICAgICAgc3luY1NuYXBzaG90OiBhY3RvckRhdGEuc3luY1NuYXBzaG90LFxuICAgICAgICBzbmFwc2hvdDogY2hpbGRTdGF0ZSxcbiAgICAgICAgc3JjLFxuICAgICAgICBzeXN0ZW1JZDogYWN0b3JEYXRhLnN5c3RlbUlkXG4gICAgICB9KTtcbiAgICAgIGNoaWxkcmVuW2FjdG9ySWRdID0gYWN0b3JSZWY7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gcmVzb2x2ZUhpc3RvcnlSZWZlcmVuY2VkU3RhdGUocm9vdCwgcmVmZXJlbmNlZCkge1xuICAgICAgaWYgKHJlZmVyZW5jZWQgaW5zdGFuY2VvZiBTdGF0ZU5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZWQ7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gcm9vdC5tYWNoaW5lLmdldFN0YXRlTm9kZUJ5SWQocmVmZXJlbmNlZC5pZCk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IHJlc29sdmUgU3RhdGVOb2RlIGZvciBpZDogJHtyZWZlcmVuY2VkLmlkfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJldml2ZUhpc3RvcnlWYWx1ZShyb290LCBoaXN0b3J5VmFsdWUpIHtcbiAgICAgIGlmICghaGlzdG9yeVZhbHVlIHx8IHR5cGVvZiBoaXN0b3J5VmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJldml2ZWQgPSB7fTtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGhpc3RvcnlWYWx1ZSkge1xuICAgICAgICBjb25zdCBhcnIgPSBoaXN0b3J5VmFsdWVba2V5XTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGFycikge1xuICAgICAgICAgIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZUhpc3RvcnlSZWZlcmVuY2VkU3RhdGUocm9vdCwgaXRlbSk7XG4gICAgICAgICAgaWYgKCFyZXNvbHZlZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldml2ZWRba2V5XSA/Pz0gW107XG4gICAgICAgICAgcmV2aXZlZFtrZXldLnB1c2gocmVzb2x2ZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV2aXZlZDtcbiAgICB9XG4gICAgY29uc3QgcmV2aXZlZEhpc3RvcnlWYWx1ZSA9IHJldml2ZUhpc3RvcnlWYWx1ZSh0aGlzLnJvb3QsIHNuYXBzaG90Lmhpc3RvcnlWYWx1ZSk7XG4gICAgY29uc3QgcmVzdG9yZWRTbmFwc2hvdCA9IGNyZWF0ZU1hY2hpbmVTbmFwc2hvdCh7XG4gICAgICAuLi5zbmFwc2hvdCxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgX25vZGVzOiBBcnJheS5mcm9tKGdldEFsbFN0YXRlTm9kZXMoZ2V0U3RhdGVOb2Rlcyh0aGlzLnJvb3QsIHNuYXBzaG90LnZhbHVlKSkpLFxuICAgICAgaGlzdG9yeVZhbHVlOiByZXZpdmVkSGlzdG9yeVZhbHVlXG4gICAgfSwgdGhpcyk7XG4gICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICBmdW5jdGlvbiByZXZpdmVDb250ZXh0KGNvbnRleHRQYXJ0LCBjaGlsZHJlbikge1xuICAgICAgaWYgKHNlZW4uaGFzKGNvbnRleHRQYXJ0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWVuLmFkZChjb250ZXh0UGFydCk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBjb250ZXh0UGFydCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGNvbnRleHRQYXJ0W2tleV07XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgaWYgKCd4c3RhdGUkJHR5cGUnIGluIHZhbHVlICYmIHZhbHVlLnhzdGF0ZSQkdHlwZSA9PT0gJCRBQ1RPUl9UWVBFKSB7XG4gICAgICAgICAgICBjb250ZXh0UGFydFtrZXldID0gY2hpbGRyZW5bdmFsdWUuaWRdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldml2ZUNvbnRleHQodmFsdWUsIGNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXZpdmVDb250ZXh0KHJlc3RvcmVkU25hcHNob3QuY29udGV4dCwgY2hpbGRyZW4pO1xuICAgIHJldHVybiByZXN0b3JlZFNuYXBzaG90O1xuICB9XG59XG5cbmV4cG9ydCB7IFN0YXRlTWFjaGluZSBhcyBTLCBTdGF0ZU5vZGUgYXMgYSB9O1xuIl0sIm5hbWVzIjpbIlMiLCJTVEFURV9ERUxJTUlURVIiLCJsIiwibWFwVmFsdWVzIiwidCIsInRvQXJyYXkiLCJxIiwiZm9ybWF0VHJhbnNpdGlvbnMiLCJ1IiwidG9UcmFuc2l0aW9uQ29uZmlnQXJyYXkiLCJ2IiwiZm9ybWF0VHJhbnNpdGlvbiIsIk4iLCJOVUxMX0VWRU5UIiwidyIsImV2YWx1YXRlR3VhcmQiLCJ4IiwiY3JlYXRlSW52b2tlSWQiLCJ5IiwiZ2V0RGVsYXllZFRyYW5zaXRpb25zIiwieiIsImZvcm1hdEluaXRpYWxUcmFuc2l0aW9uIiwiQiIsImdldENhbmRpZGF0ZXMiLCJDIiwicmVzb2x2ZVN0YXRlVmFsdWUiLCJEIiwiZ2V0QWxsU3RhdGVOb2RlcyIsImciLCJnZXRTdGF0ZU5vZGVzIiwiRSIsImNyZWF0ZU1hY2hpbmVTbmFwc2hvdCIsIkYiLCJpc0luRmluYWxTdGF0ZSIsIkciLCJtYWNyb3N0ZXAiLCJIIiwidHJhbnNpdGlvbk5vZGUiLCJJIiwicmVzb2x2ZUFjdGlvbnNBbmRDb250ZXh0IiwiSiIsImNyZWF0ZUluaXRFdmVudCIsIksiLCJtaWNyb3N0ZXAiLCJMIiwiZ2V0SW5pdGlhbFN0YXRlTm9kZXMiLCJNIiwidG9TdGF0ZVBhdGgiLCJPIiwiaXNTdGF0ZUlkIiwiUCIsImdldFN0YXRlTm9kZUJ5UGF0aCIsIlEiLCJnZXRQZXJzaXN0ZWRTbmFwc2hvdCIsIlIiLCJyZXNvbHZlUmVmZXJlbmNlZEFjdG9yIiwiYyIsImNyZWF0ZUFjdG9yIiwiJCIsIiQkQUNUT1JfVFlQRSIsImEiLCJhc3NpZ24iLCJjYWNoZSIsIldlYWtNYXAiLCJtZW1vIiwib2JqZWN0Iiwia2V5IiwiZm4iLCJtZW1vaXplZERhdGEiLCJnZXQiLCJzZXQiLCJFTVBUWV9PQkpFQ1QiLCJ0b1NlcmlhbGl6YWJsZUFjdGlvbiIsImFjdGlvbiIsInR5cGUiLCJuYW1lIiwiU3RhdGVOb2RlIiwiY29uc3RydWN0b3IiLCJjb25maWciLCJvcHRpb25zIiwiaWQiLCJwYXRoIiwic3RhdGVzIiwiaGlzdG9yeSIsImVudHJ5IiwiZXhpdCIsInBhcmVudCIsIm1hY2hpbmUiLCJtZXRhIiwib3V0cHV0Iiwib3JkZXIiLCJkZXNjcmlwdGlvbiIsInRhZ3MiLCJ0cmFuc2l0aW9ucyIsImFsd2F5cyIsIl9wYXJlbnQiLCJfa2V5IiwiX21hY2hpbmUiLCJjb25jYXQiLCJqb2luIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsImlkTWFwIiwic2l6ZSIsInN0YXRlQ29uZmlnIiwic3RhdGVOb2RlIiwiaW5pdGlhbCIsIkVycm9yIiwic2xpY2UiLCJ1bmRlZmluZWQiLCJfaW5pdGlhbGl6ZSIsIm1hcCIsImZvckVhY2giLCJkZWZpbml0aW9uIiwidmVyc2lvbiIsInRhcmdldCIsInNvdXJjZSIsImFjdGlvbnMiLCJldmVudFR5cGUiLCJyZWVudGVyIiwidG9KU09OIiwic3RhdGUiLCJvbiIsInZhbHVlcyIsImZsYXQiLCJpbnZva2UiLCJpbnZva2VDb25maWciLCJpIiwic3JjIiwic3lzdGVtSWQiLCJyZXNvbHZlZElkIiwic291cmNlTmFtZSIsIm9uRG9uZSIsIm9uRXJyb3IiLCJpbnZva2VEZWZWYWx1ZXMiLCJmbGF0TWFwIiwiZGVzY3JpcHRvciIsInJlZHVjZSIsInRyYW5zaXRpb24iLCJwdXNoIiwiYWZ0ZXIiLCJuZXh0Iiwic25hcHNob3QiLCJldmVudCIsInNlbGVjdGVkVHJhbnNpdGlvbiIsImNhbmRpZGF0ZXMiLCJjYW5kaWRhdGUiLCJndWFyZCIsInJlc29sdmVkQ29udGV4dCIsImNvbnRleHQiLCJndWFyZFBhc3NlZCIsImVyciIsImd1YXJkVHlwZSIsIm1lc3NhZ2UiLCJldmVudHMiLCJTZXQiLCJvd25FdmVudHMiLCJzdGF0ZUlkIiwiYWRkIiwiQXJyYXkiLCJmcm9tIiwiZmlsdGVyIiwic29tZSIsIlNUQVRFX0lERU5USUZJRVIiLCJTdGF0ZU1hY2hpbmUiLCJpbXBsZW1lbnRhdGlvbnMiLCJzY2hlbWFzIiwiX194c3RhdGVub2RlIiwiTWFwIiwicm9vdCIsImFjdG9ycyIsImRlbGF5cyIsImd1YXJkcyIsImJpbmQiLCJnZXRJbml0aWFsU25hcHNob3QiLCJyZXN0b3JlU25hcHNob3QiLCJzdGFydCIsImNvbnNvbGUiLCJ3YXJuIiwicHJvdmlkZSIsInJlc29sdmVTdGF0ZSIsInJlc29sdmVkU3RhdGVWYWx1ZSIsInZhbHVlIiwibm9kZVNldCIsIl9ub2RlcyIsImNoaWxkcmVuIiwic3RhdHVzIiwiZXJyb3IiLCJoaXN0b3J5VmFsdWUiLCJhY3RvclNjb3BlIiwibWljcm9zdGF0ZXMiLCJnZXRUcmFuc2l0aW9uRGF0YSIsImdldFByZUluaXRpYWxTdGF0ZSIsImluaXRFdmVudCIsImludGVybmFsUXVldWUiLCJwcmVJbml0aWFsIiwiYXNzaWdubWVudCIsInNwYXduIiwic2VsZiIsImlucHV0IiwicHJlSW5pdGlhbFN0YXRlIiwibmV4dFN0YXRlIiwibWFjcm9TdGF0ZSIsImNoaWxkIiwiZ2V0U25hcHNob3QiLCJnZXRTdGF0ZU5vZGVCeUlkIiwiZnVsbFBhdGgiLCJyZWxhdGl2ZVBhdGgiLCJyZXNvbHZlZFN0YXRlSWQiLCJfYWN0b3JTY29wZSIsInNuYXBzaG90Q2hpbGRyZW4iLCJhY3RvcklkIiwiYWN0b3JEYXRhIiwiY2hpbGRTdGF0ZSIsImxvZ2ljIiwiYWN0b3JSZWYiLCJzeW5jU25hcHNob3QiLCJyZXNvbHZlSGlzdG9yeVJlZmVyZW5jZWRTdGF0ZSIsInJlZmVyZW5jZWQiLCJyZXZpdmVIaXN0b3J5VmFsdWUiLCJyZXZpdmVkIiwiYXJyIiwiaXRlbSIsInJlc29sdmVkIiwicmV2aXZlZEhpc3RvcnlWYWx1ZSIsInJlc3RvcmVkU25hcHNob3QiLCJzZWVuIiwicmV2aXZlQ29udGV4dCIsImNvbnRleHRQYXJ0IiwiaGFzIiwieHN0YXRlJCR0eXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xstate/dist/StateMachine-b4e94439.development.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/xstate/dist/assign-6313ccb3.development.esm.js":
/*!*********************************************************************!*\
  !*** ./node_modules/xstate/dist/assign-6313ccb3.development.esm.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ assign)\n/* harmony export */ });\n/* harmony import */ var _raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./raise-78b8dcb8.development.esm.js */ \"(ssr)/./node_modules/xstate/dist/raise-78b8dcb8.development.esm.js\");\n\nfunction createSpawner(actorScope, { machine, context }, event, spawnedChildren) {\n    const spawn = (src, options)=>{\n        if (typeof src === \"string\") {\n            const logic = (0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.R)(machine, src);\n            if (!logic) {\n                throw new Error(`Actor logic '${src}' not implemented in machine '${machine.id}'`);\n            }\n            const actorRef = (0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(logic, {\n                id: options?.id,\n                parent: actorScope.self,\n                syncSnapshot: options?.syncSnapshot,\n                input: typeof options?.input === \"function\" ? options.input({\n                    context,\n                    event,\n                    self: actorScope.self\n                }) : options?.input,\n                src,\n                systemId: options?.systemId\n            });\n            spawnedChildren[actorRef.id] = actorRef;\n            return actorRef;\n        } else {\n            const actorRef = (0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(src, {\n                id: options?.id,\n                parent: actorScope.self,\n                syncSnapshot: options?.syncSnapshot,\n                input: options?.input,\n                src,\n                systemId: options?.systemId\n            });\n            return actorRef;\n        }\n    };\n    return (src, options)=>{\n        const actorRef = spawn(src, options); // TODO: fix types\n        spawnedChildren[actorRef.id] = actorRef;\n        actorScope.defer(()=>{\n            if (actorRef._processingStatus === _raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.W.Stopped) {\n                return;\n            }\n            actorRef.start();\n        });\n        return actorRef;\n    };\n}\nfunction resolveAssign(actorScope, snapshot, actionArgs, actionParams, { assignment }) {\n    if (!snapshot.context) {\n        throw new Error(\"Cannot assign to undefined `context`. Ensure that `context` is defined in the machine config.\");\n    }\n    const spawnedChildren = {};\n    const assignArgs = {\n        context: snapshot.context,\n        event: actionArgs.event,\n        spawn: createSpawner(actorScope, snapshot, actionArgs.event, spawnedChildren),\n        self: actorScope.self,\n        system: actorScope.system\n    };\n    let partialUpdate = {};\n    if (typeof assignment === \"function\") {\n        partialUpdate = assignment(assignArgs, actionParams);\n    } else {\n        for (const key of Object.keys(assignment)){\n            const propAssignment = assignment[key];\n            partialUpdate[key] = typeof propAssignment === \"function\" ? propAssignment(assignArgs, actionParams) : propAssignment;\n        }\n    }\n    const updatedContext = Object.assign({}, snapshot.context, partialUpdate);\n    return [\n        (0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.Y)(snapshot, {\n            context: updatedContext,\n            children: Object.keys(spawnedChildren).length ? {\n                ...snapshot.children,\n                ...spawnedChildren\n            } : snapshot.children\n        }),\n        undefined,\n        undefined\n    ];\n}\n/**\n * Updates the current context of the machine.\n *\n * @example\n *\n * ```ts\n * import { createMachine, assign } from 'xstate';\n *\n * const countMachine = createMachine({\n *   context: {\n *     count: 0,\n *     message: ''\n *   },\n *   on: {\n *     inc: {\n *       actions: assign({\n *         count: ({ context }) => context.count + 1\n *       })\n *     },\n *     updateMessage: {\n *       actions: assign(({ context, event }) => {\n *         return {\n *           message: event.message.trim()\n *         };\n *       })\n *     }\n *   }\n * });\n * ```\n *\n * @param assignment An object that represents the partial context to update, or\n *   a function that returns an object that represents the partial context to\n *   update.\n */ function assign(assignment) {\n    if (_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.T) {\n        console.warn(\"Custom actions should not call `assign()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.\");\n    }\n    function assign(_args, _params) {\n        {\n            throw new Error(`This isn't supposed to be called`);\n        }\n    }\n    assign.type = \"xstate.assign\";\n    assign.assignment = assignment;\n    assign.resolve = resolveAssign;\n    return assign;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHN0YXRlL2Rpc3QvYXNzaWduLTYzMTNjY2IzLmRldmVsb3BtZW50LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFrTDtBQUVsTCxTQUFTVSxjQUFjQyxVQUFVLEVBQUUsRUFDakNDLE9BQU8sRUFDUEMsT0FBTyxFQUNSLEVBQUVDLEtBQUssRUFBRUMsZUFBZTtJQUN2QixNQUFNQyxRQUFRLENBQUNDLEtBQUtDO1FBQ2xCLElBQUksT0FBT0QsUUFBUSxVQUFVO1lBQzNCLE1BQU1FLFFBQVFoQixxRUFBc0JBLENBQUNTLFNBQVNLO1lBQzlDLElBQUksQ0FBQ0UsT0FBTztnQkFDVixNQUFNLElBQUlDLE1BQU0sQ0FBQyxhQUFhLEVBQUVILElBQUksOEJBQThCLEVBQUVMLFFBQVFTLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDbkY7WUFDQSxNQUFNQyxXQUFXakIscUVBQVdBLENBQUNjLE9BQU87Z0JBQ2xDRSxJQUFJSCxTQUFTRztnQkFDYkUsUUFBUVosV0FBV2EsSUFBSTtnQkFDdkJDLGNBQWNQLFNBQVNPO2dCQUN2QkMsT0FBTyxPQUFPUixTQUFTUSxVQUFVLGFBQWFSLFFBQVFRLEtBQUssQ0FBQztvQkFDMURiO29CQUNBQztvQkFDQVUsTUFBTWIsV0FBV2EsSUFBSTtnQkFDdkIsS0FBS04sU0FBU1E7Z0JBQ2RUO2dCQUNBVSxVQUFVVCxTQUFTUztZQUNyQjtZQUNBWixlQUFlLENBQUNPLFNBQVNELEVBQUUsQ0FBQyxHQUFHQztZQUMvQixPQUFPQTtRQUNULE9BQU87WUFDTCxNQUFNQSxXQUFXakIscUVBQVdBLENBQUNZLEtBQUs7Z0JBQ2hDSSxJQUFJSCxTQUFTRztnQkFDYkUsUUFBUVosV0FBV2EsSUFBSTtnQkFDdkJDLGNBQWNQLFNBQVNPO2dCQUN2QkMsT0FBT1IsU0FBU1E7Z0JBQ2hCVDtnQkFDQVUsVUFBVVQsU0FBU1M7WUFDckI7WUFDQSxPQUFPTDtRQUNUO0lBQ0Y7SUFDQSxPQUFPLENBQUNMLEtBQUtDO1FBQ1gsTUFBTUksV0FBV04sTUFBTUMsS0FBS0MsVUFBVSxrQkFBa0I7UUFDeERILGVBQWUsQ0FBQ08sU0FBU0QsRUFBRSxDQUFDLEdBQUdDO1FBQy9CWCxXQUFXaUIsS0FBSyxDQUFDO1lBQ2YsSUFBSU4sU0FBU08saUJBQWlCLEtBQUs1QixpRUFBZ0JBLENBQUM2QixPQUFPLEVBQUU7Z0JBQzNEO1lBQ0Y7WUFDQVIsU0FBU1MsS0FBSztRQUNoQjtRQUNBLE9BQU9UO0lBQ1Q7QUFDRjtBQUVBLFNBQVNVLGNBQWNyQixVQUFVLEVBQUVzQixRQUFRLEVBQUVDLFVBQVUsRUFBRUMsWUFBWSxFQUFFLEVBQ3JFQyxVQUFVLEVBQ1g7SUFDQyxJQUFJLENBQUNILFNBQVNwQixPQUFPLEVBQUU7UUFDckIsTUFBTSxJQUFJTyxNQUFNO0lBQ2xCO0lBQ0EsTUFBTUwsa0JBQWtCLENBQUM7SUFDekIsTUFBTXNCLGFBQWE7UUFDakJ4QixTQUFTb0IsU0FBU3BCLE9BQU87UUFDekJDLE9BQU9vQixXQUFXcEIsS0FBSztRQUN2QkUsT0FBT04sY0FBY0MsWUFBWXNCLFVBQVVDLFdBQVdwQixLQUFLLEVBQUVDO1FBQzdEUyxNQUFNYixXQUFXYSxJQUFJO1FBQ3JCYyxRQUFRM0IsV0FBVzJCLE1BQU07SUFDM0I7SUFDQSxJQUFJQyxnQkFBZ0IsQ0FBQztJQUNyQixJQUFJLE9BQU9ILGVBQWUsWUFBWTtRQUNwQ0csZ0JBQWdCSCxXQUFXQyxZQUFZRjtJQUN6QyxPQUFPO1FBQ0wsS0FBSyxNQUFNSyxPQUFPQyxPQUFPQyxJQUFJLENBQUNOLFlBQWE7WUFDekMsTUFBTU8saUJBQWlCUCxVQUFVLENBQUNJLElBQUk7WUFDdENELGFBQWEsQ0FBQ0MsSUFBSSxHQUFHLE9BQU9HLG1CQUFtQixhQUFhQSxlQUFlTixZQUFZRixnQkFBZ0JRO1FBQ3pHO0lBQ0Y7SUFDQSxNQUFNQyxpQkFBaUJILE9BQU9JLE1BQU0sQ0FBQyxDQUFDLEdBQUdaLFNBQVNwQixPQUFPLEVBQUUwQjtJQUMzRCxPQUFPO1FBQUNoQyxxRUFBb0JBLENBQUMwQixVQUFVO1lBQ3JDcEIsU0FBUytCO1lBQ1RFLFVBQVVMLE9BQU9DLElBQUksQ0FBQzNCLGlCQUFpQmdDLE1BQU0sR0FBRztnQkFDOUMsR0FBR2QsU0FBU2EsUUFBUTtnQkFDcEIsR0FBRy9CLGVBQWU7WUFDcEIsSUFBSWtCLFNBQVNhLFFBQVE7UUFDdkI7UUFBSUU7UUFBV0E7S0FBVTtBQUMzQjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQ0MsR0FDRCxTQUFTSCxPQUFPVCxVQUFVO0lBQ3hCLElBQUkzQixpRUFBcUJBLEVBQUU7UUFDekJ3QyxRQUFRQyxJQUFJLENBQUM7SUFDZjtJQUNBLFNBQVNMLE9BQU9NLEtBQUssRUFBRUMsT0FBTztRQUM1QjtZQUNFLE1BQU0sSUFBSWhDLE1BQU0sQ0FBQyxnQ0FBZ0MsQ0FBQztRQUNwRDtJQUNGO0lBQ0F5QixPQUFPUSxJQUFJLEdBQUc7SUFDZFIsT0FBT1QsVUFBVSxHQUFHQTtJQUNwQlMsT0FBT1MsT0FBTyxHQUFHdEI7SUFDakIsT0FBT2E7QUFDVDtBQUV1QiIsInNvdXJjZXMiOlsid2VicGFjazovL2VyYS1wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMveHN0YXRlL2Rpc3QvYXNzaWduLTYzMTNjY2IzLmRldmVsb3BtZW50LmVzbS5qcz85YWJiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFcgYXMgUHJvY2Vzc2luZ1N0YXR1cywgUiBhcyByZXNvbHZlUmVmZXJlbmNlZEFjdG9yLCBjIGFzIGNyZWF0ZUFjdG9yLCBZIGFzIGNsb25lTWFjaGluZVNuYXBzaG90LCBUIGFzIGV4ZWN1dGluZ0N1c3RvbUFjdGlvbiB9IGZyb20gJy4vcmFpc2UtNzhiOGRjYjguZGV2ZWxvcG1lbnQuZXNtLmpzJztcblxuZnVuY3Rpb24gY3JlYXRlU3Bhd25lcihhY3RvclNjb3BlLCB7XG4gIG1hY2hpbmUsXG4gIGNvbnRleHRcbn0sIGV2ZW50LCBzcGF3bmVkQ2hpbGRyZW4pIHtcbiAgY29uc3Qgc3Bhd24gPSAoc3JjLCBvcHRpb25zKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBsb2dpYyA9IHJlc29sdmVSZWZlcmVuY2VkQWN0b3IobWFjaGluZSwgc3JjKTtcbiAgICAgIGlmICghbG9naWMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBY3RvciBsb2dpYyAnJHtzcmN9JyBub3QgaW1wbGVtZW50ZWQgaW4gbWFjaGluZSAnJHttYWNoaW5lLmlkfSdgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFjdG9yUmVmID0gY3JlYXRlQWN0b3IobG9naWMsIHtcbiAgICAgICAgaWQ6IG9wdGlvbnM/LmlkLFxuICAgICAgICBwYXJlbnQ6IGFjdG9yU2NvcGUuc2VsZixcbiAgICAgICAgc3luY1NuYXBzaG90OiBvcHRpb25zPy5zeW5jU25hcHNob3QsXG4gICAgICAgIGlucHV0OiB0eXBlb2Ygb3B0aW9ucz8uaW5wdXQgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLmlucHV0KHtcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgIHNlbGY6IGFjdG9yU2NvcGUuc2VsZlxuICAgICAgICB9KSA6IG9wdGlvbnM/LmlucHV0LFxuICAgICAgICBzcmMsXG4gICAgICAgIHN5c3RlbUlkOiBvcHRpb25zPy5zeXN0ZW1JZFxuICAgICAgfSk7XG4gICAgICBzcGF3bmVkQ2hpbGRyZW5bYWN0b3JSZWYuaWRdID0gYWN0b3JSZWY7XG4gICAgICByZXR1cm4gYWN0b3JSZWY7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGFjdG9yUmVmID0gY3JlYXRlQWN0b3Ioc3JjLCB7XG4gICAgICAgIGlkOiBvcHRpb25zPy5pZCxcbiAgICAgICAgcGFyZW50OiBhY3RvclNjb3BlLnNlbGYsXG4gICAgICAgIHN5bmNTbmFwc2hvdDogb3B0aW9ucz8uc3luY1NuYXBzaG90LFxuICAgICAgICBpbnB1dDogb3B0aW9ucz8uaW5wdXQsXG4gICAgICAgIHNyYyxcbiAgICAgICAgc3lzdGVtSWQ6IG9wdGlvbnM/LnN5c3RlbUlkXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY3RvclJlZjtcbiAgICB9XG4gIH07XG4gIHJldHVybiAoc3JjLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgYWN0b3JSZWYgPSBzcGF3bihzcmMsIG9wdGlvbnMpOyAvLyBUT0RPOiBmaXggdHlwZXNcbiAgICBzcGF3bmVkQ2hpbGRyZW5bYWN0b3JSZWYuaWRdID0gYWN0b3JSZWY7XG4gICAgYWN0b3JTY29wZS5kZWZlcigoKSA9PiB7XG4gICAgICBpZiAoYWN0b3JSZWYuX3Byb2Nlc3NpbmdTdGF0dXMgPT09IFByb2Nlc3NpbmdTdGF0dXMuU3RvcHBlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhY3RvclJlZi5zdGFydCgpO1xuICAgIH0pO1xuICAgIHJldHVybiBhY3RvclJlZjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUFzc2lnbihhY3RvclNjb3BlLCBzbmFwc2hvdCwgYWN0aW9uQXJncywgYWN0aW9uUGFyYW1zLCB7XG4gIGFzc2lnbm1lbnRcbn0pIHtcbiAgaWYgKCFzbmFwc2hvdC5jb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYXNzaWduIHRvIHVuZGVmaW5lZCBgY29udGV4dGAuIEVuc3VyZSB0aGF0IGBjb250ZXh0YCBpcyBkZWZpbmVkIGluIHRoZSBtYWNoaW5lIGNvbmZpZy4nKTtcbiAgfVxuICBjb25zdCBzcGF3bmVkQ2hpbGRyZW4gPSB7fTtcbiAgY29uc3QgYXNzaWduQXJncyA9IHtcbiAgICBjb250ZXh0OiBzbmFwc2hvdC5jb250ZXh0LFxuICAgIGV2ZW50OiBhY3Rpb25BcmdzLmV2ZW50LFxuICAgIHNwYXduOiBjcmVhdGVTcGF3bmVyKGFjdG9yU2NvcGUsIHNuYXBzaG90LCBhY3Rpb25BcmdzLmV2ZW50LCBzcGF3bmVkQ2hpbGRyZW4pLFxuICAgIHNlbGY6IGFjdG9yU2NvcGUuc2VsZixcbiAgICBzeXN0ZW06IGFjdG9yU2NvcGUuc3lzdGVtXG4gIH07XG4gIGxldCBwYXJ0aWFsVXBkYXRlID0ge307XG4gIGlmICh0eXBlb2YgYXNzaWdubWVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHBhcnRpYWxVcGRhdGUgPSBhc3NpZ25tZW50KGFzc2lnbkFyZ3MsIGFjdGlvblBhcmFtcyk7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoYXNzaWdubWVudCkpIHtcbiAgICAgIGNvbnN0IHByb3BBc3NpZ25tZW50ID0gYXNzaWdubWVudFtrZXldO1xuICAgICAgcGFydGlhbFVwZGF0ZVtrZXldID0gdHlwZW9mIHByb3BBc3NpZ25tZW50ID09PSAnZnVuY3Rpb24nID8gcHJvcEFzc2lnbm1lbnQoYXNzaWduQXJncywgYWN0aW9uUGFyYW1zKSA6IHByb3BBc3NpZ25tZW50O1xuICAgIH1cbiAgfVxuICBjb25zdCB1cGRhdGVkQ29udGV4dCA9IE9iamVjdC5hc3NpZ24oe30sIHNuYXBzaG90LmNvbnRleHQsIHBhcnRpYWxVcGRhdGUpO1xuICByZXR1cm4gW2Nsb25lTWFjaGluZVNuYXBzaG90KHNuYXBzaG90LCB7XG4gICAgY29udGV4dDogdXBkYXRlZENvbnRleHQsXG4gICAgY2hpbGRyZW46IE9iamVjdC5rZXlzKHNwYXduZWRDaGlsZHJlbikubGVuZ3RoID8ge1xuICAgICAgLi4uc25hcHNob3QuY2hpbGRyZW4sXG4gICAgICAuLi5zcGF3bmVkQ2hpbGRyZW5cbiAgICB9IDogc25hcHNob3QuY2hpbGRyZW5cbiAgfSksIHVuZGVmaW5lZCwgdW5kZWZpbmVkXTtcbn1cbi8qKlxuICogVXBkYXRlcyB0aGUgY3VycmVudCBjb250ZXh0IG9mIHRoZSBtYWNoaW5lLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGNyZWF0ZU1hY2hpbmUsIGFzc2lnbiB9IGZyb20gJ3hzdGF0ZSc7XG4gKlxuICogY29uc3QgY291bnRNYWNoaW5lID0gY3JlYXRlTWFjaGluZSh7XG4gKiAgIGNvbnRleHQ6IHtcbiAqICAgICBjb3VudDogMCxcbiAqICAgICBtZXNzYWdlOiAnJ1xuICogICB9LFxuICogICBvbjoge1xuICogICAgIGluYzoge1xuICogICAgICAgYWN0aW9uczogYXNzaWduKHtcbiAqICAgICAgICAgY291bnQ6ICh7IGNvbnRleHQgfSkgPT4gY29udGV4dC5jb3VudCArIDFcbiAqICAgICAgIH0pXG4gKiAgICAgfSxcbiAqICAgICB1cGRhdGVNZXNzYWdlOiB7XG4gKiAgICAgICBhY3Rpb25zOiBhc3NpZ24oKHsgY29udGV4dCwgZXZlbnQgfSkgPT4ge1xuICogICAgICAgICByZXR1cm4ge1xuICogICAgICAgICAgIG1lc3NhZ2U6IGV2ZW50Lm1lc3NhZ2UudHJpbSgpXG4gKiAgICAgICAgIH07XG4gKiAgICAgICB9KVxuICogICAgIH1cbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXNzaWdubWVudCBBbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBwYXJ0aWFsIGNvbnRleHQgdG8gdXBkYXRlLCBvclxuICogICBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBwYXJ0aWFsIGNvbnRleHQgdG9cbiAqICAgdXBkYXRlLlxuICovXG5mdW5jdGlvbiBhc3NpZ24oYXNzaWdubWVudCkge1xuICBpZiAoZXhlY3V0aW5nQ3VzdG9tQWN0aW9uKSB7XG4gICAgY29uc29sZS53YXJuKCdDdXN0b20gYWN0aW9ucyBzaG91bGQgbm90IGNhbGwgYGFzc2lnbigpYCBkaXJlY3RseSwgYXMgaXQgaXMgbm90IGltcGVyYXRpdmUuIFNlZSBodHRwczovL3N0YXRlbHkuYWkvZG9jcy9hY3Rpb25zI2J1aWx0LWluLWFjdGlvbnMgZm9yIG1vcmUgZGV0YWlscy4nKTtcbiAgfVxuICBmdW5jdGlvbiBhc3NpZ24oX2FyZ3MsIF9wYXJhbXMpIHtcbiAgICB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgaXNuJ3Qgc3VwcG9zZWQgdG8gYmUgY2FsbGVkYCk7XG4gICAgfVxuICB9XG4gIGFzc2lnbi50eXBlID0gJ3hzdGF0ZS5hc3NpZ24nO1xuICBhc3NpZ24uYXNzaWdubWVudCA9IGFzc2lnbm1lbnQ7XG4gIGFzc2lnbi5yZXNvbHZlID0gcmVzb2x2ZUFzc2lnbjtcbiAgcmV0dXJuIGFzc2lnbjtcbn1cblxuZXhwb3J0IHsgYXNzaWduIGFzIGEgfTtcbiJdLCJuYW1lcyI6WyJXIiwiUHJvY2Vzc2luZ1N0YXR1cyIsIlIiLCJyZXNvbHZlUmVmZXJlbmNlZEFjdG9yIiwiYyIsImNyZWF0ZUFjdG9yIiwiWSIsImNsb25lTWFjaGluZVNuYXBzaG90IiwiVCIsImV4ZWN1dGluZ0N1c3RvbUFjdGlvbiIsImNyZWF0ZVNwYXduZXIiLCJhY3RvclNjb3BlIiwibWFjaGluZSIsImNvbnRleHQiLCJldmVudCIsInNwYXduZWRDaGlsZHJlbiIsInNwYXduIiwic3JjIiwib3B0aW9ucyIsImxvZ2ljIiwiRXJyb3IiLCJpZCIsImFjdG9yUmVmIiwicGFyZW50Iiwic2VsZiIsInN5bmNTbmFwc2hvdCIsImlucHV0Iiwic3lzdGVtSWQiLCJkZWZlciIsIl9wcm9jZXNzaW5nU3RhdHVzIiwiU3RvcHBlZCIsInN0YXJ0IiwicmVzb2x2ZUFzc2lnbiIsInNuYXBzaG90IiwiYWN0aW9uQXJncyIsImFjdGlvblBhcmFtcyIsImFzc2lnbm1lbnQiLCJhc3NpZ25BcmdzIiwic3lzdGVtIiwicGFydGlhbFVwZGF0ZSIsImtleSIsIk9iamVjdCIsImtleXMiLCJwcm9wQXNzaWdubWVudCIsInVwZGF0ZWRDb250ZXh0IiwiYXNzaWduIiwiY2hpbGRyZW4iLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJjb25zb2xlIiwid2FybiIsIl9hcmdzIiwiX3BhcmFtcyIsInR5cGUiLCJyZXNvbHZlIiwiYSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xstate/dist/assign-6313ccb3.development.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/xstate/dist/log-ef959da6.development.esm.js":
/*!******************************************************************!*\
  !*** ./node_modules/xstate/dist/log-ef959da6.development.esm.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   S: () => (/* binding */ SpecialTargets),\n/* harmony export */   a: () => (/* binding */ enqueueActions),\n/* harmony export */   b: () => (/* binding */ sendTo),\n/* harmony export */   e: () => (/* binding */ emit),\n/* harmony export */   f: () => (/* binding */ forwardTo),\n/* harmony export */   l: () => (/* binding */ log),\n/* harmony export */   s: () => (/* binding */ sendParent)\n/* harmony export */ });\n/* harmony import */ var _raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./raise-78b8dcb8.development.esm.js */ \"(ssr)/./node_modules/xstate/dist/raise-78b8dcb8.development.esm.js\");\n/* harmony import */ var _assign_6313ccb3_development_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assign-6313ccb3.development.esm.js */ \"(ssr)/./node_modules/xstate/dist/assign-6313ccb3.development.esm.js\");\n\n\nfunction resolveEmit(_, snapshot, args, actionParams, { event: eventOrExpr }) {\n    const resolvedEvent = typeof eventOrExpr === \"function\" ? eventOrExpr(args, actionParams) : eventOrExpr;\n    return [\n        snapshot,\n        {\n            event: resolvedEvent\n        },\n        undefined\n    ];\n}\nfunction executeEmit(actorScope, { event }) {\n    actorScope.defer(()=>actorScope.emit(event));\n}\n/**\n * Emits an event to event handlers registered on the actor via `actor.on(event,\n * handler)`.\n *\n * @example\n *\n * ```ts\n * import { emit } from 'xstate';\n *\n * const machine = createMachine({\n *   // ...\n *   on: {\n *     something: {\n *       actions: emit({\n *         type: 'emitted',\n *         some: 'data'\n *       })\n *     }\n *   }\n *   // ...\n * });\n *\n * const actor = createActor(machine).start();\n *\n * actor.on('emitted', (event) => {\n *   console.log(event);\n * });\n *\n * actor.send({ type: 'something' });\n * // logs:\n * // {\n * //   type: 'emitted',\n * //   some: 'data'\n * // }\n * ```\n */ function emit(/** The event to emit, or an expression that returns an event to emit. */ eventOrExpr) {\n    if (_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.T) {\n        console.warn(\"Custom actions should not call `emit()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.\");\n    }\n    function emit(_args, _params) {\n        {\n            throw new Error(`This isn't supposed to be called`);\n        }\n    }\n    emit.type = \"xstate.emit\";\n    emit.event = eventOrExpr;\n    emit.resolve = resolveEmit;\n    emit.execute = executeEmit;\n    return emit;\n}\n// this is needed to make JSDoc `@link` work properly\n/**\n * @remarks\n * `T | unknown` reduces to `unknown` and that can be problematic when it comes\n * to contextual typing. It especially is a problem when the union has a\n * function member, like here:\n *\n * ```ts\n * declare function test(\n *   cbOrVal: ((arg: number) => unknown) | unknown\n * ): void;\n * test((arg) => {}); // oops, implicit any\n * ```\n *\n * This type can be used to avoid this problem. This union represents the same\n * value space as `unknown`.\n */ // https://github.com/microsoft/TypeScript/issues/23182#issuecomment-379091887\n// @TODO: we can't use native `NoInfer` as we need those:\n// https://github.com/microsoft/TypeScript/pull/61092\n// https://github.com/microsoft/TypeScript/pull/61077\n// but even with those fixes native NoInfer still doesn't work - further issues have to be reproduced and fixed\n/** @deprecated Use the built-in `NoInfer` type instead */ /** The full definition of an event, with a string `type`. */ /**\n * The string or object representing the state value relative to the parent\n * state node.\n *\n * @remarks\n * - For a child atomic state node, this is a string, e.g., `\"pending\"`.\n * - For complex state nodes, this is an object, e.g., `{ success:\n *   \"someChildState\" }`.\n */ /** @deprecated Use `AnyMachineSnapshot` instead */ // TODO: possibly refactor this somehow, use even a simpler type, and maybe even make `machine.options` private or something\n/** @ignore */ let SpecialTargets = /*#__PURE__*/ function(SpecialTargets) {\n    SpecialTargets[\"Parent\"] = \"#_parent\";\n    SpecialTargets[\"Internal\"] = \"#_internal\";\n    return SpecialTargets;\n}({});\n/** @deprecated Use `AnyActor` instead. */ // Based on RxJS types\n// TODO: in v6, this should only accept AnyActorLogic, like ActorRefFromLogic\n/** @deprecated Use `Actor<T>` instead. */ /**\n * Represents logic which can be used by an actor.\n *\n * @template TSnapshot - The type of the snapshot.\n * @template TEvent - The type of the event object.\n * @template TInput - The type of the input.\n * @template TSystem - The type of the actor system.\n */ /** @deprecated */ // TODO: cover all that can be actually returned\nfunction resolveSendTo(actorScope, snapshot, args, actionParams, { to, event: eventOrExpr, id, delay }, extra) {\n    const delaysMap = snapshot.machine.implementations.delays;\n    if (typeof eventOrExpr === \"string\") {\n        throw new Error(// eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n        `Only event objects may be used with sendTo; use sendTo({ type: \"${eventOrExpr}\" }) instead`);\n    }\n    const resolvedEvent = typeof eventOrExpr === \"function\" ? eventOrExpr(args, actionParams) : eventOrExpr;\n    let resolvedDelay;\n    if (typeof delay === \"string\") {\n        const configDelay = delaysMap && delaysMap[delay];\n        resolvedDelay = typeof configDelay === \"function\" ? configDelay(args, actionParams) : configDelay;\n    } else {\n        resolvedDelay = typeof delay === \"function\" ? delay(args, actionParams) : delay;\n    }\n    const resolvedTarget = typeof to === \"function\" ? to(args, actionParams) : to;\n    let targetActorRef;\n    if (typeof resolvedTarget === \"string\") {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n        if (resolvedTarget === SpecialTargets.Parent) {\n            targetActorRef = actorScope.self._parent;\n        } else if (resolvedTarget === SpecialTargets.Internal) {\n            targetActorRef = actorScope.self;\n        } else if (resolvedTarget.startsWith(\"#_\")) {\n            // SCXML compatibility: https://www.w3.org/TR/scxml/#SCXMLEventProcessor\n            // #_invokeid. If the target is the special term '#_invokeid', where invokeid is the invokeid of an SCXML session that the sending session has created by <invoke>, the Processor must add the event to the external queue of that session.\n            targetActorRef = snapshot.children[resolvedTarget.slice(2)];\n        } else {\n            targetActorRef = extra.deferredActorIds?.includes(resolvedTarget) ? resolvedTarget : snapshot.children[resolvedTarget];\n        }\n        if (!targetActorRef) {\n            throw new Error(`Unable to send event to actor '${resolvedTarget}' from machine '${snapshot.machine.id}'.`);\n        }\n    } else {\n        targetActorRef = resolvedTarget || actorScope.self;\n    }\n    return [\n        snapshot,\n        {\n            to: targetActorRef,\n            targetId: typeof resolvedTarget === \"string\" ? resolvedTarget : undefined,\n            event: resolvedEvent,\n            id,\n            delay: resolvedDelay\n        },\n        undefined\n    ];\n}\nfunction retryResolveSendTo(_, snapshot, params) {\n    if (typeof params.to === \"string\") {\n        params.to = snapshot.children[params.to];\n    }\n}\nfunction executeSendTo(actorScope, params) {\n    // this forms an outgoing events queue\n    // thanks to that the recipient actors are able to read the *updated* snapshot value of the sender\n    actorScope.defer(()=>{\n        const { to, event, delay, id } = params;\n        if (typeof delay === \"number\") {\n            actorScope.system.scheduler.schedule(actorScope.self, to, event, delay, id);\n            return;\n        }\n        actorScope.system._relay(actorScope.self, // at this point, in a deferred task, it should already be mutated by retryResolveSendTo\n        // if it initially started as a string\n        to, event.type === _raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.U ? (0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.V)(actorScope.self.id, event.data) : event);\n    });\n}\n/**\n * Sends an event to an actor.\n *\n * @param actor The `ActorRef` to send the event to.\n * @param event The event to send, or an expression that evaluates to the event\n *   to send\n * @param options Send action options\n *\n *   - `id` - The unique send event identifier (used with `cancel()`).\n *   - `delay` - The number of milliseconds to delay the sending of the event.\n */ function sendTo(to, eventOrExpr, options) {\n    if (_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.T) {\n        console.warn(\"Custom actions should not call `sendTo()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.\");\n    }\n    function sendTo(_args, _params) {\n        {\n            throw new Error(`This isn't supposed to be called`);\n        }\n    }\n    sendTo.type = \"xstate.sendTo\";\n    sendTo.to = to;\n    sendTo.event = eventOrExpr;\n    sendTo.id = options?.id;\n    sendTo.delay = options?.delay;\n    sendTo.resolve = resolveSendTo;\n    sendTo.retryResolve = retryResolveSendTo;\n    sendTo.execute = executeSendTo;\n    return sendTo;\n}\n/**\n * Sends an event to this machine's parent.\n *\n * @param event The event to send to the parent machine.\n * @param options Options to pass into the send event.\n */ function sendParent(event, options) {\n    return sendTo(SpecialTargets.Parent, event, options);\n}\n/**\n * Forwards (sends) an event to the `target` actor.\n *\n * @param target The target actor to forward the event to.\n * @param options Options to pass into the send action creator.\n */ function forwardTo(target, options) {\n    if (!target || typeof target === \"function\") {\n        const originalTarget = target;\n        target = (...args)=>{\n            const resolvedTarget = typeof originalTarget === \"function\" ? originalTarget(...args) : originalTarget;\n            if (!resolvedTarget) {\n                throw new Error(`Attempted to forward event to undefined actor. This risks an infinite loop in the sender.`);\n            }\n            return resolvedTarget;\n        };\n    }\n    return sendTo(target, ({ event })=>event, options);\n}\nfunction resolveEnqueueActions(actorScope, snapshot, args, actionParams, { collect }) {\n    const actions = [];\n    const enqueue = function enqueue(action) {\n        actions.push(action);\n    };\n    enqueue.assign = (...args)=>{\n        actions.push((0,_assign_6313ccb3_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)(...args));\n    };\n    enqueue.cancel = (...args)=>{\n        actions.push((0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.f)(...args));\n    };\n    enqueue.raise = (...args)=>{\n        // for some reason it fails to infer `TDelay` from `...args` here and picks its default (`never`)\n        // then it fails to typecheck that because `...args` use `string` in place of `TDelay`\n        actions.push((0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.r)(...args));\n    };\n    enqueue.sendTo = (...args)=>{\n        // for some reason it fails to infer `TDelay` from `...args` here and picks its default (`never`)\n        // then it fails to typecheck that because `...args` use `string` in place of `TDelay\n        actions.push(sendTo(...args));\n    };\n    enqueue.sendParent = (...args)=>{\n        actions.push(sendParent(...args));\n    };\n    enqueue.spawnChild = (...args)=>{\n        actions.push((0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.h)(...args));\n    };\n    enqueue.stopChild = (...args)=>{\n        actions.push((0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.k)(...args));\n    };\n    enqueue.emit = (...args)=>{\n        actions.push(emit(...args));\n    };\n    collect({\n        context: args.context,\n        event: args.event,\n        enqueue,\n        check: (guard)=>(0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.w)(guard, snapshot.context, args.event, snapshot),\n        self: actorScope.self,\n        system: actorScope.system\n    }, actionParams);\n    return [\n        snapshot,\n        undefined,\n        actions\n    ];\n}\n/**\n * Creates an action object that will execute actions that are queued by the\n * `enqueue(action)` function.\n *\n * @example\n *\n * ```ts\n * import { createMachine, enqueueActions } from 'xstate';\n *\n * const machine = createMachine({\n *   entry: enqueueActions(({ enqueue, check }) => {\n *     enqueue.assign({ count: 0 });\n *\n *     if (check('someGuard')) {\n *       enqueue.assign({ count: 1 });\n *     }\n *\n *     enqueue('someAction');\n *   })\n * });\n * ```\n */ function enqueueActions(collect) {\n    function enqueueActions(_args, _params) {\n        {\n            throw new Error(`This isn't supposed to be called`);\n        }\n    }\n    enqueueActions.type = \"xstate.enqueueActions\";\n    enqueueActions.collect = collect;\n    enqueueActions.resolve = resolveEnqueueActions;\n    return enqueueActions;\n}\nfunction resolveLog(_, snapshot, actionArgs, actionParams, { value, label }) {\n    return [\n        snapshot,\n        {\n            value: typeof value === \"function\" ? value(actionArgs, actionParams) : value,\n            label\n        },\n        undefined\n    ];\n}\nfunction executeLog({ logger }, { value, label }) {\n    if (label) {\n        logger(label, value);\n    } else {\n        logger(value);\n    }\n}\n/**\n * @param expr The expression function to evaluate which will be logged. Takes\n *   in 2 arguments:\n *\n *   - `ctx` - the current state context\n *   - `event` - the event that caused this action to be executed.\n *\n * @param label The label to give to the logged expression.\n */ function log(value = ({ context, event })=>({\n        context,\n        event\n    }), label) {\n    function log(_args, _params) {\n        {\n            throw new Error(`This isn't supposed to be called`);\n        }\n    }\n    log.type = \"xstate.log\";\n    log.value = value;\n    log.label = label;\n    log.resolve = resolveLog;\n    log.execute = executeLog;\n    return log;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHN0YXRlL2Rpc3QvbG9nLWVmOTU5ZGE2LmRldmVsb3BtZW50LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBOE07QUFDM0k7QUFFbkUsU0FBU2tCLFlBQVlDLENBQUMsRUFBRUMsUUFBUSxFQUFFQyxJQUFJLEVBQUVDLFlBQVksRUFBRSxFQUNwREMsT0FBT0MsV0FBVyxFQUNuQjtJQUNDLE1BQU1DLGdCQUFnQixPQUFPRCxnQkFBZ0IsYUFBYUEsWUFBWUgsTUFBTUMsZ0JBQWdCRTtJQUM1RixPQUFPO1FBQUNKO1FBQVU7WUFDaEJHLE9BQU9FO1FBQ1Q7UUFBR0M7S0FBVTtBQUNmO0FBQ0EsU0FBU0MsWUFBWUMsVUFBVSxFQUFFLEVBQy9CTCxLQUFLLEVBQ047SUFDQ0ssV0FBV0MsS0FBSyxDQUFDLElBQU1ELFdBQVdFLElBQUksQ0FBQ1A7QUFDekM7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FtQ0MsR0FDRCxTQUFTTyxLQUFLLHVFQUF1RSxHQUNyRk4sV0FBVztJQUNULElBQUl2QixpRUFBcUJBLEVBQUU7UUFDekI4QixRQUFRQyxJQUFJLENBQUM7SUFDZjtJQUNBLFNBQVNGLEtBQUtHLEtBQUssRUFBRUMsT0FBTztRQUMxQjtZQUNFLE1BQU0sSUFBSUMsTUFBTSxDQUFDLGdDQUFnQyxDQUFDO1FBQ3BEO0lBQ0Y7SUFDQUwsS0FBS00sSUFBSSxHQUFHO0lBQ1pOLEtBQUtQLEtBQUssR0FBR0M7SUFDYk0sS0FBS08sT0FBTyxHQUFHbkI7SUFDZlksS0FBS1EsT0FBTyxHQUFHWDtJQUNmLE9BQU9HO0FBQ1Q7QUFFQSxxREFBcUQ7QUFFckQ7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBRUQsOEVBQThFO0FBRTlFLHlEQUF5RDtBQUN6RCxxREFBcUQ7QUFDckQscURBQXFEO0FBQ3JELCtHQUErRztBQUUvRyx3REFBd0QsR0FFeEQsMkRBQTJELEdBRTNEOzs7Ozs7OztDQVFDLEdBRUQsaURB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QUFLLEVBQ047SUFDQyxPQUFPO1FBQUN2RTtRQUFVO1lBQ2hCc0UsT0FBTyxPQUFPQSxVQUFVLGFBQWFBLE1BQU1ELFlBQVluRSxnQkFBZ0JvRTtZQUN2RUM7UUFDRjtRQUFHakU7S0FBVTtBQUNmO0FBQ0EsU0FBU2tFLFdBQVcsRUFDbEJDLE1BQU0sRUFDUCxFQUFFLEVBQ0RILEtBQUssRUFDTEMsS0FBSyxFQUNOO0lBQ0MsSUFBSUEsT0FBTztRQUNURSxPQUFPRixPQUFPRDtJQUNoQixPQUFPO1FBQ0xHLE9BQU9IO0lBQ1Q7QUFDRjtBQUNBOzs7Ozs7OztDQVFDLEdBQ0QsU0FBU0ksSUFBSUosUUFBUSxDQUFDLEVBQ3BCTixPQUFPLEVBQ1A3RCxLQUFLLEVBQ04sR0FBTTtRQUNMNkQ7UUFDQTdEO0lBQ0YsRUFBRSxFQUFFb0UsS0FBSztJQUNQLFNBQVNHLElBQUk3RCxLQUFLLEVBQUVDLE9BQU87UUFDekI7WUFDRSxNQUFNLElBQUlDLE1BQU0sQ0FBQyxnQ0FBZ0MsQ0FBQztRQUNwRDtJQUNGO0lBQ0EyRCxJQUFJMUQsSUFBSSxHQUFHO0lBQ1gwRCxJQUFJSixLQUFLLEdBQUdBO0lBQ1pJLElBQUlILEtBQUssR0FBR0E7SUFDWkcsSUFBSXpELE9BQU8sR0FBR21EO0lBQ2RNLElBQUl4RCxPQUFPLEdBQUdzRDtJQUNkLE9BQU9FO0FBQ1Q7QUFFdUgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lcmEtcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL3hzdGF0ZS9kaXN0L2xvZy1lZjk1OWRhNi5kZXZlbG9wbWVudC5lc20uanM/ZmU4MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUIGFzIGV4ZWN1dGluZ0N1c3RvbUFjdGlvbiwgVSBhcyBYU1RBVEVfRVJST1IsIFYgYXMgY3JlYXRlRXJyb3JBY3RvckV2ZW50LCB3IGFzIGV2YWx1YXRlR3VhcmQsIGYgYXMgY2FuY2VsLCByIGFzIHJhaXNlLCBoIGFzIHNwYXduQ2hpbGQsIGsgYXMgc3RvcENoaWxkIH0gZnJvbSAnLi9yYWlzZS03OGI4ZGNiOC5kZXZlbG9wbWVudC5lc20uanMnO1xuaW1wb3J0IHsgYSBhcyBhc3NpZ24gfSBmcm9tICcuL2Fzc2lnbi02MzEzY2NiMy5kZXZlbG9wbWVudC5lc20uanMnO1xuXG5mdW5jdGlvbiByZXNvbHZlRW1pdChfLCBzbmFwc2hvdCwgYXJncywgYWN0aW9uUGFyYW1zLCB7XG4gIGV2ZW50OiBldmVudE9yRXhwclxufSkge1xuICBjb25zdCByZXNvbHZlZEV2ZW50ID0gdHlwZW9mIGV2ZW50T3JFeHByID09PSAnZnVuY3Rpb24nID8gZXZlbnRPckV4cHIoYXJncywgYWN0aW9uUGFyYW1zKSA6IGV2ZW50T3JFeHByO1xuICByZXR1cm4gW3NuYXBzaG90LCB7XG4gICAgZXZlbnQ6IHJlc29sdmVkRXZlbnRcbiAgfSwgdW5kZWZpbmVkXTtcbn1cbmZ1bmN0aW9uIGV4ZWN1dGVFbWl0KGFjdG9yU2NvcGUsIHtcbiAgZXZlbnRcbn0pIHtcbiAgYWN0b3JTY29wZS5kZWZlcigoKSA9PiBhY3RvclNjb3BlLmVtaXQoZXZlbnQpKTtcbn1cbi8qKlxuICogRW1pdHMgYW4gZXZlbnQgdG8gZXZlbnQgaGFuZGxlcnMgcmVnaXN0ZXJlZCBvbiB0aGUgYWN0b3IgdmlhIGBhY3Rvci5vbihldmVudCxcbiAqIGhhbmRsZXIpYC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBlbWl0IH0gZnJvbSAneHN0YXRlJztcbiAqXG4gKiBjb25zdCBtYWNoaW5lID0gY3JlYXRlTWFjaGluZSh7XG4gKiAgIC8vIC4uLlxuICogICBvbjoge1xuICogICAgIHNvbWV0aGluZzoge1xuICogICAgICAgYWN0aW9uczogZW1pdCh7XG4gKiAgICAgICAgIHR5cGU6ICdlbWl0dGVkJyxcbiAqICAgICAgICAgc29tZTogJ2RhdGEnXG4gKiAgICAgICB9KVxuICogICAgIH1cbiAqICAgfVxuICogICAvLyAuLi5cbiAqIH0pO1xuICpcbiAqIGNvbnN0IGFjdG9yID0gY3JlYXRlQWN0b3IobWFjaGluZSkuc3RhcnQoKTtcbiAqXG4gKiBhY3Rvci5vbignZW1pdHRlZCcsIChldmVudCkgPT4ge1xuICogICBjb25zb2xlLmxvZyhldmVudCk7XG4gKiB9KTtcbiAqXG4gKiBhY3Rvci5zZW5kKHsgdHlwZTogJ3NvbWV0aGluZycgfSk7XG4gKiAvLyBsb2dzOlxuICogLy8ge1xuICogLy8gICB0eXBlOiAnZW1pdHRlZCcsXG4gKiAvLyAgIHNvbWU6ICdkYXRhJ1xuICogLy8gfVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGVtaXQoLyoqIFRoZSBldmVudCB0byBlbWl0LCBvciBhbiBleHByZXNzaW9uIHRoYXQgcmV0dXJucyBhbiBldmVudCB0byBlbWl0LiAqL1xuZXZlbnRPckV4cHIpIHtcbiAgaWYgKGV4ZWN1dGluZ0N1c3RvbUFjdGlvbikge1xuICAgIGNvbnNvbGUud2FybignQ3VzdG9tIGFjdGlvbnMgc2hvdWxkIG5vdCBjYWxsIGBlbWl0KClgIGRpcmVjdGx5LCBhcyBpdCBpcyBub3QgaW1wZXJhdGl2ZS4gU2VlIGh0dHBzOi8vc3RhdGVseS5haS9kb2NzL2FjdGlvbnMjYnVpbHQtaW4tYWN0aW9ucyBmb3IgbW9yZSBkZXRhaWxzLicpO1xuICB9XG4gIGZ1bmN0aW9uIGVtaXQoX2FyZ3MsIF9wYXJhbXMpIHtcbiAgICB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgaXNuJ3Qgc3VwcG9zZWQgdG8gYmUgY2FsbGVkYCk7XG4gICAgfVxuICB9XG4gIGVtaXQudHlwZSA9ICd4c3RhdGUuZW1pdCc7XG4gIGVtaXQuZXZlbnQgPSBldmVudE9yRXhwcjtcbiAgZW1pdC5yZXNvbHZlID0gcmVzb2x2ZUVtaXQ7XG4gIGVtaXQuZXhlY3V0ZSA9IGV4ZWN1dGVFbWl0O1xuICByZXR1cm4gZW1pdDtcbn1cblxuLy8gdGhpcyBpcyBuZWVkZWQgdG8gbWFrZSBKU0RvYyBgQGxpbmtgIHdvcmsgcHJvcGVybHlcblxuLyoqXG4gKiBAcmVtYXJrc1xuICogYFQgfCB1bmtub3duYCByZWR1Y2VzIHRvIGB1bmtub3duYCBhbmQgdGhhdCBjYW4gYmUgcHJvYmxlbWF0aWMgd2hlbiBpdCBjb21lc1xuICogdG8gY29udGV4dHVhbCB0eXBpbmcuIEl0IGVzcGVjaWFsbHkgaXMgYSBwcm9ibGVtIHdoZW4gdGhlIHVuaW9uIGhhcyBhXG4gKiBmdW5jdGlvbiBtZW1iZXIsIGxpa2UgaGVyZTpcbiAqXG4gKiBgYGB0c1xuICogZGVjbGFyZSBmdW5jdGlvbiB0ZXN0KFxuICogICBjYk9yVmFsOiAoKGFyZzogbnVtYmVyKSA9PiB1bmtub3duKSB8IHVua25vd25cbiAqICk6IHZvaWQ7XG4gKiB0ZXN0KChhcmcpID0+IHt9KTsgLy8gb29wcywgaW1wbGljaXQgYW55XG4gKiBgYGBcbiAqXG4gKiBUaGlzIHR5cGUgY2FuIGJlIHVzZWQgdG8gYXZvaWQgdGhpcyBwcm9ibGVtLiBUaGlzIHVuaW9uIHJlcHJlc2VudHMgdGhlIHNhbWVcbiAqIHZhbHVlIHNwYWNlIGFzIGB1bmtub3duYC5cbiAqL1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzIzMTgyI2lzc3VlY29tbWVudC0zNzkwOTE4ODdcblxuLy8gQFRPRE86IHdlIGNhbid0IHVzZSBuYXRpdmUgYE5vSW5mZXJgIGFzIHdlIG5lZWQgdGhvc2U6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvcHVsbC82MTA5MlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L3B1bGwvNjEwNzdcbi8vIGJ1dCBldmVuIHdpdGggdGhvc2UgZml4ZXMgbmF0aXZlIE5vSW5mZXIgc3RpbGwgZG9lc24ndCB3b3JrIC0gZnVydGhlciBpc3N1ZXMgaGF2ZSB0byBiZSByZXByb2R1Y2VkIGFuZCBmaXhlZFxuXG4vKiogQGRlcHJlY2F0ZWQgVXNlIHRoZSBidWlsdC1pbiBgTm9JbmZlcmAgdHlwZSBpbnN0ZWFkICovXG5cbi8qKiBUaGUgZnVsbCBkZWZpbml0aW9uIG9mIGFuIGV2ZW50LCB3aXRoIGEgc3RyaW5nIGB0eXBlYC4gKi9cblxuLyoqXG4gKiBUaGUgc3RyaW5nIG9yIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHN0YXRlIHZhbHVlIHJlbGF0aXZlIHRvIHRoZSBwYXJlbnRcbiAqIHN0YXRlIG5vZGUuXG4gKlxuICogQHJlbWFya3NcbiAqIC0gRm9yIGEgY2hpbGQgYXRvbWljIHN0YXRlIG5vZGUsIHRoaXMgaXMgYSBzdHJpbmcsIGUuZy4sIGBcInBlbmRpbmdcImAuXG4gKiAtIEZvciBjb21wbGV4IHN0YXRlIG5vZGVzLCB0aGlzIGlzIGFuIG9iamVjdCwgZS5nLiwgYHsgc3VjY2VzczpcbiAqICAgXCJzb21lQ2hpbGRTdGF0ZVwiIH1gLlxuICovXG5cbi8qKiBAZGVwcmVjYXRlZCBVc2UgYEFueU1hY2hpbmVTbmFwc2hvdGAgaW5zdGVhZCAqL1xuXG4vLyBUT0RPOiBwb3NzaWJseSByZWZhY3RvciB0aGlzIHNvbWVob3csIHVzZSBldmVuIGEgc2ltcGxlciB0eXBlLCBhbmQgbWF5YmUgZXZlbiBtYWtlIGBtYWNoaW5lLm9wdGlvbnNgIHByaXZhdGUgb3Igc29tZXRoaW5nXG4vKiogQGlnbm9yZSAqL1xuXG5sZXQgU3BlY2lhbFRhcmdldHMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKFNwZWNpYWxUYXJnZXRzKSB7XG4gIFNwZWNpYWxUYXJnZXRzW1wiUGFyZW50XCJdID0gXCIjX3BhcmVudFwiO1xuICBTcGVjaWFsVGFyZ2V0c1tcIkludGVybmFsXCJdID0gXCIjX2ludGVybmFsXCI7XG4gIHJldHVybiBTcGVjaWFsVGFyZ2V0cztcbn0oe30pO1xuXG4vKiogQGRlcHJlY2F0ZWQgVXNlIGBBbnlBY3RvcmAgaW5zdGVhZC4gKi9cblxuLy8gQmFzZWQgb24gUnhKUyB0eXBlc1xuXG4vLyBUT0RPOiBpbiB2NiwgdGhpcyBzaG91bGQgb25seSBhY2NlcHQgQW55QWN0b3JMb2dpYywgbGlrZSBBY3RvclJlZkZyb21Mb2dpY1xuXG4vKiogQGRlcHJlY2F0ZWQgVXNlIGBBY3RvcjxUPmAgaW5zdGVhZC4gKi9cblxuLyoqXG4gKiBSZXByZXNlbnRzIGxvZ2ljIHdoaWNoIGNhbiBiZSB1c2VkIGJ5IGFuIGFjdG9yLlxuICpcbiAqIEB0ZW1wbGF0ZSBUU25hcHNob3QgLSBUaGUgdHlwZSBvZiB0aGUgc25hcHNob3QuXG4gKiBAdGVtcGxhdGUgVEV2ZW50IC0gVGhlIHR5cGUgb2YgdGhlIGV2ZW50IG9iamVjdC5cbiAqIEB0ZW1wbGF0ZSBUSW5wdXQgLSBUaGUgdHlwZSBvZiB0aGUgaW5wdXQuXG4gKiBAdGVtcGxhdGUgVFN5c3RlbSAtIFRoZSB0eXBlIG9mIHRoZSBhY3RvciBzeXN0ZW0uXG4gKi9cblxuLyoqIEBkZXByZWNhdGVkICovXG5cbi8vIFRPRE86IGNvdmVyIGFsbCB0aGF0IGNhbiBiZSBhY3R1YWxseSByZXR1cm5lZFxuXG5mdW5jdGlvbiByZXNvbHZlU2VuZFRvKGFjdG9yU2NvcGUsIHNuYXBzaG90LCBhcmdzLCBhY3Rpb25QYXJhbXMsIHtcbiAgdG8sXG4gIGV2ZW50OiBldmVudE9yRXhwcixcbiAgaWQsXG4gIGRlbGF5XG59LCBleHRyYSkge1xuICBjb25zdCBkZWxheXNNYXAgPSBzbmFwc2hvdC5tYWNoaW5lLmltcGxlbWVudGF0aW9ucy5kZWxheXM7XG4gIGlmICh0eXBlb2YgZXZlbnRPckV4cHIgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtdGVtcGxhdGUtZXhwcmVzc2lvbnNcbiAgICBgT25seSBldmVudCBvYmplY3RzIG1heSBiZSB1c2VkIHdpdGggc2VuZFRvOyB1c2Ugc2VuZFRvKHsgdHlwZTogXCIke2V2ZW50T3JFeHByfVwiIH0pIGluc3RlYWRgKTtcbiAgfVxuICBjb25zdCByZXNvbHZlZEV2ZW50ID0gdHlwZW9mIGV2ZW50T3JFeHByID09PSAnZnVuY3Rpb24nID8gZXZlbnRPckV4cHIoYXJncywgYWN0aW9uUGFyYW1zKSA6IGV2ZW50T3JFeHByO1xuICBsZXQgcmVzb2x2ZWREZWxheTtcbiAgaWYgKHR5cGVvZiBkZWxheSA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBjb25maWdEZWxheSA9IGRlbGF5c01hcCAmJiBkZWxheXNNYXBbZGVsYXldO1xuICAgIHJlc29sdmVkRGVsYXkgPSB0eXBlb2YgY29uZmlnRGVsYXkgPT09ICdmdW5jdGlvbicgPyBjb25maWdEZWxheShhcmdzLCBhY3Rpb25QYXJhbXMpIDogY29uZmlnRGVsYXk7XG4gIH0gZWxzZSB7XG4gICAgcmVzb2x2ZWREZWxheSA9IHR5cGVvZiBkZWxheSA9PT0gJ2Z1bmN0aW9uJyA/IGRlbGF5KGFyZ3MsIGFjdGlvblBhcmFtcykgOiBkZWxheTtcbiAgfVxuICBjb25zdCByZXNvbHZlZFRhcmdldCA9IHR5cGVvZiB0byA9PT0gJ2Z1bmN0aW9uJyA/IHRvKGFyZ3MsIGFjdGlvblBhcmFtcykgOiB0bztcbiAgbGV0IHRhcmdldEFjdG9yUmVmO1xuICBpZiAodHlwZW9mIHJlc29sdmVkVGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWVudW0tY29tcGFyaXNvblxuICAgIGlmIChyZXNvbHZlZFRhcmdldCA9PT0gU3BlY2lhbFRhcmdldHMuUGFyZW50KSB7XG4gICAgICB0YXJnZXRBY3RvclJlZiA9IGFjdG9yU2NvcGUuc2VsZi5fcGFyZW50O1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1lbnVtLWNvbXBhcmlzb25cbiAgICBlbHNlIGlmIChyZXNvbHZlZFRhcmdldCA9PT0gU3BlY2lhbFRhcmdldHMuSW50ZXJuYWwpIHtcbiAgICAgIHRhcmdldEFjdG9yUmVmID0gYWN0b3JTY29wZS5zZWxmO1xuICAgIH0gZWxzZSBpZiAocmVzb2x2ZWRUYXJnZXQuc3RhcnRzV2l0aCgnI18nKSkge1xuICAgICAgLy8gU0NYTUwgY29tcGF0aWJpbGl0eTogaHR0cHM6Ly93d3cudzMub3JnL1RSL3NjeG1sLyNTQ1hNTEV2ZW50UHJvY2Vzc29yXG4gICAgICAvLyAjX2ludm9rZWlkLiBJZiB0aGUgdGFyZ2V0IGlzIHRoZSBzcGVjaWFsIHRlcm0gJyNfaW52b2tlaWQnLCB3aGVyZSBpbnZva2VpZCBpcyB0aGUgaW52b2tlaWQgb2YgYW4gU0NYTUwgc2Vzc2lvbiB0aGF0IHRoZSBzZW5kaW5nIHNlc3Npb24gaGFzIGNyZWF0ZWQgYnkgPGludm9rZT4sIHRoZSBQcm9jZXNzb3IgbXVzdCBhZGQgdGhlIGV2ZW50IHRvIHRoZSBleHRlcm5hbCBxdWV1ZSBvZiB0aGF0IHNlc3Npb24uXG4gICAgICB0YXJnZXRBY3RvclJlZiA9IHNuYXBzaG90LmNoaWxkcmVuW3Jlc29sdmVkVGFyZ2V0LnNsaWNlKDIpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0QWN0b3JSZWYgPSBleHRyYS5kZWZlcnJlZEFjdG9ySWRzPy5pbmNsdWRlcyhyZXNvbHZlZFRhcmdldCkgPyByZXNvbHZlZFRhcmdldCA6IHNuYXBzaG90LmNoaWxkcmVuW3Jlc29sdmVkVGFyZ2V0XTtcbiAgICB9XG4gICAgaWYgKCF0YXJnZXRBY3RvclJlZikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gc2VuZCBldmVudCB0byBhY3RvciAnJHtyZXNvbHZlZFRhcmdldH0nIGZyb20gbWFjaGluZSAnJHtzbmFwc2hvdC5tYWNoaW5lLmlkfScuYCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRhcmdldEFjdG9yUmVmID0gcmVzb2x2ZWRUYXJnZXQgfHwgYWN0b3JTY29wZS5zZWxmO1xuICB9XG4gIHJldHVybiBbc25hcHNob3QsIHtcbiAgICB0bzogdGFyZ2V0QWN0b3JSZWYsXG4gICAgdGFyZ2V0SWQ6IHR5cGVvZiByZXNvbHZlZFRhcmdldCA9PT0gJ3N0cmluZycgPyByZXNvbHZlZFRhcmdldCA6IHVuZGVmaW5lZCxcbiAgICBldmVudDogcmVzb2x2ZWRFdmVudCxcbiAgICBpZCxcbiAgICBkZWxheTogcmVzb2x2ZWREZWxheVxuICB9LCB1bmRlZmluZWRdO1xufVxuZnVuY3Rpb24gcmV0cnlSZXNvbHZlU2VuZFRvKF8sIHNuYXBzaG90LCBwYXJhbXMpIHtcbiAgaWYgKHR5cGVvZiBwYXJhbXMudG8gPT09ICdzdHJpbmcnKSB7XG4gICAgcGFyYW1zLnRvID0gc25hcHNob3QuY2hpbGRyZW5bcGFyYW1zLnRvXTtcbiAgfVxufVxuZnVuY3Rpb24gZXhlY3V0ZVNlbmRUbyhhY3RvclNjb3BlLCBwYXJhbXMpIHtcbiAgLy8gdGhpcyBmb3JtcyBhbiBvdXRnb2luZyBldmVudHMgcXVldWVcbiAgLy8gdGhhbmtzIHRvIHRoYXQgdGhlIHJlY2lwaWVudCBhY3RvcnMgYXJlIGFibGUgdG8gcmVhZCB0aGUgKnVwZGF0ZWQqIHNuYXBzaG90IHZhbHVlIG9mIHRoZSBzZW5kZXJcbiAgYWN0b3JTY29wZS5kZWZlcigoKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgdG8sXG4gICAgICBldmVudCxcbiAgICAgIGRlbGF5LFxuICAgICAgaWRcbiAgICB9ID0gcGFyYW1zO1xuICAgIGlmICh0eXBlb2YgZGVsYXkgPT09ICdudW1iZXInKSB7XG4gICAgICBhY3RvclNjb3BlLnN5c3RlbS5zY2hlZHVsZXIuc2NoZWR1bGUoYWN0b3JTY29wZS5zZWxmLCB0bywgZXZlbnQsIGRlbGF5LCBpZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFjdG9yU2NvcGUuc3lzdGVtLl9yZWxheShhY3RvclNjb3BlLnNlbGYsXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgaW4gYSBkZWZlcnJlZCB0YXNrLCBpdCBzaG91bGQgYWxyZWFkeSBiZSBtdXRhdGVkIGJ5IHJldHJ5UmVzb2x2ZVNlbmRUb1xuICAgIC8vIGlmIGl0IGluaXRpYWxseSBzdGFydGVkIGFzIGEgc3RyaW5nXG4gICAgdG8sIGV2ZW50LnR5cGUgPT09IFhTVEFURV9FUlJPUiA/IGNyZWF0ZUVycm9yQWN0b3JFdmVudChhY3RvclNjb3BlLnNlbGYuaWQsIGV2ZW50LmRhdGEpIDogZXZlbnQpO1xuICB9KTtcbn1cbi8qKlxuICogU2VuZHMgYW4gZXZlbnQgdG8gYW4gYWN0b3IuXG4gKlxuICogQHBhcmFtIGFjdG9yIFRoZSBgQWN0b3JSZWZgIHRvIHNlbmQgdGhlIGV2ZW50IHRvLlxuICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCB0byBzZW5kLCBvciBhbiBleHByZXNzaW9uIHRoYXQgZXZhbHVhdGVzIHRvIHRoZSBldmVudFxuICogICB0byBzZW5kXG4gKiBAcGFyYW0gb3B0aW9ucyBTZW5kIGFjdGlvbiBvcHRpb25zXG4gKlxuICogICAtIGBpZGAgLSBUaGUgdW5pcXVlIHNlbmQgZXZlbnQgaWRlbnRpZmllciAodXNlZCB3aXRoIGBjYW5jZWwoKWApLlxuICogICAtIGBkZWxheWAgLSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSB0aGUgc2VuZGluZyBvZiB0aGUgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIHNlbmRUbyh0bywgZXZlbnRPckV4cHIsIG9wdGlvbnMpIHtcbiAgaWYgKGV4ZWN1dGluZ0N1c3RvbUFjdGlvbikge1xuICAgIGNvbnNvbGUud2FybignQ3VzdG9tIGFjdGlvbnMgc2hvdWxkIG5vdCBjYWxsIGBzZW5kVG8oKWAgZGlyZWN0bHksIGFzIGl0IGlzIG5vdCBpbXBlcmF0aXZlLiBTZWUgaHR0cHM6Ly9zdGF0ZWx5LmFpL2RvY3MvYWN0aW9ucyNidWlsdC1pbi1hY3Rpb25zIGZvciBtb3JlIGRldGFpbHMuJyk7XG4gIH1cbiAgZnVuY3Rpb24gc2VuZFRvKF9hcmdzLCBfcGFyYW1zKSB7XG4gICAge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIGlzbid0IHN1cHBvc2VkIHRvIGJlIGNhbGxlZGApO1xuICAgIH1cbiAgfVxuICBzZW5kVG8udHlwZSA9ICd4c3RhdGUuc2VuZFRvJztcbiAgc2VuZFRvLnRvID0gdG87XG4gIHNlbmRUby5ldmVudCA9IGV2ZW50T3JFeHByO1xuICBzZW5kVG8uaWQgPSBvcHRpb25zPy5pZDtcbiAgc2VuZFRvLmRlbGF5ID0gb3B0aW9ucz8uZGVsYXk7XG4gIHNlbmRUby5yZXNvbHZlID0gcmVzb2x2ZVNlbmRUbztcbiAgc2VuZFRvLnJldHJ5UmVzb2x2ZSA9IHJldHJ5UmVzb2x2ZVNlbmRUbztcbiAgc2VuZFRvLmV4ZWN1dGUgPSBleGVjdXRlU2VuZFRvO1xuICByZXR1cm4gc2VuZFRvO1xufVxuXG4vKipcbiAqIFNlbmRzIGFuIGV2ZW50IHRvIHRoaXMgbWFjaGluZSdzIHBhcmVudC5cbiAqXG4gKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IHRvIHNlbmQgdG8gdGhlIHBhcmVudCBtYWNoaW5lLlxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyB0byBwYXNzIGludG8gdGhlIHNlbmQgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIHNlbmRQYXJlbnQoZXZlbnQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHNlbmRUbyhTcGVjaWFsVGFyZ2V0cy5QYXJlbnQsIGV2ZW50LCBvcHRpb25zKTtcbn1cbi8qKlxuICogRm9yd2FyZHMgKHNlbmRzKSBhbiBldmVudCB0byB0aGUgYHRhcmdldGAgYWN0b3IuXG4gKlxuICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IGFjdG9yIHRvIGZvcndhcmQgdGhlIGV2ZW50IHRvLlxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyB0byBwYXNzIGludG8gdGhlIHNlbmQgYWN0aW9uIGNyZWF0b3IuXG4gKi9cbmZ1bmN0aW9uIGZvcndhcmRUbyh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgaWYgKCghdGFyZ2V0IHx8IHR5cGVvZiB0YXJnZXQgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxUYXJnZXQgPSB0YXJnZXQ7XG4gICAgdGFyZ2V0ID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IHJlc29sdmVkVGFyZ2V0ID0gdHlwZW9mIG9yaWdpbmFsVGFyZ2V0ID09PSAnZnVuY3Rpb24nID8gb3JpZ2luYWxUYXJnZXQoLi4uYXJncykgOiBvcmlnaW5hbFRhcmdldDtcbiAgICAgIGlmICghcmVzb2x2ZWRUYXJnZXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdHRlbXB0ZWQgdG8gZm9yd2FyZCBldmVudCB0byB1bmRlZmluZWQgYWN0b3IuIFRoaXMgcmlza3MgYW4gaW5maW5pdGUgbG9vcCBpbiB0aGUgc2VuZGVyLmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc29sdmVkVGFyZ2V0O1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHNlbmRUbyh0YXJnZXQsICh7XG4gICAgZXZlbnRcbiAgfSkgPT4gZXZlbnQsIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRW5xdWV1ZUFjdGlvbnMoYWN0b3JTY29wZSwgc25hcHNob3QsIGFyZ3MsIGFjdGlvblBhcmFtcywge1xuICBjb2xsZWN0XG59KSB7XG4gIGNvbnN0IGFjdGlvbnMgPSBbXTtcbiAgY29uc3QgZW5xdWV1ZSA9IGZ1bmN0aW9uIGVucXVldWUoYWN0aW9uKSB7XG4gICAgYWN0aW9ucy5wdXNoKGFjdGlvbik7XG4gIH07XG4gIGVucXVldWUuYXNzaWduID0gKC4uLmFyZ3MpID0+IHtcbiAgICBhY3Rpb25zLnB1c2goYXNzaWduKC4uLmFyZ3MpKTtcbiAgfTtcbiAgZW5xdWV1ZS5jYW5jZWwgPSAoLi4uYXJncykgPT4ge1xuICAgIGFjdGlvbnMucHVzaChjYW5jZWwoLi4uYXJncykpO1xuICB9O1xuICBlbnF1ZXVlLnJhaXNlID0gKC4uLmFyZ3MpID0+IHtcbiAgICAvLyBmb3Igc29tZSByZWFzb24gaXQgZmFpbHMgdG8gaW5mZXIgYFREZWxheWAgZnJvbSBgLi4uYXJnc2AgaGVyZSBhbmQgcGlja3MgaXRzIGRlZmF1bHQgKGBuZXZlcmApXG4gICAgLy8gdGhlbiBpdCBmYWlscyB0byB0eXBlY2hlY2sgdGhhdCBiZWNhdXNlIGAuLi5hcmdzYCB1c2UgYHN0cmluZ2AgaW4gcGxhY2Ugb2YgYFREZWxheWBcbiAgICBhY3Rpb25zLnB1c2gocmFpc2UoLi4uYXJncykpO1xuICB9O1xuICBlbnF1ZXVlLnNlbmRUbyA9ICguLi5hcmdzKSA9PiB7XG4gICAgLy8gZm9yIHNvbWUgcmVhc29uIGl0IGZhaWxzIHRvIGluZmVyIGBURGVsYXlgIGZyb20gYC4uLmFyZ3NgIGhlcmUgYW5kIHBpY2tzIGl0cyBkZWZhdWx0IChgbmV2ZXJgKVxuICAgIC8vIHRoZW4gaXQgZmFpbHMgdG8gdHlwZWNoZWNrIHRoYXQgYmVjYXVzZSBgLi4uYXJnc2AgdXNlIGBzdHJpbmdgIGluIHBsYWNlIG9mIGBURGVsYXlcbiAgICBhY3Rpb25zLnB1c2goc2VuZFRvKC4uLmFyZ3MpKTtcbiAgfTtcbiAgZW5xdWV1ZS5zZW5kUGFyZW50ID0gKC4uLmFyZ3MpID0+IHtcbiAgICBhY3Rpb25zLnB1c2goc2VuZFBhcmVudCguLi5hcmdzKSk7XG4gIH07XG4gIGVucXVldWUuc3Bhd25DaGlsZCA9ICguLi5hcmdzKSA9PiB7XG4gICAgYWN0aW9ucy5wdXNoKHNwYXduQ2hpbGQoLi4uYXJncykpO1xuICB9O1xuICBlbnF1ZXVlLnN0b3BDaGlsZCA9ICguLi5hcmdzKSA9PiB7XG4gICAgYWN0aW9ucy5wdXNoKHN0b3BDaGlsZCguLi5hcmdzKSk7XG4gIH07XG4gIGVucXVldWUuZW1pdCA9ICguLi5hcmdzKSA9PiB7XG4gICAgYWN0aW9ucy5wdXNoKGVtaXQoLi4uYXJncykpO1xuICB9O1xuICBjb2xsZWN0KHtcbiAgICBjb250ZXh0OiBhcmdzLmNvbnRleHQsXG4gICAgZXZlbnQ6IGFyZ3MuZXZlbnQsXG4gICAgZW5xdWV1ZSxcbiAgICBjaGVjazogZ3VhcmQgPT4gZXZhbHVhdGVHdWFyZChndWFyZCwgc25hcHNob3QuY29udGV4dCwgYXJncy5ldmVudCwgc25hcHNob3QpLFxuICAgIHNlbGY6IGFjdG9yU2NvcGUuc2VsZixcbiAgICBzeXN0ZW06IGFjdG9yU2NvcGUuc3lzdGVtXG4gIH0sIGFjdGlvblBhcmFtcyk7XG4gIHJldHVybiBbc25hcHNob3QsIHVuZGVmaW5lZCwgYWN0aW9uc107XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gYWN0aW9uIG9iamVjdCB0aGF0IHdpbGwgZXhlY3V0ZSBhY3Rpb25zIHRoYXQgYXJlIHF1ZXVlZCBieSB0aGVcbiAqIGBlbnF1ZXVlKGFjdGlvbilgIGZ1bmN0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGNyZWF0ZU1hY2hpbmUsIGVucXVldWVBY3Rpb25zIH0gZnJvbSAneHN0YXRlJztcbiAqXG4gKiBjb25zdCBtYWNoaW5lID0gY3JlYXRlTWFjaGluZSh7XG4gKiAgIGVudHJ5OiBlbnF1ZXVlQWN0aW9ucygoeyBlbnF1ZXVlLCBjaGVjayB9KSA9PiB7XG4gKiAgICAgZW5xdWV1ZS5hc3NpZ24oeyBjb3VudDogMCB9KTtcbiAqXG4gKiAgICAgaWYgKGNoZWNrKCdzb21lR3VhcmQnKSkge1xuICogICAgICAgZW5xdWV1ZS5hc3NpZ24oeyBjb3VudDogMSB9KTtcbiAqICAgICB9XG4gKlxuICogICAgIGVucXVldWUoJ3NvbWVBY3Rpb24nKTtcbiAqICAgfSlcbiAqIH0pO1xuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGVucXVldWVBY3Rpb25zKGNvbGxlY3QpIHtcbiAgZnVuY3Rpb24gZW5xdWV1ZUFjdGlvbnMoX2FyZ3MsIF9wYXJhbXMpIHtcbiAgICB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgaXNuJ3Qgc3VwcG9zZWQgdG8gYmUgY2FsbGVkYCk7XG4gICAgfVxuICB9XG4gIGVucXVldWVBY3Rpb25zLnR5cGUgPSAneHN0YXRlLmVucXVldWVBY3Rpb25zJztcbiAgZW5xdWV1ZUFjdGlvbnMuY29sbGVjdCA9IGNvbGxlY3Q7XG4gIGVucXVldWVBY3Rpb25zLnJlc29sdmUgPSByZXNvbHZlRW5xdWV1ZUFjdGlvbnM7XG4gIHJldHVybiBlbnF1ZXVlQWN0aW9ucztcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUxvZyhfLCBzbmFwc2hvdCwgYWN0aW9uQXJncywgYWN0aW9uUGFyYW1zLCB7XG4gIHZhbHVlLFxuICBsYWJlbFxufSkge1xuICByZXR1cm4gW3NuYXBzaG90LCB7XG4gICAgdmFsdWU6IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlKGFjdGlvbkFyZ3MsIGFjdGlvblBhcmFtcykgOiB2YWx1ZSxcbiAgICBsYWJlbFxuICB9LCB1bmRlZmluZWRdO1xufVxuZnVuY3Rpb24gZXhlY3V0ZUxvZyh7XG4gIGxvZ2dlclxufSwge1xuICB2YWx1ZSxcbiAgbGFiZWxcbn0pIHtcbiAgaWYgKGxhYmVsKSB7XG4gICAgbG9nZ2VyKGxhYmVsLCB2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgbG9nZ2VyKHZhbHVlKTtcbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0gZXhwciBUaGUgZXhwcmVzc2lvbiBmdW5jdGlvbiB0byBldmFsdWF0ZSB3aGljaCB3aWxsIGJlIGxvZ2dlZC4gVGFrZXNcbiAqICAgaW4gMiBhcmd1bWVudHM6XG4gKlxuICogICAtIGBjdHhgIC0gdGhlIGN1cnJlbnQgc3RhdGUgY29udGV4dFxuICogICAtIGBldmVudGAgLSB0aGUgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBhY3Rpb24gdG8gYmUgZXhlY3V0ZWQuXG4gKlxuICogQHBhcmFtIGxhYmVsIFRoZSBsYWJlbCB0byBnaXZlIHRvIHRoZSBsb2dnZWQgZXhwcmVzc2lvbi5cbiAqL1xuZnVuY3Rpb24gbG9nKHZhbHVlID0gKHtcbiAgY29udGV4dCxcbiAgZXZlbnRcbn0pID0+ICh7XG4gIGNvbnRleHQsXG4gIGV2ZW50XG59KSwgbGFiZWwpIHtcbiAgZnVuY3Rpb24gbG9nKF9hcmdzLCBfcGFyYW1zKSB7XG4gICAge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIGlzbid0IHN1cHBvc2VkIHRvIGJlIGNhbGxlZGApO1xuICAgIH1cbiAgfVxuICBsb2cudHlwZSA9ICd4c3RhdGUubG9nJztcbiAgbG9nLnZhbHVlID0gdmFsdWU7XG4gIGxvZy5sYWJlbCA9IGxhYmVsO1xuICBsb2cucmVzb2x2ZSA9IHJlc29sdmVMb2c7XG4gIGxvZy5leGVjdXRlID0gZXhlY3V0ZUxvZztcbiAgcmV0dXJuIGxvZztcbn1cblxuZXhwb3J0IHsgU3BlY2lhbFRhcmdldHMgYXMgUywgZW5xdWV1ZUFjdGlvbnMgYXMgYSwgc2VuZFRvIGFzIGIsIGVtaXQgYXMgZSwgZm9yd2FyZFRvIGFzIGYsIGxvZyBhcyBsLCBzZW5kUGFyZW50IGFzIHMgfTtcbiJdLCJuYW1lcyI6WyJUIiwiZXhlY3V0aW5nQ3VzdG9tQWN0aW9uIiwiVSIsIlhTVEFURV9FUlJPUiIsIlYiLCJjcmVhdGVFcnJvckFjdG9yRXZlbnQiLCJ3IiwiZXZhbHVhdGVHdWFyZCIsImYiLCJjYW5jZWwiLCJyIiwicmFpc2UiLCJoIiwic3Bhd25DaGlsZCIsImsiLCJzdG9wQ2hpbGQiLCJhIiwiYXNzaWduIiwicmVzb2x2ZUVtaXQiLCJfIiwic25hcHNob3QiLCJhcmdzIiwiYWN0aW9uUGFyYW1zIiwiZXZlbnQiLCJldmVudE9yRXhwciIsInJlc29sdmVkRXZlbnQiLCJ1bmRlZmluZWQiLCJleGVjdXRlRW1pdCIsImFjdG9yU2NvcGUiLCJkZWZlciIsImVtaXQiLCJjb25zb2xlIiwid2FybiIsIl9hcmdzIiwiX3BhcmFtcyIsIkVycm9yIiwidHlwZSIsInJlc29sdmUiLCJleGVjdXRlIiwiU3BlY2lhbFRhcmdldHMiLCJyZXNvbHZlU2VuZFRvIiwidG8iLCJpZCIsImRlbGF5IiwiZXh0cmEiLCJkZWxheXNNYXAiLCJtYWNoaW5lIiwiaW1wbGVtZW50YXRpb25zIiwiZGVsYXlzIiwicmVzb2x2ZWREZWxheSIsImNvbmZpZ0RlbGF5IiwicmVzb2x2ZWRUYXJnZXQiLCJ0YXJnZXRBY3RvclJlZiIsIlBhcmVudCIsInNlbGYiLCJfcGFyZW50IiwiSW50ZXJuYWwiLCJzdGFydHNXaXRoIiwiY2hpbGRyZW4iLCJzbGljZSIsImRlZmVycmVkQWN0b3JJZHMiLCJpbmNsdWRlcyIsInRhcmdldElkIiwicmV0cnlSZXNvbHZlU2VuZFRvIiwicGFyYW1zIiwiZXhlY3V0ZVNlbmRUbyIsInN5c3RlbSIsInNjaGVkdWxlciIsInNjaGVkdWxlIiwiX3JlbGF5IiwiZGF0YSIsInNlbmRUbyIsIm9wdGlvbnMiLCJyZXRyeVJlc29sdmUiLCJzZW5kUGFyZW50IiwiZm9yd2FyZFRvIiwidGFyZ2V0Iiwib3JpZ2luYWxUYXJnZXQiLCJyZXNvbHZlRW5xdWV1ZUFjdGlvbnMiLCJjb2xsZWN0IiwiYWN0aW9ucyIsImVucXVldWUiLCJhY3Rpb24iLCJwdXNoIiwiY29udGV4dCIsImNoZWNrIiwiZ3VhcmQiLCJlbnF1ZXVlQWN0aW9ucyIsInJlc29sdmVMb2ciLCJhY3Rpb25BcmdzIiwidmFsdWUiLCJsYWJlbCIsImV4ZWN1dGVMb2ciLCJsb2dnZXIiLCJsb2ciLCJTIiwiYiIsImUiLCJsIiwicyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xstate/dist/log-ef959da6.development.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/xstate/dist/raise-78b8dcb8.development.esm.js":
/*!********************************************************************!*\
  !*** ./node_modules/xstate/dist/raise-78b8dcb8.development.esm.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $: () => (/* binding */ $$ACTOR_TYPE),\n/* harmony export */   A: () => (/* binding */ Actor),\n/* harmony export */   B: () => (/* binding */ getCandidates),\n/* harmony export */   C: () => (/* binding */ resolveStateValue),\n/* harmony export */   D: () => (/* binding */ getAllStateNodes),\n/* harmony export */   E: () => (/* binding */ createMachineSnapshot),\n/* harmony export */   F: () => (/* binding */ isInFinalState),\n/* harmony export */   G: () => (/* binding */ macrostep),\n/* harmony export */   H: () => (/* binding */ transitionNode),\n/* harmony export */   I: () => (/* binding */ resolveActionsAndContext),\n/* harmony export */   J: () => (/* binding */ createInitEvent),\n/* harmony export */   K: () => (/* binding */ microstep),\n/* harmony export */   L: () => (/* binding */ getInitialStateNodes),\n/* harmony export */   M: () => (/* binding */ toStatePath),\n/* harmony export */   N: () => (/* binding */ NULL_EVENT),\n/* harmony export */   O: () => (/* binding */ isStateId),\n/* harmony export */   P: () => (/* binding */ getStateNodeByPath),\n/* harmony export */   Q: () => (/* binding */ getPersistedSnapshot),\n/* harmony export */   R: () => (/* binding */ resolveReferencedActor),\n/* harmony export */   S: () => (/* binding */ STATE_DELIMITER),\n/* harmony export */   T: () => (/* binding */ executingCustomAction),\n/* harmony export */   U: () => (/* binding */ XSTATE_ERROR),\n/* harmony export */   V: () => (/* binding */ createErrorActorEvent),\n/* harmony export */   W: () => (/* binding */ ProcessingStatus),\n/* harmony export */   X: () => (/* binding */ XSTATE_STOP),\n/* harmony export */   Y: () => (/* binding */ cloneMachineSnapshot),\n/* harmony export */   a: () => (/* binding */ and),\n/* harmony export */   b: () => (/* binding */ isMachineSnapshot),\n/* harmony export */   c: () => (/* binding */ createActor),\n/* harmony export */   d: () => (/* binding */ getAllOwnEventDescriptors),\n/* harmony export */   e: () => (/* binding */ toObserver),\n/* harmony export */   f: () => (/* binding */ cancel),\n/* harmony export */   g: () => (/* binding */ getStateNodes),\n/* harmony export */   h: () => (/* binding */ spawnChild),\n/* harmony export */   i: () => (/* binding */ interpret),\n/* harmony export */   j: () => (/* binding */ stop),\n/* harmony export */   k: () => (/* binding */ stopChild),\n/* harmony export */   l: () => (/* binding */ mapValues),\n/* harmony export */   m: () => (/* binding */ matchesState),\n/* harmony export */   n: () => (/* binding */ not),\n/* harmony export */   o: () => (/* binding */ or),\n/* harmony export */   p: () => (/* binding */ pathToStateValue),\n/* harmony export */   q: () => (/* binding */ formatTransitions),\n/* harmony export */   r: () => (/* binding */ raise),\n/* harmony export */   s: () => (/* binding */ stateIn),\n/* harmony export */   t: () => (/* binding */ toArray),\n/* harmony export */   u: () => (/* binding */ toTransitionConfigArray),\n/* harmony export */   v: () => (/* binding */ formatTransition),\n/* harmony export */   w: () => (/* binding */ evaluateGuard),\n/* harmony export */   x: () => (/* binding */ createInvokeId),\n/* harmony export */   y: () => (/* binding */ getDelayedTransitions),\n/* harmony export */   z: () => (/* binding */ formatInitialTransition)\n/* harmony export */ });\n/* harmony import */ var _dev_dist_xstate_dev_development_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dev/dist/xstate-dev.development.esm.js */ \"(ssr)/./node_modules/xstate/dev/dist/xstate-dev.development.esm.js\");\n\nclass Mailbox {\n    constructor(_process){\n        this._process = _process;\n        this._active = false;\n        this._current = null;\n        this._last = null;\n    }\n    start() {\n        this._active = true;\n        this.flush();\n    }\n    clear() {\n        // we can't set _current to null because we might be currently processing\n        // and enqueue following clear shouldn't start processing the enqueued item immediately\n        if (this._current) {\n            this._current.next = null;\n            this._last = this._current;\n        }\n    }\n    enqueue(event) {\n        const enqueued = {\n            value: event,\n            next: null\n        };\n        if (this._current) {\n            this._last.next = enqueued;\n            this._last = enqueued;\n            return;\n        }\n        this._current = enqueued;\n        this._last = enqueued;\n        if (this._active) {\n            this.flush();\n        }\n    }\n    flush() {\n        while(this._current){\n            // atm the given _process is responsible for implementing proper try/catch handling\n            // we assume here that this won't throw in a way that can affect this mailbox\n            const consumed = this._current;\n            this._process(consumed.value);\n            this._current = consumed.next;\n        }\n        this._last = null;\n    }\n}\nconst STATE_DELIMITER = \".\";\nconst TARGETLESS_KEY = \"\";\nconst NULL_EVENT = \"\";\nconst STATE_IDENTIFIER = \"#\";\nconst WILDCARD = \"*\";\nconst XSTATE_INIT = \"xstate.init\";\nconst XSTATE_ERROR = \"xstate.error\";\nconst XSTATE_STOP = \"xstate.stop\";\n/**\n * Returns an event that represents an implicit event that is sent after the\n * specified `delay`.\n *\n * @param delayRef The delay in milliseconds\n * @param id The state node ID where this event is handled\n */ function createAfterEvent(delayRef, id) {\n    return {\n        type: `xstate.after.${delayRef}.${id}`\n    };\n}\n/**\n * Returns an event that represents that a final state node has been reached in\n * the parent state node.\n *\n * @param id The final state node's parent state node `id`\n * @param output The data to pass into the event\n */ function createDoneStateEvent(id, output) {\n    return {\n        type: `xstate.done.state.${id}`,\n        output\n    };\n}\n/**\n * Returns an event that represents that an invoked service has terminated.\n *\n * An invoked service is terminated when it has reached a top-level final state\n * node, but not when it is canceled.\n *\n * @param invokeId The invoked service ID\n * @param output The data to pass into the event\n */ function createDoneActorEvent(invokeId, output) {\n    return {\n        type: `xstate.done.actor.${invokeId}`,\n        output,\n        actorId: invokeId\n    };\n}\nfunction createErrorActorEvent(id, error) {\n    return {\n        type: `xstate.error.actor.${id}`,\n        error,\n        actorId: id\n    };\n}\nfunction createInitEvent(input) {\n    return {\n        type: XSTATE_INIT,\n        input\n    };\n}\n/**\n * This function makes sure that unhandled errors are thrown in a separate\n * macrotask. It allows those errors to be detected by global error handlers and\n * reported to bug tracking services without interrupting our own stack of\n * execution.\n *\n * @param err Error to be thrown\n */ function reportUnhandledError(err) {\n    setTimeout(()=>{\n        throw err;\n    });\n}\nconst symbolObservable = (()=>typeof Symbol === \"function\" && Symbol.observable || \"@@observable\")();\nfunction matchesState(parentStateId, childStateId) {\n    const parentStateValue = toStateValue(parentStateId);\n    const childStateValue = toStateValue(childStateId);\n    if (typeof childStateValue === \"string\") {\n        if (typeof parentStateValue === \"string\") {\n            return childStateValue === parentStateValue;\n        }\n        // Parent more specific than child\n        return false;\n    }\n    if (typeof parentStateValue === \"string\") {\n        return parentStateValue in childStateValue;\n    }\n    return Object.keys(parentStateValue).every((key)=>{\n        if (!(key in childStateValue)) {\n            return false;\n        }\n        return matchesState(parentStateValue[key], childStateValue[key]);\n    });\n}\nfunction toStatePath(stateId) {\n    if (isArray(stateId)) {\n        return stateId;\n    }\n    const result = [];\n    let segment = \"\";\n    for(let i = 0; i < stateId.length; i++){\n        const char = stateId.charCodeAt(i);\n        switch(char){\n            // \\\n            case 92:\n                // consume the next character\n                segment += stateId[i + 1];\n                // and skip over it\n                i++;\n                continue;\n            // .\n            case 46:\n                result.push(segment);\n                segment = \"\";\n                continue;\n        }\n        segment += stateId[i];\n    }\n    result.push(segment);\n    return result;\n}\nfunction toStateValue(stateValue) {\n    if (isMachineSnapshot(stateValue)) {\n        return stateValue.value;\n    }\n    if (typeof stateValue !== \"string\") {\n        return stateValue;\n    }\n    const statePath = toStatePath(stateValue);\n    return pathToStateValue(statePath);\n}\nfunction pathToStateValue(statePath) {\n    if (statePath.length === 1) {\n        return statePath[0];\n    }\n    const value = {};\n    let marker = value;\n    for(let i = 0; i < statePath.length - 1; i++){\n        if (i === statePath.length - 2) {\n            marker[statePath[i]] = statePath[i + 1];\n        } else {\n            const previous = marker;\n            marker = {};\n            previous[statePath[i]] = marker;\n        }\n    }\n    return value;\n}\nfunction mapValues(collection, iteratee) {\n    const result = {};\n    const collectionKeys = Object.keys(collection);\n    for(let i = 0; i < collectionKeys.length; i++){\n        const key = collectionKeys[i];\n        result[key] = iteratee(collection[key], key, collection, i);\n    }\n    return result;\n}\nfunction toArrayStrict(value) {\n    if (isArray(value)) {\n        return value;\n    }\n    return [\n        value\n    ];\n}\nfunction toArray(value) {\n    if (value === undefined) {\n        return [];\n    }\n    return toArrayStrict(value);\n}\nfunction resolveOutput(mapper, context, event, self) {\n    if (typeof mapper === \"function\") {\n        return mapper({\n            context,\n            event,\n            self\n        });\n    }\n    if (!!mapper && typeof mapper === \"object\" && Object.values(mapper).some((val)=>typeof val === \"function\")) {\n        console.warn(`Dynamically mapping values to individual properties is deprecated. Use a single function that returns the mapped object instead.\\nFound object containing properties whose values are possibly mapping functions: ${Object.entries(mapper).filter(([, value])=>typeof value === \"function\").map(([key, value])=>`\\n - ${key}: ${value.toString().replace(/\\n\\s*/g, \"\")}`).join(\"\")}`);\n    }\n    return mapper;\n}\nfunction isArray(value) {\n    return Array.isArray(value);\n}\nfunction isErrorActorEvent(event) {\n    return event.type.startsWith(\"xstate.error.actor\");\n}\nfunction toTransitionConfigArray(configLike) {\n    return toArrayStrict(configLike).map((transitionLike)=>{\n        if (typeof transitionLike === \"undefined\" || typeof transitionLike === \"string\") {\n            return {\n                target: transitionLike\n            };\n        }\n        return transitionLike;\n    });\n}\nfunction normalizeTarget(target) {\n    if (target === undefined || target === TARGETLESS_KEY) {\n        return undefined;\n    }\n    return toArray(target);\n}\nfunction toObserver(nextHandler, errorHandler, completionHandler) {\n    const isObserver = typeof nextHandler === \"object\";\n    const self = isObserver ? nextHandler : undefined;\n    return {\n        next: (isObserver ? nextHandler.next : nextHandler)?.bind(self),\n        error: (isObserver ? nextHandler.error : errorHandler)?.bind(self),\n        complete: (isObserver ? nextHandler.complete : completionHandler)?.bind(self)\n    };\n}\nfunction createInvokeId(stateNodeId, index) {\n    return `${index}.${stateNodeId}`;\n}\nfunction resolveReferencedActor(machine, src) {\n    const match = src.match(/^xstate\\.invoke\\.(\\d+)\\.(.*)/);\n    if (!match) {\n        return machine.implementations.actors[src];\n    }\n    const [, indexStr, nodeId] = match;\n    const node = machine.getStateNodeById(nodeId);\n    const invokeConfig = node.config.invoke;\n    return (Array.isArray(invokeConfig) ? invokeConfig[indexStr] : invokeConfig).src;\n}\nfunction getAllOwnEventDescriptors(snapshot) {\n    return [\n        ...new Set([\n            ...snapshot._nodes.flatMap((sn)=>sn.ownEvents)\n        ])\n    ];\n}\nfunction createScheduledEventId(actorRef, id) {\n    return `${actorRef.sessionId}.${id}`;\n}\nlet idCounter = 0;\nfunction createSystem(rootActor, options) {\n    const children = new Map();\n    const keyedActors = new Map();\n    const reverseKeyedActors = new WeakMap();\n    const inspectionObservers = new Set();\n    const timerMap = {};\n    const { clock, logger } = options;\n    const scheduler = {\n        schedule: (source, target, event, delay, id = Math.random().toString(36).slice(2))=>{\n            const scheduledEvent = {\n                source,\n                target,\n                event,\n                delay,\n                id,\n                startedAt: Date.now()\n            };\n            const scheduledEventId = createScheduledEventId(source, id);\n            system._snapshot._scheduledEvents[scheduledEventId] = scheduledEvent;\n            const timeout = clock.setTimeout(()=>{\n                delete timerMap[scheduledEventId];\n                delete system._snapshot._scheduledEvents[scheduledEventId];\n                system._relay(source, target, event);\n            }, delay);\n            timerMap[scheduledEventId] = timeout;\n        },\n        cancel: (source, id)=>{\n            const scheduledEventId = createScheduledEventId(source, id);\n            const timeout = timerMap[scheduledEventId];\n            delete timerMap[scheduledEventId];\n            delete system._snapshot._scheduledEvents[scheduledEventId];\n            if (timeout !== undefined) {\n                clock.clearTimeout(timeout);\n            }\n        },\n        cancelAll: (actorRef)=>{\n            for(const scheduledEventId in system._snapshot._scheduledEvents){\n                const scheduledEvent = system._snapshot._scheduledEvents[scheduledEventId];\n                if (scheduledEvent.source === actorRef) {\n                    scheduler.cancel(actorRef, scheduledEvent.id);\n                }\n            }\n        }\n    };\n    const sendInspectionEvent = (event)=>{\n        if (!inspectionObservers.size) {\n            return;\n        }\n        const resolvedInspectionEvent = {\n            ...event,\n            rootId: rootActor.sessionId\n        };\n        inspectionObservers.forEach((observer)=>observer.next?.(resolvedInspectionEvent));\n    };\n    const system = {\n        _snapshot: {\n            _scheduledEvents: (options?.snapshot && options.snapshot.scheduler) ?? {}\n        },\n        _bookId: ()=>`x:${idCounter++}`,\n        _register: (sessionId, actorRef)=>{\n            children.set(sessionId, actorRef);\n            return sessionId;\n        },\n        _unregister: (actorRef)=>{\n            children.delete(actorRef.sessionId);\n            const systemId = reverseKeyedActors.get(actorRef);\n            if (systemId !== undefined) {\n                keyedActors.delete(systemId);\n                reverseKeyedActors.delete(actorRef);\n            }\n        },\n        get: (systemId)=>{\n            return keyedActors.get(systemId);\n        },\n        _set: (systemId, actorRef)=>{\n            const existing = keyedActors.get(systemId);\n            if (existing && existing !== actorRef) {\n                throw new Error(`Actor with system ID '${systemId}' already exists.`);\n            }\n            keyedActors.set(systemId, actorRef);\n            reverseKeyedActors.set(actorRef, systemId);\n        },\n        inspect: (observerOrFn)=>{\n            const observer = toObserver(observerOrFn);\n            inspectionObservers.add(observer);\n            return {\n                unsubscribe () {\n                    inspectionObservers.delete(observer);\n                }\n            };\n        },\n        _sendInspectionEvent: sendInspectionEvent,\n        _relay: (source, target, event)=>{\n            system._sendInspectionEvent({\n                type: \"@xstate.event\",\n                sourceRef: source,\n                actorRef: target,\n                event\n            });\n            target._send(event);\n        },\n        scheduler,\n        getSnapshot: ()=>{\n            return {\n                _scheduledEvents: {\n                    ...system._snapshot._scheduledEvents\n                }\n            };\n        },\n        start: ()=>{\n            const scheduledEvents = system._snapshot._scheduledEvents;\n            system._snapshot._scheduledEvents = {};\n            for(const scheduledId in scheduledEvents){\n                const { source, target, event, delay, id } = scheduledEvents[scheduledId];\n                scheduler.schedule(source, target, event, delay, id);\n            }\n        },\n        _clock: clock,\n        _logger: logger\n    };\n    return system;\n}\n// those are needed to make JSDoc `@link` work properly\nlet executingCustomAction = false;\nconst $$ACTOR_TYPE = 1;\n// those values are currently used by @xstate/react directly so it's important to keep the assigned values in sync\nlet ProcessingStatus = /*#__PURE__*/ function(ProcessingStatus) {\n    ProcessingStatus[ProcessingStatus[\"NotStarted\"] = 0] = \"NotStarted\";\n    ProcessingStatus[ProcessingStatus[\"Running\"] = 1] = \"Running\";\n    ProcessingStatus[ProcessingStatus[\"Stopped\"] = 2] = \"Stopped\";\n    return ProcessingStatus;\n}({});\nconst defaultOptions = {\n    clock: {\n        setTimeout: (fn, ms)=>{\n            return setTimeout(fn, ms);\n        },\n        clearTimeout: (id)=>{\n            return clearTimeout(id);\n        }\n    },\n    logger: console.log.bind(console),\n    devTools: false\n};\n/**\n * An Actor is a running process that can receive events, send events and change\n * its behavior based on the events it receives, which can cause effects outside\n * of the actor. When you run a state machine, it becomes an actor.\n */ class Actor {\n    /**\n   * Creates a new actor instance for the given logic with the provided options,\n   * if any.\n   *\n   * @param logic The logic to create an actor from\n   * @param options Actor options\n   */ constructor(logic, options){\n        this.logic = logic;\n        /** The current internal state of the actor. */ this._snapshot = void 0;\n        /**\n     * The clock that is responsible for setting and clearing timeouts, such as\n     * delayed events and transitions.\n     */ this.clock = void 0;\n        this.options = void 0;\n        /** The unique identifier for this actor relative to its parent. */ this.id = void 0;\n        this.mailbox = new Mailbox(this._process.bind(this));\n        this.observers = new Set();\n        this.eventListeners = new Map();\n        this.logger = void 0;\n        /** @internal */ this._processingStatus = ProcessingStatus.NotStarted;\n        // Actor Ref\n        this._parent = void 0;\n        /** @internal */ this._syncSnapshot = void 0;\n        this.ref = void 0;\n        // TODO: add typings for system\n        this._actorScope = void 0;\n        this._systemId = void 0;\n        /** The globally unique process ID for this invocation. */ this.sessionId = void 0;\n        /** The system to which this actor belongs. */ this.system = void 0;\n        this._doneEvent = void 0;\n        this.src = void 0;\n        // array of functions to defer\n        this._deferred = [];\n        const resolvedOptions = {\n            ...defaultOptions,\n            ...options\n        };\n        const { clock, logger, parent, syncSnapshot, id, systemId, inspect } = resolvedOptions;\n        this.system = parent ? parent.system : createSystem(this, {\n            clock,\n            logger\n        });\n        if (inspect && !parent) {\n            // Always inspect at the system-level\n            this.system.inspect(toObserver(inspect));\n        }\n        this.sessionId = this.system._bookId();\n        this.id = id ?? this.sessionId;\n        this.logger = options?.logger ?? this.system._logger;\n        this.clock = options?.clock ?? this.system._clock;\n        this._parent = parent;\n        this._syncSnapshot = syncSnapshot;\n        this.options = resolvedOptions;\n        this.src = resolvedOptions.src ?? logic;\n        this.ref = this;\n        this._actorScope = {\n            self: this,\n            id: this.id,\n            sessionId: this.sessionId,\n            logger: this.logger,\n            defer: (fn)=>{\n                this._deferred.push(fn);\n            },\n            system: this.system,\n            stopChild: (child)=>{\n                if (child._parent !== this) {\n                    throw new Error(`Cannot stop child actor ${child.id} of ${this.id} because it is not a child`);\n                }\n                child._stop();\n            },\n            emit: (emittedEvent)=>{\n                const listeners = this.eventListeners.get(emittedEvent.type);\n                const wildcardListener = this.eventListeners.get(\"*\");\n                if (!listeners && !wildcardListener) {\n                    return;\n                }\n                const allListeners = [\n                    ...listeners ? listeners.values() : [],\n                    ...wildcardListener ? wildcardListener.values() : []\n                ];\n                for (const handler of allListeners){\n                    handler(emittedEvent);\n                }\n            },\n            actionExecutor: (action)=>{\n                const exec = ()=>{\n                    this._actorScope.system._sendInspectionEvent({\n                        type: \"@xstate.action\",\n                        actorRef: this,\n                        action: {\n                            type: action.type,\n                            params: action.params\n                        }\n                    });\n                    if (!action.exec) {\n                        return;\n                    }\n                    const saveExecutingCustomAction = executingCustomAction;\n                    try {\n                        executingCustomAction = true;\n                        action.exec(action.info, action.params);\n                    } finally{\n                        executingCustomAction = saveExecutingCustomAction;\n                    }\n                };\n                if (this._processingStatus === ProcessingStatus.Running) {\n                    exec();\n                } else {\n                    this._deferred.push(exec);\n                }\n            }\n        };\n        // Ensure that the send method is bound to this Actor instance\n        // if destructured\n        this.send = this.send.bind(this);\n        this.system._sendInspectionEvent({\n            type: \"@xstate.actor\",\n            actorRef: this\n        });\n        if (systemId) {\n            this._systemId = systemId;\n            this.system._set(systemId, this);\n        }\n        this._initState(options?.snapshot ?? options?.state);\n        if (systemId && this._snapshot.status !== \"active\") {\n            this.system._unregister(this);\n        }\n    }\n    _initState(persistedState) {\n        try {\n            this._snapshot = persistedState ? this.logic.restoreSnapshot ? this.logic.restoreSnapshot(persistedState, this._actorScope) : persistedState : this.logic.getInitialSnapshot(this._actorScope, this.options?.input);\n        } catch (err) {\n            // if we get here then it means that we assign a value to this._snapshot that is not of the correct type\n            // we can't get the true `TSnapshot & { status: 'error'; }`, it's impossible\n            // so right now this is a lie of sorts\n            this._snapshot = {\n                status: \"error\",\n                output: undefined,\n                error: err\n            };\n        }\n    }\n    update(snapshot, event) {\n        // Update state\n        this._snapshot = snapshot;\n        // Execute deferred effects\n        let deferredFn;\n        while(deferredFn = this._deferred.shift()){\n            try {\n                deferredFn();\n            } catch (err) {\n                // this error can only be caught when executing *initial* actions\n                // it's the only time when we call actions provided by the user through those deferreds\n                // when the actor is already running we always execute them synchronously while transitioning\n                // no \"builtin deferred\" should actually throw an error since they are either safe\n                // or the control flow is passed through the mailbox and errors should be caught by the `_process` used by the mailbox\n                this._deferred.length = 0;\n                this._snapshot = {\n                    ...snapshot,\n                    status: \"error\",\n                    error: err\n                };\n            }\n        }\n        switch(this._snapshot.status){\n            case \"active\":\n                for (const observer of this.observers){\n                    try {\n                        observer.next?.(snapshot);\n                    } catch (err) {\n                        reportUnhandledError(err);\n                    }\n                }\n                break;\n            case \"done\":\n                // next observers are meant to be notified about done snapshots\n                // this can be seen as something that is different from how observable work\n                // but with observables `complete` callback is called without any arguments\n                // it's more ergonomic for XState to treat a done snapshot as a \"next\" value\n                // and the completion event as something that is separate,\n                // something that merely follows emitting that done snapshot\n                for (const observer of this.observers){\n                    try {\n                        observer.next?.(snapshot);\n                    } catch (err) {\n                        reportUnhandledError(err);\n                    }\n                }\n                this._stopProcedure();\n                this._complete();\n                this._doneEvent = createDoneActorEvent(this.id, this._snapshot.output);\n                if (this._parent) {\n                    this.system._relay(this, this._parent, this._doneEvent);\n                }\n                break;\n            case \"error\":\n                this._error(this._snapshot.error);\n                break;\n        }\n        this.system._sendInspectionEvent({\n            type: \"@xstate.snapshot\",\n            actorRef: this,\n            event,\n            snapshot\n        });\n    }\n    /**\n   * Subscribe an observer to an actor’s snapshot values.\n   *\n   * @remarks\n   * The observer will receive the actor’s snapshot value when it is emitted.\n   * The observer can be:\n   *\n   * - A plain function that receives the latest snapshot, or\n   * - An observer object whose `.next(snapshot)` method receives the latest\n   *   snapshot\n   *\n   * @example\n   *\n   * ```ts\n   * // Observer as a plain function\n   * const subscription = actor.subscribe((snapshot) => {\n   *   console.log(snapshot);\n   * });\n   * ```\n   *\n   * @example\n   *\n   * ```ts\n   * // Observer as an object\n   * const subscription = actor.subscribe({\n   *   next(snapshot) {\n   *     console.log(snapshot);\n   *   },\n   *   error(err) {\n   *     // ...\n   *   },\n   *   complete() {\n   *     // ...\n   *   }\n   * });\n   * ```\n   *\n   * The return value of `actor.subscribe(observer)` is a subscription object\n   * that has an `.unsubscribe()` method. You can call\n   * `subscription.unsubscribe()` to unsubscribe the observer:\n   *\n   * @example\n   *\n   * ```ts\n   * const subscription = actor.subscribe((snapshot) => {\n   *   // ...\n   * });\n   *\n   * // Unsubscribe the observer\n   * subscription.unsubscribe();\n   * ```\n   *\n   * When the actor is stopped, all of its observers will automatically be\n   * unsubscribed.\n   *\n   * @param observer - Either a plain function that receives the latest\n   *   snapshot, or an observer object whose `.next(snapshot)` method receives\n   *   the latest snapshot\n   */ subscribe(nextListenerOrObserver, errorListener, completeListener) {\n        const observer = toObserver(nextListenerOrObserver, errorListener, completeListener);\n        if (this._processingStatus !== ProcessingStatus.Stopped) {\n            this.observers.add(observer);\n        } else {\n            switch(this._snapshot.status){\n                case \"done\":\n                    try {\n                        observer.complete?.();\n                    } catch (err) {\n                        reportUnhandledError(err);\n                    }\n                    break;\n                case \"error\":\n                    {\n                        const err = this._snapshot.error;\n                        if (!observer.error) {\n                            reportUnhandledError(err);\n                        } else {\n                            try {\n                                observer.error(err);\n                            } catch (err) {\n                                reportUnhandledError(err);\n                            }\n                        }\n                        break;\n                    }\n            }\n        }\n        return {\n            unsubscribe: ()=>{\n                this.observers.delete(observer);\n            }\n        };\n    }\n    on(type, handler) {\n        let listeners = this.eventListeners.get(type);\n        if (!listeners) {\n            listeners = new Set();\n            this.eventListeners.set(type, listeners);\n        }\n        const wrappedHandler = handler.bind(undefined);\n        listeners.add(wrappedHandler);\n        return {\n            unsubscribe: ()=>{\n                listeners.delete(wrappedHandler);\n            }\n        };\n    }\n    /** Starts the Actor from the initial state */ start() {\n        if (this._processingStatus === ProcessingStatus.Running) {\n            // Do not restart the service if it is already started\n            return this;\n        }\n        if (this._syncSnapshot) {\n            this.subscribe({\n                next: (snapshot)=>{\n                    if (snapshot.status === \"active\") {\n                        this.system._relay(this, this._parent, {\n                            type: `xstate.snapshot.${this.id}`,\n                            snapshot\n                        });\n                    }\n                },\n                error: ()=>{}\n            });\n        }\n        this.system._register(this.sessionId, this);\n        if (this._systemId) {\n            this.system._set(this._systemId, this);\n        }\n        this._processingStatus = ProcessingStatus.Running;\n        // TODO: this isn't correct when rehydrating\n        const initEvent = createInitEvent(this.options.input);\n        this.system._sendInspectionEvent({\n            type: \"@xstate.event\",\n            sourceRef: this._parent,\n            actorRef: this,\n            event: initEvent\n        });\n        const status = this._snapshot.status;\n        switch(status){\n            case \"done\":\n                // a state machine can be \"done\" upon initialization (it could reach a final state using initial microsteps)\n                // we still need to complete observers, flush deferreds etc\n                this.update(this._snapshot, initEvent);\n                // TODO: rethink cleanup of observers, mailbox, etc\n                return this;\n            case \"error\":\n                this._error(this._snapshot.error);\n                return this;\n        }\n        if (!this._parent) {\n            this.system.start();\n        }\n        if (this.logic.start) {\n            try {\n                this.logic.start(this._snapshot, this._actorScope);\n            } catch (err) {\n                this._snapshot = {\n                    ...this._snapshot,\n                    status: \"error\",\n                    error: err\n                };\n                this._error(err);\n                return this;\n            }\n        }\n        // TODO: this notifies all subscribers but usually this is redundant\n        // there is no real change happening here\n        // we need to rethink if this needs to be refactored\n        this.update(this._snapshot, initEvent);\n        if (this.options.devTools) {\n            this.attachDevTools();\n        }\n        this.mailbox.start();\n        return this;\n    }\n    _process(event) {\n        let nextState;\n        let caughtError;\n        try {\n            nextState = this.logic.transition(this._snapshot, event, this._actorScope);\n        } catch (err) {\n            // we wrap it in a box so we can rethrow it later even if falsy value gets caught here\n            caughtError = {\n                err\n            };\n        }\n        if (caughtError) {\n            const { err } = caughtError;\n            this._snapshot = {\n                ...this._snapshot,\n                status: \"error\",\n                error: err\n            };\n            this._error(err);\n            return;\n        }\n        this.update(nextState, event);\n        if (event.type === XSTATE_STOP) {\n            this._stopProcedure();\n            this._complete();\n        }\n    }\n    _stop() {\n        if (this._processingStatus === ProcessingStatus.Stopped) {\n            return this;\n        }\n        this.mailbox.clear();\n        if (this._processingStatus === ProcessingStatus.NotStarted) {\n            this._processingStatus = ProcessingStatus.Stopped;\n            return this;\n        }\n        this.mailbox.enqueue({\n            type: XSTATE_STOP\n        });\n        return this;\n    }\n    /** Stops the Actor and unsubscribe all listeners. */ stop() {\n        if (this._parent) {\n            throw new Error(\"A non-root actor cannot be stopped directly.\");\n        }\n        return this._stop();\n    }\n    _complete() {\n        for (const observer of this.observers){\n            try {\n                observer.complete?.();\n            } catch (err) {\n                reportUnhandledError(err);\n            }\n        }\n        this.observers.clear();\n    }\n    _reportError(err) {\n        if (!this.observers.size) {\n            if (!this._parent) {\n                reportUnhandledError(err);\n            }\n            return;\n        }\n        let reportError = false;\n        for (const observer of this.observers){\n            const errorListener = observer.error;\n            reportError ||= !errorListener;\n            try {\n                errorListener?.(err);\n            } catch (err2) {\n                reportUnhandledError(err2);\n            }\n        }\n        this.observers.clear();\n        if (reportError) {\n            reportUnhandledError(err);\n        }\n    }\n    _error(err) {\n        this._stopProcedure();\n        this._reportError(err);\n        if (this._parent) {\n            this.system._relay(this, this._parent, createErrorActorEvent(this.id, err));\n        }\n    }\n    // TODO: atm children don't belong entirely to the actor so\n    // in a way - it's not even super aware of them\n    // so we can't stop them from here but we really should!\n    // right now, they are being stopped within the machine's transition\n    // but that could throw and leave us with \"orphaned\" active actors\n    _stopProcedure() {\n        if (this._processingStatus !== ProcessingStatus.Running) {\n            // Actor already stopped; do nothing\n            return this;\n        }\n        // Cancel all delayed events\n        this.system.scheduler.cancelAll(this);\n        // TODO: mailbox.reset\n        this.mailbox.clear();\n        // TODO: after `stop` we must prepare ourselves for receiving events again\n        // events sent *after* stop signal must be queued\n        // it seems like this should be the common behavior for all of our consumers\n        // so perhaps this should be unified somehow for all of them\n        this.mailbox = new Mailbox(this._process.bind(this));\n        this._processingStatus = ProcessingStatus.Stopped;\n        this.system._unregister(this);\n        return this;\n    }\n    /** @internal */ _send(event) {\n        if (this._processingStatus === ProcessingStatus.Stopped) {\n            // do nothing\n            {\n                const eventString = JSON.stringify(event);\n                console.warn(`Event \"${event.type}\" was sent to stopped actor \"${this.id} (${this.sessionId})\". This actor has already reached its final state, and will not transition.\\nEvent: ${eventString}`);\n            }\n            return;\n        }\n        this.mailbox.enqueue(event);\n    }\n    /**\n   * Sends an event to the running Actor to trigger a transition.\n   *\n   * @param event The event to send\n   */ send(event) {\n        if (typeof event === \"string\") {\n            throw new Error(`Only event objects may be sent to actors; use .send({ type: \"${event}\" }) instead`);\n        }\n        this.system._relay(undefined, this, event);\n    }\n    attachDevTools() {\n        const { devTools } = this.options;\n        if (devTools) {\n            const resolvedDevToolsAdapter = typeof devTools === \"function\" ? devTools : _dev_dist_xstate_dev_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.devToolsAdapter;\n            resolvedDevToolsAdapter(this);\n        }\n    }\n    toJSON() {\n        return {\n            xstate$$type: $$ACTOR_TYPE,\n            id: this.id\n        };\n    }\n    /**\n   * Obtain the internal state of the actor, which can be persisted.\n   *\n   * @remarks\n   * The internal state can be persisted from any actor, not only machines.\n   *\n   * Note that the persisted state is not the same as the snapshot from\n   * {@link Actor.getSnapshot}. Persisted state represents the internal state of\n   * the actor, while snapshots represent the actor's last emitted value.\n   *\n   * Can be restored with {@link ActorOptions.state}\n   * @see https://stately.ai/docs/persistence\n   */ getPersistedSnapshot(options) {\n        return this.logic.getPersistedSnapshot(this._snapshot, options);\n    }\n    [symbolObservable]() {\n        return this;\n    }\n    /**\n   * Read an actor’s snapshot synchronously.\n   *\n   * @remarks\n   * The snapshot represent an actor's last emitted value.\n   *\n   * When an actor receives an event, its internal state may change. An actor\n   * may emit a snapshot when a state transition occurs.\n   *\n   * Note that some actors, such as callback actors generated with\n   * `fromCallback`, will not emit snapshots.\n   * @see {@link Actor.subscribe} to subscribe to an actor’s snapshot values.\n   * @see {@link Actor.getPersistedSnapshot} to persist the internal state of an actor (which is more than just a snapshot).\n   */ getSnapshot() {\n        if (!this._snapshot) {\n            throw new Error(`Snapshot can't be read while the actor initializes itself`);\n        }\n        return this._snapshot;\n    }\n}\n/**\n * Creates a new actor instance for the given actor logic with the provided\n * options, if any.\n *\n * @remarks\n * When you create an actor from actor logic via `createActor(logic)`, you\n * implicitly create an actor system where the created actor is the root actor.\n * Any actors spawned from this root actor and its descendants are part of that\n * actor system.\n * @example\n *\n * ```ts\n * import { createActor } from 'xstate';\n * import { someActorLogic } from './someActorLogic.ts';\n *\n * // Creating the actor, which implicitly creates an actor system with itself as the root actor\n * const actor = createActor(someActorLogic);\n *\n * actor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n *\n * // Actors must be started by calling `actor.start()`, which will also start the actor system.\n * actor.start();\n *\n * // Actors can receive events\n * actor.send({ type: 'someEvent' });\n *\n * // You can stop root actors by calling `actor.stop()`, which will also stop the actor system and all actors in that system.\n * actor.stop();\n * ```\n *\n * @param logic - The actor logic to create an actor from. For a state machine\n *   actor logic creator, see {@link createMachine}. Other actor logic creators\n *   include {@link fromCallback}, {@link fromEventObservable},\n *   {@link fromObservable}, {@link fromPromise}, and {@link fromTransition}.\n * @param options - Actor options\n */ function createActor(logic, ...[options]) {\n    return new Actor(logic, options);\n}\n/**\n * Creates a new Interpreter instance for the given machine with the provided\n * options, if any.\n *\n * @deprecated Use `createActor` instead\n * @alias\n */ const interpret = createActor;\n/**\n * @deprecated Use `Actor` instead.\n * @alias\n */ function resolveCancel(_, snapshot, actionArgs, actionParams, { sendId }) {\n    const resolvedSendId = typeof sendId === \"function\" ? sendId(actionArgs, actionParams) : sendId;\n    return [\n        snapshot,\n        {\n            sendId: resolvedSendId\n        },\n        undefined\n    ];\n}\nfunction executeCancel(actorScope, params) {\n    actorScope.defer(()=>{\n        actorScope.system.scheduler.cancel(actorScope.self, params.sendId);\n    });\n}\n/**\n * Cancels a delayed `sendTo(...)` action that is waiting to be executed. The\n * canceled `sendTo(...)` action will not send its event or execute, unless the\n * `delay` has already elapsed before `cancel(...)` is called.\n *\n * @example\n *\n * ```ts\n * import { createMachine, sendTo, cancel } from 'xstate';\n *\n * const machine = createMachine({\n *   // ...\n *   on: {\n *     sendEvent: {\n *       actions: sendTo(\n *         'some-actor',\n *         { type: 'someEvent' },\n *         {\n *           id: 'some-id',\n *           delay: 1000\n *         }\n *       )\n *     },\n *     cancelEvent: {\n *       actions: cancel('some-id')\n *     }\n *   }\n * });\n * ```\n *\n * @param sendId The `id` of the `sendTo(...)` action to cancel.\n */ function cancel(sendId) {\n    function cancel(_args, _params) {\n        {\n            throw new Error(`This isn't supposed to be called`);\n        }\n    }\n    cancel.type = \"xstate.cancel\";\n    cancel.sendId = sendId;\n    cancel.resolve = resolveCancel;\n    cancel.execute = executeCancel;\n    return cancel;\n}\nfunction resolveSpawn(actorScope, snapshot, actionArgs, _actionParams, { id, systemId, src, input, syncSnapshot }) {\n    const logic = typeof src === \"string\" ? resolveReferencedActor(snapshot.machine, src) : src;\n    const resolvedId = typeof id === \"function\" ? id(actionArgs) : id;\n    let actorRef;\n    let resolvedInput = undefined;\n    if (logic) {\n        resolvedInput = typeof input === \"function\" ? input({\n            context: snapshot.context,\n            event: actionArgs.event,\n            self: actorScope.self\n        }) : input;\n        actorRef = createActor(logic, {\n            id: resolvedId,\n            src,\n            parent: actorScope.self,\n            syncSnapshot,\n            systemId,\n            input: resolvedInput\n        });\n    }\n    if (!actorRef) {\n        console.warn(// eslint-disable-next-line @typescript-eslint/restrict-template-expressions,@typescript-eslint/no-base-to-string\n        `Actor type '${src}' not found in machine '${actorScope.id}'.`);\n    }\n    return [\n        cloneMachineSnapshot(snapshot, {\n            children: {\n                ...snapshot.children,\n                [resolvedId]: actorRef\n            }\n        }),\n        {\n            id,\n            systemId,\n            actorRef,\n            src,\n            input: resolvedInput\n        },\n        undefined\n    ];\n}\nfunction executeSpawn(actorScope, { actorRef }) {\n    if (!actorRef) {\n        return;\n    }\n    actorScope.defer(()=>{\n        if (actorRef._processingStatus === ProcessingStatus.Stopped) {\n            return;\n        }\n        actorRef.start();\n    });\n}\nfunction spawnChild(...[src, { id, systemId, input, syncSnapshot = false } = {}]) {\n    function spawnChild1(_args, _params) {\n        {\n            throw new Error(`This isn't supposed to be called`);\n        }\n    }\n    spawnChild1.type = \"xstate.spawnChild\";\n    spawnChild1.id = id;\n    spawnChild1.systemId = systemId;\n    spawnChild1.src = src;\n    spawnChild1.input = input;\n    spawnChild1.syncSnapshot = syncSnapshot;\n    spawnChild1.resolve = resolveSpawn;\n    spawnChild1.execute = executeSpawn;\n    return spawnChild1;\n}\nfunction resolveStop(_, snapshot, args, actionParams, { actorRef }) {\n    const actorRefOrString = typeof actorRef === \"function\" ? actorRef(args, actionParams) : actorRef;\n    const resolvedActorRef = typeof actorRefOrString === \"string\" ? snapshot.children[actorRefOrString] : actorRefOrString;\n    let children = snapshot.children;\n    if (resolvedActorRef) {\n        children = {\n            ...children\n        };\n        delete children[resolvedActorRef.id];\n    }\n    return [\n        cloneMachineSnapshot(snapshot, {\n            children\n        }),\n        resolvedActorRef,\n        undefined\n    ];\n}\nfunction executeStop(actorScope, actorRef) {\n    if (!actorRef) {\n        return;\n    }\n    // we need to eagerly unregister it here so a new actor with the same systemId can be registered immediately\n    // since we defer actual stopping of the actor but we don't defer actor creations (and we can't do that)\n    // this could throw on `systemId` collision, for example, when dealing with reentering transitions\n    actorScope.system._unregister(actorRef);\n    // this allows us to prevent an actor from being started if it gets stopped within the same macrostep\n    // this can happen, for example, when the invoking state is being exited immediately by an always transition\n    if (actorRef._processingStatus !== ProcessingStatus.Running) {\n        actorScope.stopChild(actorRef);\n        return;\n    }\n    // stopping a child enqueues a stop event in the child actor's mailbox\n    // we need for all of the already enqueued events to be processed before we stop the child\n    // the parent itself might want to send some events to a child (for example from exit actions on the invoking state)\n    // and we don't want to ignore those events\n    actorScope.defer(()=>{\n        actorScope.stopChild(actorRef);\n    });\n}\n/**\n * Stops a child actor.\n *\n * @param actorRef The actor to stop.\n */ function stopChild(actorRef) {\n    function stop(_args, _params) {\n        {\n            throw new Error(`This isn't supposed to be called`);\n        }\n    }\n    stop.type = \"xstate.stopChild\";\n    stop.actorRef = actorRef;\n    stop.resolve = resolveStop;\n    stop.execute = executeStop;\n    return stop;\n}\n/**\n * Stops a child actor.\n *\n * @deprecated Use `stopChild(...)` instead\n * @alias\n */ const stop = stopChild;\nfunction checkStateIn(snapshot, _, { stateValue }) {\n    if (typeof stateValue === \"string\" && isStateId(stateValue)) {\n        const target = snapshot.machine.getStateNodeById(stateValue);\n        return snapshot._nodes.some((sn)=>sn === target);\n    }\n    return snapshot.matches(stateValue);\n}\nfunction stateIn(stateValue) {\n    function stateIn() {\n        {\n            throw new Error(`This isn't supposed to be called`);\n        }\n    }\n    stateIn.check = checkStateIn;\n    stateIn.stateValue = stateValue;\n    return stateIn;\n}\nfunction checkNot(snapshot, { context, event }, { guards }) {\n    return !evaluateGuard(guards[0], context, event, snapshot);\n}\n/**\n * Higher-order guard that evaluates to `true` if the `guard` passed to it\n * evaluates to `false`.\n *\n * @category Guards\n * @example\n *\n * ```ts\n * import { setup, not } from 'xstate';\n *\n * const machine = setup({\n *   guards: {\n *     someNamedGuard: () => false\n *   }\n * }).createMachine({\n *   on: {\n *     someEvent: {\n *       guard: not('someNamedGuard'),\n *       actions: () => {\n *         // will be executed if guard in `not(...)`\n *         // evaluates to `false`\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @returns A guard\n */ function not(guard) {\n    function not(_args, _params) {\n        {\n            throw new Error(`This isn't supposed to be called`);\n        }\n    }\n    not.check = checkNot;\n    not.guards = [\n        guard\n    ];\n    return not;\n}\nfunction checkAnd(snapshot, { context, event }, { guards }) {\n    return guards.every((guard)=>evaluateGuard(guard, context, event, snapshot));\n}\n/**\n * Higher-order guard that evaluates to `true` if all `guards` passed to it\n * evaluate to `true`.\n *\n * @category Guards\n * @example\n *\n * ```ts\n * import { setup, and } from 'xstate';\n *\n * const machine = setup({\n *   guards: {\n *     someNamedGuard: () => true\n *   }\n * }).createMachine({\n *   on: {\n *     someEvent: {\n *       guard: and([({ context }) => context.value > 0, 'someNamedGuard']),\n *       actions: () => {\n *         // will be executed if all guards in `and(...)`\n *         // evaluate to true\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @returns A guard action object\n */ function and(guards) {\n    function and(_args, _params) {\n        {\n            throw new Error(`This isn't supposed to be called`);\n        }\n    }\n    and.check = checkAnd;\n    and.guards = guards;\n    return and;\n}\nfunction checkOr(snapshot, { context, event }, { guards }) {\n    return guards.some((guard)=>evaluateGuard(guard, context, event, snapshot));\n}\n/**\n * Higher-order guard that evaluates to `true` if any of the `guards` passed to\n * it evaluate to `true`.\n *\n * @category Guards\n * @example\n *\n * ```ts\n * import { setup, or } from 'xstate';\n *\n * const machine = setup({\n *   guards: {\n *     someNamedGuard: () => true\n *   }\n * }).createMachine({\n *   on: {\n *     someEvent: {\n *       guard: or([({ context }) => context.value > 0, 'someNamedGuard']),\n *       actions: () => {\n *         // will be executed if any of the guards in `or(...)`\n *         // evaluate to true\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @returns A guard action object\n */ function or(guards) {\n    function or(_args, _params) {\n        {\n            throw new Error(`This isn't supposed to be called`);\n        }\n    }\n    or.check = checkOr;\n    or.guards = guards;\n    return or;\n}\n// TODO: throw on cycles (depth check should be enough)\nfunction evaluateGuard(guard, context, event, snapshot) {\n    const { machine } = snapshot;\n    const isInline = typeof guard === \"function\";\n    const resolved = isInline ? guard : machine.implementations.guards[typeof guard === \"string\" ? guard : guard.type];\n    if (!isInline && !resolved) {\n        throw new Error(`Guard '${typeof guard === \"string\" ? guard : guard.type}' is not implemented.'.`);\n    }\n    if (typeof resolved !== \"function\") {\n        return evaluateGuard(resolved, context, event, snapshot);\n    }\n    const guardArgs = {\n        context,\n        event\n    };\n    const guardParams = isInline || typeof guard === \"string\" ? undefined : \"params\" in guard ? typeof guard.params === \"function\" ? guard.params({\n        context,\n        event\n    }) : guard.params : undefined;\n    if (!(\"check\" in resolved)) {\n        // the existing type of `.guards` assumes non-nullable `TExpressionGuard`\n        // inline guards expect `TExpressionGuard` to be set to `undefined`\n        // it's fine to cast this here, our logic makes sure that we call those 2 \"variants\" correctly\n        return resolved(guardArgs, guardParams);\n    }\n    const builtinGuard = resolved;\n    return builtinGuard.check(snapshot, guardArgs, resolved // this holds all params\n    );\n}\nconst isAtomicStateNode = (stateNode)=>stateNode.type === \"atomic\" || stateNode.type === \"final\";\nfunction getChildren(stateNode) {\n    return Object.values(stateNode.states).filter((sn)=>sn.type !== \"history\");\n}\nfunction getProperAncestors(stateNode, toStateNode) {\n    const ancestors = [];\n    if (toStateNode === stateNode) {\n        return ancestors;\n    }\n    // add all ancestors\n    let m = stateNode.parent;\n    while(m && m !== toStateNode){\n        ancestors.push(m);\n        m = m.parent;\n    }\n    return ancestors;\n}\nfunction getAllStateNodes(stateNodes) {\n    const nodeSet = new Set(stateNodes);\n    const adjList = getAdjList(nodeSet);\n    // add descendants\n    for (const s of nodeSet){\n        // if previously active, add existing child nodes\n        if (s.type === \"compound\" && (!adjList.get(s) || !adjList.get(s).length)) {\n            getInitialStateNodesWithTheirAncestors(s).forEach((sn)=>nodeSet.add(sn));\n        } else {\n            if (s.type === \"parallel\") {\n                for (const child of getChildren(s)){\n                    if (child.type === \"history\") {\n                        continue;\n                    }\n                    if (!nodeSet.has(child)) {\n                        const initialStates = getInitialStateNodesWithTheirAncestors(child);\n                        for (const initialStateNode of initialStates){\n                            nodeSet.add(initialStateNode);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    // add all ancestors\n    for (const s of nodeSet){\n        let m = s.parent;\n        while(m){\n            nodeSet.add(m);\n            m = m.parent;\n        }\n    }\n    return nodeSet;\n}\nfunction getValueFromAdj(baseNode, adjList) {\n    const childStateNodes = adjList.get(baseNode);\n    if (!childStateNodes) {\n        return {}; // todo: fix?\n    }\n    if (baseNode.type === \"compound\") {\n        const childStateNode = childStateNodes[0];\n        if (childStateNode) {\n            if (isAtomicStateNode(childStateNode)) {\n                return childStateNode.key;\n            }\n        } else {\n            return {};\n        }\n    }\n    const stateValue = {};\n    for (const childStateNode of childStateNodes){\n        stateValue[childStateNode.key] = getValueFromAdj(childStateNode, adjList);\n    }\n    return stateValue;\n}\nfunction getAdjList(stateNodes) {\n    const adjList = new Map();\n    for (const s of stateNodes){\n        if (!adjList.has(s)) {\n            adjList.set(s, []);\n        }\n        if (s.parent) {\n            if (!adjList.has(s.parent)) {\n                adjList.set(s.parent, []);\n            }\n            adjList.get(s.parent).push(s);\n        }\n    }\n    return adjList;\n}\nfunction getStateValue(rootNode, stateNodes) {\n    const config = getAllStateNodes(stateNodes);\n    return getValueFromAdj(rootNode, getAdjList(config));\n}\nfunction isInFinalState(stateNodeSet, stateNode) {\n    if (stateNode.type === \"compound\") {\n        return getChildren(stateNode).some((s)=>s.type === \"final\" && stateNodeSet.has(s));\n    }\n    if (stateNode.type === \"parallel\") {\n        return getChildren(stateNode).every((sn)=>isInFinalState(stateNodeSet, sn));\n    }\n    return stateNode.type === \"final\";\n}\nconst isStateId = (str)=>str[0] === STATE_IDENTIFIER;\nfunction getCandidates(stateNode, receivedEventType) {\n    const candidates = stateNode.transitions.get(receivedEventType) || [\n        ...stateNode.transitions.keys()\n    ].filter((eventDescriptor)=>{\n        // check if transition is a wildcard transition,\n        // which matches any non-transient events\n        if (eventDescriptor === WILDCARD) {\n            return true;\n        }\n        if (!eventDescriptor.endsWith(\".*\")) {\n            return false;\n        }\n        if (/.*\\*.+/.test(eventDescriptor)) {\n            console.warn(`Wildcards can only be the last token of an event descriptor (e.g., \"event.*\") or the entire event descriptor (\"*\"). Check the \"${eventDescriptor}\" event.`);\n        }\n        const partialEventTokens = eventDescriptor.split(\".\");\n        const eventTokens = receivedEventType.split(\".\");\n        for(let tokenIndex = 0; tokenIndex < partialEventTokens.length; tokenIndex++){\n            const partialEventToken = partialEventTokens[tokenIndex];\n            const eventToken = eventTokens[tokenIndex];\n            if (partialEventToken === \"*\") {\n                const isLastToken = tokenIndex === partialEventTokens.length - 1;\n                if (!isLastToken) {\n                    console.warn(`Infix wildcards in transition events are not allowed. Check the \"${eventDescriptor}\" transition.`);\n                }\n                return isLastToken;\n            }\n            if (partialEventToken !== eventToken) {\n                return false;\n            }\n        }\n        return true;\n    }).sort((a, b)=>b.length - a.length).flatMap((key)=>stateNode.transitions.get(key));\n    return candidates;\n}\n/** All delayed transitions from the config. */ function getDelayedTransitions(stateNode) {\n    const afterConfig = stateNode.config.after;\n    if (!afterConfig) {\n        return [];\n    }\n    const mutateEntryExit = (delay)=>{\n        const afterEvent = createAfterEvent(delay, stateNode.id);\n        const eventType = afterEvent.type;\n        stateNode.entry.push(raise(afterEvent, {\n            id: eventType,\n            delay\n        }));\n        stateNode.exit.push(cancel(eventType));\n        return eventType;\n    };\n    const delayedTransitions = Object.keys(afterConfig).flatMap((delay)=>{\n        const configTransition = afterConfig[delay];\n        const resolvedTransition = typeof configTransition === \"string\" ? {\n            target: configTransition\n        } : configTransition;\n        const resolvedDelay = Number.isNaN(+delay) ? delay : +delay;\n        const eventType = mutateEntryExit(resolvedDelay);\n        return toArray(resolvedTransition).map((transition)=>({\n                ...transition,\n                event: eventType,\n                delay: resolvedDelay\n            }));\n    });\n    return delayedTransitions.map((delayedTransition)=>{\n        const { delay } = delayedTransition;\n        return {\n            ...formatTransition(stateNode, delayedTransition.event, delayedTransition),\n            delay\n        };\n    });\n}\nfunction formatTransition(stateNode, descriptor, transitionConfig) {\n    const normalizedTarget = normalizeTarget(transitionConfig.target);\n    const reenter = transitionConfig.reenter ?? false;\n    const target = resolveTarget(stateNode, normalizedTarget);\n    // TODO: should this be part of a lint rule instead?\n    if (transitionConfig.cond) {\n        throw new Error(`State \"${stateNode.id}\" has declared \\`cond\\` for one of its transitions. This property has been renamed to \\`guard\\`. Please update your code.`);\n    }\n    const transition = {\n        ...transitionConfig,\n        actions: toArray(transitionConfig.actions),\n        guard: transitionConfig.guard,\n        target,\n        source: stateNode,\n        reenter,\n        eventType: descriptor,\n        toJSON: ()=>({\n                ...transition,\n                source: `#${stateNode.id}`,\n                target: target ? target.map((t)=>`#${t.id}`) : undefined\n            })\n    };\n    return transition;\n}\nfunction formatTransitions(stateNode) {\n    const transitions = new Map();\n    if (stateNode.config.on) {\n        for (const descriptor of Object.keys(stateNode.config.on)){\n            if (descriptor === NULL_EVENT) {\n                throw new Error('Null events (\"\") cannot be specified as a transition key. Use `always: { ... }` instead.');\n            }\n            const transitionsConfig = stateNode.config.on[descriptor];\n            transitions.set(descriptor, toTransitionConfigArray(transitionsConfig).map((t)=>formatTransition(stateNode, descriptor, t)));\n        }\n    }\n    if (stateNode.config.onDone) {\n        const descriptor = `xstate.done.state.${stateNode.id}`;\n        transitions.set(descriptor, toTransitionConfigArray(stateNode.config.onDone).map((t)=>formatTransition(stateNode, descriptor, t)));\n    }\n    for (const invokeDef of stateNode.invoke){\n        if (invokeDef.onDone) {\n            const descriptor = `xstate.done.actor.${invokeDef.id}`;\n            transitions.set(descriptor, toTransitionConfigArray(invokeDef.onDone).map((t)=>formatTransition(stateNode, descriptor, t)));\n        }\n        if (invokeDef.onError) {\n            const descriptor = `xstate.error.actor.${invokeDef.id}`;\n            transitions.set(descriptor, toTransitionConfigArray(invokeDef.onError).map((t)=>formatTransition(stateNode, descriptor, t)));\n        }\n        if (invokeDef.onSnapshot) {\n            const descriptor = `xstate.snapshot.${invokeDef.id}`;\n            transitions.set(descriptor, toTransitionConfigArray(invokeDef.onSnapshot).map((t)=>formatTransition(stateNode, descriptor, t)));\n        }\n    }\n    for (const delayedTransition of stateNode.after){\n        let existing = transitions.get(delayedTransition.eventType);\n        if (!existing) {\n            existing = [];\n            transitions.set(delayedTransition.eventType, existing);\n        }\n        existing.push(delayedTransition);\n    }\n    return transitions;\n}\nfunction formatInitialTransition(stateNode, _target) {\n    const resolvedTarget = typeof _target === \"string\" ? stateNode.states[_target] : _target ? stateNode.states[_target.target] : undefined;\n    if (!resolvedTarget && _target) {\n        throw new Error(// eslint-disable-next-line @typescript-eslint/restrict-template-expressions, @typescript-eslint/no-base-to-string\n        `Initial state node \"${_target}\" not found on parent state node #${stateNode.id}`);\n    }\n    const transition = {\n        source: stateNode,\n        actions: !_target || typeof _target === \"string\" ? [] : toArray(_target.actions),\n        eventType: null,\n        reenter: false,\n        target: resolvedTarget ? [\n            resolvedTarget\n        ] : [],\n        toJSON: ()=>({\n                ...transition,\n                source: `#${stateNode.id}`,\n                target: resolvedTarget ? [\n                    `#${resolvedTarget.id}`\n                ] : []\n            })\n    };\n    return transition;\n}\nfunction resolveTarget(stateNode, targets) {\n    if (targets === undefined) {\n        // an undefined target signals that the state node should not transition from that state when receiving that event\n        return undefined;\n    }\n    return targets.map((target)=>{\n        if (typeof target !== \"string\") {\n            return target;\n        }\n        if (isStateId(target)) {\n            return stateNode.machine.getStateNodeById(target);\n        }\n        const isInternalTarget = target[0] === STATE_DELIMITER;\n        // If internal target is defined on machine,\n        // do not include machine key on target\n        if (isInternalTarget && !stateNode.parent) {\n            return getStateNodeByPath(stateNode, target.slice(1));\n        }\n        const resolvedTarget = isInternalTarget ? stateNode.key + target : target;\n        if (stateNode.parent) {\n            try {\n                const targetStateNode = getStateNodeByPath(stateNode.parent, resolvedTarget);\n                return targetStateNode;\n            } catch (err) {\n                throw new Error(`Invalid transition definition for state node '${stateNode.id}':\\n${err.message}`);\n            }\n        } else {\n            throw new Error(`Invalid target: \"${target}\" is not a valid target from the root node. Did you mean \".${target}\"?`);\n        }\n    });\n}\nfunction resolveHistoryDefaultTransition(stateNode) {\n    const normalizedTarget = normalizeTarget(stateNode.config.target);\n    if (!normalizedTarget) {\n        return stateNode.parent.initial;\n    }\n    return {\n        target: normalizedTarget.map((t)=>typeof t === \"string\" ? getStateNodeByPath(stateNode.parent, t) : t)\n    };\n}\nfunction isHistoryNode(stateNode) {\n    return stateNode.type === \"history\";\n}\nfunction getInitialStateNodesWithTheirAncestors(stateNode) {\n    const states = getInitialStateNodes(stateNode);\n    for (const initialState of states){\n        for (const ancestor of getProperAncestors(initialState, stateNode)){\n            states.add(ancestor);\n        }\n    }\n    return states;\n}\nfunction getInitialStateNodes(stateNode) {\n    const set = new Set();\n    function iter(descStateNode) {\n        if (set.has(descStateNode)) {\n            return;\n        }\n        set.add(descStateNode);\n        if (descStateNode.type === \"compound\") {\n            iter(descStateNode.initial.target[0]);\n        } else if (descStateNode.type === \"parallel\") {\n            for (const child of getChildren(descStateNode)){\n                iter(child);\n            }\n        }\n    }\n    iter(stateNode);\n    return set;\n}\n/** Returns the child state node from its relative `stateKey`, or throws. */ function getStateNode(stateNode, stateKey) {\n    if (isStateId(stateKey)) {\n        return stateNode.machine.getStateNodeById(stateKey);\n    }\n    if (!stateNode.states) {\n        throw new Error(`Unable to retrieve child state '${stateKey}' from '${stateNode.id}'; no child states exist.`);\n    }\n    const result = stateNode.states[stateKey];\n    if (!result) {\n        throw new Error(`Child state '${stateKey}' does not exist on '${stateNode.id}'`);\n    }\n    return result;\n}\n/**\n * Returns the relative state node from the given `statePath`, or throws.\n *\n * @param statePath The string or string array relative path to the state node.\n */ function getStateNodeByPath(stateNode, statePath) {\n    if (typeof statePath === \"string\" && isStateId(statePath)) {\n        try {\n            return stateNode.machine.getStateNodeById(statePath);\n        } catch  {\n        // try individual paths\n        // throw e;\n        }\n    }\n    const arrayStatePath = toStatePath(statePath).slice();\n    let currentStateNode = stateNode;\n    while(arrayStatePath.length){\n        const key = arrayStatePath.shift();\n        if (!key.length) {\n            break;\n        }\n        currentStateNode = getStateNode(currentStateNode, key);\n    }\n    return currentStateNode;\n}\n/**\n * Returns the state nodes represented by the current state value.\n *\n * @param stateValue The state value or State instance\n */ function getStateNodes(stateNode, stateValue) {\n    if (typeof stateValue === \"string\") {\n        const childStateNode = stateNode.states[stateValue];\n        if (!childStateNode) {\n            throw new Error(`State '${stateValue}' does not exist on '${stateNode.id}'`);\n        }\n        return [\n            stateNode,\n            childStateNode\n        ];\n    }\n    const childStateKeys = Object.keys(stateValue);\n    const childStateNodes = childStateKeys.map((subStateKey)=>getStateNode(stateNode, subStateKey)).filter(Boolean);\n    return [\n        stateNode.machine.root,\n        stateNode\n    ].concat(childStateNodes, childStateKeys.reduce((allSubStateNodes, subStateKey)=>{\n        const subStateNode = getStateNode(stateNode, subStateKey);\n        if (!subStateNode) {\n            return allSubStateNodes;\n        }\n        const subStateNodes = getStateNodes(subStateNode, stateValue[subStateKey]);\n        return allSubStateNodes.concat(subStateNodes);\n    }, []));\n}\nfunction transitionAtomicNode(stateNode, stateValue, snapshot, event) {\n    const childStateNode = getStateNode(stateNode, stateValue);\n    const next = childStateNode.next(snapshot, event);\n    if (!next || !next.length) {\n        return stateNode.next(snapshot, event);\n    }\n    return next;\n}\nfunction transitionCompoundNode(stateNode, stateValue, snapshot, event) {\n    const subStateKeys = Object.keys(stateValue);\n    const childStateNode = getStateNode(stateNode, subStateKeys[0]);\n    const next = transitionNode(childStateNode, stateValue[subStateKeys[0]], snapshot, event);\n    if (!next || !next.length) {\n        return stateNode.next(snapshot, event);\n    }\n    return next;\n}\nfunction transitionParallelNode(stateNode, stateValue, snapshot, event) {\n    const allInnerTransitions = [];\n    for (const subStateKey of Object.keys(stateValue)){\n        const subStateValue = stateValue[subStateKey];\n        if (!subStateValue) {\n            continue;\n        }\n        const subStateNode = getStateNode(stateNode, subStateKey);\n        const innerTransitions = transitionNode(subStateNode, subStateValue, snapshot, event);\n        if (innerTransitions) {\n            allInnerTransitions.push(...innerTransitions);\n        }\n    }\n    if (!allInnerTransitions.length) {\n        return stateNode.next(snapshot, event);\n    }\n    return allInnerTransitions;\n}\nfunction transitionNode(stateNode, stateValue, snapshot, event) {\n    // leaf node\n    if (typeof stateValue === \"string\") {\n        return transitionAtomicNode(stateNode, stateValue, snapshot, event);\n    }\n    // compound node\n    if (Object.keys(stateValue).length === 1) {\n        return transitionCompoundNode(stateNode, stateValue, snapshot, event);\n    }\n    // parallel node\n    return transitionParallelNode(stateNode, stateValue, snapshot, event);\n}\nfunction getHistoryNodes(stateNode) {\n    return Object.keys(stateNode.states).map((key)=>stateNode.states[key]).filter((sn)=>sn.type === \"history\");\n}\nfunction isDescendant(childStateNode, parentStateNode) {\n    let marker = childStateNode;\n    while(marker.parent && marker.parent !== parentStateNode){\n        marker = marker.parent;\n    }\n    return marker.parent === parentStateNode;\n}\nfunction hasIntersection(s1, s2) {\n    const set1 = new Set(s1);\n    const set2 = new Set(s2);\n    for (const item of set1){\n        if (set2.has(item)) {\n            return true;\n        }\n    }\n    for (const item of set2){\n        if (set1.has(item)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction removeConflictingTransitions(enabledTransitions, stateNodeSet, historyValue) {\n    const filteredTransitions = new Set();\n    for (const t1 of enabledTransitions){\n        let t1Preempted = false;\n        const transitionsToRemove = new Set();\n        for (const t2 of filteredTransitions){\n            if (hasIntersection(computeExitSet([\n                t1\n            ], stateNodeSet, historyValue), computeExitSet([\n                t2\n            ], stateNodeSet, historyValue))) {\n                if (isDescendant(t1.source, t2.source)) {\n                    transitionsToRemove.add(t2);\n                } else {\n                    t1Preempted = true;\n                    break;\n                }\n            }\n        }\n        if (!t1Preempted) {\n            for (const t3 of transitionsToRemove){\n                filteredTransitions.delete(t3);\n            }\n            filteredTransitions.add(t1);\n        }\n    }\n    return Array.from(filteredTransitions);\n}\nfunction findLeastCommonAncestor(stateNodes) {\n    const [head, ...tail] = stateNodes;\n    for (const ancestor of getProperAncestors(head, undefined)){\n        if (tail.every((sn)=>isDescendant(sn, ancestor))) {\n            return ancestor;\n        }\n    }\n}\nfunction getEffectiveTargetStates(transition, historyValue) {\n    if (!transition.target) {\n        return [];\n    }\n    const targets = new Set();\n    for (const targetNode of transition.target){\n        if (isHistoryNode(targetNode)) {\n            if (historyValue[targetNode.id]) {\n                for (const node of historyValue[targetNode.id]){\n                    targets.add(node);\n                }\n            } else {\n                for (const node of getEffectiveTargetStates(resolveHistoryDefaultTransition(targetNode), historyValue)){\n                    targets.add(node);\n                }\n            }\n        } else {\n            targets.add(targetNode);\n        }\n    }\n    return [\n        ...targets\n    ];\n}\nfunction getTransitionDomain(transition, historyValue) {\n    const targetStates = getEffectiveTargetStates(transition, historyValue);\n    if (!targetStates) {\n        return;\n    }\n    if (!transition.reenter && targetStates.every((target)=>target === transition.source || isDescendant(target, transition.source))) {\n        return transition.source;\n    }\n    const lca = findLeastCommonAncestor(targetStates.concat(transition.source));\n    if (lca) {\n        return lca;\n    }\n    // at this point we know that it's a root transition since LCA couldn't be found\n    if (transition.reenter) {\n        return;\n    }\n    return transition.source.machine.root;\n}\nfunction computeExitSet(transitions, stateNodeSet, historyValue) {\n    const statesToExit = new Set();\n    for (const t of transitions){\n        if (t.target?.length) {\n            const domain = getTransitionDomain(t, historyValue);\n            if (t.reenter && t.source === domain) {\n                statesToExit.add(domain);\n            }\n            for (const stateNode of stateNodeSet){\n                if (isDescendant(stateNode, domain)) {\n                    statesToExit.add(stateNode);\n                }\n            }\n        }\n    }\n    return [\n        ...statesToExit\n    ];\n}\nfunction areStateNodeCollectionsEqual(prevStateNodes, nextStateNodeSet) {\n    if (prevStateNodes.length !== nextStateNodeSet.size) {\n        return false;\n    }\n    for (const node of prevStateNodes){\n        if (!nextStateNodeSet.has(node)) {\n            return false;\n        }\n    }\n    return true;\n}\n/** https://www.w3.org/TR/scxml/#microstepProcedure */ function microstep(transitions, currentSnapshot, actorScope, event, isInitial, internalQueue) {\n    if (!transitions.length) {\n        return currentSnapshot;\n    }\n    const mutStateNodeSet = new Set(currentSnapshot._nodes);\n    let historyValue = currentSnapshot.historyValue;\n    const filteredTransitions = removeConflictingTransitions(transitions, mutStateNodeSet, historyValue);\n    let nextState = currentSnapshot;\n    // Exit states\n    if (!isInitial) {\n        [nextState, historyValue] = exitStates(nextState, event, actorScope, filteredTransitions, mutStateNodeSet, historyValue, internalQueue, actorScope.actionExecutor);\n    }\n    // Execute transition content\n    nextState = resolveActionsAndContext(nextState, event, actorScope, filteredTransitions.flatMap((t)=>t.actions), internalQueue, undefined);\n    // Enter states\n    nextState = enterStates(nextState, event, actorScope, filteredTransitions, mutStateNodeSet, internalQueue, historyValue, isInitial);\n    const nextStateNodes = [\n        ...mutStateNodeSet\n    ];\n    if (nextState.status === \"done\") {\n        nextState = resolveActionsAndContext(nextState, event, actorScope, nextStateNodes.sort((a, b)=>b.order - a.order).flatMap((state)=>state.exit), internalQueue, undefined);\n    }\n    // eslint-disable-next-line no-useless-catch\n    try {\n        if (historyValue === currentSnapshot.historyValue && areStateNodeCollectionsEqual(currentSnapshot._nodes, mutStateNodeSet)) {\n            return nextState;\n        }\n        return cloneMachineSnapshot(nextState, {\n            _nodes: nextStateNodes,\n            historyValue\n        });\n    } catch (e) {\n        // TODO: Refactor this once proper error handling is implemented.\n        // See https://github.com/statelyai/rfcs/pull/4\n        throw e;\n    }\n}\nfunction getMachineOutput(snapshot, event, actorScope, rootNode, rootCompletionNode) {\n    if (rootNode.output === undefined) {\n        return;\n    }\n    const doneStateEvent = createDoneStateEvent(rootCompletionNode.id, rootCompletionNode.output !== undefined && rootCompletionNode.parent ? resolveOutput(rootCompletionNode.output, snapshot.context, event, actorScope.self) : undefined);\n    return resolveOutput(rootNode.output, snapshot.context, doneStateEvent, actorScope.self);\n}\nfunction enterStates(currentSnapshot, event, actorScope, filteredTransitions, mutStateNodeSet, internalQueue, historyValue, isInitial) {\n    let nextSnapshot = currentSnapshot;\n    const statesToEnter = new Set();\n    // those are states that were directly targeted or indirectly targeted by the explicit target\n    // in other words, those are states for which initial actions should be executed\n    // when we target `#deep_child` initial actions of its ancestors shouldn't be executed\n    const statesForDefaultEntry = new Set();\n    computeEntrySet(filteredTransitions, historyValue, statesForDefaultEntry, statesToEnter);\n    // In the initial state, the root state node is \"entered\".\n    if (isInitial) {\n        statesForDefaultEntry.add(currentSnapshot.machine.root);\n    }\n    const completedNodes = new Set();\n    for (const stateNodeToEnter of [\n        ...statesToEnter\n    ].sort((a, b)=>a.order - b.order)){\n        mutStateNodeSet.add(stateNodeToEnter);\n        const actions = [];\n        // Add entry actions\n        actions.push(...stateNodeToEnter.entry);\n        for (const invokeDef of stateNodeToEnter.invoke){\n            actions.push(spawnChild(invokeDef.src, {\n                ...invokeDef,\n                syncSnapshot: !!invokeDef.onSnapshot\n            }));\n        }\n        if (statesForDefaultEntry.has(stateNodeToEnter)) {\n            const initialActions = stateNodeToEnter.initial.actions;\n            actions.push(...initialActions);\n        }\n        nextSnapshot = resolveActionsAndContext(nextSnapshot, event, actorScope, actions, internalQueue, stateNodeToEnter.invoke.map((invokeDef)=>invokeDef.id));\n        if (stateNodeToEnter.type === \"final\") {\n            const parent = stateNodeToEnter.parent;\n            let ancestorMarker = parent?.type === \"parallel\" ? parent : parent?.parent;\n            let rootCompletionNode = ancestorMarker || stateNodeToEnter;\n            if (parent?.type === \"compound\") {\n                internalQueue.push(createDoneStateEvent(parent.id, stateNodeToEnter.output !== undefined ? resolveOutput(stateNodeToEnter.output, nextSnapshot.context, event, actorScope.self) : undefined));\n            }\n            while(ancestorMarker?.type === \"parallel\" && !completedNodes.has(ancestorMarker) && isInFinalState(mutStateNodeSet, ancestorMarker)){\n                completedNodes.add(ancestorMarker);\n                internalQueue.push(createDoneStateEvent(ancestorMarker.id));\n                rootCompletionNode = ancestorMarker;\n                ancestorMarker = ancestorMarker.parent;\n            }\n            if (ancestorMarker) {\n                continue;\n            }\n            nextSnapshot = cloneMachineSnapshot(nextSnapshot, {\n                status: \"done\",\n                output: getMachineOutput(nextSnapshot, event, actorScope, nextSnapshot.machine.root, rootCompletionNode)\n            });\n        }\n    }\n    return nextSnapshot;\n}\nfunction computeEntrySet(transitions, historyValue, statesForDefaultEntry, statesToEnter) {\n    for (const t of transitions){\n        const domain = getTransitionDomain(t, historyValue);\n        for (const s of t.target || []){\n            if (!isHistoryNode(s) && // if the target is different than the source then it will *definitely* be entered\n            (t.source !== s || // we know that the domain can't lie within the source\n            // if it's different than the source then it's outside of it and it means that the target has to be entered as well\n            t.source !== domain || // reentering transitions always enter the target, even if it's the source itself\n            t.reenter)) {\n                statesToEnter.add(s);\n                statesForDefaultEntry.add(s);\n            }\n            addDescendantStatesToEnter(s, historyValue, statesForDefaultEntry, statesToEnter);\n        }\n        const targetStates = getEffectiveTargetStates(t, historyValue);\n        for (const s of targetStates){\n            const ancestors = getProperAncestors(s, domain);\n            if (domain?.type === \"parallel\") {\n                ancestors.push(domain);\n            }\n            addAncestorStatesToEnter(statesToEnter, historyValue, statesForDefaultEntry, ancestors, !t.source.parent && t.reenter ? undefined : domain);\n        }\n    }\n}\nfunction addDescendantStatesToEnter(stateNode, historyValue, statesForDefaultEntry, statesToEnter) {\n    if (isHistoryNode(stateNode)) {\n        if (historyValue[stateNode.id]) {\n            const historyStateNodes = historyValue[stateNode.id];\n            for (const s of historyStateNodes){\n                statesToEnter.add(s);\n                addDescendantStatesToEnter(s, historyValue, statesForDefaultEntry, statesToEnter);\n            }\n            for (const s of historyStateNodes){\n                addProperAncestorStatesToEnter(s, stateNode.parent, statesToEnter, historyValue, statesForDefaultEntry);\n            }\n        } else {\n            const historyDefaultTransition = resolveHistoryDefaultTransition(stateNode);\n            for (const s of historyDefaultTransition.target){\n                statesToEnter.add(s);\n                if (historyDefaultTransition === stateNode.parent?.initial) {\n                    statesForDefaultEntry.add(stateNode.parent);\n                }\n                addDescendantStatesToEnter(s, historyValue, statesForDefaultEntry, statesToEnter);\n            }\n            for (const s of historyDefaultTransition.target){\n                addProperAncestorStatesToEnter(s, stateNode.parent, statesToEnter, historyValue, statesForDefaultEntry);\n            }\n        }\n    } else {\n        if (stateNode.type === \"compound\") {\n            const [initialState] = stateNode.initial.target;\n            if (!isHistoryNode(initialState)) {\n                statesToEnter.add(initialState);\n                statesForDefaultEntry.add(initialState);\n            }\n            addDescendantStatesToEnter(initialState, historyValue, statesForDefaultEntry, statesToEnter);\n            addProperAncestorStatesToEnter(initialState, stateNode, statesToEnter, historyValue, statesForDefaultEntry);\n        } else {\n            if (stateNode.type === \"parallel\") {\n                for (const child of getChildren(stateNode).filter((sn)=>!isHistoryNode(sn))){\n                    if (![\n                        ...statesToEnter\n                    ].some((s)=>isDescendant(s, child))) {\n                        if (!isHistoryNode(child)) {\n                            statesToEnter.add(child);\n                            statesForDefaultEntry.add(child);\n                        }\n                        addDescendantStatesToEnter(child, historyValue, statesForDefaultEntry, statesToEnter);\n                    }\n                }\n            }\n        }\n    }\n}\nfunction addAncestorStatesToEnter(statesToEnter, historyValue, statesForDefaultEntry, ancestors, reentrancyDomain) {\n    for (const anc of ancestors){\n        if (!reentrancyDomain || isDescendant(anc, reentrancyDomain)) {\n            statesToEnter.add(anc);\n        }\n        if (anc.type === \"parallel\") {\n            for (const child of getChildren(anc).filter((sn)=>!isHistoryNode(sn))){\n                if (![\n                    ...statesToEnter\n                ].some((s)=>isDescendant(s, child))) {\n                    statesToEnter.add(child);\n                    addDescendantStatesToEnter(child, historyValue, statesForDefaultEntry, statesToEnter);\n                }\n            }\n        }\n    }\n}\nfunction addProperAncestorStatesToEnter(stateNode, toStateNode, statesToEnter, historyValue, statesForDefaultEntry) {\n    addAncestorStatesToEnter(statesToEnter, historyValue, statesForDefaultEntry, getProperAncestors(stateNode, toStateNode));\n}\nfunction exitStates(currentSnapshot, event, actorScope, transitions, mutStateNodeSet, historyValue, internalQueue, _actionExecutor) {\n    let nextSnapshot = currentSnapshot;\n    const statesToExit = computeExitSet(transitions, mutStateNodeSet, historyValue);\n    statesToExit.sort((a, b)=>b.order - a.order);\n    let changedHistory;\n    // From SCXML algorithm: https://www.w3.org/TR/scxml/#exitStates\n    for (const exitStateNode of statesToExit){\n        for (const historyNode of getHistoryNodes(exitStateNode)){\n            let predicate;\n            if (historyNode.history === \"deep\") {\n                predicate = (sn)=>isAtomicStateNode(sn) && isDescendant(sn, exitStateNode);\n            } else {\n                predicate = (sn)=>{\n                    return sn.parent === exitStateNode;\n                };\n            }\n            changedHistory ??= {\n                ...historyValue\n            };\n            changedHistory[historyNode.id] = Array.from(mutStateNodeSet).filter(predicate);\n        }\n    }\n    for (const s of statesToExit){\n        nextSnapshot = resolveActionsAndContext(nextSnapshot, event, actorScope, [\n            ...s.exit,\n            ...s.invoke.map((def)=>stopChild(def.id))\n        ], internalQueue, undefined);\n        mutStateNodeSet.delete(s);\n    }\n    return [\n        nextSnapshot,\n        changedHistory || historyValue\n    ];\n}\nfunction getAction(machine, actionType) {\n    return machine.implementations.actions[actionType];\n}\nfunction resolveAndExecuteActionsWithContext(currentSnapshot, event, actorScope, actions, extra, retries) {\n    const { machine } = currentSnapshot;\n    let intermediateSnapshot = currentSnapshot;\n    for (const action of actions){\n        const isInline = typeof action === \"function\";\n        const resolvedAction = isInline ? action : // the existing type of `.actions` assumes non-nullable `TExpressionAction`\n        // it's fine to cast this here to get a common type and lack of errors in the rest of the code\n        // our logic below makes sure that we call those 2 \"variants\" correctly\n        getAction(machine, typeof action === \"string\" ? action : action.type);\n        const actionArgs = {\n            context: intermediateSnapshot.context,\n            event,\n            self: actorScope.self,\n            system: actorScope.system\n        };\n        const actionParams = isInline || typeof action === \"string\" ? undefined : \"params\" in action ? typeof action.params === \"function\" ? action.params({\n            context: intermediateSnapshot.context,\n            event\n        }) : action.params : undefined;\n        if (!resolvedAction || !(\"resolve\" in resolvedAction)) {\n            actorScope.actionExecutor({\n                type: typeof action === \"string\" ? action : typeof action === \"object\" ? action.type : action.name || \"(anonymous)\",\n                info: actionArgs,\n                params: actionParams,\n                exec: resolvedAction\n            });\n            continue;\n        }\n        const builtinAction = resolvedAction;\n        const [nextState, params, actions] = builtinAction.resolve(actorScope, intermediateSnapshot, actionArgs, actionParams, resolvedAction, // this holds all params\n        extra);\n        intermediateSnapshot = nextState;\n        if (\"retryResolve\" in builtinAction) {\n            retries?.push([\n                builtinAction,\n                params\n            ]);\n        }\n        if (\"execute\" in builtinAction) {\n            actorScope.actionExecutor({\n                type: builtinAction.type,\n                info: actionArgs,\n                params,\n                exec: builtinAction.execute.bind(null, actorScope, params)\n            });\n        }\n        if (actions) {\n            intermediateSnapshot = resolveAndExecuteActionsWithContext(intermediateSnapshot, event, actorScope, actions, extra, retries);\n        }\n    }\n    return intermediateSnapshot;\n}\nfunction resolveActionsAndContext(currentSnapshot, event, actorScope, actions, internalQueue, deferredActorIds) {\n    const retries = deferredActorIds ? [] : undefined;\n    const nextState = resolveAndExecuteActionsWithContext(currentSnapshot, event, actorScope, actions, {\n        internalQueue,\n        deferredActorIds\n    }, retries);\n    retries?.forEach(([builtinAction, params])=>{\n        builtinAction.retryResolve(actorScope, nextState, params);\n    });\n    return nextState;\n}\nfunction macrostep(snapshot, event, actorScope, internalQueue) {\n    if (event.type === WILDCARD) {\n        throw new Error(`An event cannot have the wildcard type ('${WILDCARD}')`);\n    }\n    let nextSnapshot = snapshot;\n    const microstates = [];\n    function addMicrostate(microstate, event, transitions) {\n        actorScope.system._sendInspectionEvent({\n            type: \"@xstate.microstep\",\n            actorRef: actorScope.self,\n            event,\n            snapshot: microstate,\n            _transitions: transitions\n        });\n        microstates.push(microstate);\n    }\n    // Handle stop event\n    if (event.type === XSTATE_STOP) {\n        nextSnapshot = cloneMachineSnapshot(stopChildren(nextSnapshot, event, actorScope), {\n            status: \"stopped\"\n        });\n        addMicrostate(nextSnapshot, event, []);\n        return {\n            snapshot: nextSnapshot,\n            microstates\n        };\n    }\n    let nextEvent = event;\n    // Assume the state is at rest (no raised events)\n    // Determine the next state based on the next microstep\n    if (nextEvent.type !== XSTATE_INIT) {\n        const currentEvent = nextEvent;\n        const isErr = isErrorActorEvent(currentEvent);\n        const transitions = selectTransitions(currentEvent, nextSnapshot);\n        if (isErr && !transitions.length) {\n            // TODO: we should likely only allow transitions selected by very explicit descriptors\n            // `*` shouldn't be matched, likely `xstate.error.*` shouldn't be either\n            // similarly `xstate.error.actor.*` and `xstate.error.actor.todo.*` have to be considered too\n            nextSnapshot = cloneMachineSnapshot(snapshot, {\n                status: \"error\",\n                error: currentEvent.error\n            });\n            addMicrostate(nextSnapshot, currentEvent, []);\n            return {\n                snapshot: nextSnapshot,\n                microstates\n            };\n        }\n        nextSnapshot = microstep(transitions, snapshot, actorScope, nextEvent, false, // isInitial\n        internalQueue);\n        addMicrostate(nextSnapshot, currentEvent, transitions);\n    }\n    let shouldSelectEventlessTransitions = true;\n    while(nextSnapshot.status === \"active\"){\n        let enabledTransitions = shouldSelectEventlessTransitions ? selectEventlessTransitions(nextSnapshot, nextEvent) : [];\n        // eventless transitions should always be selected after selecting *regular* transitions\n        // by assigning `undefined` to `previousState` we ensure that `shouldSelectEventlessTransitions` gets always computed to true in such a case\n        const previousState = enabledTransitions.length ? nextSnapshot : undefined;\n        if (!enabledTransitions.length) {\n            if (!internalQueue.length) {\n                break;\n            }\n            nextEvent = internalQueue.shift();\n            enabledTransitions = selectTransitions(nextEvent, nextSnapshot);\n        }\n        nextSnapshot = microstep(enabledTransitions, nextSnapshot, actorScope, nextEvent, false, internalQueue);\n        shouldSelectEventlessTransitions = nextSnapshot !== previousState;\n        addMicrostate(nextSnapshot, nextEvent, enabledTransitions);\n    }\n    if (nextSnapshot.status !== \"active\") {\n        stopChildren(nextSnapshot, nextEvent, actorScope);\n    }\n    return {\n        snapshot: nextSnapshot,\n        microstates\n    };\n}\nfunction stopChildren(nextState, event, actorScope) {\n    return resolveActionsAndContext(nextState, event, actorScope, Object.values(nextState.children).map((child)=>stopChild(child)), [], undefined);\n}\nfunction selectTransitions(event, nextState) {\n    return nextState.machine.getTransitionData(nextState, event);\n}\nfunction selectEventlessTransitions(nextState, event) {\n    const enabledTransitionSet = new Set();\n    const atomicStates = nextState._nodes.filter(isAtomicStateNode);\n    for (const stateNode of atomicStates){\n        loop: for (const s of [\n            stateNode\n        ].concat(getProperAncestors(stateNode, undefined))){\n            if (!s.always) {\n                continue;\n            }\n            for (const transition of s.always){\n                if (transition.guard === undefined || evaluateGuard(transition.guard, nextState.context, event, nextState)) {\n                    enabledTransitionSet.add(transition);\n                    break loop;\n                }\n            }\n        }\n    }\n    return removeConflictingTransitions(Array.from(enabledTransitionSet), new Set(nextState._nodes), nextState.historyValue);\n}\n/**\n * Resolves a partial state value with its full representation in the state\n * node's machine.\n *\n * @param stateValue The partial state value to resolve.\n */ function resolveStateValue(rootNode, stateValue) {\n    const allStateNodes = getAllStateNodes(getStateNodes(rootNode, stateValue));\n    return getStateValue(rootNode, [\n        ...allStateNodes\n    ]);\n}\nfunction isMachineSnapshot(value) {\n    return !!value && typeof value === \"object\" && \"machine\" in value && \"value\" in value;\n}\nconst machineSnapshotMatches = function matches(testValue) {\n    return matchesState(testValue, this.value);\n};\nconst machineSnapshotHasTag = function hasTag(tag) {\n    return this.tags.has(tag);\n};\nconst machineSnapshotCan = function can(event) {\n    if (!this.machine) {\n        console.warn(`state.can(...) used outside of a machine-created State object; this will always return false.`);\n    }\n    const transitionData = this.machine.getTransitionData(this, event);\n    return !!transitionData?.length && // Check that at least one transition is not forbidden\n    transitionData.some((t)=>t.target !== undefined || t.actions.length);\n};\nconst machineSnapshotToJSON = function toJSON() {\n    const { _nodes: nodes, tags, machine, getMeta, toJSON, can, hasTag, matches, ...jsonValues } = this;\n    return {\n        ...jsonValues,\n        tags: Array.from(tags)\n    };\n};\nconst machineSnapshotGetMeta = function getMeta() {\n    return this._nodes.reduce((acc, stateNode)=>{\n        if (stateNode.meta !== undefined) {\n            acc[stateNode.id] = stateNode.meta;\n        }\n        return acc;\n    }, {});\n};\nfunction createMachineSnapshot(config, machine) {\n    return {\n        status: config.status,\n        output: config.output,\n        error: config.error,\n        machine,\n        context: config.context,\n        _nodes: config._nodes,\n        value: getStateValue(machine.root, config._nodes),\n        tags: new Set(config._nodes.flatMap((sn)=>sn.tags)),\n        children: config.children,\n        historyValue: config.historyValue || {},\n        matches: machineSnapshotMatches,\n        hasTag: machineSnapshotHasTag,\n        can: machineSnapshotCan,\n        getMeta: machineSnapshotGetMeta,\n        toJSON: machineSnapshotToJSON\n    };\n}\nfunction cloneMachineSnapshot(snapshot, config = {}) {\n    return createMachineSnapshot({\n        ...snapshot,\n        ...config\n    }, snapshot.machine);\n}\nfunction serializeHistoryValue(historyValue) {\n    if (typeof historyValue !== \"object\" || historyValue === null) {\n        return {};\n    }\n    const result = {};\n    for(const key in historyValue){\n        const value = historyValue[key];\n        if (Array.isArray(value)) {\n            result[key] = value.map((item)=>({\n                    id: item.id\n                }));\n        }\n    }\n    return result;\n}\nfunction getPersistedSnapshot(snapshot, options) {\n    const { _nodes: nodes, tags, machine, children, context, can, hasTag, matches, getMeta, toJSON, ...jsonValues } = snapshot;\n    const childrenJson = {};\n    for(const id in children){\n        const child = children[id];\n        if (typeof child.src !== \"string\" && (!options || !(\"__unsafeAllowInlineActors\" in options))) {\n            throw new Error(\"An inline child actor cannot be persisted.\");\n        }\n        childrenJson[id] = {\n            snapshot: child.getPersistedSnapshot(options),\n            src: child.src,\n            systemId: child._systemId,\n            syncSnapshot: child._syncSnapshot\n        };\n    }\n    const persisted = {\n        ...jsonValues,\n        context: persistContext(context),\n        children: childrenJson,\n        historyValue: serializeHistoryValue(jsonValues.historyValue)\n    };\n    return persisted;\n}\nfunction persistContext(contextPart) {\n    let copy;\n    for(const key in contextPart){\n        const value = contextPart[key];\n        if (value && typeof value === \"object\") {\n            if (\"sessionId\" in value && \"send\" in value && \"ref\" in value) {\n                copy ??= Array.isArray(contextPart) ? contextPart.slice() : {\n                    ...contextPart\n                };\n                copy[key] = {\n                    xstate$$type: $$ACTOR_TYPE,\n                    id: value.id\n                };\n            } else {\n                const result = persistContext(value);\n                if (result !== value) {\n                    copy ??= Array.isArray(contextPart) ? contextPart.slice() : {\n                        ...contextPart\n                    };\n                    copy[key] = result;\n                }\n            }\n        }\n    }\n    return copy ?? contextPart;\n}\nfunction resolveRaise(_, snapshot, args, actionParams, { event: eventOrExpr, id, delay }, { internalQueue }) {\n    const delaysMap = snapshot.machine.implementations.delays;\n    if (typeof eventOrExpr === \"string\") {\n        throw new Error(// eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n        `Only event objects may be used with raise; use raise({ type: \"${eventOrExpr}\" }) instead`);\n    }\n    const resolvedEvent = typeof eventOrExpr === \"function\" ? eventOrExpr(args, actionParams) : eventOrExpr;\n    let resolvedDelay;\n    if (typeof delay === \"string\") {\n        const configDelay = delaysMap && delaysMap[delay];\n        resolvedDelay = typeof configDelay === \"function\" ? configDelay(args, actionParams) : configDelay;\n    } else {\n        resolvedDelay = typeof delay === \"function\" ? delay(args, actionParams) : delay;\n    }\n    if (typeof resolvedDelay !== \"number\") {\n        internalQueue.push(resolvedEvent);\n    }\n    return [\n        snapshot,\n        {\n            event: resolvedEvent,\n            id,\n            delay: resolvedDelay\n        },\n        undefined\n    ];\n}\nfunction executeRaise(actorScope, params) {\n    const { event, delay, id } = params;\n    if (typeof delay === \"number\") {\n        actorScope.defer(()=>{\n            const self = actorScope.self;\n            actorScope.system.scheduler.schedule(self, self, event, delay, id);\n        });\n        return;\n    }\n}\n/**\n * Raises an event. This places the event in the internal event queue, so that\n * the event is immediately consumed by the machine in the current step.\n *\n * @param eventType The event to raise.\n */ function raise(eventOrExpr, options) {\n    if (executingCustomAction) {\n        console.warn(\"Custom actions should not call `raise()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.\");\n    }\n    function raise(_args, _params) {\n        {\n            throw new Error(`This isn't supposed to be called`);\n        }\n    }\n    raise.type = \"xstate.raise\";\n    raise.event = eventOrExpr;\n    raise.id = options?.id;\n    raise.delay = options?.delay;\n    raise.resolve = resolveRaise;\n    raise.execute = executeRaise;\n    return raise;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHN0YXRlL2Rpc3QvcmFpc2UtNzhiOGRjYjguZGV2ZWxvcG1lbnQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTRFO0FBRTVFLE1BQU1DO0lBQ0pDLFlBQVlDLFFBQVEsQ0FBRTtRQUNwQixJQUFJLENBQUNBLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDQyxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUNDLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNDLEtBQUssR0FBRztJQUNmO0lBQ0FDLFFBQVE7UUFDTixJQUFJLENBQUNILE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ0ksS0FBSztJQUNaO0lBQ0FDLFFBQVE7UUFDTix5RUFBeUU7UUFDekUsdUZBQXVGO1FBQ3ZGLElBQUksSUFBSSxDQUFDSixRQUFRLEVBQUU7WUFDakIsSUFBSSxDQUFDQSxRQUFRLENBQUNLLElBQUksR0FBRztZQUNyQixJQUFJLENBQUNKLEtBQUssR0FBRyxJQUFJLENBQUNELFFBQVE7UUFDNUI7SUFDRjtJQUNBTSxRQUFRQyxLQUFLLEVBQUU7UUFDYixNQUFNQyxXQUFXO1lBQ2ZDLE9BQU9GO1lBQ1BGLE1BQU07UUFDUjtRQUNBLElBQUksSUFBSSxDQUFDTCxRQUFRLEVBQUU7WUFDakIsSUFBSSxDQUFDQyxLQUFLLENBQUNJLElBQUksR0FBR0c7WUFDbEIsSUFBSSxDQUFDUCxLQUFLLEdBQUdPO1lBQ2I7UUFDRjtRQUNBLElBQUksQ0FBQ1IsUUFBUSxHQUFHUTtRQUNoQixJQUFJLENBQUNQLEtBQUssR0FBR087UUFDYixJQUFJLElBQUksQ0FBQ1QsT0FBTyxFQUFFO1lBQ2hCLElBQUksQ0FBQ0ksS0FBSztRQUNaO0lBQ0Y7SUFDQUEsUUFBUTtRQUNOLE1BQU8sSUFBSSxDQUFDSCxRQUFRLENBQUU7WUFDcEIsbUZBQW1GO1lBQ25GLDZFQUE2RTtZQUM3RSxNQUFNVSxXQUFXLElBQUksQ0FBQ1YsUUFBUTtZQUM5QixJQUFJLENBQUNGLFFBQVEsQ0FBQ1ksU0FBU0QsS0FBSztZQUM1QixJQUFJLENBQUNULFFBQVEsR0FBR1UsU0FBU0wsSUFBSTtRQUMvQjtRQUNBLElBQUksQ0FBQ0osS0FBSyxHQUFHO0lBQ2Y7QUFDRjtBQUVBLE1BQU1VLGtCQUFrQjtBQUN4QixNQUFNQyxpQkFBaUI7QUFDdkIsTUFBTUMsYUFBYTtBQUNuQixNQUFNQyxtQkFBbUI7QUFDekIsTUFBTUMsV0FBVztBQUNqQixNQUFNQyxjQUFjO0FBQ3BCLE1BQU1DLGVBQWU7QUFDckIsTUFBTUMsY0FBYztBQUVwQjs7Ozs7O0NBTUMsR0FDRCxTQUFTQyxpQkFBaUJDLFFBQVEsRUFBRUMsRUFBRTtJQUNwQyxPQUFPO1FBQ0xDLE1BQU0sQ0FBQyxhQUFhLEVBQUVGLFNBQVMsQ0FBQyxFQUFFQyxHQUFHLENBQUM7SUFDeEM7QUFDRjtBQUVBOzs7Ozs7Q0FNQyxHQUNELFNBQVNFLHFCQUFxQkYsRUFBRSxFQUFFRyxNQUFNO0lBQ3RDLE9BQU87UUFDTEYsTUFBTSxDQUFDLGtCQUFrQixFQUFFRCxHQUFHLENBQUM7UUFDL0JHO0lBQ0Y7QUFDRjtBQUVBOzs7Ozs7OztDQVFDLEdBQ0QsU0FBU0MscUJBQXFCQyxRQUFRLEVBQUVGLE1BQU07SUFDNUMsT0FBTztRQUNMRixNQUFNLENBQUMsa0JBQWtCLEVBQUVJLFNBQVMsQ0FBQztRQUNyQ0Y7UUFDQUcsU0FBU0Q7SUFDWDtBQUNGO0FBQ0EsU0FBU0Usc0JBQXNCUCxFQUFFLEVBQUVRLEtBQUs7SUFDdEMsT0FBTztRQUNMUCxNQUFNLENBQUMsbUJBQW1CLEVBQUVELEdBQUcsQ0FBQztRQUNoQ1E7UUFDQUYsU0FBU047SUFDWDtBQUNGO0FBQ0EsU0FBU1MsZ0JBQWdCQyxLQUFLO0lBQzVCLE9BQU87UUFDTFQsTUFBTU47UUFDTmU7SUFDRjtBQUNGO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNDLHFCQUFxQkMsR0FBRztJQUMvQkMsV0FBVztRQUNULE1BQU1EO0lBQ1I7QUFDRjtBQUVBLE1BQU1FLG1CQUFtQixDQUFDLElBQU0sT0FBT0MsV0FBVyxjQUFjQSxPQUFPQyxVQUFVLElBQUksY0FBYTtBQUVsRyxTQUFTQyxhQUFhQyxhQUFhLEVBQUVDLFlBQVk7SUFDL0MsTUFBTUMsbUJBQW1CQyxhQUFhSDtJQUN0QyxNQUFNSSxrQkFBa0JELGFBQWFGO0lBQ3JDLElBQUksT0FBT0csb0JBQW9CLFVBQVU7UUFDdkMsSUFBSSxPQUFPRixxQkFBcUIsVUFBVTtZQUN4QyxPQUFPRSxvQkFBb0JGO1FBQzdCO1FBRUEsa0NBQWtDO1FBQ2xDLE9BQU87SUFDVDtJQUNBLElBQUksT0FBT0EscUJBQXFCLFVBQVU7UUFDeEMsT0FBT0Esb0JBQW9CRTtJQUM3QjtJQUNBLE9BQU9DLE9BQU9DLElBQUksQ0FBQ0osa0JBQWtCSyxLQUFLLENBQUNDLENBQUFBO1FBQ3pDLElBQUksQ0FBRUEsQ0FBQUEsT0FBT0osZUFBYyxHQUFJO1lBQzdCLE9BQU87UUFDVDtRQUNBLE9BQU9MLGFBQWFHLGdCQUFnQixDQUFDTSxJQUFJLEVBQUVKLGVBQWUsQ0FBQ0ksSUFBSTtJQUNqRTtBQUNGO0FBQ0EsU0FBU0MsWUFBWUMsT0FBTztJQUMxQixJQUFJQyxRQUFRRCxVQUFVO1FBQ3BCLE9BQU9BO0lBQ1Q7SUFDQSxNQUFNRSxTQUFTLEVBQUU7SUFDakIsSUFBSUMsVUFBVTtJQUNkLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJSixRQUFRSyxNQUFNLEVBQUVELElBQUs7UUFDdkMsTUFBTUUsT0FBT04sUUFBUU8sVUFBVSxDQUFDSDtRQUNoQyxPQUFRRTtZQUNOLElBQUk7WUFDSixLQUFLO2dCQUNILDZCQUE2QjtnQkFDN0JILFdBQVdILE9BQU8sQ0FBQ0ksSUFBSSxFQUFFO2dCQUN6QixtQkFBbUI7Z0JBQ25CQTtnQkFDQTtZQUNGLElBQUk7WUFDSixLQUFLO2dCQUNIRixPQUFPTSxJQUFJLENBQUNMO2dCQUNaQSxVQUFVO2dCQUNWO1FBQ0o7UUFDQUEsV0FBV0gsT0FBTyxDQUFDSSxFQUFFO0lBQ3ZCO0lBQ0FGLE9BQU9NLElBQUksQ0FBQ0w7SUFDWixPQUFPRDtBQUNUO0FBQ0EsU0FBU1QsYUFBYWdCLFVBQVU7SUFDOUIsSUFBSUMsa0JBQWtCRCxhQUFhO1FBQ2pDLE9BQU9BLFdBQVdqRCxLQUFLO0lBQ3pCO0lBQ0EsSUFBSSxPQUFPaUQsZUFBZSxVQUFVO1FBQ2xDLE9BQU9BO0lBQ1Q7SUFDQSxNQUFNRSxZQUFZWixZQUFZVTtJQUM5QixPQUFPRyxpQkFBaUJEO0FBQzFCO0FBQ0EsU0FBU0MsaUJBQWlCRCxTQUFTO0lBQ2pDLElBQUlBLFVBQVVOLE1BQU0sS0FBSyxHQUFHO1FBQzFCLE9BQU9NLFNBQVMsQ0FBQyxFQUFFO0lBQ3JCO0lBQ0EsTUFBTW5ELFFBQVEsQ0FBQztJQUNmLElBQUlxRCxTQUFTckQ7SUFDYixJQUFLLElBQUk0QyxJQUFJLEdBQUdBLElBQUlPLFVBQVVOLE1BQU0sR0FBRyxHQUFHRCxJQUFLO1FBQzdDLElBQUlBLE1BQU1PLFVBQVVOLE1BQU0sR0FBRyxHQUFHO1lBQzlCUSxNQUFNLENBQUNGLFNBQVMsQ0FBQ1AsRUFBRSxDQUFDLEdBQUdPLFNBQVMsQ0FBQ1AsSUFBSSxFQUFFO1FBQ3pDLE9BQU87WUFDTCxNQUFNVSxXQUFXRDtZQUNqQkEsU0FBUyxDQUFDO1lBQ1ZDLFFBQVEsQ0FBQ0gsU0FBUyxDQUFDUCxFQUFFLENBQUMsR0FBR1M7UUFDM0I7SUFDRjtJQUNBLE9BQU9yRDtBQUNUO0FBQ0EsU0FBU3VELFVBQVVDLFVBQVUsRUFBRUMsUUFBUTtJQUNyQyxNQUFNZixTQUFTLENBQUM7SUFDaEIsTUFBTWdCLGlCQUFpQnZCLE9BQU9DLElBQUksQ0FBQ29CO0lBQ25DLElBQUssSUFBSVosSUFBSSxHQUFHQSxJQUFJYyxlQUFlYixNQUFNLEVBQUVELElBQUs7UUFDOUMsTUFBTU4sTUFBTW9CLGNBQWMsQ0FBQ2QsRUFBRTtRQUM3QkYsTUFBTSxDQUFDSixJQUFJLEdBQUdtQixTQUFTRCxVQUFVLENBQUNsQixJQUFJLEVBQUVBLEtBQUtrQixZQUFZWjtJQUMzRDtJQUNBLE9BQU9GO0FBQ1Q7QUFDQSxTQUFTaUIsY0FBYzNELEtBQUs7SUFDMUIsSUFBSXlDLFFBQVF6QyxRQUFRO1FBQ2xCLE9BQU9BO0lBQ1Q7SUFDQSxPQUFPO1FBQUNBO0tBQU07QUFDaEI7QUFDQSxTQUFTNEQsUUFBUTVELEtBQUs7SUFDcEIsSUFBSUEsVUFBVTZELFdBQVc7UUFDdkIsT0FBTyxFQUFFO0lBQ1g7SUFDQSxPQUFPRixjQUFjM0Q7QUFDdkI7QUFDQSxTQUFTOEQsY0FBY0MsTUFBTSxFQUFFQyxPQUFPLEVBQUVsRSxLQUFLLEVBQUVtRSxJQUFJO0lBQ2pELElBQUksT0FBT0YsV0FBVyxZQUFZO1FBQ2hDLE9BQU9BLE9BQU87WUFDWkM7WUFDQWxFO1lBQ0FtRTtRQUNGO0lBQ0Y7SUFDQSxJQUFJLENBQUMsQ0FBQ0YsVUFBVSxPQUFPQSxXQUFXLFlBQVk1QixPQUFPK0IsTUFBTSxDQUFDSCxRQUFRSSxJQUFJLENBQUNDLENBQUFBLE1BQU8sT0FBT0EsUUFBUSxhQUFhO1FBQzFHQyxRQUFRQyxJQUFJLENBQUMsQ0FBQyxrTkFBa04sRUFBRW5DLE9BQU9vQyxPQUFPLENBQUNSLFFBQVFTLE1BQU0sQ0FBQyxDQUFDLEdBQUd4RSxNQUFNLEdBQUssT0FBT0EsVUFBVSxZQUFZeUUsR0FBRyxDQUFDLENBQUMsQ0FBQ25DLEtBQUt0QyxNQUFNLEdBQUssQ0FBQyxLQUFLLEVBQUVzQyxJQUFJLEVBQUUsRUFBRXRDLE1BQU0wRSxRQUFRLEdBQUdDLE9BQU8sQ0FBQyxVQUFVLElBQUksQ0FBQyxFQUFFQyxJQUFJLENBQUMsSUFBSSxDQUFDO0lBQ3hZO0lBQ0EsT0FBT2I7QUFDVDtBQUNBLFNBQVN0QixRQUFRekMsS0FBSztJQUNwQixPQUFPNkUsTUFBTXBDLE9BQU8sQ0FBQ3pDO0FBQ3ZCO0FBQ0EsU0FBUzhFLGtCQUFrQmhGLEtBQUs7SUFDOUIsT0FBT0EsTUFBTWUsSUFBSSxDQUFDa0UsVUFBVSxDQUFDO0FBQy9CO0FBQ0EsU0FBU0Msd0JBQXdCQyxVQUFVO0lBQ3pDLE9BQU90QixjQUFjc0IsWUFBWVIsR0FBRyxDQUFDUyxDQUFBQTtRQUNuQyxJQUFJLE9BQU9BLG1CQUFtQixlQUFlLE9BQU9BLG1CQUFtQixVQUFVO1lBQy9FLE9BQU87Z0JBQ0xDLFFBQVFEO1lBQ1Y7UUFDRjtRQUNBLE9BQU9BO0lBQ1Q7QUFDRjtBQUNBLFNBQVNFLGdCQUFnQkQsTUFBTTtJQUM3QixJQUFJQSxXQUFXdEIsYUFBYXNCLFdBQVdoRixnQkFBZ0I7UUFDckQsT0FBTzBEO0lBQ1Q7SUFDQSxPQUFPRCxRQUFRdUI7QUFDakI7QUFDQSxTQUFTRSxXQUFXQyxXQUFXLEVBQUVDLFlBQVksRUFBRUMsaUJBQWlCO0lBQzlELE1BQU1DLGFBQWEsT0FBT0gsZ0JBQWdCO0lBQzFDLE1BQU1yQixPQUFPd0IsYUFBYUgsY0FBY3pCO0lBQ3hDLE9BQU87UUFDTGpFLE1BQU82RixDQUFBQSxhQUFhSCxZQUFZMUYsSUFBSSxHQUFHMEYsV0FBVSxHQUFJSSxLQUFLekI7UUFDMUQ3QyxPQUFRcUUsQ0FBQUEsYUFBYUgsWUFBWWxFLEtBQUssR0FBR21FLFlBQVcsR0FBSUcsS0FBS3pCO1FBQzdEMEIsVUFBV0YsQ0FBQUEsYUFBYUgsWUFBWUssUUFBUSxHQUFHSCxpQkFBZ0IsR0FBSUUsS0FBS3pCO0lBQzFFO0FBQ0Y7QUFDQSxTQUFTMkIsZUFBZUMsV0FBVyxFQUFFQyxLQUFLO0lBQ3hDLE9BQU8sQ0FBQyxFQUFFQSxNQUFNLENBQUMsRUFBRUQsWUFBWSxDQUFDO0FBQ2xDO0FBQ0EsU0FBU0UsdUJBQXVCQyxPQUFPLEVBQUVDLEdBQUc7SUFDMUMsTUFBTUMsUUFBUUQsSUFBSUMsS0FBSyxDQUFDO0lBQ3hCLElBQUksQ0FBQ0EsT0FBTztRQUNWLE9BQU9GLFFBQVFHLGVBQWUsQ0FBQ0MsTUFBTSxDQUFDSCxJQUFJO0lBQzVDO0lBQ0EsTUFBTSxHQUFHSSxVQUFVQyxPQUFPLEdBQUdKO0lBQzdCLE1BQU1LLE9BQU9QLFFBQVFRLGdCQUFnQixDQUFDRjtJQUN0QyxNQUFNRyxlQUFlRixLQUFLRyxNQUFNLENBQUNDLE1BQU07SUFDdkMsT0FBTyxDQUFDOUIsTUFBTXBDLE9BQU8sQ0FBQ2dFLGdCQUFnQkEsWUFBWSxDQUFDSixTQUFTLEdBQUdJLFlBQVcsRUFBR1IsR0FBRztBQUNsRjtBQUNBLFNBQVNXLDBCQUEwQkMsUUFBUTtJQUN6QyxPQUFPO1dBQUksSUFBSUMsSUFBSTtlQUFJRCxTQUFTRSxNQUFNLENBQUNDLE9BQU8sQ0FBQ0MsQ0FBQUEsS0FBTUEsR0FBR0MsU0FBUztTQUFFO0tBQUU7QUFDdkU7QUFFQSxTQUFTQyx1QkFBdUJDLFFBQVEsRUFBRXhHLEVBQUU7SUFDMUMsT0FBTyxDQUFDLEVBQUV3RyxTQUFTQyxTQUFTLENBQUMsQ0FBQyxFQUFFekcsR0FBRyxDQUFDO0FBQ3RDO0FBQ0EsSUFBSTBHLFlBQVk7QUFDaEIsU0FBU0MsYUFBYUMsU0FBUyxFQUFFQyxPQUFPO0lBQ3RDLE1BQU1DLFdBQVcsSUFBSUM7SUFDckIsTUFBTUMsY0FBYyxJQUFJRDtJQUN4QixNQUFNRSxxQkFBcUIsSUFBSUM7SUFDL0IsTUFBTUMsc0JBQXNCLElBQUlqQjtJQUNoQyxNQUFNa0IsV0FBVyxDQUFDO0lBQ2xCLE1BQU0sRUFDSkMsS0FBSyxFQUNMQyxNQUFNLEVBQ1AsR0FBR1Q7SUFDSixNQUFNVSxZQUFZO1FBQ2hCQyxVQUFVLENBQUNDLFFBQVFsRCxRQUFRckYsT0FBT3dJLE9BQU8xSCxLQUFLMkgsS0FBS0MsTUFBTSxHQUFHOUQsUUFBUSxDQUFDLElBQUkrRCxLQUFLLENBQUMsRUFBRTtZQUMvRSxNQUFNQyxpQkFBaUI7Z0JBQ3JCTDtnQkFDQWxEO2dCQUNBckY7Z0JBQ0F3STtnQkFDQTFIO2dCQUNBK0gsV0FBV0MsS0FBS0MsR0FBRztZQUNyQjtZQUNBLE1BQU1DLG1CQUFtQjNCLHVCQUF1QmtCLFFBQVF6SDtZQUN4RG1JLE9BQU9DLFNBQVMsQ0FBQ0MsZ0JBQWdCLENBQUNILGlCQUFpQixHQUFHSjtZQUN0RCxNQUFNUSxVQUFVakIsTUFBTXhHLFVBQVUsQ0FBQztnQkFDL0IsT0FBT3VHLFFBQVEsQ0FBQ2MsaUJBQWlCO2dCQUNqQyxPQUFPQyxPQUFPQyxTQUFTLENBQUNDLGdCQUFnQixDQUFDSCxpQkFBaUI7Z0JBQzFEQyxPQUFPSSxNQUFNLENBQUNkLFFBQVFsRCxRQUFRckY7WUFDaEMsR0FBR3dJO1lBQ0hOLFFBQVEsQ0FBQ2MsaUJBQWlCLEdBQUdJO1FBQy9CO1FBQ0FFLFFBQVEsQ0FBQ2YsUUFBUXpIO1lBQ2YsTUFBTWtJLG1CQUFtQjNCLHVCQUF1QmtCLFFBQVF6SDtZQUN4RCxNQUFNc0ksVUFBVWxCLFFBQVEsQ0FBQ2MsaUJBQWlCO1lBQzFDLE9BQU9kLFFBQVEsQ0FBQ2MsaUJBQWlCO1lBQ2pDLE9BQU9DLE9BQU9DLFNBQVMsQ0FBQ0MsZ0JBQWdCLENBQUNILGlCQUFpQjtZQUMxRCxJQUFJSSxZQUFZckYsV0FBVztnQkFDekJvRSxNQUFNb0IsWUFBWSxDQUFDSDtZQUNyQjtRQUNGO1FBQ0FJLFdBQVdsQyxDQUFBQTtZQUNULElBQUssTUFBTTBCLG9CQUFvQkMsT0FBT0MsU0FBUyxDQUFDQyxnQkFBZ0IsQ0FBRTtnQkFDaEUsTUFBTVAsaUJBQWlCSyxPQUFPQyxTQUFTLENBQUNDLGdCQUFnQixDQUFDSCxpQkFBaUI7Z0JBQzFFLElBQUlKLGVBQWVMLE1BQU0sS0FBS2pCLFVBQVU7b0JBQ3RDZSxVQUFVaUIsTUFBTSxDQUFDaEMsVUFBVXNCLGVBQWU5SCxFQUFFO2dCQUM5QztZQUNGO1FBQ0Y7SUFDRjtJQUNBLE1BQU0ySSxzQkFBc0J6SixDQUFBQTtRQUMxQixJQUFJLENBQUNpSSxvQkFBb0J5QixJQUFJLEVBQUU7WUFDN0I7UUFDRjtRQUNBLE1BQU1DLDBCQUEwQjtZQUM5QixHQUFHM0osS0FBSztZQUNSNEosUUFBUWxDLFVBQVVILFNBQVM7UUFDN0I7UUFDQVUsb0JBQW9CNEIsT0FBTyxDQUFDQyxDQUFBQSxXQUFZQSxTQUFTaEssSUFBSSxHQUFHNko7SUFDMUQ7SUFDQSxNQUFNVixTQUFTO1FBQ2JDLFdBQVc7WUFDVEMsa0JBQWtCLENBQUN4QixTQUFTWixZQUFZWSxRQUFRWixRQUFRLENBQUNzQixTQUFTLEtBQUssQ0FBQztRQUMxRTtRQUNBMEIsU0FBUyxJQUFNLENBQUMsRUFBRSxFQUFFdkMsWUFBWSxDQUFDO1FBQ2pDd0MsV0FBVyxDQUFDekMsV0FBV0Q7WUFDckJNLFNBQVNxQyxHQUFHLENBQUMxQyxXQUFXRDtZQUN4QixPQUFPQztRQUNUO1FBQ0EyQyxhQUFhNUMsQ0FBQUE7WUFDWE0sU0FBU3VDLE1BQU0sQ0FBQzdDLFNBQVNDLFNBQVM7WUFDbEMsTUFBTTZDLFdBQVdyQyxtQkFBbUJzQyxHQUFHLENBQUMvQztZQUN4QyxJQUFJOEMsYUFBYXJHLFdBQVc7Z0JBQzFCK0QsWUFBWXFDLE1BQU0sQ0FBQ0M7Z0JBQ25CckMsbUJBQW1Cb0MsTUFBTSxDQUFDN0M7WUFDNUI7UUFDRjtRQUNBK0MsS0FBS0QsQ0FBQUE7WUFDSCxPQUFPdEMsWUFBWXVDLEdBQUcsQ0FBQ0Q7UUFDekI7UUFDQUUsTUFBTSxDQUFDRixVQUFVOUM7WUFDZixNQUFNaUQsV0FBV3pDLFlBQVl1QyxHQUFHLENBQUNEO1lBQ2pDLElBQUlHLFlBQVlBLGFBQWFqRCxVQUFVO2dCQUNyQyxNQUFNLElBQUlrRCxNQUFNLENBQUMsc0JBQXNCLEVBQUVKLFNBQVMsaUJBQWlCLENBQUM7WUFDdEU7WUFDQXRDLFlBQVltQyxHQUFHLENBQUNHLFVBQVU5QztZQUMxQlMsbUJBQW1Ca0MsR0FBRyxDQUFDM0MsVUFBVThDO1FBQ25DO1FBQ0FLLFNBQVNDLENBQUFBO1lBQ1AsTUFBTVosV0FBV3ZFLFdBQVdtRjtZQUM1QnpDLG9CQUFvQjBDLEdBQUcsQ0FBQ2I7WUFDeEIsT0FBTztnQkFDTGM7b0JBQ0UzQyxvQkFBb0JrQyxNQUFNLENBQUNMO2dCQUM3QjtZQUNGO1FBQ0Y7UUFDQWUsc0JBQXNCcEI7UUFDdEJKLFFBQVEsQ0FBQ2QsUUFBUWxELFFBQVFyRjtZQUN2QmlKLE9BQU80QixvQkFBb0IsQ0FBQztnQkFDMUI5SixNQUFNO2dCQUNOK0osV0FBV3ZDO2dCQUNYakIsVUFBVWpDO2dCQUNWckY7WUFDRjtZQUNBcUYsT0FBTzBGLEtBQUssQ0FBQy9LO1FBQ2Y7UUFDQXFJO1FBQ0EyQyxhQUFhO1lBQ1gsT0FBTztnQkFDTDdCLGtCQUFrQjtvQkFDaEIsR0FBR0YsT0FBT0MsU0FBUyxDQUFDQyxnQkFBZ0I7Z0JBQ3RDO1lBQ0Y7UUFDRjtRQUNBeEosT0FBTztZQUNMLE1BQU1zTCxrQkFBa0JoQyxPQUFPQyxTQUFTLENBQUNDLGdCQUFnQjtZQUN6REYsT0FBT0MsU0FBUyxDQUFDQyxnQkFBZ0IsR0FBRyxDQUFDO1lBQ3JDLElBQUssTUFBTStCLGVBQWVELGdCQUFpQjtnQkFDekMsTUFBTSxFQUNKMUMsTUFBTSxFQUNObEQsTUFBTSxFQUNOckYsS0FBSyxFQUNMd0ksS0FBSyxFQUNMMUgsRUFBRSxFQUNILEdBQUdtSyxlQUFlLENBQUNDLFlBQVk7Z0JBQ2hDN0MsVUFBVUMsUUFBUSxDQUFDQyxRQUFRbEQsUUFBUXJGLE9BQU93SSxPQUFPMUg7WUFDbkQ7UUFDRjtRQUNBcUssUUFBUWhEO1FBQ1JpRCxTQUFTaEQ7SUFDWDtJQUNBLE9BQU9hO0FBQ1Q7QUFFQSx1REFBdUQ7QUFFdkQsSUFBSW9DLHdCQUF3QjtBQUM1QixNQUFNQyxlQUFlO0FBRXJCLGtIQUFrSDtBQUNsSCxJQUFJQyxtQkFBbUIsV0FBVyxHQUFFLFNBQVVBLGdCQUFnQjtJQUM1REEsZ0JBQWdCLENBQUNBLGdCQUFnQixDQUFDLGFBQWEsR0FBRyxFQUFFLEdBQUc7SUFDdkRBLGdCQUFnQixDQUFDQSxnQkFBZ0IsQ0FBQyxVQUFVLEdBQUcsRUFBRSxHQUFHO0lBQ3BEQSxnQkFBZ0IsQ0FBQ0EsZ0JBQWdCLENBQUMsVUFBVSxHQUFHLEVBQUUsR0FBRztJQUNwRCxPQUFPQTtBQUNULEVBQUUsQ0FBQztBQUNILE1BQU1DLGlCQUFpQjtJQUNyQnJELE9BQU87UUFDTHhHLFlBQVksQ0FBQzhKLElBQUlDO1lBQ2YsT0FBTy9KLFdBQVc4SixJQUFJQztRQUN4QjtRQUNBbkMsY0FBY3pJLENBQUFBO1lBQ1osT0FBT3lJLGFBQWF6STtRQUN0QjtJQUNGO0lBQ0FzSCxRQUFRN0QsUUFBUW9ILEdBQUcsQ0FBQy9GLElBQUksQ0FBQ3JCO0lBQ3pCcUgsVUFBVTtBQUNaO0FBRUE7Ozs7Q0FJQyxHQUNELE1BQU1DO0lBQ0o7Ozs7OztHQU1DLEdBQ0R2TSxZQUFZd00sS0FBSyxFQUFFbkUsT0FBTyxDQUFFO1FBQzFCLElBQUksQ0FBQ21FLEtBQUssR0FBR0E7UUFDYiw2Q0FBNkMsR0FDN0MsSUFBSSxDQUFDNUMsU0FBUyxHQUFHLEtBQUs7UUFDdEI7OztLQUdDLEdBQ0QsSUFBSSxDQUFDZixLQUFLLEdBQUcsS0FBSztRQUNsQixJQUFJLENBQUNSLE9BQU8sR0FBRyxLQUFLO1FBQ3BCLGlFQUFpRSxHQUNqRSxJQUFJLENBQUM3RyxFQUFFLEdBQUcsS0FBSztRQUNmLElBQUksQ0FBQ2lMLE9BQU8sR0FBRyxJQUFJMU0sUUFBUSxJQUFJLENBQUNFLFFBQVEsQ0FBQ3FHLElBQUksQ0FBQyxJQUFJO1FBQ2xELElBQUksQ0FBQ29HLFNBQVMsR0FBRyxJQUFJaEY7UUFDckIsSUFBSSxDQUFDaUYsY0FBYyxHQUFHLElBQUlwRTtRQUMxQixJQUFJLENBQUNPLE1BQU0sR0FBRyxLQUFLO1FBQ25CLGNBQWMsR0FDZCxJQUFJLENBQUM4RCxpQkFBaUIsR0FBR1gsaUJBQWlCWSxVQUFVO1FBQ3BELFlBQVk7UUFDWixJQUFJLENBQUNDLE9BQU8sR0FBRyxLQUFLO1FBQ3BCLGNBQWMsR0FDZCxJQUFJLENBQUNDLGFBQWEsR0FBRyxLQUFLO1FBQzFCLElBQUksQ0FBQ0MsR0FBRyxHQUFHLEtBQUs7UUFDaEIsK0JBQStCO1FBQy9CLElBQUksQ0FBQ0MsV0FBVyxHQUFHLEtBQUs7UUFDeEIsSUFBSSxDQUFDQyxTQUFTLEdBQUcsS0FBSztRQUN0Qix3REFBd0QsR0FDeEQsSUFBSSxDQUFDakYsU0FBUyxHQUFHLEtBQUs7UUFDdEIsNENBQTRDLEdBQzVDLElBQUksQ0FBQzBCLE1BQU0sR0FBRyxLQUFLO1FBQ25CLElBQUksQ0FBQ3dELFVBQVUsR0FBRyxLQUFLO1FBQ3ZCLElBQUksQ0FBQ3RHLEdBQUcsR0FBRyxLQUFLO1FBQ2hCLDhCQUE4QjtRQUM5QixJQUFJLENBQUN1RyxTQUFTLEdBQUcsRUFBRTtRQUNuQixNQUFNQyxrQkFBa0I7WUFDdEIsR0FBR25CLGNBQWM7WUFDakIsR0FBRzdELE9BQU87UUFDWjtRQUNBLE1BQU0sRUFDSlEsS0FBSyxFQUNMQyxNQUFNLEVBQ053RSxNQUFNLEVBQ05DLFlBQVksRUFDWi9MLEVBQUUsRUFDRnNKLFFBQVEsRUFDUkssT0FBTyxFQUNSLEdBQUdrQztRQUNKLElBQUksQ0FBQzFELE1BQU0sR0FBRzJELFNBQVNBLE9BQU8zRCxNQUFNLEdBQUd4QixhQUFhLElBQUksRUFBRTtZQUN4RFU7WUFDQUM7UUFDRjtRQUNBLElBQUlxQyxXQUFXLENBQUNtQyxRQUFRO1lBQ3RCLHFDQUFxQztZQUNyQyxJQUFJLENBQUMzRCxNQUFNLENBQUN3QixPQUFPLENBQUNsRixXQUFXa0Y7UUFDakM7UUFDQSxJQUFJLENBQUNsRCxTQUFTLEdBQUcsSUFBSSxDQUFDMEIsTUFBTSxDQUFDYyxPQUFPO1FBQ3BDLElBQUksQ0FBQ2pKLEVBQUUsR0FBR0EsTUFBTSxJQUFJLENBQUN5RyxTQUFTO1FBQzlCLElBQUksQ0FBQ2EsTUFBTSxHQUFHVCxTQUFTUyxVQUFVLElBQUksQ0FBQ2EsTUFBTSxDQUFDbUMsT0FBTztRQUNwRCxJQUFJLENBQUNqRCxLQUFLLEdBQUdSLFNBQVNRLFNBQVMsSUFBSSxDQUFDYyxNQUFNLENBQUNrQyxNQUFNO1FBQ2pELElBQUksQ0FBQ2lCLE9BQU8sR0FBR1E7UUFDZixJQUFJLENBQUNQLGFBQWEsR0FBR1E7UUFDckIsSUFBSSxDQUFDbEYsT0FBTyxHQUFHZ0Y7UUFDZixJQUFJLENBQUN4RyxHQUFHLEdBQUd3RyxnQkFBZ0J4RyxHQUFHLElBQUkyRjtRQUNsQyxJQUFJLENBQUNRLEdBQUcsR0FBRyxJQUFJO1FBQ2YsSUFBSSxDQUFDQyxXQUFXLEdBQUc7WUFDakJwSSxNQUFNLElBQUk7WUFDVnJELElBQUksSUFBSSxDQUFDQSxFQUFFO1lBQ1h5RyxXQUFXLElBQUksQ0FBQ0EsU0FBUztZQUN6QmEsUUFBUSxJQUFJLENBQUNBLE1BQU07WUFDbkIwRSxPQUFPckIsQ0FBQUE7Z0JBQ0wsSUFBSSxDQUFDaUIsU0FBUyxDQUFDeEosSUFBSSxDQUFDdUk7WUFDdEI7WUFDQXhDLFFBQVEsSUFBSSxDQUFDQSxNQUFNO1lBQ25COEQsV0FBV0MsQ0FBQUE7Z0JBQ1QsSUFBSUEsTUFBTVosT0FBTyxLQUFLLElBQUksRUFBRTtvQkFDMUIsTUFBTSxJQUFJNUIsTUFBTSxDQUFDLHdCQUF3QixFQUFFd0MsTUFBTWxNLEVBQUUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDQSxFQUFFLENBQUMsMEJBQTBCLENBQUM7Z0JBQy9GO2dCQUNBa00sTUFBTUMsS0FBSztZQUNiO1lBQ0FDLE1BQU1DLENBQUFBO2dCQUNKLE1BQU1DLFlBQVksSUFBSSxDQUFDbkIsY0FBYyxDQUFDNUIsR0FBRyxDQUFDOEMsYUFBYXBNLElBQUk7Z0JBQzNELE1BQU1zTSxtQkFBbUIsSUFBSSxDQUFDcEIsY0FBYyxDQUFDNUIsR0FBRyxDQUFDO2dCQUNqRCxJQUFJLENBQUMrQyxhQUFhLENBQUNDLGtCQUFrQjtvQkFDbkM7Z0JBQ0Y7Z0JBQ0EsTUFBTUMsZUFBZTt1QkFBS0YsWUFBWUEsVUFBVWhKLE1BQU0sS0FBSyxFQUFFO3VCQUFPaUosbUJBQW1CQSxpQkFBaUJqSixNQUFNLEtBQUssRUFBRTtpQkFBRTtnQkFDdkgsS0FBSyxNQUFNbUosV0FBV0QsYUFBYztvQkFDbENDLFFBQVFKO2dCQUNWO1lBQ0Y7WUFDQUssZ0JBQWdCQyxDQUFBQTtnQkFDZCxNQUFNQyxPQUFPO29CQUNYLElBQUksQ0FBQ25CLFdBQVcsQ0FBQ3RELE1BQU0sQ0FBQzRCLG9CQUFvQixDQUFDO3dCQUMzQzlKLE1BQU07d0JBQ051RyxVQUFVLElBQUk7d0JBQ2RtRyxRQUFROzRCQUNOMU0sTUFBTTBNLE9BQU8xTSxJQUFJOzRCQUNqQjRNLFFBQVFGLE9BQU9FLE1BQU07d0JBQ3ZCO29CQUNGO29CQUNBLElBQUksQ0FBQ0YsT0FBT0MsSUFBSSxFQUFFO3dCQUNoQjtvQkFDRjtvQkFDQSxNQUFNRSw0QkFBNEJ2QztvQkFDbEMsSUFBSTt3QkFDRkEsd0JBQXdCO3dCQUN4Qm9DLE9BQU9DLElBQUksQ0FBQ0QsT0FBT0ksSUFBSSxFQUFFSixPQUFPRSxNQUFNO29CQUN4QyxTQUFVO3dCQUNSdEMsd0JBQXdCdUM7b0JBQzFCO2dCQUNGO2dCQUNBLElBQUksSUFBSSxDQUFDMUIsaUJBQWlCLEtBQUtYLGlCQUFpQnVDLE9BQU8sRUFBRTtvQkFDdkRKO2dCQUNGLE9BQU87b0JBQ0wsSUFBSSxDQUFDaEIsU0FBUyxDQUFDeEosSUFBSSxDQUFDd0s7Z0JBQ3RCO1lBQ0Y7UUFDRjtRQUVBLDhEQUE4RDtRQUM5RCxrQkFBa0I7UUFDbEIsSUFBSSxDQUFDSyxJQUFJLEdBQUcsSUFBSSxDQUFDQSxJQUFJLENBQUNuSSxJQUFJLENBQUMsSUFBSTtRQUMvQixJQUFJLENBQUNxRCxNQUFNLENBQUM0QixvQkFBb0IsQ0FBQztZQUMvQjlKLE1BQU07WUFDTnVHLFVBQVUsSUFBSTtRQUNoQjtRQUNBLElBQUk4QyxVQUFVO1lBQ1osSUFBSSxDQUFDb0MsU0FBUyxHQUFHcEM7WUFDakIsSUFBSSxDQUFDbkIsTUFBTSxDQUFDcUIsSUFBSSxDQUFDRixVQUFVLElBQUk7UUFDakM7UUFDQSxJQUFJLENBQUM0RCxVQUFVLENBQUNyRyxTQUFTWixZQUFZWSxTQUFTc0c7UUFDOUMsSUFBSTdELFlBQVksSUFBSSxDQUFDbEIsU0FBUyxDQUFDZ0YsTUFBTSxLQUFLLFVBQVU7WUFDbEQsSUFBSSxDQUFDakYsTUFBTSxDQUFDaUIsV0FBVyxDQUFDLElBQUk7UUFDOUI7SUFDRjtJQUNBOEQsV0FBV0csY0FBYyxFQUFFO1FBQ3pCLElBQUk7WUFDRixJQUFJLENBQUNqRixTQUFTLEdBQUdpRixpQkFBaUIsSUFBSSxDQUFDckMsS0FBSyxDQUFDc0MsZUFBZSxHQUFHLElBQUksQ0FBQ3RDLEtBQUssQ0FBQ3NDLGVBQWUsQ0FBQ0QsZ0JBQWdCLElBQUksQ0FBQzVCLFdBQVcsSUFBSTRCLGlCQUFpQixJQUFJLENBQUNyQyxLQUFLLENBQUN1QyxrQkFBa0IsQ0FBQyxJQUFJLENBQUM5QixXQUFXLEVBQUUsSUFBSSxDQUFDNUUsT0FBTyxFQUFFbkc7UUFDL00sRUFBRSxPQUFPRSxLQUFLO1lBQ1osd0dBQXdHO1lBQ3hHLDRFQUE0RTtZQUM1RSxzQ0FBc0M7WUFDdEMsSUFBSSxDQUFDd0gsU0FBUyxHQUFHO2dCQUNmZ0YsUUFBUTtnQkFDUmpOLFFBQVE4QztnQkFDUnpDLE9BQU9JO1lBQ1Q7UUFDRjtJQUNGO0lBQ0E0TSxPQUFPdkgsUUFBUSxFQUFFL0csS0FBSyxFQUFFO1FBQ3RCLGVBQWU7UUFDZixJQUFJLENBQUNrSixTQUFTLEdBQUduQztRQUVqQiwyQkFBMkI7UUFDM0IsSUFBSXdIO1FBQ0osTUFBT0EsYUFBYSxJQUFJLENBQUM3QixTQUFTLENBQUM4QixLQUFLLEdBQUk7WUFDMUMsSUFBSTtnQkFDRkQ7WUFDRixFQUFFLE9BQU83TSxLQUFLO2dCQUNaLGlFQUFpRTtnQkFDakUsdUZBQXVGO2dCQUN2Riw2RkFBNkY7Z0JBQzdGLGtGQUFrRjtnQkFDbEYsc0hBQXNIO2dCQUN0SCxJQUFJLENBQUNnTCxTQUFTLENBQUMzSixNQUFNLEdBQUc7Z0JBQ3hCLElBQUksQ0FBQ21HLFNBQVMsR0FBRztvQkFDZixHQUFHbkMsUUFBUTtvQkFDWG1ILFFBQVE7b0JBQ1I1TSxPQUFPSTtnQkFDVDtZQUNGO1FBQ0Y7UUFDQSxPQUFRLElBQUksQ0FBQ3dILFNBQVMsQ0FBQ2dGLE1BQU07WUFDM0IsS0FBSztnQkFDSCxLQUFLLE1BQU1wRSxZQUFZLElBQUksQ0FBQ2tDLFNBQVMsQ0FBRTtvQkFDckMsSUFBSTt3QkFDRmxDLFNBQVNoSyxJQUFJLEdBQUdpSDtvQkFDbEIsRUFBRSxPQUFPckYsS0FBSzt3QkFDWkQscUJBQXFCQztvQkFDdkI7Z0JBQ0Y7Z0JBQ0E7WUFDRixLQUFLO2dCQUNILCtEQUErRDtnQkFDL0QsMkVBQTJFO2dCQUMzRSwyRUFBMkU7Z0JBQzNFLDRFQUE0RTtnQkFDNUUsMERBQTBEO2dCQUMxRCw0REFBNEQ7Z0JBQzVELEtBQUssTUFBTW9JLFlBQVksSUFBSSxDQUFDa0MsU0FBUyxDQUFFO29CQUNyQyxJQUFJO3dCQUNGbEMsU0FBU2hLLElBQUksR0FBR2lIO29CQUNsQixFQUFFLE9BQU9yRixLQUFLO3dCQUNaRCxxQkFBcUJDO29CQUN2QjtnQkFDRjtnQkFDQSxJQUFJLENBQUMrTSxjQUFjO2dCQUNuQixJQUFJLENBQUNDLFNBQVM7Z0JBQ2QsSUFBSSxDQUFDakMsVUFBVSxHQUFHdkwscUJBQXFCLElBQUksQ0FBQ0osRUFBRSxFQUFFLElBQUksQ0FBQ29JLFNBQVMsQ0FBQ2pJLE1BQU07Z0JBQ3JFLElBQUksSUFBSSxDQUFDbUwsT0FBTyxFQUFFO29CQUNoQixJQUFJLENBQUNuRCxNQUFNLENBQUNJLE1BQU0sQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDK0MsT0FBTyxFQUFFLElBQUksQ0FBQ0ssVUFBVTtnQkFDeEQ7Z0JBQ0E7WUFDRixLQUFLO2dCQUNILElBQUksQ0FBQ2tDLE1BQU0sQ0FBQyxJQUFJLENBQUN6RixTQUFTLENBQUM1SCxLQUFLO2dCQUNoQztRQUNKO1FBQ0EsSUFBSSxDQUFDMkgsTUFBTSxDQUFDNEIsb0JBQW9CLENBQUM7WUFDL0I5SixNQUFNO1lBQ051RyxVQUFVLElBQUk7WUFDZHRIO1lBQ0ErRztRQUNGO0lBQ0Y7SUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTBEQyxHQUVENkgsVUFBVUMsc0JBQXNCLEVBQUVDLGFBQWEsRUFBRUMsZ0JBQWdCLEVBQUU7UUFDakUsTUFBTWpGLFdBQVd2RSxXQUFXc0osd0JBQXdCQyxlQUFlQztRQUNuRSxJQUFJLElBQUksQ0FBQzdDLGlCQUFpQixLQUFLWCxpQkFBaUJ5RCxPQUFPLEVBQUU7WUFDdkQsSUFBSSxDQUFDaEQsU0FBUyxDQUFDckIsR0FBRyxDQUFDYjtRQUNyQixPQUFPO1lBQ0wsT0FBUSxJQUFJLENBQUNaLFNBQVMsQ0FBQ2dGLE1BQU07Z0JBQzNCLEtBQUs7b0JBQ0gsSUFBSTt3QkFDRnBFLFNBQVNqRSxRQUFRO29CQUNuQixFQUFFLE9BQU9uRSxLQUFLO3dCQUNaRCxxQkFBcUJDO29CQUN2QjtvQkFDQTtnQkFDRixLQUFLO29CQUNIO3dCQUNFLE1BQU1BLE1BQU0sSUFBSSxDQUFDd0gsU0FBUyxDQUFDNUgsS0FBSzt3QkFDaEMsSUFBSSxDQUFDd0ksU0FBU3hJLEtBQUssRUFBRTs0QkFDbkJHLHFCQUFxQkM7d0JBQ3ZCLE9BQU87NEJBQ0wsSUFBSTtnQ0FDRm9JLFNBQVN4SSxLQUFLLENBQUNJOzRCQUNqQixFQUFFLE9BQU9BLEtBQUs7Z0NBQ1pELHFCQUFxQkM7NEJBQ3ZCO3dCQUNGO3dCQUNBO29CQUNGO1lBQ0o7UUFDRjtRQUNBLE9BQU87WUFDTGtKLGFBQWE7Z0JBQ1gsSUFBSSxDQUFDb0IsU0FBUyxDQUFDN0IsTUFBTSxDQUFDTDtZQUN4QjtRQUNGO0lBQ0Y7SUFDQW1GLEdBQUdsTyxJQUFJLEVBQUV3TSxPQUFPLEVBQUU7UUFDaEIsSUFBSUgsWUFBWSxJQUFJLENBQUNuQixjQUFjLENBQUM1QixHQUFHLENBQUN0SjtRQUN4QyxJQUFJLENBQUNxTSxXQUFXO1lBQ2RBLFlBQVksSUFBSXBHO1lBQ2hCLElBQUksQ0FBQ2lGLGNBQWMsQ0FBQ2hDLEdBQUcsQ0FBQ2xKLE1BQU1xTTtRQUNoQztRQUNBLE1BQU04QixpQkFBaUIzQixRQUFRM0gsSUFBSSxDQUFDN0I7UUFDcENxSixVQUFVekMsR0FBRyxDQUFDdUU7UUFDZCxPQUFPO1lBQ0x0RSxhQUFhO2dCQUNYd0MsVUFBVWpELE1BQU0sQ0FBQytFO1lBQ25CO1FBQ0Y7SUFDRjtJQUVBLDRDQUE0QyxHQUM1Q3ZQLFFBQVE7UUFDTixJQUFJLElBQUksQ0FBQ3VNLGlCQUFpQixLQUFLWCxpQkFBaUJ1QyxPQUFPLEVBQUU7WUFDdkQsc0RBQXNEO1lBQ3RELE9BQU8sSUFBSTtRQUNiO1FBQ0EsSUFBSSxJQUFJLENBQUN6QixhQUFhLEVBQUU7WUFDdEIsSUFBSSxDQUFDdUMsU0FBUyxDQUFDO2dCQUNiOU8sTUFBTWlILENBQUFBO29CQUNKLElBQUlBLFNBQVNtSCxNQUFNLEtBQUssVUFBVTt3QkFDaEMsSUFBSSxDQUFDakYsTUFBTSxDQUFDSSxNQUFNLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQytDLE9BQU8sRUFBRTs0QkFDckNyTCxNQUFNLENBQUMsZ0JBQWdCLEVBQUUsSUFBSSxDQUFDRCxFQUFFLENBQUMsQ0FBQzs0QkFDbENpRzt3QkFDRjtvQkFDRjtnQkFDRjtnQkFDQXpGLE9BQU8sS0FBTztZQUNoQjtRQUNGO1FBQ0EsSUFBSSxDQUFDMkgsTUFBTSxDQUFDZSxTQUFTLENBQUMsSUFBSSxDQUFDekMsU0FBUyxFQUFFLElBQUk7UUFDMUMsSUFBSSxJQUFJLENBQUNpRixTQUFTLEVBQUU7WUFDbEIsSUFBSSxDQUFDdkQsTUFBTSxDQUFDcUIsSUFBSSxDQUFDLElBQUksQ0FBQ2tDLFNBQVMsRUFBRSxJQUFJO1FBQ3ZDO1FBQ0EsSUFBSSxDQUFDTixpQkFBaUIsR0FBR1gsaUJBQWlCdUMsT0FBTztRQUVqRCw0Q0FBNEM7UUFDNUMsTUFBTXFCLFlBQVk1TixnQkFBZ0IsSUFBSSxDQUFDb0csT0FBTyxDQUFDbkcsS0FBSztRQUNwRCxJQUFJLENBQUN5SCxNQUFNLENBQUM0QixvQkFBb0IsQ0FBQztZQUMvQjlKLE1BQU07WUFDTitKLFdBQVcsSUFBSSxDQUFDc0IsT0FBTztZQUN2QjlFLFVBQVUsSUFBSTtZQUNkdEgsT0FBT21QO1FBQ1Q7UUFDQSxNQUFNakIsU0FBUyxJQUFJLENBQUNoRixTQUFTLENBQUNnRixNQUFNO1FBQ3BDLE9BQVFBO1lBQ04sS0FBSztnQkFDSCw0R0FBNEc7Z0JBQzVHLDJEQUEyRDtnQkFDM0QsSUFBSSxDQUFDSSxNQUFNLENBQUMsSUFBSSxDQUFDcEYsU0FBUyxFQUFFaUc7Z0JBQzVCLG1EQUFtRDtnQkFDbkQsT0FBTyxJQUFJO1lBQ2IsS0FBSztnQkFDSCxJQUFJLENBQUNSLE1BQU0sQ0FBQyxJQUFJLENBQUN6RixTQUFTLENBQUM1SCxLQUFLO2dCQUNoQyxPQUFPLElBQUk7UUFDZjtRQUNBLElBQUksQ0FBQyxJQUFJLENBQUM4SyxPQUFPLEVBQUU7WUFDakIsSUFBSSxDQUFDbkQsTUFBTSxDQUFDdEosS0FBSztRQUNuQjtRQUNBLElBQUksSUFBSSxDQUFDbU0sS0FBSyxDQUFDbk0sS0FBSyxFQUFFO1lBQ3BCLElBQUk7Z0JBQ0YsSUFBSSxDQUFDbU0sS0FBSyxDQUFDbk0sS0FBSyxDQUFDLElBQUksQ0FBQ3VKLFNBQVMsRUFBRSxJQUFJLENBQUNxRCxXQUFXO1lBQ25ELEVBQUUsT0FBTzdLLEtBQUs7Z0JBQ1osSUFBSSxDQUFDd0gsU0FBUyxHQUFHO29CQUNmLEdBQUcsSUFBSSxDQUFDQSxTQUFTO29CQUNqQmdGLFFBQVE7b0JBQ1I1TSxPQUFPSTtnQkFDVDtnQkFDQSxJQUFJLENBQUNpTixNQUFNLENBQUNqTjtnQkFDWixPQUFPLElBQUk7WUFDYjtRQUNGO1FBRUEsb0VBQW9FO1FBQ3BFLHlDQUF5QztRQUN6QyxvREFBb0Q7UUFDcEQsSUFBSSxDQUFDNE0sTUFBTSxDQUFDLElBQUksQ0FBQ3BGLFNBQVMsRUFBRWlHO1FBQzVCLElBQUksSUFBSSxDQUFDeEgsT0FBTyxDQUFDaUUsUUFBUSxFQUFFO1lBQ3pCLElBQUksQ0FBQ3dELGNBQWM7UUFDckI7UUFDQSxJQUFJLENBQUNyRCxPQUFPLENBQUNwTSxLQUFLO1FBQ2xCLE9BQU8sSUFBSTtJQUNiO0lBQ0FKLFNBQVNTLEtBQUssRUFBRTtRQUNkLElBQUlxUDtRQUNKLElBQUlDO1FBQ0osSUFBSTtZQUNGRCxZQUFZLElBQUksQ0FBQ3ZELEtBQUssQ0FBQ3lELFVBQVUsQ0FBQyxJQUFJLENBQUNyRyxTQUFTLEVBQUVsSixPQUFPLElBQUksQ0FBQ3VNLFdBQVc7UUFDM0UsRUFBRSxPQUFPN0ssS0FBSztZQUNaLHNGQUFzRjtZQUN0RjROLGNBQWM7Z0JBQ1o1TjtZQUNGO1FBQ0Y7UUFDQSxJQUFJNE4sYUFBYTtZQUNmLE1BQU0sRUFDSjVOLEdBQUcsRUFDSixHQUFHNE47WUFDSixJQUFJLENBQUNwRyxTQUFTLEdBQUc7Z0JBQ2YsR0FBRyxJQUFJLENBQUNBLFNBQVM7Z0JBQ2pCZ0YsUUFBUTtnQkFDUjVNLE9BQU9JO1lBQ1Q7WUFDQSxJQUFJLENBQUNpTixNQUFNLENBQUNqTjtZQUNaO1FBQ0Y7UUFDQSxJQUFJLENBQUM0TSxNQUFNLENBQUNlLFdBQVdyUDtRQUN2QixJQUFJQSxNQUFNZSxJQUFJLEtBQUtKLGFBQWE7WUFDOUIsSUFBSSxDQUFDOE4sY0FBYztZQUNuQixJQUFJLENBQUNDLFNBQVM7UUFDaEI7SUFDRjtJQUNBekIsUUFBUTtRQUNOLElBQUksSUFBSSxDQUFDZixpQkFBaUIsS0FBS1gsaUJBQWlCeUQsT0FBTyxFQUFFO1lBQ3ZELE9BQU8sSUFBSTtRQUNiO1FBQ0EsSUFBSSxDQUFDakQsT0FBTyxDQUFDbE0sS0FBSztRQUNsQixJQUFJLElBQUksQ0FBQ3FNLGlCQUFpQixLQUFLWCxpQkFBaUJZLFVBQVUsRUFBRTtZQUMxRCxJQUFJLENBQUNELGlCQUFpQixHQUFHWCxpQkFBaUJ5RCxPQUFPO1lBQ2pELE9BQU8sSUFBSTtRQUNiO1FBQ0EsSUFBSSxDQUFDakQsT0FBTyxDQUFDaE0sT0FBTyxDQUFDO1lBQ25CZ0IsTUFBTUo7UUFDUjtRQUNBLE9BQU8sSUFBSTtJQUNiO0lBRUEsbURBQW1ELEdBQ25ENk8sT0FBTztRQUNMLElBQUksSUFBSSxDQUFDcEQsT0FBTyxFQUFFO1lBQ2hCLE1BQU0sSUFBSTVCLE1BQU07UUFDbEI7UUFDQSxPQUFPLElBQUksQ0FBQ3lDLEtBQUs7SUFDbkI7SUFDQXlCLFlBQVk7UUFDVixLQUFLLE1BQU01RSxZQUFZLElBQUksQ0FBQ2tDLFNBQVMsQ0FBRTtZQUNyQyxJQUFJO2dCQUNGbEMsU0FBU2pFLFFBQVE7WUFDbkIsRUFBRSxPQUFPbkUsS0FBSztnQkFDWkQscUJBQXFCQztZQUN2QjtRQUNGO1FBQ0EsSUFBSSxDQUFDc0ssU0FBUyxDQUFDbk0sS0FBSztJQUN0QjtJQUNBNFAsYUFBYS9OLEdBQUcsRUFBRTtRQUNoQixJQUFJLENBQUMsSUFBSSxDQUFDc0ssU0FBUyxDQUFDdEMsSUFBSSxFQUFFO1lBQ3hCLElBQUksQ0FBQyxJQUFJLENBQUMwQyxPQUFPLEVBQUU7Z0JBQ2pCM0sscUJBQXFCQztZQUN2QjtZQUNBO1FBQ0Y7UUFDQSxJQUFJZ08sY0FBYztRQUNsQixLQUFLLE1BQU01RixZQUFZLElBQUksQ0FBQ2tDLFNBQVMsQ0FBRTtZQUNyQyxNQUFNOEMsZ0JBQWdCaEYsU0FBU3hJLEtBQUs7WUFDcENvTyxnQkFBZ0IsQ0FBQ1o7WUFDakIsSUFBSTtnQkFDRkEsZ0JBQWdCcE47WUFDbEIsRUFBRSxPQUFPaU8sTUFBTTtnQkFDYmxPLHFCQUFxQmtPO1lBQ3ZCO1FBQ0Y7UUFDQSxJQUFJLENBQUMzRCxTQUFTLENBQUNuTSxLQUFLO1FBQ3BCLElBQUk2UCxhQUFhO1lBQ2ZqTyxxQkFBcUJDO1FBQ3ZCO0lBQ0Y7SUFDQWlOLE9BQU9qTixHQUFHLEVBQUU7UUFDVixJQUFJLENBQUMrTSxjQUFjO1FBQ25CLElBQUksQ0FBQ2dCLFlBQVksQ0FBQy9OO1FBQ2xCLElBQUksSUFBSSxDQUFDMEssT0FBTyxFQUFFO1lBQ2hCLElBQUksQ0FBQ25ELE1BQU0sQ0FBQ0ksTUFBTSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMrQyxPQUFPLEVBQUUvSyxzQkFBc0IsSUFBSSxDQUFDUCxFQUFFLEVBQUVZO1FBQ3hFO0lBQ0Y7SUFDQSwyREFBMkQ7SUFDM0QsK0NBQStDO0lBQy9DLHdEQUF3RDtJQUN4RCxvRUFBb0U7SUFDcEUsa0VBQWtFO0lBQ2xFK00saUJBQWlCO1FBQ2YsSUFBSSxJQUFJLENBQUN2QyxpQkFBaUIsS0FBS1gsaUJBQWlCdUMsT0FBTyxFQUFFO1lBQ3ZELG9DQUFvQztZQUNwQyxPQUFPLElBQUk7UUFDYjtRQUVBLDRCQUE0QjtRQUM1QixJQUFJLENBQUM3RSxNQUFNLENBQUNaLFNBQVMsQ0FBQ21CLFNBQVMsQ0FBQyxJQUFJO1FBRXBDLHNCQUFzQjtRQUN0QixJQUFJLENBQUN1QyxPQUFPLENBQUNsTSxLQUFLO1FBQ2xCLDBFQUEwRTtRQUMxRSxpREFBaUQ7UUFDakQsNEVBQTRFO1FBQzVFLDREQUE0RDtRQUM1RCxJQUFJLENBQUNrTSxPQUFPLEdBQUcsSUFBSTFNLFFBQVEsSUFBSSxDQUFDRSxRQUFRLENBQUNxRyxJQUFJLENBQUMsSUFBSTtRQUNsRCxJQUFJLENBQUNzRyxpQkFBaUIsR0FBR1gsaUJBQWlCeUQsT0FBTztRQUNqRCxJQUFJLENBQUMvRixNQUFNLENBQUNpQixXQUFXLENBQUMsSUFBSTtRQUM1QixPQUFPLElBQUk7SUFDYjtJQUVBLGNBQWMsR0FDZGEsTUFBTS9LLEtBQUssRUFBRTtRQUNYLElBQUksSUFBSSxDQUFDa00saUJBQWlCLEtBQUtYLGlCQUFpQnlELE9BQU8sRUFBRTtZQUN2RCxhQUFhO1lBQ2I7Z0JBQ0UsTUFBTVksY0FBY0MsS0FBS0MsU0FBUyxDQUFDOVA7Z0JBQ25DdUUsUUFBUUMsSUFBSSxDQUFDLENBQUMsT0FBTyxFQUFFeEUsTUFBTWUsSUFBSSxDQUFDLDZCQUE2QixFQUFFLElBQUksQ0FBQ0QsRUFBRSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUN5RyxTQUFTLENBQUMscUZBQXFGLEVBQUVxSSxZQUFZLENBQUM7WUFDbE07WUFDQTtRQUNGO1FBQ0EsSUFBSSxDQUFDN0QsT0FBTyxDQUFDaE0sT0FBTyxDQUFDQztJQUN2QjtJQUVBOzs7O0dBSUMsR0FDRCtOLEtBQUsvTixLQUFLLEVBQUU7UUFDVixJQUFJLE9BQU9BLFVBQVUsVUFBVTtZQUM3QixNQUFNLElBQUl3SyxNQUFNLENBQUMsNkRBQTZELEVBQUV4SyxNQUFNLFlBQVksQ0FBQztRQUNyRztRQUNBLElBQUksQ0FBQ2lKLE1BQU0sQ0FBQ0ksTUFBTSxDQUFDdEYsV0FBVyxJQUFJLEVBQUUvRDtJQUN0QztJQUNBb1AsaUJBQWlCO1FBQ2YsTUFBTSxFQUNKeEQsUUFBUSxFQUNULEdBQUcsSUFBSSxDQUFDakUsT0FBTztRQUNoQixJQUFJaUUsVUFBVTtZQUNaLE1BQU1tRSwwQkFBMEIsT0FBT25FLGFBQWEsYUFBYUEsV0FBV3hNLG9GQUFlQTtZQUMzRjJRLHdCQUF3QixJQUFJO1FBQzlCO0lBQ0Y7SUFDQUMsU0FBUztRQUNQLE9BQU87WUFDTEMsY0FBYzNFO1lBQ2R4SyxJQUFJLElBQUksQ0FBQ0EsRUFBRTtRQUNiO0lBQ0Y7SUFFQTs7Ozs7Ozs7Ozs7O0dBWUMsR0FFRG9QLHFCQUFxQnZJLE9BQU8sRUFBRTtRQUM1QixPQUFPLElBQUksQ0FBQ21FLEtBQUssQ0FBQ29FLG9CQUFvQixDQUFDLElBQUksQ0FBQ2hILFNBQVMsRUFBRXZCO0lBQ3pEO0lBQ0EsQ0FBQy9GLGlCQUFpQixHQUFHO1FBQ25CLE9BQU8sSUFBSTtJQUNiO0lBRUE7Ozs7Ozs7Ozs7Ozs7R0FhQyxHQUNEb0osY0FBYztRQUNaLElBQUksQ0FBQyxJQUFJLENBQUM5QixTQUFTLEVBQUU7WUFDbkIsTUFBTSxJQUFJc0IsTUFBTSxDQUFDLHlEQUF5RCxDQUFDO1FBQzdFO1FBQ0EsT0FBTyxJQUFJLENBQUN0QixTQUFTO0lBQ3ZCO0FBQ0Y7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXFDQyxHQUNELFNBQVNpSCxZQUFZckUsS0FBSyxFQUFFLEdBQUcsQ0FBQ25FLFFBQVE7SUFDdEMsT0FBTyxJQUFJa0UsTUFBTUMsT0FBT25FO0FBQzFCO0FBRUE7Ozs7OztDQU1DLEdBQ0QsTUFBTXlJLFlBQVlEO0FBRWxCOzs7Q0FHQyxHQUVELFNBQVNFLGNBQWNDLENBQUMsRUFBRXZKLFFBQVEsRUFBRXdKLFVBQVUsRUFBRUMsWUFBWSxFQUFFLEVBQzVEQyxNQUFNLEVBQ1A7SUFDQyxNQUFNQyxpQkFBaUIsT0FBT0QsV0FBVyxhQUFhQSxPQUFPRixZQUFZQyxnQkFBZ0JDO0lBQ3pGLE9BQU87UUFBQzFKO1FBQVU7WUFDaEIwSixRQUFRQztRQUNWO1FBQUczTTtLQUFVO0FBQ2Y7QUFDQSxTQUFTNE0sY0FBY0MsVUFBVSxFQUFFakQsTUFBTTtJQUN2Q2lELFdBQVc5RCxLQUFLLENBQUM7UUFDZjhELFdBQVczSCxNQUFNLENBQUNaLFNBQVMsQ0FBQ2lCLE1BQU0sQ0FBQ3NILFdBQVd6TSxJQUFJLEVBQUV3SixPQUFPOEMsTUFBTTtJQUNuRTtBQUNGO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0ErQkMsR0FDRCxTQUFTbkgsT0FBT21ILE1BQU07SUFDcEIsU0FBU25ILE9BQU91SCxLQUFLLEVBQUVDLE9BQU87UUFDNUI7WUFDRSxNQUFNLElBQUl0RyxNQUFNLENBQUMsZ0NBQWdDLENBQUM7UUFDcEQ7SUFDRjtJQUNBbEIsT0FBT3ZJLElBQUksR0FBRztJQUNkdUksT0FBT21ILE1BQU0sR0FBR0E7SUFDaEJuSCxPQUFPeUgsT0FBTyxHQUFHVjtJQUNqQi9HLE9BQU8wSCxPQUFPLEdBQUdMO0lBQ2pCLE9BQU9ySDtBQUNUO0FBRUEsU0FBUzJILGFBQWFMLFVBQVUsRUFBRTdKLFFBQVEsRUFBRXdKLFVBQVUsRUFBRVcsYUFBYSxFQUFFLEVBQ3JFcFEsRUFBRSxFQUNGc0osUUFBUSxFQUNSakUsR0FBRyxFQUNIM0UsS0FBSyxFQUNMcUwsWUFBWSxFQUNiO0lBQ0MsTUFBTWYsUUFBUSxPQUFPM0YsUUFBUSxXQUFXRix1QkFBdUJjLFNBQVNiLE9BQU8sRUFBRUMsT0FBT0E7SUFDeEYsTUFBTWdMLGFBQWEsT0FBT3JRLE9BQU8sYUFBYUEsR0FBR3lQLGNBQWN6UDtJQUMvRCxJQUFJd0c7SUFDSixJQUFJOEosZ0JBQWdCck47SUFDcEIsSUFBSStILE9BQU87UUFDVHNGLGdCQUFnQixPQUFPNVAsVUFBVSxhQUFhQSxNQUFNO1lBQ2xEMEMsU0FBUzZDLFNBQVM3QyxPQUFPO1lBQ3pCbEUsT0FBT3VRLFdBQVd2USxLQUFLO1lBQ3ZCbUUsTUFBTXlNLFdBQVd6TSxJQUFJO1FBQ3ZCLEtBQUszQztRQUNMOEYsV0FBVzZJLFlBQVlyRSxPQUFPO1lBQzVCaEwsSUFBSXFRO1lBQ0poTDtZQUNBeUcsUUFBUWdFLFdBQVd6TSxJQUFJO1lBQ3ZCMEk7WUFDQXpDO1lBQ0E1SSxPQUFPNFA7UUFDVDtJQUNGO0lBQ0EsSUFBSSxDQUFDOUosVUFBVTtRQUNiL0MsUUFBUUMsSUFBSSxDQUNaLGlIQUFpSDtRQUNqSCxDQUFDLFlBQVksRUFBRTJCLElBQUksd0JBQXdCLEVBQUV5SyxXQUFXOVAsRUFBRSxDQUFDLEVBQUUsQ0FBQztJQUNoRTtJQUNBLE9BQU87UUFBQ3VRLHFCQUFxQnRLLFVBQVU7WUFDckNhLFVBQVU7Z0JBQ1IsR0FBR2IsU0FBU2EsUUFBUTtnQkFDcEIsQ0FBQ3VKLFdBQVcsRUFBRTdKO1lBQ2hCO1FBQ0Y7UUFBSTtZQUNGeEc7WUFDQXNKO1lBQ0E5QztZQUNBbkI7WUFDQTNFLE9BQU80UDtRQUNUO1FBQUdyTjtLQUFVO0FBQ2Y7QUFDQSxTQUFTdU4sYUFBYVYsVUFBVSxFQUFFLEVBQ2hDdEosUUFBUSxFQUNUO0lBQ0MsSUFBSSxDQUFDQSxVQUFVO1FBQ2I7SUFDRjtJQUNBc0osV0FBVzlELEtBQUssQ0FBQztRQUNmLElBQUl4RixTQUFTNEUsaUJBQWlCLEtBQUtYLGlCQUFpQnlELE9BQU8sRUFBRTtZQUMzRDtRQUNGO1FBQ0ExSCxTQUFTM0gsS0FBSztJQUNoQjtBQUNGO0FBQ0EsU0FBUzRSLFdBQVcsR0FBRyxDQUFDcEwsS0FBSyxFQUMzQnJGLEVBQUUsRUFDRnNKLFFBQVEsRUFDUjVJLEtBQUssRUFDTHFMLGVBQWUsS0FBSyxFQUNyQixHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ0wsU0FBUzBFLFlBQVdWLEtBQUssRUFBRUMsT0FBTztRQUNoQztZQUNFLE1BQU0sSUFBSXRHLE1BQU0sQ0FBQyxnQ0FBZ0MsQ0FBQztRQUNwRDtJQUNGO0lBQ0ErRyxZQUFXeFEsSUFBSSxHQUFHO0lBQ2xCd1EsWUFBV3pRLEVBQUUsR0FBR0E7SUFDaEJ5USxZQUFXbkgsUUFBUSxHQUFHQTtJQUN0Qm1ILFlBQVdwTCxHQUFHLEdBQUdBO0lBQ2pCb0wsWUFBVy9QLEtBQUssR0FBR0E7SUFDbkIrUCxZQUFXMUUsWUFBWSxHQUFHQTtJQUMxQjBFLFlBQVdSLE9BQU8sR0FBR0U7SUFDckJNLFlBQVdQLE9BQU8sR0FBR007SUFDckIsT0FBT0M7QUFDVDtBQUVBLFNBQVNDLFlBQVlsQixDQUFDLEVBQUV2SixRQUFRLEVBQUUwSyxJQUFJLEVBQUVqQixZQUFZLEVBQUUsRUFDcERsSixRQUFRLEVBQ1Q7SUFDQyxNQUFNb0ssbUJBQW1CLE9BQU9wSyxhQUFhLGFBQWFBLFNBQVNtSyxNQUFNakIsZ0JBQWdCbEo7SUFDekYsTUFBTXFLLG1CQUFtQixPQUFPRCxxQkFBcUIsV0FBVzNLLFNBQVNhLFFBQVEsQ0FBQzhKLGlCQUFpQixHQUFHQTtJQUN0RyxJQUFJOUosV0FBV2IsU0FBU2EsUUFBUTtJQUNoQyxJQUFJK0osa0JBQWtCO1FBQ3BCL0osV0FBVztZQUNULEdBQUdBLFFBQVE7UUFDYjtRQUNBLE9BQU9BLFFBQVEsQ0FBQytKLGlCQUFpQjdRLEVBQUUsQ0FBQztJQUN0QztJQUNBLE9BQU87UUFBQ3VRLHFCQUFxQnRLLFVBQVU7WUFDckNhO1FBQ0Y7UUFBSStKO1FBQWtCNU47S0FBVTtBQUNsQztBQUNBLFNBQVM2TixZQUFZaEIsVUFBVSxFQUFFdEosUUFBUTtJQUN2QyxJQUFJLENBQUNBLFVBQVU7UUFDYjtJQUNGO0lBRUEsNEdBQTRHO0lBQzVHLHdHQUF3RztJQUN4RyxrR0FBa0c7SUFDbEdzSixXQUFXM0gsTUFBTSxDQUFDaUIsV0FBVyxDQUFDNUM7SUFFOUIscUdBQXFHO0lBQ3JHLDRHQUE0RztJQUM1RyxJQUFJQSxTQUFTNEUsaUJBQWlCLEtBQUtYLGlCQUFpQnVDLE9BQU8sRUFBRTtRQUMzRDhDLFdBQVc3RCxTQUFTLENBQUN6RjtRQUNyQjtJQUNGO0lBQ0Esc0VBQXNFO0lBQ3RFLDBGQUEwRjtJQUMxRixvSEFBb0g7SUFDcEgsMkNBQTJDO0lBQzNDc0osV0FBVzlELEtBQUssQ0FBQztRQUNmOEQsV0FBVzdELFNBQVMsQ0FBQ3pGO0lBQ3ZCO0FBQ0Y7QUFDQTs7OztDQUlDLEdBQ0QsU0FBU3lGLFVBQVV6RixRQUFRO0lBQ3pCLFNBQVNrSSxLQUFLcUIsS0FBSyxFQUFFQyxPQUFPO1FBQzFCO1lBQ0UsTUFBTSxJQUFJdEcsTUFBTSxDQUFDLGdDQUFnQyxDQUFDO1FBQ3BEO0lBQ0Y7SUFDQWdGLEtBQUt6TyxJQUFJLEdBQUc7SUFDWnlPLEtBQUtsSSxRQUFRLEdBQUdBO0lBQ2hCa0ksS0FBS3VCLE9BQU8sR0FBR1M7SUFDZmhDLEtBQUt3QixPQUFPLEdBQUdZO0lBQ2YsT0FBT3BDO0FBQ1Q7QUFFQTs7Ozs7Q0FLQyxHQUNELE1BQU1BLE9BQU96QztBQUViLFNBQVM4RSxhQUFhOUssUUFBUSxFQUFFdUosQ0FBQyxFQUFFLEVBQ2pDbk4sVUFBVSxFQUNYO0lBQ0MsSUFBSSxPQUFPQSxlQUFlLFlBQVkyTyxVQUFVM08sYUFBYTtRQUMzRCxNQUFNa0MsU0FBUzBCLFNBQVNiLE9BQU8sQ0FBQ1EsZ0JBQWdCLENBQUN2RDtRQUNqRCxPQUFPNEQsU0FBU0UsTUFBTSxDQUFDNUMsSUFBSSxDQUFDOEMsQ0FBQUEsS0FBTUEsT0FBTzlCO0lBQzNDO0lBQ0EsT0FBTzBCLFNBQVNnTCxPQUFPLENBQUM1TztBQUMxQjtBQUNBLFNBQVM2TyxRQUFRN08sVUFBVTtJQUN6QixTQUFTNk87UUFDUDtZQUNFLE1BQU0sSUFBSXhILE1BQU0sQ0FBQyxnQ0FBZ0MsQ0FBQztRQUNwRDtJQUNGO0lBQ0F3SCxRQUFRQyxLQUFLLEdBQUdKO0lBQ2hCRyxRQUFRN08sVUFBVSxHQUFHQTtJQUNyQixPQUFPNk87QUFDVDtBQUNBLFNBQVNFLFNBQVNuTCxRQUFRLEVBQUUsRUFDMUI3QyxPQUFPLEVBQ1BsRSxLQUFLLEVBQ04sRUFBRSxFQUNEbVMsTUFBTSxFQUNQO0lBQ0MsT0FBTyxDQUFDQyxjQUFjRCxNQUFNLENBQUMsRUFBRSxFQUFFak8sU0FBU2xFLE9BQU8rRztBQUNuRDtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBNEJDLEdBQ0QsU0FBU3NMLElBQUlDLEtBQUs7SUFDaEIsU0FBU0QsSUFBSXhCLEtBQUssRUFBRUMsT0FBTztRQUN6QjtZQUNFLE1BQU0sSUFBSXRHLE1BQU0sQ0FBQyxnQ0FBZ0MsQ0FBQztRQUNwRDtJQUNGO0lBQ0E2SCxJQUFJSixLQUFLLEdBQUdDO0lBQ1pHLElBQUlGLE1BQU0sR0FBRztRQUFDRztLQUFNO0lBQ3BCLE9BQU9EO0FBQ1Q7QUFDQSxTQUFTRSxTQUFTeEwsUUFBUSxFQUFFLEVBQzFCN0MsT0FBTyxFQUNQbEUsS0FBSyxFQUNOLEVBQUUsRUFDRG1TLE1BQU0sRUFDUDtJQUNDLE9BQU9BLE9BQU81UCxLQUFLLENBQUMrUCxDQUFBQSxRQUFTRixjQUFjRSxPQUFPcE8sU0FBU2xFLE9BQU8rRztBQUNwRTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBNEJDLEdBQ0QsU0FBU3lMLElBQUlMLE1BQU07SUFDakIsU0FBU0ssSUFBSTNCLEtBQUssRUFBRUMsT0FBTztRQUN6QjtZQUNFLE1BQU0sSUFBSXRHLE1BQU0sQ0FBQyxnQ0FBZ0MsQ0FBQztRQUNwRDtJQUNGO0lBQ0FnSSxJQUFJUCxLQUFLLEdBQUdNO0lBQ1pDLElBQUlMLE1BQU0sR0FBR0E7SUFDYixPQUFPSztBQUNUO0FBQ0EsU0FBU0MsUUFBUTFMLFFBQVEsRUFBRSxFQUN6QjdDLE9BQU8sRUFDUGxFLEtBQUssRUFDTixFQUFFLEVBQ0RtUyxNQUFNLEVBQ1A7SUFDQyxPQUFPQSxPQUFPOU4sSUFBSSxDQUFDaU8sQ0FBQUEsUUFBU0YsY0FBY0UsT0FBT3BPLFNBQVNsRSxPQUFPK0c7QUFDbkU7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTRCQyxHQUNELFNBQVMyTCxHQUFHUCxNQUFNO0lBQ2hCLFNBQVNPLEdBQUc3QixLQUFLLEVBQUVDLE9BQU87UUFDeEI7WUFDRSxNQUFNLElBQUl0RyxNQUFNLENBQUMsZ0NBQWdDLENBQUM7UUFDcEQ7SUFDRjtJQUNBa0ksR0FBR1QsS0FBSyxHQUFHUTtJQUNYQyxHQUFHUCxNQUFNLEdBQUdBO0lBQ1osT0FBT087QUFDVDtBQUVBLHVEQUF1RDtBQUN2RCxTQUFTTixjQUFjRSxLQUFLLEVBQUVwTyxPQUFPLEVBQUVsRSxLQUFLLEVBQUUrRyxRQUFRO0lBQ3BELE1BQU0sRUFDSmIsT0FBTyxFQUNSLEdBQUdhO0lBQ0osTUFBTTRMLFdBQVcsT0FBT0wsVUFBVTtJQUNsQyxNQUFNTSxXQUFXRCxXQUFXTCxRQUFRcE0sUUFBUUcsZUFBZSxDQUFDOEwsTUFBTSxDQUFDLE9BQU9HLFVBQVUsV0FBV0EsUUFBUUEsTUFBTXZSLElBQUksQ0FBQztJQUNsSCxJQUFJLENBQUM0UixZQUFZLENBQUNDLFVBQVU7UUFDMUIsTUFBTSxJQUFJcEksTUFBTSxDQUFDLE9BQU8sRUFBRSxPQUFPOEgsVUFBVSxXQUFXQSxRQUFRQSxNQUFNdlIsSUFBSSxDQUFDLHVCQUF1QixDQUFDO0lBQ25HO0lBQ0EsSUFBSSxPQUFPNlIsYUFBYSxZQUFZO1FBQ2xDLE9BQU9SLGNBQWNRLFVBQVUxTyxTQUFTbEUsT0FBTytHO0lBQ2pEO0lBQ0EsTUFBTThMLFlBQVk7UUFDaEIzTztRQUNBbEU7SUFDRjtJQUNBLE1BQU04UyxjQUFjSCxZQUFZLE9BQU9MLFVBQVUsV0FBV3ZPLFlBQVksWUFBWXVPLFFBQVEsT0FBT0EsTUFBTTNFLE1BQU0sS0FBSyxhQUFhMkUsTUFBTTNFLE1BQU0sQ0FBQztRQUM1SXpKO1FBQ0FsRTtJQUNGLEtBQUtzUyxNQUFNM0UsTUFBTSxHQUFHNUo7SUFDcEIsSUFBSSxDQUFFLFlBQVc2TyxRQUFPLEdBQUk7UUFDMUIseUVBQXlFO1FBQ3pFLG1FQUFtRTtRQUNuRSw4RkFBOEY7UUFDOUYsT0FBT0EsU0FBU0MsV0FBV0M7SUFDN0I7SUFDQSxNQUFNQyxlQUFlSDtJQUNyQixPQUFPRyxhQUFhZCxLQUFLLENBQUNsTCxVQUFVOEwsV0FBV0QsU0FBUyx3QkFBd0I7O0FBRWxGO0FBRUEsTUFBTUksb0JBQW9CQyxDQUFBQSxZQUFhQSxVQUFVbFMsSUFBSSxLQUFLLFlBQVlrUyxVQUFVbFMsSUFBSSxLQUFLO0FBQ3pGLFNBQVNtUyxZQUFZRCxTQUFTO0lBQzVCLE9BQU81USxPQUFPK0IsTUFBTSxDQUFDNk8sVUFBVUUsTUFBTSxFQUFFek8sTUFBTSxDQUFDeUMsQ0FBQUEsS0FBTUEsR0FBR3BHLElBQUksS0FBSztBQUNsRTtBQUNBLFNBQVNxUyxtQkFBbUJILFNBQVMsRUFBRUksV0FBVztJQUNoRCxNQUFNQyxZQUFZLEVBQUU7SUFDcEIsSUFBSUQsZ0JBQWdCSixXQUFXO1FBQzdCLE9BQU9LO0lBQ1Q7SUFFQSxvQkFBb0I7SUFDcEIsSUFBSUMsSUFBSU4sVUFBVXJHLE1BQU07SUFDeEIsTUFBTzJHLEtBQUtBLE1BQU1GLFlBQWE7UUFDN0JDLFVBQVVwUSxJQUFJLENBQUNxUTtRQUNmQSxJQUFJQSxFQUFFM0csTUFBTTtJQUNkO0lBQ0EsT0FBTzBHO0FBQ1Q7QUFDQSxTQUFTRSxpQkFBaUJDLFVBQVU7SUFDbEMsTUFBTUMsVUFBVSxJQUFJMU0sSUFBSXlNO0lBQ3hCLE1BQU1FLFVBQVVDLFdBQVdGO0lBRTNCLGtCQUFrQjtJQUNsQixLQUFLLE1BQU1HLEtBQUtILFFBQVM7UUFDdkIsaURBQWlEO1FBQ2pELElBQUlHLEVBQUU5UyxJQUFJLEtBQUssY0FBZSxFQUFDNFMsUUFBUXRKLEdBQUcsQ0FBQ3dKLE1BQU0sQ0FBQ0YsUUFBUXRKLEdBQUcsQ0FBQ3dKLEdBQUc5USxNQUFNLEdBQUc7WUFDeEUrUSx1Q0FBdUNELEdBQUdoSyxPQUFPLENBQUMxQyxDQUFBQSxLQUFNdU0sUUFBUS9JLEdBQUcsQ0FBQ3hEO1FBQ3RFLE9BQU87WUFDTCxJQUFJME0sRUFBRTlTLElBQUksS0FBSyxZQUFZO2dCQUN6QixLQUFLLE1BQU1pTSxTQUFTa0csWUFBWVcsR0FBSTtvQkFDbEMsSUFBSTdHLE1BQU1qTSxJQUFJLEtBQUssV0FBVzt3QkFDNUI7b0JBQ0Y7b0JBQ0EsSUFBSSxDQUFDMlMsUUFBUUssR0FBRyxDQUFDL0csUUFBUTt3QkFDdkIsTUFBTWdILGdCQUFnQkYsdUNBQXVDOUc7d0JBQzdELEtBQUssTUFBTWlILG9CQUFvQkQsY0FBZTs0QkFDNUNOLFFBQVEvSSxHQUFHLENBQUNzSjt3QkFDZDtvQkFDRjtnQkFDRjtZQUNGO1FBQ0Y7SUFDRjtJQUVBLG9CQUFvQjtJQUNwQixLQUFLLE1BQU1KLEtBQUtILFFBQVM7UUFDdkIsSUFBSUgsSUFBSU0sRUFBRWpILE1BQU07UUFDaEIsTUFBTzJHLEVBQUc7WUFDUkcsUUFBUS9JLEdBQUcsQ0FBQzRJO1lBQ1pBLElBQUlBLEVBQUUzRyxNQUFNO1FBQ2Q7SUFDRjtJQUNBLE9BQU84RztBQUNUO0FBQ0EsU0FBU1EsZ0JBQWdCQyxRQUFRLEVBQUVSLE9BQU87SUFDeEMsTUFBTVMsa0JBQWtCVCxRQUFRdEosR0FBRyxDQUFDOEo7SUFDcEMsSUFBSSxDQUFDQyxpQkFBaUI7UUFDcEIsT0FBTyxDQUFDLEdBQUcsYUFBYTtJQUMxQjtJQUNBLElBQUlELFNBQVNwVCxJQUFJLEtBQUssWUFBWTtRQUNoQyxNQUFNc1QsaUJBQWlCRCxlQUFlLENBQUMsRUFBRTtRQUN6QyxJQUFJQyxnQkFBZ0I7WUFDbEIsSUFBSXJCLGtCQUFrQnFCLGlCQUFpQjtnQkFDckMsT0FBT0EsZUFBZTdSLEdBQUc7WUFDM0I7UUFDRixPQUFPO1lBQ0wsT0FBTyxDQUFDO1FBQ1Y7SUFDRjtJQUNBLE1BQU1XLGFBQWEsQ0FBQztJQUNwQixLQUFLLE1BQU1rUixrQkFBa0JELGdCQUFpQjtRQUM1Q2pSLFVBQVUsQ0FBQ2tSLGVBQWU3UixHQUFHLENBQUMsR0FBRzBSLGdCQUFnQkcsZ0JBQWdCVjtJQUNuRTtJQUNBLE9BQU94UTtBQUNUO0FBQ0EsU0FBU3lRLFdBQVdILFVBQVU7SUFDNUIsTUFBTUUsVUFBVSxJQUFJOUw7SUFDcEIsS0FBSyxNQUFNZ00sS0FBS0osV0FBWTtRQUMxQixJQUFJLENBQUNFLFFBQVFJLEdBQUcsQ0FBQ0YsSUFBSTtZQUNuQkYsUUFBUTFKLEdBQUcsQ0FBQzRKLEdBQUcsRUFBRTtRQUNuQjtRQUNBLElBQUlBLEVBQUVqSCxNQUFNLEVBQUU7WUFDWixJQUFJLENBQUMrRyxRQUFRSSxHQUFHLENBQUNGLEVBQUVqSCxNQUFNLEdBQUc7Z0JBQzFCK0csUUFBUTFKLEdBQUcsQ0FBQzRKLEVBQUVqSCxNQUFNLEVBQUUsRUFBRTtZQUMxQjtZQUNBK0csUUFBUXRKLEdBQUcsQ0FBQ3dKLEVBQUVqSCxNQUFNLEVBQUUxSixJQUFJLENBQUMyUTtRQUM3QjtJQUNGO0lBQ0EsT0FBT0Y7QUFDVDtBQUNBLFNBQVNXLGNBQWNDLFFBQVEsRUFBRWQsVUFBVTtJQUN6QyxNQUFNN00sU0FBUzRNLGlCQUFpQkM7SUFDaEMsT0FBT1MsZ0JBQWdCSyxVQUFVWCxXQUFXaE47QUFDOUM7QUFDQSxTQUFTNE4sZUFBZUMsWUFBWSxFQUFFeEIsU0FBUztJQUM3QyxJQUFJQSxVQUFVbFMsSUFBSSxLQUFLLFlBQVk7UUFDakMsT0FBT21TLFlBQVlELFdBQVc1TyxJQUFJLENBQUN3UCxDQUFBQSxJQUFLQSxFQUFFOVMsSUFBSSxLQUFLLFdBQVcwVCxhQUFhVixHQUFHLENBQUNGO0lBQ2pGO0lBQ0EsSUFBSVosVUFBVWxTLElBQUksS0FBSyxZQUFZO1FBQ2pDLE9BQU9tUyxZQUFZRCxXQUFXMVEsS0FBSyxDQUFDNEUsQ0FBQUEsS0FBTXFOLGVBQWVDLGNBQWN0TjtJQUN6RTtJQUNBLE9BQU84TCxVQUFVbFMsSUFBSSxLQUFLO0FBQzVCO0FBQ0EsTUFBTStRLFlBQVk0QyxDQUFBQSxNQUFPQSxHQUFHLENBQUMsRUFBRSxLQUFLblU7QUFDcEMsU0FBU29VLGNBQWMxQixTQUFTLEVBQUUyQixpQkFBaUI7SUFDakQsTUFBTUMsYUFBYTVCLFVBQVU2QixXQUFXLENBQUN6SyxHQUFHLENBQUN1SyxzQkFBc0I7V0FBSTNCLFVBQVU2QixXQUFXLENBQUN4UyxJQUFJO0tBQUcsQ0FBQ29DLE1BQU0sQ0FBQ3FRLENBQUFBO1FBQzFHLGdEQUFnRDtRQUNoRCx5Q0FBeUM7UUFDekMsSUFBSUEsb0JBQW9CdlUsVUFBVTtZQUNoQyxPQUFPO1FBQ1Q7UUFDQSxJQUFJLENBQUN1VSxnQkFBZ0JDLFFBQVEsQ0FBQyxPQUFPO1lBQ25DLE9BQU87UUFDVDtRQUNBLElBQUksU0FBU0MsSUFBSSxDQUFDRixrQkFBa0I7WUFDbEN4USxRQUFRQyxJQUFJLENBQUMsQ0FBQywrSEFBK0gsRUFBRXVRLGdCQUFnQixRQUFRLENBQUM7UUFDMUs7UUFDQSxNQUFNRyxxQkFBcUJILGdCQUFnQkksS0FBSyxDQUFDO1FBQ2pELE1BQU1DLGNBQWNSLGtCQUFrQk8sS0FBSyxDQUFDO1FBQzVDLElBQUssSUFBSUUsYUFBYSxHQUFHQSxhQUFhSCxtQkFBbUJuUyxNQUFNLEVBQUVzUyxhQUFjO1lBQzdFLE1BQU1DLG9CQUFvQkosa0JBQWtCLENBQUNHLFdBQVc7WUFDeEQsTUFBTUUsYUFBYUgsV0FBVyxDQUFDQyxXQUFXO1lBQzFDLElBQUlDLHNCQUFzQixLQUFLO2dCQUM3QixNQUFNRSxjQUFjSCxlQUFlSCxtQkFBbUJuUyxNQUFNLEdBQUc7Z0JBQy9ELElBQUksQ0FBQ3lTLGFBQWE7b0JBQ2hCalIsUUFBUUMsSUFBSSxDQUFDLENBQUMsaUVBQWlFLEVBQUV1USxnQkFBZ0IsYUFBYSxDQUFDO2dCQUNqSDtnQkFDQSxPQUFPUztZQUNUO1lBQ0EsSUFBSUYsc0JBQXNCQyxZQUFZO2dCQUNwQyxPQUFPO1lBQ1Q7UUFDRjtRQUNBLE9BQU87SUFDVCxHQUFHRSxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUEsRUFBRTVTLE1BQU0sR0FBRzJTLEVBQUUzUyxNQUFNLEVBQUVtRSxPQUFPLENBQUMxRSxDQUFBQSxNQUFPeVEsVUFBVTZCLFdBQVcsQ0FBQ3pLLEdBQUcsQ0FBQzdIO0lBQ2hGLE9BQU9xUztBQUNUO0FBRUEsNkNBQTZDLEdBQzdDLFNBQVNlLHNCQUFzQjNDLFNBQVM7SUFDdEMsTUFBTTRDLGNBQWM1QyxVQUFVck0sTUFBTSxDQUFDa1AsS0FBSztJQUMxQyxJQUFJLENBQUNELGFBQWE7UUFDaEIsT0FBTyxFQUFFO0lBQ1g7SUFDQSxNQUFNRSxrQkFBa0J2TixDQUFBQTtRQUN0QixNQUFNd04sYUFBYXBWLGlCQUFpQjRILE9BQU95SyxVQUFVblMsRUFBRTtRQUN2RCxNQUFNbVYsWUFBWUQsV0FBV2pWLElBQUk7UUFDakNrUyxVQUFVaUQsS0FBSyxDQUFDaFQsSUFBSSxDQUFDaVQsTUFBTUgsWUFBWTtZQUNyQ2xWLElBQUltVjtZQUNKek47UUFDRjtRQUNBeUssVUFBVW1ELElBQUksQ0FBQ2xULElBQUksQ0FBQ29HLE9BQU8yTTtRQUMzQixPQUFPQTtJQUNUO0lBQ0EsTUFBTUkscUJBQXFCaFUsT0FBT0MsSUFBSSxDQUFDdVQsYUFBYTNPLE9BQU8sQ0FBQ3NCLENBQUFBO1FBQzFELE1BQU04TixtQkFBbUJULFdBQVcsQ0FBQ3JOLE1BQU07UUFDM0MsTUFBTStOLHFCQUFxQixPQUFPRCxxQkFBcUIsV0FBVztZQUNoRWpSLFFBQVFpUjtRQUNWLElBQUlBO1FBQ0osTUFBTUUsZ0JBQWdCQyxPQUFPQyxLQUFLLENBQUMsQ0FBQ2xPLFNBQVNBLFFBQVEsQ0FBQ0E7UUFDdEQsTUFBTXlOLFlBQVlGLGdCQUFnQlM7UUFDbEMsT0FBTzFTLFFBQVF5UyxvQkFBb0I1UixHQUFHLENBQUM0SyxDQUFBQSxhQUFlO2dCQUNwRCxHQUFHQSxVQUFVO2dCQUNidlAsT0FBT2lXO2dCQUNQek4sT0FBT2dPO1lBQ1Q7SUFDRjtJQUNBLE9BQU9ILG1CQUFtQjFSLEdBQUcsQ0FBQ2dTLENBQUFBO1FBQzVCLE1BQU0sRUFDSm5PLEtBQUssRUFDTixHQUFHbU87UUFDSixPQUFPO1lBQ0wsR0FBR0MsaUJBQWlCM0QsV0FBVzBELGtCQUFrQjNXLEtBQUssRUFBRTJXLGtCQUFrQjtZQUMxRW5PO1FBQ0Y7SUFDRjtBQUNGO0FBQ0EsU0FBU29PLGlCQUFpQjNELFNBQVMsRUFBRTRELFVBQVUsRUFBRUMsZ0JBQWdCO0lBQy9ELE1BQU1DLG1CQUFtQnpSLGdCQUFnQndSLGlCQUFpQnpSLE1BQU07SUFDaEUsTUFBTTJSLFVBQVVGLGlCQUFpQkUsT0FBTyxJQUFJO0lBQzVDLE1BQU0zUixTQUFTNFIsY0FBY2hFLFdBQVc4RDtJQUV4QyxvREFBb0Q7SUFDcEQsSUFBSUQsaUJBQWlCSSxJQUFJLEVBQUU7UUFDekIsTUFBTSxJQUFJMU0sTUFBTSxDQUFDLE9BQU8sRUFBRXlJLFVBQVVuUyxFQUFFLENBQUMseUhBQXlILENBQUM7SUFDbks7SUFDQSxNQUFNeU8sYUFBYTtRQUNqQixHQUFHdUgsZ0JBQWdCO1FBQ25CSyxTQUFTclQsUUFBUWdULGlCQUFpQkssT0FBTztRQUN6QzdFLE9BQU93RSxpQkFBaUJ4RSxLQUFLO1FBQzdCak47UUFDQWtELFFBQVEwSztRQUNSK0Q7UUFDQWYsV0FBV1k7UUFDWDdHLFFBQVEsSUFBTztnQkFDYixHQUFHVCxVQUFVO2dCQUNiaEgsUUFBUSxDQUFDLENBQUMsRUFBRTBLLFVBQVVuUyxFQUFFLENBQUMsQ0FBQztnQkFDMUJ1RSxRQUFRQSxTQUFTQSxPQUFPVixHQUFHLENBQUN5UyxDQUFBQSxJQUFLLENBQUMsQ0FBQyxFQUFFQSxFQUFFdFcsRUFBRSxDQUFDLENBQUMsSUFBSWlEO1lBQ2pEO0lBQ0Y7SUFDQSxPQUFPd0w7QUFDVDtBQUNBLFNBQVM4SCxrQkFBa0JwRSxTQUFTO0lBQ2xDLE1BQU02QixjQUFjLElBQUlqTjtJQUN4QixJQUFJb0wsVUFBVXJNLE1BQU0sQ0FBQ3FJLEVBQUUsRUFBRTtRQUN2QixLQUFLLE1BQU00SCxjQUFjeFUsT0FBT0MsSUFBSSxDQUFDMlEsVUFBVXJNLE1BQU0sQ0FBQ3FJLEVBQUUsRUFBRztZQUN6RCxJQUFJNEgsZUFBZXZXLFlBQVk7Z0JBQzdCLE1BQU0sSUFBSWtLLE1BQU07WUFDbEI7WUFDQSxNQUFNOE0sb0JBQW9CckUsVUFBVXJNLE1BQU0sQ0FBQ3FJLEVBQUUsQ0FBQzRILFdBQVc7WUFDekQvQixZQUFZN0ssR0FBRyxDQUFDNE0sWUFBWTNSLHdCQUF3Qm9TLG1CQUFtQjNTLEdBQUcsQ0FBQ3lTLENBQUFBLElBQUtSLGlCQUFpQjNELFdBQVc0RCxZQUFZTztRQUMxSDtJQUNGO0lBQ0EsSUFBSW5FLFVBQVVyTSxNQUFNLENBQUMyUSxNQUFNLEVBQUU7UUFDM0IsTUFBTVYsYUFBYSxDQUFDLGtCQUFrQixFQUFFNUQsVUFBVW5TLEVBQUUsQ0FBQyxDQUFDO1FBQ3REZ1UsWUFBWTdLLEdBQUcsQ0FBQzRNLFlBQVkzUix3QkFBd0IrTixVQUFVck0sTUFBTSxDQUFDMlEsTUFBTSxFQUFFNVMsR0FBRyxDQUFDeVMsQ0FBQUEsSUFBS1IsaUJBQWlCM0QsV0FBVzRELFlBQVlPO0lBQ2hJO0lBQ0EsS0FBSyxNQUFNSSxhQUFhdkUsVUFBVXBNLE1BQU0sQ0FBRTtRQUN4QyxJQUFJMlEsVUFBVUQsTUFBTSxFQUFFO1lBQ3BCLE1BQU1WLGFBQWEsQ0FBQyxrQkFBa0IsRUFBRVcsVUFBVTFXLEVBQUUsQ0FBQyxDQUFDO1lBQ3REZ1UsWUFBWTdLLEdBQUcsQ0FBQzRNLFlBQVkzUix3QkFBd0JzUyxVQUFVRCxNQUFNLEVBQUU1UyxHQUFHLENBQUN5UyxDQUFBQSxJQUFLUixpQkFBaUIzRCxXQUFXNEQsWUFBWU87UUFDekg7UUFDQSxJQUFJSSxVQUFVQyxPQUFPLEVBQUU7WUFDckIsTUFBTVosYUFBYSxDQUFDLG1CQUFtQixFQUFFVyxVQUFVMVcsRUFBRSxDQUFDLENBQUM7WUFDdkRnVSxZQUFZN0ssR0FBRyxDQUFDNE0sWUFBWTNSLHdCQUF3QnNTLFVBQVVDLE9BQU8sRUFBRTlTLEdBQUcsQ0FBQ3lTLENBQUFBLElBQUtSLGlCQUFpQjNELFdBQVc0RCxZQUFZTztRQUMxSDtRQUNBLElBQUlJLFVBQVVFLFVBQVUsRUFBRTtZQUN4QixNQUFNYixhQUFhLENBQUMsZ0JBQWdCLEVBQUVXLFVBQVUxVyxFQUFFLENBQUMsQ0FBQztZQUNwRGdVLFlBQVk3SyxHQUFHLENBQUM0TSxZQUFZM1Isd0JBQXdCc1MsVUFBVUUsVUFBVSxFQUFFL1MsR0FBRyxDQUFDeVMsQ0FBQUEsSUFBS1IsaUJBQWlCM0QsV0FBVzRELFlBQVlPO1FBQzdIO0lBQ0Y7SUFDQSxLQUFLLE1BQU1ULHFCQUFxQjFELFVBQVU2QyxLQUFLLENBQUU7UUFDL0MsSUFBSXZMLFdBQVd1SyxZQUFZekssR0FBRyxDQUFDc00sa0JBQWtCVixTQUFTO1FBQzFELElBQUksQ0FBQzFMLFVBQVU7WUFDYkEsV0FBVyxFQUFFO1lBQ2J1SyxZQUFZN0ssR0FBRyxDQUFDME0sa0JBQWtCVixTQUFTLEVBQUUxTDtRQUMvQztRQUNBQSxTQUFTckgsSUFBSSxDQUFDeVQ7SUFDaEI7SUFDQSxPQUFPN0I7QUFDVDtBQUNBLFNBQVM2Qyx3QkFBd0IxRSxTQUFTLEVBQUUyRSxPQUFPO0lBQ2pELE1BQU1DLGlCQUFpQixPQUFPRCxZQUFZLFdBQVczRSxVQUFVRSxNQUFNLENBQUN5RSxRQUFRLEdBQUdBLFVBQVUzRSxVQUFVRSxNQUFNLENBQUN5RSxRQUFRdlMsTUFBTSxDQUFDLEdBQUd0QjtJQUM5SCxJQUFJLENBQUM4VCxrQkFBa0JELFNBQVM7UUFDOUIsTUFBTSxJQUFJcE4sTUFDVixrSEFBa0g7UUFDbEgsQ0FBQyxvQkFBb0IsRUFBRW9OLFFBQVEsa0NBQWtDLEVBQUUzRSxVQUFVblMsRUFBRSxDQUFDLENBQUM7SUFDbkY7SUFDQSxNQUFNeU8sYUFBYTtRQUNqQmhILFFBQVEwSztRQUNSa0UsU0FBUyxDQUFDUyxXQUFXLE9BQU9BLFlBQVksV0FBVyxFQUFFLEdBQUc5VCxRQUFROFQsUUFBUVQsT0FBTztRQUMvRWxCLFdBQVc7UUFDWGUsU0FBUztRQUNUM1IsUUFBUXdTLGlCQUFpQjtZQUFDQTtTQUFlLEdBQUcsRUFBRTtRQUM5QzdILFFBQVEsSUFBTztnQkFDYixHQUFHVCxVQUFVO2dCQUNiaEgsUUFBUSxDQUFDLENBQUMsRUFBRTBLLFVBQVVuUyxFQUFFLENBQUMsQ0FBQztnQkFDMUJ1RSxRQUFRd1MsaUJBQWlCO29CQUFDLENBQUMsQ0FBQyxFQUFFQSxlQUFlL1csRUFBRSxDQUFDLENBQUM7aUJBQUMsR0FBRyxFQUFFO1lBQ3pEO0lBQ0Y7SUFDQSxPQUFPeU87QUFDVDtBQUNBLFNBQVMwSCxjQUFjaEUsU0FBUyxFQUFFNkUsT0FBTztJQUN2QyxJQUFJQSxZQUFZL1QsV0FBVztRQUN6QixrSEFBa0g7UUFDbEgsT0FBT0E7SUFDVDtJQUNBLE9BQU8rVCxRQUFRblQsR0FBRyxDQUFDVSxDQUFBQTtRQUNqQixJQUFJLE9BQU9BLFdBQVcsVUFBVTtZQUM5QixPQUFPQTtRQUNUO1FBQ0EsSUFBSXlNLFVBQVV6TSxTQUFTO1lBQ3JCLE9BQU80TixVQUFVL00sT0FBTyxDQUFDUSxnQkFBZ0IsQ0FBQ3JCO1FBQzVDO1FBQ0EsTUFBTTBTLG1CQUFtQjFTLE1BQU0sQ0FBQyxFQUFFLEtBQUtqRjtRQUN2Qyw0Q0FBNEM7UUFDNUMsdUNBQXVDO1FBQ3ZDLElBQUkyWCxvQkFBb0IsQ0FBQzlFLFVBQVVyRyxNQUFNLEVBQUU7WUFDekMsT0FBT29MLG1CQUFtQi9FLFdBQVc1TixPQUFPc0QsS0FBSyxDQUFDO1FBQ3BEO1FBQ0EsTUFBTWtQLGlCQUFpQkUsbUJBQW1COUUsVUFBVXpRLEdBQUcsR0FBRzZDLFNBQVNBO1FBQ25FLElBQUk0TixVQUFVckcsTUFBTSxFQUFFO1lBQ3BCLElBQUk7Z0JBQ0YsTUFBTXFMLGtCQUFrQkQsbUJBQW1CL0UsVUFBVXJHLE1BQU0sRUFBRWlMO2dCQUM3RCxPQUFPSTtZQUNULEVBQUUsT0FBT3ZXLEtBQUs7Z0JBQ1osTUFBTSxJQUFJOEksTUFBTSxDQUFDLDhDQUE4QyxFQUFFeUksVUFBVW5TLEVBQUUsQ0FBQyxJQUFJLEVBQUVZLElBQUl3VyxPQUFPLENBQUMsQ0FBQztZQUNuRztRQUNGLE9BQU87WUFDTCxNQUFNLElBQUkxTixNQUFNLENBQUMsaUJBQWlCLEVBQUVuRixPQUFPLDJEQUEyRCxFQUFFQSxPQUFPLEVBQUUsQ0FBQztRQUNwSDtJQUNGO0FBQ0Y7QUFDQSxTQUFTOFMsZ0NBQWdDbEYsU0FBUztJQUNoRCxNQUFNOEQsbUJBQW1CelIsZ0JBQWdCMk4sVUFBVXJNLE1BQU0sQ0FBQ3ZCLE1BQU07SUFDaEUsSUFBSSxDQUFDMFIsa0JBQWtCO1FBQ3JCLE9BQU85RCxVQUFVckcsTUFBTSxDQUFDd0wsT0FBTztJQUNqQztJQUNBLE9BQU87UUFDTC9TLFFBQVEwUixpQkFBaUJwUyxHQUFHLENBQUN5UyxDQUFBQSxJQUFLLE9BQU9BLE1BQU0sV0FBV1ksbUJBQW1CL0UsVUFBVXJHLE1BQU0sRUFBRXdLLEtBQUtBO0lBQ3RHO0FBQ0Y7QUFDQSxTQUFTaUIsY0FBY3BGLFNBQVM7SUFDOUIsT0FBT0EsVUFBVWxTLElBQUksS0FBSztBQUM1QjtBQUNBLFNBQVMrUyx1Q0FBdUNiLFNBQVM7SUFDdkQsTUFBTUUsU0FBU21GLHFCQUFxQnJGO0lBQ3BDLEtBQUssTUFBTXNGLGdCQUFnQnBGLE9BQVE7UUFDakMsS0FBSyxNQUFNcUYsWUFBWXBGLG1CQUFtQm1GLGNBQWN0RixXQUFZO1lBQ2xFRSxPQUFPeEksR0FBRyxDQUFDNk47UUFDYjtJQUNGO0lBQ0EsT0FBT3JGO0FBQ1Q7QUFDQSxTQUFTbUYscUJBQXFCckYsU0FBUztJQUNyQyxNQUFNaEosTUFBTSxJQUFJakQ7SUFDaEIsU0FBU3lSLEtBQUtDLGFBQWE7UUFDekIsSUFBSXpPLElBQUk4SixHQUFHLENBQUMyRSxnQkFBZ0I7WUFDMUI7UUFDRjtRQUNBek8sSUFBSVUsR0FBRyxDQUFDK047UUFDUixJQUFJQSxjQUFjM1gsSUFBSSxLQUFLLFlBQVk7WUFDckMwWCxLQUFLQyxjQUFjTixPQUFPLENBQUMvUyxNQUFNLENBQUMsRUFBRTtRQUN0QyxPQUFPLElBQUlxVCxjQUFjM1gsSUFBSSxLQUFLLFlBQVk7WUFDNUMsS0FBSyxNQUFNaU0sU0FBU2tHLFlBQVl3RixlQUFnQjtnQkFDOUNELEtBQUt6TDtZQUNQO1FBQ0Y7SUFDRjtJQUNBeUwsS0FBS3hGO0lBQ0wsT0FBT2hKO0FBQ1Q7QUFDQSwwRUFBMEUsR0FDMUUsU0FBUzBPLGFBQWExRixTQUFTLEVBQUUyRixRQUFRO0lBQ3ZDLElBQUk5RyxVQUFVOEcsV0FBVztRQUN2QixPQUFPM0YsVUFBVS9NLE9BQU8sQ0FBQ1EsZ0JBQWdCLENBQUNrUztJQUM1QztJQUNBLElBQUksQ0FBQzNGLFVBQVVFLE1BQU0sRUFBRTtRQUNyQixNQUFNLElBQUkzSSxNQUFNLENBQUMsZ0NBQWdDLEVBQUVvTyxTQUFTLFFBQVEsRUFBRTNGLFVBQVVuUyxFQUFFLENBQUMseUJBQXlCLENBQUM7SUFDL0c7SUFDQSxNQUFNOEIsU0FBU3FRLFVBQVVFLE1BQU0sQ0FBQ3lGLFNBQVM7SUFDekMsSUFBSSxDQUFDaFcsUUFBUTtRQUNYLE1BQU0sSUFBSTRILE1BQU0sQ0FBQyxhQUFhLEVBQUVvTyxTQUFTLHFCQUFxQixFQUFFM0YsVUFBVW5TLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDakY7SUFDQSxPQUFPOEI7QUFDVDtBQUVBOzs7O0NBSUMsR0FDRCxTQUFTb1YsbUJBQW1CL0UsU0FBUyxFQUFFNVAsU0FBUztJQUM5QyxJQUFJLE9BQU9BLGNBQWMsWUFBWXlPLFVBQVV6TyxZQUFZO1FBQ3pELElBQUk7WUFDRixPQUFPNFAsVUFBVS9NLE9BQU8sQ0FBQ1EsZ0JBQWdCLENBQUNyRDtRQUM1QyxFQUFFLE9BQU07UUFDTix1QkFBdUI7UUFDdkIsV0FBVztRQUNiO0lBQ0Y7SUFDQSxNQUFNd1YsaUJBQWlCcFcsWUFBWVksV0FBV3NGLEtBQUs7SUFDbkQsSUFBSW1RLG1CQUFtQjdGO0lBQ3ZCLE1BQU80RixlQUFlOVYsTUFBTSxDQUFFO1FBQzVCLE1BQU1QLE1BQU1xVyxlQUFlckssS0FBSztRQUNoQyxJQUFJLENBQUNoTSxJQUFJTyxNQUFNLEVBQUU7WUFDZjtRQUNGO1FBQ0ErVixtQkFBbUJILGFBQWFHLGtCQUFrQnRXO0lBQ3BEO0lBQ0EsT0FBT3NXO0FBQ1Q7QUFFQTs7OztDQUlDLEdBQ0QsU0FBU0MsY0FBYzlGLFNBQVMsRUFBRTlQLFVBQVU7SUFDMUMsSUFBSSxPQUFPQSxlQUFlLFVBQVU7UUFDbEMsTUFBTWtSLGlCQUFpQnBCLFVBQVVFLE1BQU0sQ0FBQ2hRLFdBQVc7UUFDbkQsSUFBSSxDQUFDa1IsZ0JBQWdCO1lBQ25CLE1BQU0sSUFBSTdKLE1BQU0sQ0FBQyxPQUFPLEVBQUVySCxXQUFXLHFCQUFxQixFQUFFOFAsVUFBVW5TLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDN0U7UUFDQSxPQUFPO1lBQUNtUztZQUFXb0I7U0FBZTtJQUNwQztJQUNBLE1BQU0yRSxpQkFBaUIzVyxPQUFPQyxJQUFJLENBQUNhO0lBQ25DLE1BQU1pUixrQkFBa0I0RSxlQUFlclUsR0FBRyxDQUFDc1UsQ0FBQUEsY0FBZU4sYUFBYTFGLFdBQVdnRyxjQUFjdlUsTUFBTSxDQUFDd1U7SUFDdkcsT0FBTztRQUFDakcsVUFBVS9NLE9BQU8sQ0FBQ2lULElBQUk7UUFBRWxHO0tBQVUsQ0FBQ21HLE1BQU0sQ0FBQ2hGLGlCQUFpQjRFLGVBQWVLLE1BQU0sQ0FBQyxDQUFDQyxrQkFBa0JMO1FBQzFHLE1BQU1NLGVBQWVaLGFBQWExRixXQUFXZ0c7UUFDN0MsSUFBSSxDQUFDTSxjQUFjO1lBQ2pCLE9BQU9EO1FBQ1Q7UUFDQSxNQUFNRSxnQkFBZ0JULGNBQWNRLGNBQWNwVyxVQUFVLENBQUM4VixZQUFZO1FBQ3pFLE9BQU9LLGlCQUFpQkYsTUFBTSxDQUFDSTtJQUNqQyxHQUFHLEVBQUU7QUFDUDtBQUNBLFNBQVNDLHFCQUFxQnhHLFNBQVMsRUFBRTlQLFVBQVUsRUFBRTRELFFBQVEsRUFBRS9HLEtBQUs7SUFDbEUsTUFBTXFVLGlCQUFpQnNFLGFBQWExRixXQUFXOVA7SUFDL0MsTUFBTXJELE9BQU91VSxlQUFldlUsSUFBSSxDQUFDaUgsVUFBVS9HO0lBQzNDLElBQUksQ0FBQ0YsUUFBUSxDQUFDQSxLQUFLaUQsTUFBTSxFQUFFO1FBQ3pCLE9BQU9rUSxVQUFVblQsSUFBSSxDQUFDaUgsVUFBVS9HO0lBQ2xDO0lBQ0EsT0FBT0Y7QUFDVDtBQUNBLFNBQVM0Wix1QkFBdUJ6RyxTQUFTLEVBQUU5UCxVQUFVLEVBQUU0RCxRQUFRLEVBQUUvRyxLQUFLO0lBQ3BFLE1BQU0yWixlQUFldFgsT0FBT0MsSUFBSSxDQUFDYTtJQUNqQyxNQUFNa1IsaUJBQWlCc0UsYUFBYTFGLFdBQVcwRyxZQUFZLENBQUMsRUFBRTtJQUM5RCxNQUFNN1osT0FBTzhaLGVBQWV2RixnQkFBZ0JsUixVQUFVLENBQUN3VyxZQUFZLENBQUMsRUFBRSxDQUFDLEVBQUU1UyxVQUFVL0c7SUFDbkYsSUFBSSxDQUFDRixRQUFRLENBQUNBLEtBQUtpRCxNQUFNLEVBQUU7UUFDekIsT0FBT2tRLFVBQVVuVCxJQUFJLENBQUNpSCxVQUFVL0c7SUFDbEM7SUFDQSxPQUFPRjtBQUNUO0FBQ0EsU0FBUytaLHVCQUF1QjVHLFNBQVMsRUFBRTlQLFVBQVUsRUFBRTRELFFBQVEsRUFBRS9HLEtBQUs7SUFDcEUsTUFBTThaLHNCQUFzQixFQUFFO0lBQzlCLEtBQUssTUFBTWIsZUFBZTVXLE9BQU9DLElBQUksQ0FBQ2EsWUFBYTtRQUNqRCxNQUFNNFcsZ0JBQWdCNVcsVUFBVSxDQUFDOFYsWUFBWTtRQUM3QyxJQUFJLENBQUNjLGVBQWU7WUFDbEI7UUFDRjtRQUNBLE1BQU1SLGVBQWVaLGFBQWExRixXQUFXZ0c7UUFDN0MsTUFBTWUsbUJBQW1CSixlQUFlTCxjQUFjUSxlQUFlaFQsVUFBVS9HO1FBQy9FLElBQUlnYSxrQkFBa0I7WUFDcEJGLG9CQUFvQjVXLElBQUksSUFBSThXO1FBQzlCO0lBQ0Y7SUFDQSxJQUFJLENBQUNGLG9CQUFvQi9XLE1BQU0sRUFBRTtRQUMvQixPQUFPa1EsVUFBVW5ULElBQUksQ0FBQ2lILFVBQVUvRztJQUNsQztJQUNBLE9BQU84WjtBQUNUO0FBQ0EsU0FBU0YsZUFBZTNHLFNBQVMsRUFBRTlQLFVBQVUsRUFBRTRELFFBQVEsRUFBRS9HLEtBQUs7SUFDNUQsWUFBWTtJQUNaLElBQUksT0FBT21ELGVBQWUsVUFBVTtRQUNsQyxPQUFPc1cscUJBQXFCeEcsV0FBVzlQLFlBQVk0RCxVQUFVL0c7SUFDL0Q7SUFFQSxnQkFBZ0I7SUFDaEIsSUFBSXFDLE9BQU9DLElBQUksQ0FBQ2EsWUFBWUosTUFBTSxLQUFLLEdBQUc7UUFDeEMsT0FBTzJXLHVCQUF1QnpHLFdBQVc5UCxZQUFZNEQsVUFBVS9HO0lBQ2pFO0lBRUEsZ0JBQWdCO0lBQ2hCLE9BQU82Wix1QkFBdUI1RyxXQUFXOVAsWUFBWTRELFVBQVUvRztBQUNqRTtBQUNBLFNBQVNpYSxnQkFBZ0JoSCxTQUFTO0lBQ2hDLE9BQU81USxPQUFPQyxJQUFJLENBQUMyUSxVQUFVRSxNQUFNLEVBQUV4TyxHQUFHLENBQUNuQyxDQUFBQSxNQUFPeVEsVUFBVUUsTUFBTSxDQUFDM1EsSUFBSSxFQUFFa0MsTUFBTSxDQUFDeUMsQ0FBQUEsS0FBTUEsR0FBR3BHLElBQUksS0FBSztBQUNsRztBQUNBLFNBQVNtWixhQUFhN0YsY0FBYyxFQUFFOEYsZUFBZTtJQUNuRCxJQUFJNVcsU0FBUzhRO0lBQ2IsTUFBTzlRLE9BQU9xSixNQUFNLElBQUlySixPQUFPcUosTUFBTSxLQUFLdU4sZ0JBQWlCO1FBQ3pENVcsU0FBU0EsT0FBT3FKLE1BQU07SUFDeEI7SUFDQSxPQUFPckosT0FBT3FKLE1BQU0sS0FBS3VOO0FBQzNCO0FBQ0EsU0FBU0MsZ0JBQWdCQyxFQUFFLEVBQUVDLEVBQUU7SUFDN0IsTUFBTUMsT0FBTyxJQUFJdlQsSUFBSXFUO0lBQ3JCLE1BQU1HLE9BQU8sSUFBSXhULElBQUlzVDtJQUNyQixLQUFLLE1BQU1HLFFBQVFGLEtBQU07UUFDdkIsSUFBSUMsS0FBS3pHLEdBQUcsQ0FBQzBHLE9BQU87WUFDbEIsT0FBTztRQUNUO0lBQ0Y7SUFDQSxLQUFLLE1BQU1BLFFBQVFELEtBQU07UUFDdkIsSUFBSUQsS0FBS3hHLEdBQUcsQ0FBQzBHLE9BQU87WUFDbEIsT0FBTztRQUNUO0lBQ0Y7SUFDQSxPQUFPO0FBQ1Q7QUFDQSxTQUFTQyw2QkFBNkJDLGtCQUFrQixFQUFFbEcsWUFBWSxFQUFFbUcsWUFBWTtJQUNsRixNQUFNQyxzQkFBc0IsSUFBSTdUO0lBQ2hDLEtBQUssTUFBTThULE1BQU1ILG1CQUFvQjtRQUNuQyxJQUFJSSxjQUFjO1FBQ2xCLE1BQU1DLHNCQUFzQixJQUFJaFU7UUFDaEMsS0FBSyxNQUFNaVUsTUFBTUosb0JBQXFCO1lBQ3BDLElBQUlULGdCQUFnQmMsZUFBZTtnQkFBQ0o7YUFBRyxFQUFFckcsY0FBY21HLGVBQWVNLGVBQWU7Z0JBQUNEO2FBQUcsRUFBRXhHLGNBQWNtRyxnQkFBZ0I7Z0JBQ3ZILElBQUlWLGFBQWFZLEdBQUd2UyxNQUFNLEVBQUUwUyxHQUFHMVMsTUFBTSxHQUFHO29CQUN0Q3lTLG9CQUFvQnJRLEdBQUcsQ0FBQ3NRO2dCQUMxQixPQUFPO29CQUNMRixjQUFjO29CQUNkO2dCQUNGO1lBQ0Y7UUFDRjtRQUNBLElBQUksQ0FBQ0EsYUFBYTtZQUNoQixLQUFLLE1BQU1JLE1BQU1ILG9CQUFxQjtnQkFDcENILG9CQUFvQjFRLE1BQU0sQ0FBQ2dSO1lBQzdCO1lBQ0FOLG9CQUFvQmxRLEdBQUcsQ0FBQ21RO1FBQzFCO0lBQ0Y7SUFDQSxPQUFPL1YsTUFBTXFXLElBQUksQ0FBQ1A7QUFDcEI7QUFDQSxTQUFTUSx3QkFBd0I1SCxVQUFVO0lBQ3pDLE1BQU0sQ0FBQzZILE1BQU0sR0FBR0MsS0FBSyxHQUFHOUg7SUFDeEIsS0FBSyxNQUFNK0UsWUFBWXBGLG1CQUFtQmtJLE1BQU12WCxXQUFZO1FBQzFELElBQUl3WCxLQUFLaFosS0FBSyxDQUFDNEUsQ0FBQUEsS0FBTStTLGFBQWEvUyxJQUFJcVIsWUFBWTtZQUNoRCxPQUFPQTtRQUNUO0lBQ0Y7QUFDRjtBQUNBLFNBQVNnRCx5QkFBeUJqTSxVQUFVLEVBQUVxTCxZQUFZO0lBQ3hELElBQUksQ0FBQ3JMLFdBQVdsSyxNQUFNLEVBQUU7UUFDdEIsT0FBTyxFQUFFO0lBQ1g7SUFDQSxNQUFNeVMsVUFBVSxJQUFJOVE7SUFDcEIsS0FBSyxNQUFNeVUsY0FBY2xNLFdBQVdsSyxNQUFNLENBQUU7UUFDMUMsSUFBSWdULGNBQWNvRCxhQUFhO1lBQzdCLElBQUliLFlBQVksQ0FBQ2EsV0FBVzNhLEVBQUUsQ0FBQyxFQUFFO2dCQUMvQixLQUFLLE1BQU0yRixRQUFRbVUsWUFBWSxDQUFDYSxXQUFXM2EsRUFBRSxDQUFDLENBQUU7b0JBQzlDZ1gsUUFBUW5OLEdBQUcsQ0FBQ2xFO2dCQUNkO1lBQ0YsT0FBTztnQkFDTCxLQUFLLE1BQU1BLFFBQVErVSx5QkFBeUJyRCxnQ0FBZ0NzRCxhQUFhYixjQUFlO29CQUN0RzlDLFFBQVFuTixHQUFHLENBQUNsRTtnQkFDZDtZQUNGO1FBQ0YsT0FBTztZQUNMcVIsUUFBUW5OLEdBQUcsQ0FBQzhRO1FBQ2Q7SUFDRjtJQUNBLE9BQU87V0FBSTNEO0tBQVE7QUFDckI7QUFDQSxTQUFTNEQsb0JBQW9Cbk0sVUFBVSxFQUFFcUwsWUFBWTtJQUNuRCxNQUFNZSxlQUFlSCx5QkFBeUJqTSxZQUFZcUw7SUFDMUQsSUFBSSxDQUFDZSxjQUFjO1FBQ2pCO0lBQ0Y7SUFDQSxJQUFJLENBQUNwTSxXQUFXeUgsT0FBTyxJQUFJMkUsYUFBYXBaLEtBQUssQ0FBQzhDLENBQUFBLFNBQVVBLFdBQVdrSyxXQUFXaEgsTUFBTSxJQUFJMlIsYUFBYTdVLFFBQVFrSyxXQUFXaEgsTUFBTSxJQUFJO1FBQ2hJLE9BQU9nSCxXQUFXaEgsTUFBTTtJQUMxQjtJQUNBLE1BQU1xVCxNQUFNUCx3QkFBd0JNLGFBQWF2QyxNQUFNLENBQUM3SixXQUFXaEgsTUFBTTtJQUN6RSxJQUFJcVQsS0FBSztRQUNQLE9BQU9BO0lBQ1Q7SUFFQSxnRkFBZ0Y7SUFDaEYsSUFBSXJNLFdBQVd5SCxPQUFPLEVBQUU7UUFDdEI7SUFDRjtJQUNBLE9BQU96SCxXQUFXaEgsTUFBTSxDQUFDckMsT0FBTyxDQUFDaVQsSUFBSTtBQUN2QztBQUNBLFNBQVMrQixlQUFlcEcsV0FBVyxFQUFFTCxZQUFZLEVBQUVtRyxZQUFZO0lBQzdELE1BQU1pQixlQUFlLElBQUk3VTtJQUN6QixLQUFLLE1BQU1vUSxLQUFLdEMsWUFBYTtRQUMzQixJQUFJc0MsRUFBRS9SLE1BQU0sRUFBRXRDLFFBQVE7WUFDcEIsTUFBTStZLFNBQVNKLG9CQUFvQnRFLEdBQUd3RDtZQUN0QyxJQUFJeEQsRUFBRUosT0FBTyxJQUFJSSxFQUFFN08sTUFBTSxLQUFLdVQsUUFBUTtnQkFDcENELGFBQWFsUixHQUFHLENBQUNtUjtZQUNuQjtZQUNBLEtBQUssTUFBTTdJLGFBQWF3QixhQUFjO2dCQUNwQyxJQUFJeUYsYUFBYWpILFdBQVc2SSxTQUFTO29CQUNuQ0QsYUFBYWxSLEdBQUcsQ0FBQ3NJO2dCQUNuQjtZQUNGO1FBQ0Y7SUFDRjtJQUNBLE9BQU87V0FBSTRJO0tBQWE7QUFDMUI7QUFDQSxTQUFTRSw2QkFBNkJDLGNBQWMsRUFBRUMsZ0JBQWdCO0lBQ3BFLElBQUlELGVBQWVqWixNQUFNLEtBQUtrWixpQkFBaUJ2UyxJQUFJLEVBQUU7UUFDbkQsT0FBTztJQUNUO0lBQ0EsS0FBSyxNQUFNakQsUUFBUXVWLGVBQWdCO1FBQ2pDLElBQUksQ0FBQ0MsaUJBQWlCbEksR0FBRyxDQUFDdE4sT0FBTztZQUMvQixPQUFPO1FBQ1Q7SUFDRjtJQUNBLE9BQU87QUFDVDtBQUVBLG9EQUFvRCxHQUNwRCxTQUFTeVYsVUFBVXBILFdBQVcsRUFBRXFILGVBQWUsRUFBRXZMLFVBQVUsRUFBRTVRLEtBQUssRUFBRW9jLFNBQVMsRUFBRUMsYUFBYTtJQUMxRixJQUFJLENBQUN2SCxZQUFZL1IsTUFBTSxFQUFFO1FBQ3ZCLE9BQU9vWjtJQUNUO0lBQ0EsTUFBTUcsa0JBQWtCLElBQUl0VixJQUFJbVYsZ0JBQWdCbFYsTUFBTTtJQUN0RCxJQUFJMlQsZUFBZXVCLGdCQUFnQnZCLFlBQVk7SUFDL0MsTUFBTUMsc0JBQXNCSCw2QkFBNkI1RixhQUFhd0gsaUJBQWlCMUI7SUFDdkYsSUFBSXZMLFlBQVk4TTtJQUVoQixjQUFjO0lBQ2QsSUFBSSxDQUFDQyxXQUFXO1FBQ2QsQ0FBQy9NLFdBQVd1TCxhQUFhLEdBQUcyQixXQUFXbE4sV0FBV3JQLE9BQU80USxZQUFZaUsscUJBQXFCeUIsaUJBQWlCMUIsY0FBY3lCLGVBQWV6TCxXQUFXcEQsY0FBYztJQUNuSztJQUVBLDZCQUE2QjtJQUM3QjZCLFlBQVltTix5QkFBeUJuTixXQUFXclAsT0FBTzRRLFlBQVlpSyxvQkFBb0IzVCxPQUFPLENBQUNrUSxDQUFBQSxJQUFLQSxFQUFFRCxPQUFPLEdBQUdrRixlQUFldFk7SUFFL0gsZUFBZTtJQUNmc0wsWUFBWW9OLFlBQVlwTixXQUFXclAsT0FBTzRRLFlBQVlpSyxxQkFBcUJ5QixpQkFBaUJELGVBQWV6QixjQUFjd0I7SUFDekgsTUFBTU0saUJBQWlCO1dBQUlKO0tBQWdCO0lBQzNDLElBQUlqTixVQUFVbkIsTUFBTSxLQUFLLFFBQVE7UUFDL0JtQixZQUFZbU4seUJBQXlCbk4sV0FBV3JQLE9BQU80USxZQUFZOEwsZUFBZWpILElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNQSxFQUFFZ0gsS0FBSyxHQUFHakgsRUFBRWlILEtBQUssRUFBRXpWLE9BQU8sQ0FBQytHLENBQUFBLFFBQVNBLE1BQU1tSSxJQUFJLEdBQUdpRyxlQUFldFk7SUFDbks7SUFFQSw0Q0FBNEM7SUFDNUMsSUFBSTtRQUNGLElBQUk2VyxpQkFBaUJ1QixnQkFBZ0J2QixZQUFZLElBQUltQiw2QkFBNkJJLGdCQUFnQmxWLE1BQU0sRUFBRXFWLGtCQUFrQjtZQUMxSCxPQUFPak47UUFDVDtRQUNBLE9BQU9nQyxxQkFBcUJoQyxXQUFXO1lBQ3JDcEksUUFBUXlWO1lBQ1I5QjtRQUNGO0lBQ0YsRUFBRSxPQUFPZ0MsR0FBRztRQUNWLGlFQUFpRTtRQUNqRSwrQ0FBK0M7UUFDL0MsTUFBTUE7SUFDUjtBQUNGO0FBQ0EsU0FBU0MsaUJBQWlCOVYsUUFBUSxFQUFFL0csS0FBSyxFQUFFNFEsVUFBVSxFQUFFMkQsUUFBUSxFQUFFdUksa0JBQWtCO0lBQ2pGLElBQUl2SSxTQUFTdFQsTUFBTSxLQUFLOEMsV0FBVztRQUNqQztJQUNGO0lBQ0EsTUFBTWdaLGlCQUFpQi9iLHFCQUFxQjhiLG1CQUFtQmhjLEVBQUUsRUFBRWdjLG1CQUFtQjdiLE1BQU0sS0FBSzhDLGFBQWErWSxtQkFBbUJsUSxNQUFNLEdBQUc1SSxjQUFjOFksbUJBQW1CN2IsTUFBTSxFQUFFOEYsU0FBUzdDLE9BQU8sRUFBRWxFLE9BQU80USxXQUFXek0sSUFBSSxJQUFJSjtJQUMvTixPQUFPQyxjQUFjdVEsU0FBU3RULE1BQU0sRUFBRThGLFNBQVM3QyxPQUFPLEVBQUU2WSxnQkFBZ0JuTSxXQUFXek0sSUFBSTtBQUN6RjtBQUNBLFNBQVNzWSxZQUFZTixlQUFlLEVBQUVuYyxLQUFLLEVBQUU0USxVQUFVLEVBQUVpSyxtQkFBbUIsRUFBRXlCLGVBQWUsRUFBRUQsYUFBYSxFQUFFekIsWUFBWSxFQUFFd0IsU0FBUztJQUNuSSxJQUFJWSxlQUFlYjtJQUNuQixNQUFNYyxnQkFBZ0IsSUFBSWpXO0lBQzFCLDZGQUE2RjtJQUM3RixnRkFBZ0Y7SUFDaEYsc0ZBQXNGO0lBQ3RGLE1BQU1rVyx3QkFBd0IsSUFBSWxXO0lBQ2xDbVcsZ0JBQWdCdEMscUJBQXFCRCxjQUFjc0MsdUJBQXVCRDtJQUUxRSwwREFBMEQ7SUFDMUQsSUFBSWIsV0FBVztRQUNiYyxzQkFBc0J2UyxHQUFHLENBQUN3UixnQkFBZ0JqVyxPQUFPLENBQUNpVCxJQUFJO0lBQ3hEO0lBQ0EsTUFBTWlFLGlCQUFpQixJQUFJcFc7SUFDM0IsS0FBSyxNQUFNcVcsb0JBQW9CO1dBQUlKO0tBQWMsQ0FBQ3hILElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxFQUFFaUgsS0FBSyxHQUFHaEgsRUFBRWdILEtBQUssRUFBRztRQUNuRkwsZ0JBQWdCM1IsR0FBRyxDQUFDMFM7UUFDcEIsTUFBTWxHLFVBQVUsRUFBRTtRQUVsQixvQkFBb0I7UUFDcEJBLFFBQVFqVSxJQUFJLElBQUltYSxpQkFBaUJuSCxLQUFLO1FBQ3RDLEtBQUssTUFBTXNCLGFBQWE2RixpQkFBaUJ4VyxNQUFNLENBQUU7WUFDL0NzUSxRQUFRalUsSUFBSSxDQUFDcU8sV0FBV2lHLFVBQVVyUixHQUFHLEVBQUU7Z0JBQ3JDLEdBQUdxUixTQUFTO2dCQUNaM0ssY0FBYyxDQUFDLENBQUMySyxVQUFVRSxVQUFVO1lBQ3RDO1FBQ0Y7UUFDQSxJQUFJd0Ysc0JBQXNCbkosR0FBRyxDQUFDc0osbUJBQW1CO1lBQy9DLE1BQU1DLGlCQUFpQkQsaUJBQWlCakYsT0FBTyxDQUFDakIsT0FBTztZQUN2REEsUUFBUWpVLElBQUksSUFBSW9hO1FBQ2xCO1FBQ0FOLGVBQWVSLHlCQUF5QlEsY0FBY2hkLE9BQU80USxZQUFZdUcsU0FBU2tGLGVBQWVnQixpQkFBaUJ4VyxNQUFNLENBQUNsQyxHQUFHLENBQUM2UyxDQUFBQSxZQUFhQSxVQUFVMVcsRUFBRTtRQUN0SixJQUFJdWMsaUJBQWlCdGMsSUFBSSxLQUFLLFNBQVM7WUFDckMsTUFBTTZMLFNBQVN5USxpQkFBaUJ6USxNQUFNO1lBQ3RDLElBQUkyUSxpQkFBaUIzUSxRQUFRN0wsU0FBUyxhQUFhNkwsU0FBU0EsUUFBUUE7WUFDcEUsSUFBSWtRLHFCQUFxQlMsa0JBQWtCRjtZQUMzQyxJQUFJelEsUUFBUTdMLFNBQVMsWUFBWTtnQkFDL0JzYixjQUFjblosSUFBSSxDQUFDbEMscUJBQXFCNEwsT0FBTzlMLEVBQUUsRUFBRXVjLGlCQUFpQnBjLE1BQU0sS0FBSzhDLFlBQVlDLGNBQWNxWixpQkFBaUJwYyxNQUFNLEVBQUUrYixhQUFhOVksT0FBTyxFQUFFbEUsT0FBTzRRLFdBQVd6TSxJQUFJLElBQUlKO1lBQ3BMO1lBQ0EsTUFBT3daLGdCQUFnQnhjLFNBQVMsY0FBYyxDQUFDcWMsZUFBZXJKLEdBQUcsQ0FBQ3dKLG1CQUFtQi9JLGVBQWU4SCxpQkFBaUJpQixnQkFBaUI7Z0JBQ3BJSCxlQUFlelMsR0FBRyxDQUFDNFM7Z0JBQ25CbEIsY0FBY25aLElBQUksQ0FBQ2xDLHFCQUFxQnVjLGVBQWV6YyxFQUFFO2dCQUN6RGdjLHFCQUFxQlM7Z0JBQ3JCQSxpQkFBaUJBLGVBQWUzUSxNQUFNO1lBQ3hDO1lBQ0EsSUFBSTJRLGdCQUFnQjtnQkFDbEI7WUFDRjtZQUNBUCxlQUFlM0wscUJBQXFCMkwsY0FBYztnQkFDaEQ5TyxRQUFRO2dCQUNSak4sUUFBUTRiLGlCQUFpQkcsY0FBY2hkLE9BQU80USxZQUFZb00sYUFBYTlXLE9BQU8sQ0FBQ2lULElBQUksRUFBRTJEO1lBQ3ZGO1FBQ0Y7SUFDRjtJQUNBLE9BQU9FO0FBQ1Q7QUFDQSxTQUFTRyxnQkFBZ0JySSxXQUFXLEVBQUU4RixZQUFZLEVBQUVzQyxxQkFBcUIsRUFBRUQsYUFBYTtJQUN0RixLQUFLLE1BQU03RixLQUFLdEMsWUFBYTtRQUMzQixNQUFNZ0gsU0FBU0osb0JBQW9CdEUsR0FBR3dEO1FBQ3RDLEtBQUssTUFBTS9HLEtBQUt1RCxFQUFFL1IsTUFBTSxJQUFJLEVBQUUsQ0FBRTtZQUM5QixJQUFJLENBQUNnVCxjQUFjeEUsTUFDbkIsa0ZBQWtGO1lBQ2xGdUQsQ0FBQUEsRUFBRTdPLE1BQU0sS0FBS3NMLEtBQ2Isc0RBQXNEO1lBQ3RELG1IQUFtSDtZQUNuSHVELEVBQUU3TyxNQUFNLEtBQUt1VCxVQUNiLGlGQUFpRjtZQUNqRjFFLEVBQUVKLE9BQU8sR0FBRztnQkFDVmlHLGNBQWN0UyxHQUFHLENBQUNrSjtnQkFDbEJxSixzQkFBc0J2UyxHQUFHLENBQUNrSjtZQUM1QjtZQUNBMkosMkJBQTJCM0osR0FBRytHLGNBQWNzQyx1QkFBdUJEO1FBQ3JFO1FBQ0EsTUFBTXRCLGVBQWVILHlCQUF5QnBFLEdBQUd3RDtRQUNqRCxLQUFLLE1BQU0vRyxLQUFLOEgsYUFBYztZQUM1QixNQUFNckksWUFBWUYsbUJBQW1CUyxHQUFHaUk7WUFDeEMsSUFBSUEsUUFBUS9hLFNBQVMsWUFBWTtnQkFDL0J1UyxVQUFVcFEsSUFBSSxDQUFDNFk7WUFDakI7WUFDQTJCLHlCQUF5QlIsZUFBZXJDLGNBQWNzQyx1QkFBdUI1SixXQUFXLENBQUM4RCxFQUFFN08sTUFBTSxDQUFDcUUsTUFBTSxJQUFJd0ssRUFBRUosT0FBTyxHQUFHalQsWUFBWStYO1FBQ3RJO0lBQ0Y7QUFDRjtBQUNBLFNBQVMwQiwyQkFBMkJ2SyxTQUFTLEVBQUUySCxZQUFZLEVBQUVzQyxxQkFBcUIsRUFBRUQsYUFBYTtJQUMvRixJQUFJNUUsY0FBY3BGLFlBQVk7UUFDNUIsSUFBSTJILFlBQVksQ0FBQzNILFVBQVVuUyxFQUFFLENBQUMsRUFBRTtZQUM5QixNQUFNNGMsb0JBQW9COUMsWUFBWSxDQUFDM0gsVUFBVW5TLEVBQUUsQ0FBQztZQUNwRCxLQUFLLE1BQU0rUyxLQUFLNkosa0JBQW1CO2dCQUNqQ1QsY0FBY3RTLEdBQUcsQ0FBQ2tKO2dCQUNsQjJKLDJCQUEyQjNKLEdBQUcrRyxjQUFjc0MsdUJBQXVCRDtZQUNyRTtZQUNBLEtBQUssTUFBTXBKLEtBQUs2SixrQkFBbUI7Z0JBQ2pDQywrQkFBK0I5SixHQUFHWixVQUFVckcsTUFBTSxFQUFFcVEsZUFBZXJDLGNBQWNzQztZQUNuRjtRQUNGLE9BQU87WUFDTCxNQUFNVSwyQkFBMkJ6RixnQ0FBZ0NsRjtZQUNqRSxLQUFLLE1BQU1ZLEtBQUsrSix5QkFBeUJ2WSxNQUFNLENBQUU7Z0JBQy9DNFgsY0FBY3RTLEdBQUcsQ0FBQ2tKO2dCQUNsQixJQUFJK0osNkJBQTZCM0ssVUFBVXJHLE1BQU0sRUFBRXdMLFNBQVM7b0JBQzFEOEUsc0JBQXNCdlMsR0FBRyxDQUFDc0ksVUFBVXJHLE1BQU07Z0JBQzVDO2dCQUNBNFEsMkJBQTJCM0osR0FBRytHLGNBQWNzQyx1QkFBdUJEO1lBQ3JFO1lBQ0EsS0FBSyxNQUFNcEosS0FBSytKLHlCQUF5QnZZLE1BQU0sQ0FBRTtnQkFDL0NzWSwrQkFBK0I5SixHQUFHWixVQUFVckcsTUFBTSxFQUFFcVEsZUFBZXJDLGNBQWNzQztZQUNuRjtRQUNGO0lBQ0YsT0FBTztRQUNMLElBQUlqSyxVQUFVbFMsSUFBSSxLQUFLLFlBQVk7WUFDakMsTUFBTSxDQUFDd1gsYUFBYSxHQUFHdEYsVUFBVW1GLE9BQU8sQ0FBQy9TLE1BQU07WUFDL0MsSUFBSSxDQUFDZ1QsY0FBY0UsZUFBZTtnQkFDaEMwRSxjQUFjdFMsR0FBRyxDQUFDNE47Z0JBQ2xCMkUsc0JBQXNCdlMsR0FBRyxDQUFDNE47WUFDNUI7WUFDQWlGLDJCQUEyQmpGLGNBQWNxQyxjQUFjc0MsdUJBQXVCRDtZQUM5RVUsK0JBQStCcEYsY0FBY3RGLFdBQVdnSyxlQUFlckMsY0FBY3NDO1FBQ3ZGLE9BQU87WUFDTCxJQUFJakssVUFBVWxTLElBQUksS0FBSyxZQUFZO2dCQUNqQyxLQUFLLE1BQU1pTSxTQUFTa0csWUFBWUQsV0FBV3ZPLE1BQU0sQ0FBQ3lDLENBQUFBLEtBQU0sQ0FBQ2tSLGNBQWNsUixLQUFNO29CQUMzRSxJQUFJLENBQUM7MkJBQUk4VjtxQkFBYyxDQUFDNVksSUFBSSxDQUFDd1AsQ0FBQUEsSUFBS3FHLGFBQWFyRyxHQUFHN0csU0FBUzt3QkFDekQsSUFBSSxDQUFDcUwsY0FBY3JMLFFBQVE7NEJBQ3pCaVEsY0FBY3RTLEdBQUcsQ0FBQ3FDOzRCQUNsQmtRLHNCQUFzQnZTLEdBQUcsQ0FBQ3FDO3dCQUM1Qjt3QkFDQXdRLDJCQUEyQnhRLE9BQU80TixjQUFjc0MsdUJBQXVCRDtvQkFDekU7Z0JBQ0Y7WUFDRjtRQUNGO0lBQ0Y7QUFDRjtBQUNBLFNBQVNRLHlCQUF5QlIsYUFBYSxFQUFFckMsWUFBWSxFQUFFc0MscUJBQXFCLEVBQUU1SixTQUFTLEVBQUV1SyxnQkFBZ0I7SUFDL0csS0FBSyxNQUFNQyxPQUFPeEssVUFBVztRQUMzQixJQUFJLENBQUN1SyxvQkFBb0IzRCxhQUFhNEQsS0FBS0QsbUJBQW1CO1lBQzVEWixjQUFjdFMsR0FBRyxDQUFDbVQ7UUFDcEI7UUFDQSxJQUFJQSxJQUFJL2MsSUFBSSxLQUFLLFlBQVk7WUFDM0IsS0FBSyxNQUFNaU0sU0FBU2tHLFlBQVk0SyxLQUFLcFosTUFBTSxDQUFDeUMsQ0FBQUEsS0FBTSxDQUFDa1IsY0FBY2xSLEtBQU07Z0JBQ3JFLElBQUksQ0FBQzt1QkFBSThWO2lCQUFjLENBQUM1WSxJQUFJLENBQUN3UCxDQUFBQSxJQUFLcUcsYUFBYXJHLEdBQUc3RyxTQUFTO29CQUN6RGlRLGNBQWN0UyxHQUFHLENBQUNxQztvQkFDbEJ3USwyQkFBMkJ4USxPQUFPNE4sY0FBY3NDLHVCQUF1QkQ7Z0JBQ3pFO1lBQ0Y7UUFDRjtJQUNGO0FBQ0Y7QUFDQSxTQUFTVSwrQkFBK0IxSyxTQUFTLEVBQUVJLFdBQVcsRUFBRTRKLGFBQWEsRUFBRXJDLFlBQVksRUFBRXNDLHFCQUFxQjtJQUNoSE8seUJBQXlCUixlQUFlckMsY0FBY3NDLHVCQUF1QjlKLG1CQUFtQkgsV0FBV0k7QUFDN0c7QUFDQSxTQUFTa0osV0FBV0osZUFBZSxFQUFFbmMsS0FBSyxFQUFFNFEsVUFBVSxFQUFFa0UsV0FBVyxFQUFFd0gsZUFBZSxFQUFFMUIsWUFBWSxFQUFFeUIsYUFBYSxFQUFFMEIsZUFBZTtJQUNoSSxJQUFJZixlQUFlYjtJQUNuQixNQUFNTixlQUFlWCxlQUFlcEcsYUFBYXdILGlCQUFpQjFCO0lBQ2xFaUIsYUFBYXBHLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNQSxFQUFFZ0gsS0FBSyxHQUFHakgsRUFBRWlILEtBQUs7SUFDN0MsSUFBSXFCO0lBRUosZ0VBQWdFO0lBQ2hFLEtBQUssTUFBTUMsaUJBQWlCcEMsYUFBYztRQUN4QyxLQUFLLE1BQU1xQyxlQUFlakUsZ0JBQWdCZ0UsZUFBZ0I7WUFDeEQsSUFBSUU7WUFDSixJQUFJRCxZQUFZRSxPQUFPLEtBQUssUUFBUTtnQkFDbENELFlBQVloWCxDQUFBQSxLQUFNNkwsa0JBQWtCN0wsT0FBTytTLGFBQWEvUyxJQUFJOFc7WUFDOUQsT0FBTztnQkFDTEUsWUFBWWhYLENBQUFBO29CQUNWLE9BQU9BLEdBQUd5RixNQUFNLEtBQUtxUjtnQkFDdkI7WUFDRjtZQUNBRCxtQkFBbUI7Z0JBQ2pCLEdBQUdwRCxZQUFZO1lBQ2pCO1lBQ0FvRCxjQUFjLENBQUNFLFlBQVlwZCxFQUFFLENBQUMsR0FBR2lFLE1BQU1xVyxJQUFJLENBQUNrQixpQkFBaUI1WCxNQUFNLENBQUN5WjtRQUN0RTtJQUNGO0lBQ0EsS0FBSyxNQUFNdEssS0FBS2dJLGFBQWM7UUFDNUJtQixlQUFlUix5QkFBeUJRLGNBQWNoZCxPQUFPNFEsWUFBWTtlQUFJaUQsRUFBRXVDLElBQUk7ZUFBS3ZDLEVBQUVoTixNQUFNLENBQUNsQyxHQUFHLENBQUMwWixDQUFBQSxNQUFPdFIsVUFBVXNSLElBQUl2ZCxFQUFFO1NBQUcsRUFBRXViLGVBQWV0WTtRQUNoSnVZLGdCQUFnQm5TLE1BQU0sQ0FBQzBKO0lBQ3pCO0lBQ0EsT0FBTztRQUFDbUo7UUFBY2dCLGtCQUFrQnBEO0tBQWE7QUFDdkQ7QUFDQSxTQUFTMEQsVUFBVXBZLE9BQU8sRUFBRXFZLFVBQVU7SUFDcEMsT0FBT3JZLFFBQVFHLGVBQWUsQ0FBQzhRLE9BQU8sQ0FBQ29ILFdBQVc7QUFDcEQ7QUFDQSxTQUFTQyxvQ0FBb0NyQyxlQUFlLEVBQUVuYyxLQUFLLEVBQUU0USxVQUFVLEVBQUV1RyxPQUFPLEVBQUVzSCxLQUFLLEVBQUVDLE9BQU87SUFDdEcsTUFBTSxFQUNKeFksT0FBTyxFQUNSLEdBQUdpVztJQUNKLElBQUl3Qyx1QkFBdUJ4QztJQUMzQixLQUFLLE1BQU0xTyxVQUFVMEosUUFBUztRQUM1QixNQUFNeEUsV0FBVyxPQUFPbEYsV0FBVztRQUNuQyxNQUFNbVIsaUJBQWlCak0sV0FBV2xGLFNBQ2xDLDJFQUEyRTtRQUMzRSw4RkFBOEY7UUFDOUYsdUVBQXVFO1FBRXZFNlEsVUFBVXBZLFNBQVMsT0FBT3VILFdBQVcsV0FBV0EsU0FBU0EsT0FBTzFNLElBQUk7UUFDcEUsTUFBTXdQLGFBQWE7WUFDakJyTSxTQUFTeWEscUJBQXFCemEsT0FBTztZQUNyQ2xFO1lBQ0FtRSxNQUFNeU0sV0FBV3pNLElBQUk7WUFDckI4RSxRQUFRMkgsV0FBVzNILE1BQU07UUFDM0I7UUFDQSxNQUFNdUgsZUFBZW1DLFlBQVksT0FBT2xGLFdBQVcsV0FBVzFKLFlBQVksWUFBWTBKLFNBQVMsT0FBT0EsT0FBT0UsTUFBTSxLQUFLLGFBQWFGLE9BQU9FLE1BQU0sQ0FBQztZQUNqSnpKLFNBQVN5YSxxQkFBcUJ6YSxPQUFPO1lBQ3JDbEU7UUFDRixLQUFLeU4sT0FBT0UsTUFBTSxHQUFHNUo7UUFDckIsSUFBSSxDQUFDNmEsa0JBQWtCLENBQUUsY0FBYUEsY0FBYSxHQUFJO1lBQ3JEaE8sV0FBV3BELGNBQWMsQ0FBQztnQkFDeEJ6TSxNQUFNLE9BQU8wTSxXQUFXLFdBQVdBLFNBQVMsT0FBT0EsV0FBVyxXQUFXQSxPQUFPMU0sSUFBSSxHQUFHME0sT0FBT29SLElBQUksSUFBSTtnQkFDdEdoUixNQUFNMEM7Z0JBQ041QyxRQUFRNkM7Z0JBQ1I5QyxNQUFNa1I7WUFDUjtZQUNBO1FBQ0Y7UUFDQSxNQUFNRSxnQkFBZ0JGO1FBQ3RCLE1BQU0sQ0FBQ3ZQLFdBQVcxQixRQUFRd0osUUFBUSxHQUFHMkgsY0FBYy9OLE9BQU8sQ0FBQ0gsWUFBWStOLHNCQUFzQnBPLFlBQVlDLGNBQWNvTyxnQkFDdkgsd0JBQXdCO1FBQ3hCSDtRQUNBRSx1QkFBdUJ0UDtRQUN2QixJQUFJLGtCQUFrQnlQLGVBQWU7WUFDbkNKLFNBQVN4YixLQUFLO2dCQUFDNGI7Z0JBQWVuUjthQUFPO1FBQ3ZDO1FBQ0EsSUFBSSxhQUFhbVIsZUFBZTtZQUM5QmxPLFdBQVdwRCxjQUFjLENBQUM7Z0JBQ3hCek0sTUFBTStkLGNBQWMvZCxJQUFJO2dCQUN4QjhNLE1BQU0wQztnQkFDTjVDO2dCQUNBRCxNQUFNb1IsY0FBYzlOLE9BQU8sQ0FBQ3BMLElBQUksQ0FBQyxNQUFNZ0wsWUFBWWpEO1lBQ3JEO1FBQ0Y7UUFDQSxJQUFJd0osU0FBUztZQUNYd0gsdUJBQXVCSCxvQ0FBb0NHLHNCQUFzQjNlLE9BQU80USxZQUFZdUcsU0FBU3NILE9BQU9DO1FBQ3RIO0lBQ0Y7SUFDQSxPQUFPQztBQUNUO0FBQ0EsU0FBU25DLHlCQUF5QkwsZUFBZSxFQUFFbmMsS0FBSyxFQUFFNFEsVUFBVSxFQUFFdUcsT0FBTyxFQUFFa0YsYUFBYSxFQUFFMEMsZ0JBQWdCO0lBQzVHLE1BQU1MLFVBQVVLLG1CQUFtQixFQUFFLEdBQUdoYjtJQUN4QyxNQUFNc0wsWUFBWW1QLG9DQUFvQ3JDLGlCQUFpQm5jLE9BQU80USxZQUFZdUcsU0FBUztRQUNqR2tGO1FBQ0EwQztJQUNGLEdBQUdMO0lBQ0hBLFNBQVM3VSxRQUFRLENBQUMsQ0FBQ2lWLGVBQWVuUixPQUFPO1FBQ3ZDbVIsY0FBY0UsWUFBWSxDQUFDcE8sWUFBWXZCLFdBQVcxQjtJQUNwRDtJQUNBLE9BQU8wQjtBQUNUO0FBQ0EsU0FBUzRQLFVBQVVsWSxRQUFRLEVBQUUvRyxLQUFLLEVBQUU0USxVQUFVLEVBQUV5TCxhQUFhO0lBQzNELElBQUlyYyxNQUFNZSxJQUFJLEtBQUtQLFVBQVU7UUFDM0IsTUFBTSxJQUFJZ0ssTUFBTSxDQUFDLHlDQUF5QyxFQUFFaEssU0FBUyxFQUFFLENBQUM7SUFDMUU7SUFDQSxJQUFJd2MsZUFBZWpXO0lBQ25CLE1BQU1tWSxjQUFjLEVBQUU7SUFDdEIsU0FBU0MsY0FBY0MsVUFBVSxFQUFFcGYsS0FBSyxFQUFFOFUsV0FBVztRQUNuRGxFLFdBQVczSCxNQUFNLENBQUM0QixvQkFBb0IsQ0FBQztZQUNyQzlKLE1BQU07WUFDTnVHLFVBQVVzSixXQUFXek0sSUFBSTtZQUN6Qm5FO1lBQ0ErRyxVQUFVcVk7WUFDVkMsY0FBY3ZLO1FBQ2hCO1FBQ0FvSyxZQUFZaGMsSUFBSSxDQUFDa2M7SUFDbkI7SUFFQSxvQkFBb0I7SUFDcEIsSUFBSXBmLE1BQU1lLElBQUksS0FBS0osYUFBYTtRQUM5QnFjLGVBQWUzTCxxQkFBcUJpTyxhQUFhdEMsY0FBY2hkLE9BQU80USxhQUFhO1lBQ2pGMUMsUUFBUTtRQUNWO1FBQ0FpUixjQUFjbkMsY0FBY2hkLE9BQU8sRUFBRTtRQUNyQyxPQUFPO1lBQ0wrRyxVQUFVaVc7WUFDVmtDO1FBQ0Y7SUFDRjtJQUNBLElBQUlLLFlBQVl2ZjtJQUVoQixpREFBaUQ7SUFDakQsdURBQXVEO0lBQ3ZELElBQUl1ZixVQUFVeGUsSUFBSSxLQUFLTixhQUFhO1FBQ2xDLE1BQU0rZSxlQUFlRDtRQUNyQixNQUFNRSxRQUFRemEsa0JBQWtCd2E7UUFDaEMsTUFBTTFLLGNBQWM0SyxrQkFBa0JGLGNBQWN4QztRQUNwRCxJQUFJeUMsU0FBUyxDQUFDM0ssWUFBWS9SLE1BQU0sRUFBRTtZQUNoQyxzRkFBc0Y7WUFDdEYsd0VBQXdFO1lBQ3hFLDZGQUE2RjtZQUM3RmlhLGVBQWUzTCxxQkFBcUJ0SyxVQUFVO2dCQUM1Q21ILFFBQVE7Z0JBQ1I1TSxPQUFPa2UsYUFBYWxlLEtBQUs7WUFDM0I7WUFDQTZkLGNBQWNuQyxjQUFjd0MsY0FBYyxFQUFFO1lBQzVDLE9BQU87Z0JBQ0x6WSxVQUFVaVc7Z0JBQ1ZrQztZQUNGO1FBQ0Y7UUFDQWxDLGVBQWVkLFVBQVVwSCxhQUFhL04sVUFBVTZKLFlBQVkyTyxXQUFXLE9BQ3ZFLFlBQVk7UUFDWmxEO1FBQ0E4QyxjQUFjbkMsY0FBY3dDLGNBQWMxSztJQUM1QztJQUNBLElBQUk2SyxtQ0FBbUM7SUFDdkMsTUFBTzNDLGFBQWE5TyxNQUFNLEtBQUssU0FBVTtRQUN2QyxJQUFJeU0scUJBQXFCZ0YsbUNBQW1DQywyQkFBMkI1QyxjQUFjdUMsYUFBYSxFQUFFO1FBRXBILHdGQUF3RjtRQUN4Riw0SUFBNEk7UUFDNUksTUFBTU0sZ0JBQWdCbEYsbUJBQW1CNVgsTUFBTSxHQUFHaWEsZUFBZWpaO1FBQ2pFLElBQUksQ0FBQzRXLG1CQUFtQjVYLE1BQU0sRUFBRTtZQUM5QixJQUFJLENBQUNzWixjQUFjdFosTUFBTSxFQUFFO2dCQUN6QjtZQUNGO1lBQ0F3YyxZQUFZbEQsY0FBYzdOLEtBQUs7WUFDL0JtTSxxQkFBcUIrRSxrQkFBa0JILFdBQVd2QztRQUNwRDtRQUNBQSxlQUFlZCxVQUFVdkIsb0JBQW9CcUMsY0FBY3BNLFlBQVkyTyxXQUFXLE9BQU9sRDtRQUN6RnNELG1DQUFtQzNDLGlCQUFpQjZDO1FBQ3BEVixjQUFjbkMsY0FBY3VDLFdBQVc1RTtJQUN6QztJQUNBLElBQUlxQyxhQUFhOU8sTUFBTSxLQUFLLFVBQVU7UUFDcENvUixhQUFhdEMsY0FBY3VDLFdBQVczTztJQUN4QztJQUNBLE9BQU87UUFDTDdKLFVBQVVpVztRQUNWa0M7SUFDRjtBQUNGO0FBQ0EsU0FBU0ksYUFBYWpRLFNBQVMsRUFBRXJQLEtBQUssRUFBRTRRLFVBQVU7SUFDaEQsT0FBTzRMLHlCQUF5Qm5OLFdBQVdyUCxPQUFPNFEsWUFBWXZPLE9BQU8rQixNQUFNLENBQUNpTCxVQUFVekgsUUFBUSxFQUFFakQsR0FBRyxDQUFDcUksQ0FBQUEsUUFBU0QsVUFBVUMsU0FBUyxFQUFFLEVBQUVqSjtBQUN0STtBQUNBLFNBQVMyYixrQkFBa0IxZixLQUFLLEVBQUVxUCxTQUFTO0lBQ3pDLE9BQU9BLFVBQVVuSixPQUFPLENBQUM0WixpQkFBaUIsQ0FBQ3pRLFdBQVdyUDtBQUN4RDtBQUNBLFNBQVM0ZiwyQkFBMkJ2USxTQUFTLEVBQUVyUCxLQUFLO0lBQ2xELE1BQU0rZix1QkFBdUIsSUFBSS9ZO0lBQ2pDLE1BQU1nWixlQUFlM1EsVUFBVXBJLE1BQU0sQ0FBQ3ZDLE1BQU0sQ0FBQ3NPO0lBQzdDLEtBQUssTUFBTUMsYUFBYStNLGFBQWM7UUFDcENDLE1BQU0sS0FBSyxNQUFNcE0sS0FBSztZQUFDWjtTQUFVLENBQUNtRyxNQUFNLENBQUNoRyxtQkFBbUJILFdBQVdsUCxZQUFhO1lBQ2xGLElBQUksQ0FBQzhQLEVBQUVxTSxNQUFNLEVBQUU7Z0JBQ2I7WUFDRjtZQUNBLEtBQUssTUFBTTNRLGNBQWNzRSxFQUFFcU0sTUFBTSxDQUFFO2dCQUNqQyxJQUFJM1EsV0FBVytDLEtBQUssS0FBS3ZPLGFBQWFxTyxjQUFjN0MsV0FBVytDLEtBQUssRUFBRWpELFVBQVVuTCxPQUFPLEVBQUVsRSxPQUFPcVAsWUFBWTtvQkFDMUcwUSxxQkFBcUJwVixHQUFHLENBQUM0RTtvQkFDekIsTUFBTTBRO2dCQUNSO1lBQ0Y7UUFDRjtJQUNGO0lBQ0EsT0FBT3ZGLDZCQUE2QjNWLE1BQU1xVyxJQUFJLENBQUMyRSx1QkFBdUIsSUFBSS9ZLElBQUlxSSxVQUFVcEksTUFBTSxHQUFHb0ksVUFBVXVMLFlBQVk7QUFDekg7QUFFQTs7Ozs7Q0FLQyxHQUNELFNBQVN1RixrQkFBa0I1TCxRQUFRLEVBQUVwUixVQUFVO0lBQzdDLE1BQU1pZCxnQkFBZ0I1TSxpQkFBaUJ1RixjQUFjeEUsVUFBVXBSO0lBQy9ELE9BQU9tUixjQUFjQyxVQUFVO1dBQUk2TDtLQUFjO0FBQ25EO0FBRUEsU0FBU2hkLGtCQUFrQmxELEtBQUs7SUFDOUIsT0FBTyxDQUFDLENBQUNBLFNBQVMsT0FBT0EsVUFBVSxZQUFZLGFBQWFBLFNBQVMsV0FBV0E7QUFDbEY7QUFDQSxNQUFNbWdCLHlCQUF5QixTQUFTdE8sUUFBUXVPLFNBQVM7SUFDdkQsT0FBT3ZlLGFBQWF1ZSxXQUFXLElBQUksQ0FBQ3BnQixLQUFLO0FBQzNDO0FBQ0EsTUFBTXFnQix3QkFBd0IsU0FBU0MsT0FBT0MsR0FBRztJQUMvQyxPQUFPLElBQUksQ0FBQ0MsSUFBSSxDQUFDM00sR0FBRyxDQUFDME07QUFDdkI7QUFDQSxNQUFNRSxxQkFBcUIsU0FBU0MsSUFBSTVnQixLQUFLO0lBQzNDLElBQUksQ0FBQyxJQUFJLENBQUNrRyxPQUFPLEVBQUU7UUFDakIzQixRQUFRQyxJQUFJLENBQUMsQ0FBQyw2RkFBNkYsQ0FBQztJQUM5RztJQUNBLE1BQU1xYyxpQkFBaUIsSUFBSSxDQUFDM2EsT0FBTyxDQUFDNFosaUJBQWlCLENBQUMsSUFBSSxFQUFFOWY7SUFDNUQsT0FBTyxDQUFDLENBQUM2Z0IsZ0JBQWdCOWQsVUFDekIsc0RBQXNEO0lBQ3REOGQsZUFBZXhjLElBQUksQ0FBQytTLENBQUFBLElBQUtBLEVBQUUvUixNQUFNLEtBQUt0QixhQUFhcVQsRUFBRUQsT0FBTyxDQUFDcFUsTUFBTTtBQUNyRTtBQUNBLE1BQU0rZCx3QkFBd0IsU0FBUzlRO0lBQ3JDLE1BQU0sRUFDSi9JLFFBQVE4WixLQUFLLEVBQ2JMLElBQUksRUFDSnhhLE9BQU8sRUFDUDhhLE9BQU8sRUFDUGhSLE1BQU0sRUFDTjRRLEdBQUcsRUFDSEosTUFBTSxFQUNOek8sT0FBTyxFQUNQLEdBQUdrUCxZQUNKLEdBQUcsSUFBSTtJQUNSLE9BQU87UUFDTCxHQUFHQSxVQUFVO1FBQ2JQLE1BQU0zYixNQUFNcVcsSUFBSSxDQUFDc0Y7SUFDbkI7QUFDRjtBQUNBLE1BQU1RLHlCQUF5QixTQUFTRjtJQUN0QyxPQUFPLElBQUksQ0FBQy9aLE1BQU0sQ0FBQ29TLE1BQU0sQ0FBQyxDQUFDOEgsS0FBS2xPO1FBQzlCLElBQUlBLFVBQVVtTyxJQUFJLEtBQUtyZCxXQUFXO1lBQ2hDb2QsR0FBRyxDQUFDbE8sVUFBVW5TLEVBQUUsQ0FBQyxHQUFHbVMsVUFBVW1PLElBQUk7UUFDcEM7UUFDQSxPQUFPRDtJQUNULEdBQUcsQ0FBQztBQUNOO0FBQ0EsU0FBU0Usc0JBQXNCemEsTUFBTSxFQUFFVixPQUFPO0lBQzVDLE9BQU87UUFDTGdJLFFBQVF0SCxPQUFPc0gsTUFBTTtRQUNyQmpOLFFBQVEyRixPQUFPM0YsTUFBTTtRQUNyQkssT0FBT3NGLE9BQU90RixLQUFLO1FBQ25CNEU7UUFDQWhDLFNBQVMwQyxPQUFPMUMsT0FBTztRQUN2QitDLFFBQVFMLE9BQU9LLE1BQU07UUFDckIvRyxPQUFPb1UsY0FBY3BPLFFBQVFpVCxJQUFJLEVBQUV2UyxPQUFPSyxNQUFNO1FBQ2hEeVosTUFBTSxJQUFJMVosSUFBSUosT0FBT0ssTUFBTSxDQUFDQyxPQUFPLENBQUNDLENBQUFBLEtBQU1BLEdBQUd1WixJQUFJO1FBQ2pEOVksVUFBVWhCLE9BQU9nQixRQUFRO1FBQ3pCZ1QsY0FBY2hVLE9BQU9nVSxZQUFZLElBQUksQ0FBQztRQUN0QzdJLFNBQVNzTztRQUNURyxRQUFRRDtRQUNSSyxLQUFLRDtRQUNMSyxTQUFTRTtRQUNUbFIsUUFBUThRO0lBQ1Y7QUFDRjtBQUNBLFNBQVN6UCxxQkFBcUJ0SyxRQUFRLEVBQUVILFNBQVMsQ0FBQyxDQUFDO0lBQ2pELE9BQU95YSxzQkFBc0I7UUFDM0IsR0FBR3RhLFFBQVE7UUFDWCxHQUFHSCxNQUFNO0lBQ1gsR0FBR0csU0FBU2IsT0FBTztBQUNyQjtBQUNBLFNBQVNvYixzQkFBc0IxRyxZQUFZO0lBQ3pDLElBQUksT0FBT0EsaUJBQWlCLFlBQVlBLGlCQUFpQixNQUFNO1FBQzdELE9BQU8sQ0FBQztJQUNWO0lBQ0EsTUFBTWhZLFNBQVMsQ0FBQztJQUNoQixJQUFLLE1BQU1KLE9BQU9vWSxhQUFjO1FBQzlCLE1BQU0xYSxRQUFRMGEsWUFBWSxDQUFDcFksSUFBSTtRQUMvQixJQUFJdUMsTUFBTXBDLE9BQU8sQ0FBQ3pDLFFBQVE7WUFDeEIwQyxNQUFNLENBQUNKLElBQUksR0FBR3RDLE1BQU15RSxHQUFHLENBQUM4VixDQUFBQSxPQUFTO29CQUMvQjNaLElBQUkyWixLQUFLM1osRUFBRTtnQkFDYjtRQUNGO0lBQ0Y7SUFDQSxPQUFPOEI7QUFDVDtBQUNBLFNBQVNzTixxQkFBcUJuSixRQUFRLEVBQUVZLE9BQU87SUFDN0MsTUFBTSxFQUNKVixRQUFROFosS0FBSyxFQUNiTCxJQUFJLEVBQ0p4YSxPQUFPLEVBQ1AwQixRQUFRLEVBQ1IxRCxPQUFPLEVBQ1AwYyxHQUFHLEVBQ0hKLE1BQU0sRUFDTnpPLE9BQU8sRUFDUGlQLE9BQU8sRUFDUGhSLE1BQU0sRUFDTixHQUFHaVIsWUFDSixHQUFHbGE7SUFDSixNQUFNd2EsZUFBZSxDQUFDO0lBQ3RCLElBQUssTUFBTXpnQixNQUFNOEcsU0FBVTtRQUN6QixNQUFNb0YsUUFBUXBGLFFBQVEsQ0FBQzlHLEdBQUc7UUFDMUIsSUFBSSxPQUFPa00sTUFBTTdHLEdBQUcsS0FBSyxZQUFhLEVBQUN3QixXQUFXLENBQUUsZ0NBQStCQSxPQUFNLENBQUMsR0FBSTtZQUM1RixNQUFNLElBQUk2QyxNQUFNO1FBQ2xCO1FBQ0ErVyxZQUFZLENBQUN6Z0IsR0FBRyxHQUFHO1lBQ2pCaUcsVUFBVWlHLE1BQU1rRCxvQkFBb0IsQ0FBQ3ZJO1lBQ3JDeEIsS0FBSzZHLE1BQU03RyxHQUFHO1lBQ2RpRSxVQUFVNEMsTUFBTVIsU0FBUztZQUN6QkssY0FBY0csTUFBTVgsYUFBYTtRQUNuQztJQUNGO0lBQ0EsTUFBTW1WLFlBQVk7UUFDaEIsR0FBR1AsVUFBVTtRQUNiL2MsU0FBU3VkLGVBQWV2ZDtRQUN4QjBELFVBQVUyWjtRQUNWM0csY0FBYzBHLHNCQUFzQkwsV0FBV3JHLFlBQVk7SUFDN0Q7SUFDQSxPQUFPNEc7QUFDVDtBQUNBLFNBQVNDLGVBQWVDLFdBQVc7SUFDakMsSUFBSUM7SUFDSixJQUFLLE1BQU1uZixPQUFPa2YsWUFBYTtRQUM3QixNQUFNeGhCLFFBQVF3aEIsV0FBVyxDQUFDbGYsSUFBSTtRQUM5QixJQUFJdEMsU0FBUyxPQUFPQSxVQUFVLFVBQVU7WUFDdEMsSUFBSSxlQUFlQSxTQUFTLFVBQVVBLFNBQVMsU0FBU0EsT0FBTztnQkFDN0R5aEIsU0FBUzVjLE1BQU1wQyxPQUFPLENBQUMrZSxlQUFlQSxZQUFZL1ksS0FBSyxLQUFLO29CQUMxRCxHQUFHK1ksV0FBVztnQkFDaEI7Z0JBQ0FDLElBQUksQ0FBQ25mLElBQUksR0FBRztvQkFDVnlOLGNBQWMzRTtvQkFDZHhLLElBQUlaLE1BQU1ZLEVBQUU7Z0JBQ2Q7WUFDRixPQUFPO2dCQUNMLE1BQU04QixTQUFTNmUsZUFBZXZoQjtnQkFDOUIsSUFBSTBDLFdBQVcxQyxPQUFPO29CQUNwQnloQixTQUFTNWMsTUFBTXBDLE9BQU8sQ0FBQytlLGVBQWVBLFlBQVkvWSxLQUFLLEtBQUs7d0JBQzFELEdBQUcrWSxXQUFXO29CQUNoQjtvQkFDQUMsSUFBSSxDQUFDbmYsSUFBSSxHQUFHSTtnQkFDZDtZQUNGO1FBQ0Y7SUFDRjtJQUNBLE9BQU8rZSxRQUFRRDtBQUNqQjtBQUVBLFNBQVNFLGFBQWF0UixDQUFDLEVBQUV2SixRQUFRLEVBQUUwSyxJQUFJLEVBQUVqQixZQUFZLEVBQUUsRUFDckR4USxPQUFPNmhCLFdBQVcsRUFDbEIvZ0IsRUFBRSxFQUNGMEgsS0FBSyxFQUNOLEVBQUUsRUFDRDZULGFBQWEsRUFDZDtJQUNDLE1BQU15RixZQUFZL2EsU0FBU2IsT0FBTyxDQUFDRyxlQUFlLENBQUMwYixNQUFNO0lBQ3pELElBQUksT0FBT0YsZ0JBQWdCLFVBQVU7UUFDbkMsTUFBTSxJQUFJclgsTUFDViw0RUFBNEU7UUFDNUUsQ0FBQyw4REFBOEQsRUFBRXFYLFlBQVksWUFBWSxDQUFDO0lBQzVGO0lBQ0EsTUFBTUcsZ0JBQWdCLE9BQU9ILGdCQUFnQixhQUFhQSxZQUFZcFEsTUFBTWpCLGdCQUFnQnFSO0lBQzVGLElBQUlyTDtJQUNKLElBQUksT0FBT2hPLFVBQVUsVUFBVTtRQUM3QixNQUFNeVosY0FBY0gsYUFBYUEsU0FBUyxDQUFDdFosTUFBTTtRQUNqRGdPLGdCQUFnQixPQUFPeUwsZ0JBQWdCLGFBQWFBLFlBQVl4USxNQUFNakIsZ0JBQWdCeVI7SUFDeEYsT0FBTztRQUNMekwsZ0JBQWdCLE9BQU9oTyxVQUFVLGFBQWFBLE1BQU1pSixNQUFNakIsZ0JBQWdCaEk7SUFDNUU7SUFDQSxJQUFJLE9BQU9nTyxrQkFBa0IsVUFBVTtRQUNyQzZGLGNBQWNuWixJQUFJLENBQUM4ZTtJQUNyQjtJQUNBLE9BQU87UUFBQ2piO1FBQVU7WUFDaEIvRyxPQUFPZ2lCO1lBQ1BsaEI7WUFDQTBILE9BQU9nTztRQUNUO1FBQUd6UztLQUFVO0FBQ2Y7QUFDQSxTQUFTbWUsYUFBYXRSLFVBQVUsRUFBRWpELE1BQU07SUFDdEMsTUFBTSxFQUNKM04sS0FBSyxFQUNMd0ksS0FBSyxFQUNMMUgsRUFBRSxFQUNILEdBQUc2TTtJQUNKLElBQUksT0FBT25GLFVBQVUsVUFBVTtRQUM3Qm9JLFdBQVc5RCxLQUFLLENBQUM7WUFDZixNQUFNM0ksT0FBT3lNLFdBQVd6TSxJQUFJO1lBQzVCeU0sV0FBVzNILE1BQU0sQ0FBQ1osU0FBUyxDQUFDQyxRQUFRLENBQUNuRSxNQUFNQSxNQUFNbkUsT0FBT3dJLE9BQU8xSDtRQUNqRTtRQUNBO0lBQ0Y7QUFDRjtBQUNBOzs7OztDQUtDLEdBQ0QsU0FBU3FWLE1BQU0wTCxXQUFXLEVBQUVsYSxPQUFPO0lBQ2pDLElBQUkwRCx1QkFBdUI7UUFDekI5RyxRQUFRQyxJQUFJLENBQUM7SUFDZjtJQUNBLFNBQVMyUixNQUFNdEYsS0FBSyxFQUFFQyxPQUFPO1FBQzNCO1lBQ0UsTUFBTSxJQUFJdEcsTUFBTSxDQUFDLGdDQUFnQyxDQUFDO1FBQ3BEO0lBQ0Y7SUFDQTJMLE1BQU1wVixJQUFJLEdBQUc7SUFDYm9WLE1BQU1uVyxLQUFLLEdBQUc2aEI7SUFDZDFMLE1BQU1yVixFQUFFLEdBQUc2RyxTQUFTN0c7SUFDcEJxVixNQUFNM04sS0FBSyxHQUFHYixTQUFTYTtJQUN2QjJOLE1BQU1wRixPQUFPLEdBQUc2UTtJQUNoQnpMLE1BQU1uRixPQUFPLEdBQUdrUjtJQUNoQixPQUFPL0w7QUFDVDtBQUVrakMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lcmEtcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL3hzdGF0ZS9kaXN0L3JhaXNlLTc4YjhkY2I4LmRldmVsb3BtZW50LmVzbS5qcz8wNzg3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRldlRvb2xzQWRhcHRlciB9IGZyb20gJy4uL2Rldi9kaXN0L3hzdGF0ZS1kZXYuZGV2ZWxvcG1lbnQuZXNtLmpzJztcblxuY2xhc3MgTWFpbGJveCB7XG4gIGNvbnN0cnVjdG9yKF9wcm9jZXNzKSB7XG4gICAgdGhpcy5fcHJvY2VzcyA9IF9wcm9jZXNzO1xuICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuX2N1cnJlbnQgPSBudWxsO1xuICAgIHRoaXMuX2xhc3QgPSBudWxsO1xuICB9XG4gIHN0YXJ0KCkge1xuICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5mbHVzaCgpO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIC8vIHdlIGNhbid0IHNldCBfY3VycmVudCB0byBudWxsIGJlY2F1c2Ugd2UgbWlnaHQgYmUgY3VycmVudGx5IHByb2Nlc3NpbmdcbiAgICAvLyBhbmQgZW5xdWV1ZSBmb2xsb3dpbmcgY2xlYXIgc2hvdWxkbid0IHN0YXJ0IHByb2Nlc3NpbmcgdGhlIGVucXVldWVkIGl0ZW0gaW1tZWRpYXRlbHlcbiAgICBpZiAodGhpcy5fY3VycmVudCkge1xuICAgICAgdGhpcy5fY3VycmVudC5uZXh0ID0gbnVsbDtcbiAgICAgIHRoaXMuX2xhc3QgPSB0aGlzLl9jdXJyZW50O1xuICAgIH1cbiAgfVxuICBlbnF1ZXVlKGV2ZW50KSB7XG4gICAgY29uc3QgZW5xdWV1ZWQgPSB7XG4gICAgICB2YWx1ZTogZXZlbnQsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcbiAgICBpZiAodGhpcy5fY3VycmVudCkge1xuICAgICAgdGhpcy5fbGFzdC5uZXh0ID0gZW5xdWV1ZWQ7XG4gICAgICB0aGlzLl9sYXN0ID0gZW5xdWV1ZWQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2N1cnJlbnQgPSBlbnF1ZXVlZDtcbiAgICB0aGlzLl9sYXN0ID0gZW5xdWV1ZWQ7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhpcy5mbHVzaCgpO1xuICAgIH1cbiAgfVxuICBmbHVzaCgpIHtcbiAgICB3aGlsZSAodGhpcy5fY3VycmVudCkge1xuICAgICAgLy8gYXRtIHRoZSBnaXZlbiBfcHJvY2VzcyBpcyByZXNwb25zaWJsZSBmb3IgaW1wbGVtZW50aW5nIHByb3BlciB0cnkvY2F0Y2ggaGFuZGxpbmdcbiAgICAgIC8vIHdlIGFzc3VtZSBoZXJlIHRoYXQgdGhpcyB3b24ndCB0aHJvdyBpbiBhIHdheSB0aGF0IGNhbiBhZmZlY3QgdGhpcyBtYWlsYm94XG4gICAgICBjb25zdCBjb25zdW1lZCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICB0aGlzLl9wcm9jZXNzKGNvbnN1bWVkLnZhbHVlKTtcbiAgICAgIHRoaXMuX2N1cnJlbnQgPSBjb25zdW1lZC5uZXh0O1xuICAgIH1cbiAgICB0aGlzLl9sYXN0ID0gbnVsbDtcbiAgfVxufVxuXG5jb25zdCBTVEFURV9ERUxJTUlURVIgPSAnLic7XG5jb25zdCBUQVJHRVRMRVNTX0tFWSA9ICcnO1xuY29uc3QgTlVMTF9FVkVOVCA9ICcnO1xuY29uc3QgU1RBVEVfSURFTlRJRklFUiA9ICcjJztcbmNvbnN0IFdJTERDQVJEID0gJyonO1xuY29uc3QgWFNUQVRFX0lOSVQgPSAneHN0YXRlLmluaXQnO1xuY29uc3QgWFNUQVRFX0VSUk9SID0gJ3hzdGF0ZS5lcnJvcic7XG5jb25zdCBYU1RBVEVfU1RPUCA9ICd4c3RhdGUuc3RvcCc7XG5cbi8qKlxuICogUmV0dXJucyBhbiBldmVudCB0aGF0IHJlcHJlc2VudHMgYW4gaW1wbGljaXQgZXZlbnQgdGhhdCBpcyBzZW50IGFmdGVyIHRoZVxuICogc3BlY2lmaWVkIGBkZWxheWAuXG4gKlxuICogQHBhcmFtIGRlbGF5UmVmIFRoZSBkZWxheSBpbiBtaWxsaXNlY29uZHNcbiAqIEBwYXJhbSBpZCBUaGUgc3RhdGUgbm9kZSBJRCB3aGVyZSB0aGlzIGV2ZW50IGlzIGhhbmRsZWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQWZ0ZXJFdmVudChkZWxheVJlZiwgaWQpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBgeHN0YXRlLmFmdGVyLiR7ZGVsYXlSZWZ9LiR7aWR9YFxuICB9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gZXZlbnQgdGhhdCByZXByZXNlbnRzIHRoYXQgYSBmaW5hbCBzdGF0ZSBub2RlIGhhcyBiZWVuIHJlYWNoZWQgaW5cbiAqIHRoZSBwYXJlbnQgc3RhdGUgbm9kZS5cbiAqXG4gKiBAcGFyYW0gaWQgVGhlIGZpbmFsIHN0YXRlIG5vZGUncyBwYXJlbnQgc3RhdGUgbm9kZSBgaWRgXG4gKiBAcGFyYW0gb3V0cHV0IFRoZSBkYXRhIHRvIHBhc3MgaW50byB0aGUgZXZlbnRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRG9uZVN0YXRlRXZlbnQoaWQsIG91dHB1dCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IGB4c3RhdGUuZG9uZS5zdGF0ZS4ke2lkfWAsXG4gICAgb3V0cHV0XG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBldmVudCB0aGF0IHJlcHJlc2VudHMgdGhhdCBhbiBpbnZva2VkIHNlcnZpY2UgaGFzIHRlcm1pbmF0ZWQuXG4gKlxuICogQW4gaW52b2tlZCBzZXJ2aWNlIGlzIHRlcm1pbmF0ZWQgd2hlbiBpdCBoYXMgcmVhY2hlZCBhIHRvcC1sZXZlbCBmaW5hbCBzdGF0ZVxuICogbm9kZSwgYnV0IG5vdCB3aGVuIGl0IGlzIGNhbmNlbGVkLlxuICpcbiAqIEBwYXJhbSBpbnZva2VJZCBUaGUgaW52b2tlZCBzZXJ2aWNlIElEXG4gKiBAcGFyYW0gb3V0cHV0IFRoZSBkYXRhIHRvIHBhc3MgaW50byB0aGUgZXZlbnRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRG9uZUFjdG9yRXZlbnQoaW52b2tlSWQsIG91dHB1dCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IGB4c3RhdGUuZG9uZS5hY3Rvci4ke2ludm9rZUlkfWAsXG4gICAgb3V0cHV0LFxuICAgIGFjdG9ySWQ6IGludm9rZUlkXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVFcnJvckFjdG9yRXZlbnQoaWQsIGVycm9yKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogYHhzdGF0ZS5lcnJvci5hY3Rvci4ke2lkfWAsXG4gICAgZXJyb3IsXG4gICAgYWN0b3JJZDogaWRcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUluaXRFdmVudChpbnB1dCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFhTVEFURV9JTklULFxuICAgIGlucHV0XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBtYWtlcyBzdXJlIHRoYXQgdW5oYW5kbGVkIGVycm9ycyBhcmUgdGhyb3duIGluIGEgc2VwYXJhdGVcbiAqIG1hY3JvdGFzay4gSXQgYWxsb3dzIHRob3NlIGVycm9ycyB0byBiZSBkZXRlY3RlZCBieSBnbG9iYWwgZXJyb3IgaGFuZGxlcnMgYW5kXG4gKiByZXBvcnRlZCB0byBidWcgdHJhY2tpbmcgc2VydmljZXMgd2l0aG91dCBpbnRlcnJ1cHRpbmcgb3VyIG93biBzdGFjayBvZlxuICogZXhlY3V0aW9uLlxuICpcbiAqIEBwYXJhbSBlcnIgRXJyb3IgdG8gYmUgdGhyb3duXG4gKi9cbmZ1bmN0aW9uIHJlcG9ydFVuaGFuZGxlZEVycm9yKGVycikge1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICB0aHJvdyBlcnI7XG4gIH0pO1xufVxuXG5jb25zdCBzeW1ib2xPYnNlcnZhYmxlID0gKCgpID0+IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLm9ic2VydmFibGUgfHwgJ0BAb2JzZXJ2YWJsZScpKCk7XG5cbmZ1bmN0aW9uIG1hdGNoZXNTdGF0ZShwYXJlbnRTdGF0ZUlkLCBjaGlsZFN0YXRlSWQpIHtcbiAgY29uc3QgcGFyZW50U3RhdGVWYWx1ZSA9IHRvU3RhdGVWYWx1ZShwYXJlbnRTdGF0ZUlkKTtcbiAgY29uc3QgY2hpbGRTdGF0ZVZhbHVlID0gdG9TdGF0ZVZhbHVlKGNoaWxkU3RhdGVJZCk7XG4gIGlmICh0eXBlb2YgY2hpbGRTdGF0ZVZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2YgcGFyZW50U3RhdGVWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBjaGlsZFN0YXRlVmFsdWUgPT09IHBhcmVudFN0YXRlVmFsdWU7XG4gICAgfVxuXG4gICAgLy8gUGFyZW50IG1vcmUgc3BlY2lmaWMgdGhhbiBjaGlsZFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIHBhcmVudFN0YXRlVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcmVudFN0YXRlVmFsdWUgaW4gY2hpbGRTdGF0ZVZhbHVlO1xuICB9XG4gIHJldHVybiBPYmplY3Qua2V5cyhwYXJlbnRTdGF0ZVZhbHVlKS5ldmVyeShrZXkgPT4ge1xuICAgIGlmICghKGtleSBpbiBjaGlsZFN0YXRlVmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBtYXRjaGVzU3RhdGUocGFyZW50U3RhdGVWYWx1ZVtrZXldLCBjaGlsZFN0YXRlVmFsdWVba2V5XSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gdG9TdGF0ZVBhdGgoc3RhdGVJZCkge1xuICBpZiAoaXNBcnJheShzdGF0ZUlkKSkge1xuICAgIHJldHVybiBzdGF0ZUlkO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgc2VnbWVudCA9ICcnO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlSWQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGFyID0gc3RhdGVJZC5jaGFyQ29kZUF0KGkpO1xuICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgLy8gXFxcbiAgICAgIGNhc2UgOTI6XG4gICAgICAgIC8vIGNvbnN1bWUgdGhlIG5leHQgY2hhcmFjdGVyXG4gICAgICAgIHNlZ21lbnQgKz0gc3RhdGVJZFtpICsgMV07XG4gICAgICAgIC8vIGFuZCBza2lwIG92ZXIgaXRcbiAgICAgICAgaSsrO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIC8vIC5cbiAgICAgIGNhc2UgNDY6XG4gICAgICAgIHJlc3VsdC5wdXNoKHNlZ21lbnQpO1xuICAgICAgICBzZWdtZW50ID0gJyc7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBzZWdtZW50ICs9IHN0YXRlSWRbaV07XG4gIH1cbiAgcmVzdWx0LnB1c2goc2VnbWVudCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB0b1N0YXRlVmFsdWUoc3RhdGVWYWx1ZSkge1xuICBpZiAoaXNNYWNoaW5lU25hcHNob3Qoc3RhdGVWYWx1ZSkpIHtcbiAgICByZXR1cm4gc3RhdGVWYWx1ZS52YWx1ZTtcbiAgfVxuICBpZiAodHlwZW9mIHN0YXRlVmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHN0YXRlVmFsdWU7XG4gIH1cbiAgY29uc3Qgc3RhdGVQYXRoID0gdG9TdGF0ZVBhdGgoc3RhdGVWYWx1ZSk7XG4gIHJldHVybiBwYXRoVG9TdGF0ZVZhbHVlKHN0YXRlUGF0aCk7XG59XG5mdW5jdGlvbiBwYXRoVG9TdGF0ZVZhbHVlKHN0YXRlUGF0aCkge1xuICBpZiAoc3RhdGVQYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBzdGF0ZVBhdGhbMF07XG4gIH1cbiAgY29uc3QgdmFsdWUgPSB7fTtcbiAgbGV0IG1hcmtlciA9IHZhbHVlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlUGF0aC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBpZiAoaSA9PT0gc3RhdGVQYXRoLmxlbmd0aCAtIDIpIHtcbiAgICAgIG1hcmtlcltzdGF0ZVBhdGhbaV1dID0gc3RhdGVQYXRoW2kgKyAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcHJldmlvdXMgPSBtYXJrZXI7XG4gICAgICBtYXJrZXIgPSB7fTtcbiAgICAgIHByZXZpb3VzW3N0YXRlUGF0aFtpXV0gPSBtYXJrZXI7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIG1hcFZhbHVlcyhjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgY29uc3QgY29sbGVjdGlvbktleXMgPSBPYmplY3Qua2V5cyhjb2xsZWN0aW9uKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xsZWN0aW9uS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGtleSA9IGNvbGxlY3Rpb25LZXlzW2ldO1xuICAgIHJlc3VsdFtrZXldID0gaXRlcmF0ZWUoY29sbGVjdGlvbltrZXldLCBrZXksIGNvbGxlY3Rpb24sIGkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB0b0FycmF5U3RyaWN0KHZhbHVlKSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gW3ZhbHVlXTtcbn1cbmZ1bmN0aW9uIHRvQXJyYXkodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIHRvQXJyYXlTdHJpY3QodmFsdWUpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZU91dHB1dChtYXBwZXIsIGNvbnRleHQsIGV2ZW50LCBzZWxmKSB7XG4gIGlmICh0eXBlb2YgbWFwcGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1hcHBlcih7XG4gICAgICBjb250ZXh0LFxuICAgICAgZXZlbnQsXG4gICAgICBzZWxmXG4gICAgfSk7XG4gIH1cbiAgaWYgKCEhbWFwcGVyICYmIHR5cGVvZiBtYXBwZXIgPT09ICdvYmplY3QnICYmIE9iamVjdC52YWx1ZXMobWFwcGVyKS5zb21lKHZhbCA9PiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSkge1xuICAgIGNvbnNvbGUud2FybihgRHluYW1pY2FsbHkgbWFwcGluZyB2YWx1ZXMgdG8gaW5kaXZpZHVhbCBwcm9wZXJ0aWVzIGlzIGRlcHJlY2F0ZWQuIFVzZSBhIHNpbmdsZSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIG1hcHBlZCBvYmplY3QgaW5zdGVhZC5cXG5Gb3VuZCBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIHdob3NlIHZhbHVlcyBhcmUgcG9zc2libHkgbWFwcGluZyBmdW5jdGlvbnM6ICR7T2JqZWN0LmVudHJpZXMobWFwcGVyKS5maWx0ZXIoKFssIHZhbHVlXSkgPT4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gYFxcbiAtICR7a2V5fTogJHt2YWx1ZS50b1N0cmluZygpLnJlcGxhY2UoL1xcblxccyovZywgJycpfWApLmpvaW4oJycpfWApO1xuICB9XG4gIHJldHVybiBtYXBwZXI7XG59XG5mdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzRXJyb3JBY3RvckV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC50eXBlLnN0YXJ0c1dpdGgoJ3hzdGF0ZS5lcnJvci5hY3RvcicpO1xufVxuZnVuY3Rpb24gdG9UcmFuc2l0aW9uQ29uZmlnQXJyYXkoY29uZmlnTGlrZSkge1xuICByZXR1cm4gdG9BcnJheVN0cmljdChjb25maWdMaWtlKS5tYXAodHJhbnNpdGlvbkxpa2UgPT4ge1xuICAgIGlmICh0eXBlb2YgdHJhbnNpdGlvbkxpa2UgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB0cmFuc2l0aW9uTGlrZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRhcmdldDogdHJhbnNpdGlvbkxpa2VcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2l0aW9uTGlrZTtcbiAgfSk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVUYXJnZXQodGFyZ2V0KSB7XG4gIGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCB8fCB0YXJnZXQgPT09IFRBUkdFVExFU1NfS0VZKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gdG9BcnJheSh0YXJnZXQpO1xufVxuZnVuY3Rpb24gdG9PYnNlcnZlcihuZXh0SGFuZGxlciwgZXJyb3JIYW5kbGVyLCBjb21wbGV0aW9uSGFuZGxlcikge1xuICBjb25zdCBpc09ic2VydmVyID0gdHlwZW9mIG5leHRIYW5kbGVyID09PSAnb2JqZWN0JztcbiAgY29uc3Qgc2VsZiA9IGlzT2JzZXJ2ZXIgPyBuZXh0SGFuZGxlciA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIHtcbiAgICBuZXh0OiAoaXNPYnNlcnZlciA/IG5leHRIYW5kbGVyLm5leHQgOiBuZXh0SGFuZGxlcik/LmJpbmQoc2VsZiksXG4gICAgZXJyb3I6IChpc09ic2VydmVyID8gbmV4dEhhbmRsZXIuZXJyb3IgOiBlcnJvckhhbmRsZXIpPy5iaW5kKHNlbGYpLFxuICAgIGNvbXBsZXRlOiAoaXNPYnNlcnZlciA/IG5leHRIYW5kbGVyLmNvbXBsZXRlIDogY29tcGxldGlvbkhhbmRsZXIpPy5iaW5kKHNlbGYpXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVJbnZva2VJZChzdGF0ZU5vZGVJZCwgaW5kZXgpIHtcbiAgcmV0dXJuIGAke2luZGV4fS4ke3N0YXRlTm9kZUlkfWA7XG59XG5mdW5jdGlvbiByZXNvbHZlUmVmZXJlbmNlZEFjdG9yKG1hY2hpbmUsIHNyYykge1xuICBjb25zdCBtYXRjaCA9IHNyYy5tYXRjaCgvXnhzdGF0ZVxcLmludm9rZVxcLihcXGQrKVxcLiguKikvKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBtYWNoaW5lLmltcGxlbWVudGF0aW9ucy5hY3RvcnNbc3JjXTtcbiAgfVxuICBjb25zdCBbLCBpbmRleFN0ciwgbm9kZUlkXSA9IG1hdGNoO1xuICBjb25zdCBub2RlID0gbWFjaGluZS5nZXRTdGF0ZU5vZGVCeUlkKG5vZGVJZCk7XG4gIGNvbnN0IGludm9rZUNvbmZpZyA9IG5vZGUuY29uZmlnLmludm9rZTtcbiAgcmV0dXJuIChBcnJheS5pc0FycmF5KGludm9rZUNvbmZpZykgPyBpbnZva2VDb25maWdbaW5kZXhTdHJdIDogaW52b2tlQ29uZmlnKS5zcmM7XG59XG5mdW5jdGlvbiBnZXRBbGxPd25FdmVudERlc2NyaXB0b3JzKHNuYXBzaG90KSB7XG4gIHJldHVybiBbLi4ubmV3IFNldChbLi4uc25hcHNob3QuX25vZGVzLmZsYXRNYXAoc24gPT4gc24ub3duRXZlbnRzKV0pXTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2NoZWR1bGVkRXZlbnRJZChhY3RvclJlZiwgaWQpIHtcbiAgcmV0dXJuIGAke2FjdG9yUmVmLnNlc3Npb25JZH0uJHtpZH1gO1xufVxubGV0IGlkQ291bnRlciA9IDA7XG5mdW5jdGlvbiBjcmVhdGVTeXN0ZW0ocm9vdEFjdG9yLCBvcHRpb25zKSB7XG4gIGNvbnN0IGNoaWxkcmVuID0gbmV3IE1hcCgpO1xuICBjb25zdCBrZXllZEFjdG9ycyA9IG5ldyBNYXAoKTtcbiAgY29uc3QgcmV2ZXJzZUtleWVkQWN0b3JzID0gbmV3IFdlYWtNYXAoKTtcbiAgY29uc3QgaW5zcGVjdGlvbk9ic2VydmVycyA9IG5ldyBTZXQoKTtcbiAgY29uc3QgdGltZXJNYXAgPSB7fTtcbiAgY29uc3Qge1xuICAgIGNsb2NrLFxuICAgIGxvZ2dlclxuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qgc2NoZWR1bGVyID0ge1xuICAgIHNjaGVkdWxlOiAoc291cmNlLCB0YXJnZXQsIGV2ZW50LCBkZWxheSwgaWQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKSkgPT4ge1xuICAgICAgY29uc3Qgc2NoZWR1bGVkRXZlbnQgPSB7XG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBldmVudCxcbiAgICAgICAgZGVsYXksXG4gICAgICAgIGlkLFxuICAgICAgICBzdGFydGVkQXQ6IERhdGUubm93KClcbiAgICAgIH07XG4gICAgICBjb25zdCBzY2hlZHVsZWRFdmVudElkID0gY3JlYXRlU2NoZWR1bGVkRXZlbnRJZChzb3VyY2UsIGlkKTtcbiAgICAgIHN5c3RlbS5fc25hcHNob3QuX3NjaGVkdWxlZEV2ZW50c1tzY2hlZHVsZWRFdmVudElkXSA9IHNjaGVkdWxlZEV2ZW50O1xuICAgICAgY29uc3QgdGltZW91dCA9IGNsb2NrLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBkZWxldGUgdGltZXJNYXBbc2NoZWR1bGVkRXZlbnRJZF07XG4gICAgICAgIGRlbGV0ZSBzeXN0ZW0uX3NuYXBzaG90Ll9zY2hlZHVsZWRFdmVudHNbc2NoZWR1bGVkRXZlbnRJZF07XG4gICAgICAgIHN5c3RlbS5fcmVsYXkoc291cmNlLCB0YXJnZXQsIGV2ZW50KTtcbiAgICAgIH0sIGRlbGF5KTtcbiAgICAgIHRpbWVyTWFwW3NjaGVkdWxlZEV2ZW50SWRdID0gdGltZW91dDtcbiAgICB9LFxuICAgIGNhbmNlbDogKHNvdXJjZSwgaWQpID0+IHtcbiAgICAgIGNvbnN0IHNjaGVkdWxlZEV2ZW50SWQgPSBjcmVhdGVTY2hlZHVsZWRFdmVudElkKHNvdXJjZSwgaWQpO1xuICAgICAgY29uc3QgdGltZW91dCA9IHRpbWVyTWFwW3NjaGVkdWxlZEV2ZW50SWRdO1xuICAgICAgZGVsZXRlIHRpbWVyTWFwW3NjaGVkdWxlZEV2ZW50SWRdO1xuICAgICAgZGVsZXRlIHN5c3RlbS5fc25hcHNob3QuX3NjaGVkdWxlZEV2ZW50c1tzY2hlZHVsZWRFdmVudElkXTtcbiAgICAgIGlmICh0aW1lb3V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2xvY2suY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgY2FuY2VsQWxsOiBhY3RvclJlZiA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHNjaGVkdWxlZEV2ZW50SWQgaW4gc3lzdGVtLl9zbmFwc2hvdC5fc2NoZWR1bGVkRXZlbnRzKSB7XG4gICAgICAgIGNvbnN0IHNjaGVkdWxlZEV2ZW50ID0gc3lzdGVtLl9zbmFwc2hvdC5fc2NoZWR1bGVkRXZlbnRzW3NjaGVkdWxlZEV2ZW50SWRdO1xuICAgICAgICBpZiAoc2NoZWR1bGVkRXZlbnQuc291cmNlID09PSBhY3RvclJlZikge1xuICAgICAgICAgIHNjaGVkdWxlci5jYW5jZWwoYWN0b3JSZWYsIHNjaGVkdWxlZEV2ZW50LmlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3Qgc2VuZEluc3BlY3Rpb25FdmVudCA9IGV2ZW50ID0+IHtcbiAgICBpZiAoIWluc3BlY3Rpb25PYnNlcnZlcnMuc2l6ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHZlZEluc3BlY3Rpb25FdmVudCA9IHtcbiAgICAgIC4uLmV2ZW50LFxuICAgICAgcm9vdElkOiByb290QWN0b3Iuc2Vzc2lvbklkXG4gICAgfTtcbiAgICBpbnNwZWN0aW9uT2JzZXJ2ZXJzLmZvckVhY2gob2JzZXJ2ZXIgPT4gb2JzZXJ2ZXIubmV4dD8uKHJlc29sdmVkSW5zcGVjdGlvbkV2ZW50KSk7XG4gIH07XG4gIGNvbnN0IHN5c3RlbSA9IHtcbiAgICBfc25hcHNob3Q6IHtcbiAgICAgIF9zY2hlZHVsZWRFdmVudHM6IChvcHRpb25zPy5zbmFwc2hvdCAmJiBvcHRpb25zLnNuYXBzaG90LnNjaGVkdWxlcikgPz8ge31cbiAgICB9LFxuICAgIF9ib29rSWQ6ICgpID0+IGB4OiR7aWRDb3VudGVyKyt9YCxcbiAgICBfcmVnaXN0ZXI6IChzZXNzaW9uSWQsIGFjdG9yUmVmKSA9PiB7XG4gICAgICBjaGlsZHJlbi5zZXQoc2Vzc2lvbklkLCBhY3RvclJlZik7XG4gICAgICByZXR1cm4gc2Vzc2lvbklkO1xuICAgIH0sXG4gICAgX3VucmVnaXN0ZXI6IGFjdG9yUmVmID0+IHtcbiAgICAgIGNoaWxkcmVuLmRlbGV0ZShhY3RvclJlZi5zZXNzaW9uSWQpO1xuICAgICAgY29uc3Qgc3lzdGVtSWQgPSByZXZlcnNlS2V5ZWRBY3RvcnMuZ2V0KGFjdG9yUmVmKTtcbiAgICAgIGlmIChzeXN0ZW1JZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGtleWVkQWN0b3JzLmRlbGV0ZShzeXN0ZW1JZCk7XG4gICAgICAgIHJldmVyc2VLZXllZEFjdG9ycy5kZWxldGUoYWN0b3JSZWYpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0OiBzeXN0ZW1JZCA9PiB7XG4gICAgICByZXR1cm4ga2V5ZWRBY3RvcnMuZ2V0KHN5c3RlbUlkKTtcbiAgICB9LFxuICAgIF9zZXQ6IChzeXN0ZW1JZCwgYWN0b3JSZWYpID0+IHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nID0ga2V5ZWRBY3RvcnMuZ2V0KHN5c3RlbUlkKTtcbiAgICAgIGlmIChleGlzdGluZyAmJiBleGlzdGluZyAhPT0gYWN0b3JSZWYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBY3RvciB3aXRoIHN5c3RlbSBJRCAnJHtzeXN0ZW1JZH0nIGFscmVhZHkgZXhpc3RzLmApO1xuICAgICAgfVxuICAgICAga2V5ZWRBY3RvcnMuc2V0KHN5c3RlbUlkLCBhY3RvclJlZik7XG4gICAgICByZXZlcnNlS2V5ZWRBY3RvcnMuc2V0KGFjdG9yUmVmLCBzeXN0ZW1JZCk7XG4gICAgfSxcbiAgICBpbnNwZWN0OiBvYnNlcnZlck9yRm4gPT4ge1xuICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSB0b09ic2VydmVyKG9ic2VydmVyT3JGbik7XG4gICAgICBpbnNwZWN0aW9uT2JzZXJ2ZXJzLmFkZChvYnNlcnZlcik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgICBpbnNwZWN0aW9uT2JzZXJ2ZXJzLmRlbGV0ZShvYnNlcnZlcik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICBfc2VuZEluc3BlY3Rpb25FdmVudDogc2VuZEluc3BlY3Rpb25FdmVudCxcbiAgICBfcmVsYXk6IChzb3VyY2UsIHRhcmdldCwgZXZlbnQpID0+IHtcbiAgICAgIHN5c3RlbS5fc2VuZEluc3BlY3Rpb25FdmVudCh7XG4gICAgICAgIHR5cGU6ICdAeHN0YXRlLmV2ZW50JyxcbiAgICAgICAgc291cmNlUmVmOiBzb3VyY2UsXG4gICAgICAgIGFjdG9yUmVmOiB0YXJnZXQsXG4gICAgICAgIGV2ZW50XG4gICAgICB9KTtcbiAgICAgIHRhcmdldC5fc2VuZChldmVudCk7XG4gICAgfSxcbiAgICBzY2hlZHVsZXIsXG4gICAgZ2V0U25hcHNob3Q6ICgpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIF9zY2hlZHVsZWRFdmVudHM6IHtcbiAgICAgICAgICAuLi5zeXN0ZW0uX3NuYXBzaG90Ll9zY2hlZHVsZWRFdmVudHNcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIHN0YXJ0OiAoKSA9PiB7XG4gICAgICBjb25zdCBzY2hlZHVsZWRFdmVudHMgPSBzeXN0ZW0uX3NuYXBzaG90Ll9zY2hlZHVsZWRFdmVudHM7XG4gICAgICBzeXN0ZW0uX3NuYXBzaG90Ll9zY2hlZHVsZWRFdmVudHMgPSB7fTtcbiAgICAgIGZvciAoY29uc3Qgc2NoZWR1bGVkSWQgaW4gc2NoZWR1bGVkRXZlbnRzKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgIGRlbGF5LFxuICAgICAgICAgIGlkXG4gICAgICAgIH0gPSBzY2hlZHVsZWRFdmVudHNbc2NoZWR1bGVkSWRdO1xuICAgICAgICBzY2hlZHVsZXIuc2NoZWR1bGUoc291cmNlLCB0YXJnZXQsIGV2ZW50LCBkZWxheSwgaWQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2Nsb2NrOiBjbG9jayxcbiAgICBfbG9nZ2VyOiBsb2dnZXJcbiAgfTtcbiAgcmV0dXJuIHN5c3RlbTtcbn1cblxuLy8gdGhvc2UgYXJlIG5lZWRlZCB0byBtYWtlIEpTRG9jIGBAbGlua2Agd29yayBwcm9wZXJseVxuXG5sZXQgZXhlY3V0aW5nQ3VzdG9tQWN0aW9uID0gZmFsc2U7XG5jb25zdCAkJEFDVE9SX1RZUEUgPSAxO1xuXG4vLyB0aG9zZSB2YWx1ZXMgYXJlIGN1cnJlbnRseSB1c2VkIGJ5IEB4c3RhdGUvcmVhY3QgZGlyZWN0bHkgc28gaXQncyBpbXBvcnRhbnQgdG8ga2VlcCB0aGUgYXNzaWduZWQgdmFsdWVzIGluIHN5bmNcbmxldCBQcm9jZXNzaW5nU3RhdHVzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChQcm9jZXNzaW5nU3RhdHVzKSB7XG4gIFByb2Nlc3NpbmdTdGF0dXNbUHJvY2Vzc2luZ1N0YXR1c1tcIk5vdFN0YXJ0ZWRcIl0gPSAwXSA9IFwiTm90U3RhcnRlZFwiO1xuICBQcm9jZXNzaW5nU3RhdHVzW1Byb2Nlc3NpbmdTdGF0dXNbXCJSdW5uaW5nXCJdID0gMV0gPSBcIlJ1bm5pbmdcIjtcbiAgUHJvY2Vzc2luZ1N0YXR1c1tQcm9jZXNzaW5nU3RhdHVzW1wiU3RvcHBlZFwiXSA9IDJdID0gXCJTdG9wcGVkXCI7XG4gIHJldHVybiBQcm9jZXNzaW5nU3RhdHVzO1xufSh7fSk7XG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgY2xvY2s6IHtcbiAgICBzZXRUaW1lb3V0OiAoZm4sIG1zKSA9PiB7XG4gICAgICByZXR1cm4gc2V0VGltZW91dChmbiwgbXMpO1xuICAgIH0sXG4gICAgY2xlYXJUaW1lb3V0OiBpZCA9PiB7XG4gICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KGlkKTtcbiAgICB9XG4gIH0sXG4gIGxvZ2dlcjogY29uc29sZS5sb2cuYmluZChjb25zb2xlKSxcbiAgZGV2VG9vbHM6IGZhbHNlXG59O1xuXG4vKipcbiAqIEFuIEFjdG9yIGlzIGEgcnVubmluZyBwcm9jZXNzIHRoYXQgY2FuIHJlY2VpdmUgZXZlbnRzLCBzZW5kIGV2ZW50cyBhbmQgY2hhbmdlXG4gKiBpdHMgYmVoYXZpb3IgYmFzZWQgb24gdGhlIGV2ZW50cyBpdCByZWNlaXZlcywgd2hpY2ggY2FuIGNhdXNlIGVmZmVjdHMgb3V0c2lkZVxuICogb2YgdGhlIGFjdG9yLiBXaGVuIHlvdSBydW4gYSBzdGF0ZSBtYWNoaW5lLCBpdCBiZWNvbWVzIGFuIGFjdG9yLlxuICovXG5jbGFzcyBBY3RvciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGFjdG9yIGluc3RhbmNlIGZvciB0aGUgZ2l2ZW4gbG9naWMgd2l0aCB0aGUgcHJvdmlkZWQgb3B0aW9ucyxcbiAgICogaWYgYW55LlxuICAgKlxuICAgKiBAcGFyYW0gbG9naWMgVGhlIGxvZ2ljIHRvIGNyZWF0ZSBhbiBhY3RvciBmcm9tXG4gICAqIEBwYXJhbSBvcHRpb25zIEFjdG9yIG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKGxvZ2ljLCBvcHRpb25zKSB7XG4gICAgdGhpcy5sb2dpYyA9IGxvZ2ljO1xuICAgIC8qKiBUaGUgY3VycmVudCBpbnRlcm5hbCBzdGF0ZSBvZiB0aGUgYWN0b3IuICovXG4gICAgdGhpcy5fc25hcHNob3QgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogVGhlIGNsb2NrIHRoYXQgaXMgcmVzcG9uc2libGUgZm9yIHNldHRpbmcgYW5kIGNsZWFyaW5nIHRpbWVvdXRzLCBzdWNoIGFzXG4gICAgICogZGVsYXllZCBldmVudHMgYW5kIHRyYW5zaXRpb25zLlxuICAgICAqL1xuICAgIHRoaXMuY2xvY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5vcHRpb25zID0gdm9pZCAwO1xuICAgIC8qKiBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgYWN0b3IgcmVsYXRpdmUgdG8gaXRzIHBhcmVudC4gKi9cbiAgICB0aGlzLmlkID0gdm9pZCAwO1xuICAgIHRoaXMubWFpbGJveCA9IG5ldyBNYWlsYm94KHRoaXMuX3Byb2Nlc3MuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5vYnNlcnZlcnMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5ldmVudExpc3RlbmVycyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmxvZ2dlciA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcHJvY2Vzc2luZ1N0YXR1cyA9IFByb2Nlc3NpbmdTdGF0dXMuTm90U3RhcnRlZDtcbiAgICAvLyBBY3RvciBSZWZcbiAgICB0aGlzLl9wYXJlbnQgPSB2b2lkIDA7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3N5bmNTbmFwc2hvdCA9IHZvaWQgMDtcbiAgICB0aGlzLnJlZiA9IHZvaWQgMDtcbiAgICAvLyBUT0RPOiBhZGQgdHlwaW5ncyBmb3Igc3lzdGVtXG4gICAgdGhpcy5fYWN0b3JTY29wZSA9IHZvaWQgMDtcbiAgICB0aGlzLl9zeXN0ZW1JZCA9IHZvaWQgMDtcbiAgICAvKiogVGhlIGdsb2JhbGx5IHVuaXF1ZSBwcm9jZXNzIElEIGZvciB0aGlzIGludm9jYXRpb24uICovXG4gICAgdGhpcy5zZXNzaW9uSWQgPSB2b2lkIDA7XG4gICAgLyoqIFRoZSBzeXN0ZW0gdG8gd2hpY2ggdGhpcyBhY3RvciBiZWxvbmdzLiAqL1xuICAgIHRoaXMuc3lzdGVtID0gdm9pZCAwO1xuICAgIHRoaXMuX2RvbmVFdmVudCA9IHZvaWQgMDtcbiAgICB0aGlzLnNyYyA9IHZvaWQgMDtcbiAgICAvLyBhcnJheSBvZiBmdW5jdGlvbnMgdG8gZGVmZXJcbiAgICB0aGlzLl9kZWZlcnJlZCA9IFtdO1xuICAgIGNvbnN0IHJlc29sdmVkT3B0aW9ucyA9IHtcbiAgICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG4gICAgY29uc3Qge1xuICAgICAgY2xvY2ssXG4gICAgICBsb2dnZXIsXG4gICAgICBwYXJlbnQsXG4gICAgICBzeW5jU25hcHNob3QsXG4gICAgICBpZCxcbiAgICAgIHN5c3RlbUlkLFxuICAgICAgaW5zcGVjdFxuICAgIH0gPSByZXNvbHZlZE9wdGlvbnM7XG4gICAgdGhpcy5zeXN0ZW0gPSBwYXJlbnQgPyBwYXJlbnQuc3lzdGVtIDogY3JlYXRlU3lzdGVtKHRoaXMsIHtcbiAgICAgIGNsb2NrLFxuICAgICAgbG9nZ2VyXG4gICAgfSk7XG4gICAgaWYgKGluc3BlY3QgJiYgIXBhcmVudCkge1xuICAgICAgLy8gQWx3YXlzIGluc3BlY3QgYXQgdGhlIHN5c3RlbS1sZXZlbFxuICAgICAgdGhpcy5zeXN0ZW0uaW5zcGVjdCh0b09ic2VydmVyKGluc3BlY3QpKTtcbiAgICB9XG4gICAgdGhpcy5zZXNzaW9uSWQgPSB0aGlzLnN5c3RlbS5fYm9va0lkKCk7XG4gICAgdGhpcy5pZCA9IGlkID8/IHRoaXMuc2Vzc2lvbklkO1xuICAgIHRoaXMubG9nZ2VyID0gb3B0aW9ucz8ubG9nZ2VyID8/IHRoaXMuc3lzdGVtLl9sb2dnZXI7XG4gICAgdGhpcy5jbG9jayA9IG9wdGlvbnM/LmNsb2NrID8/IHRoaXMuc3lzdGVtLl9jbG9jaztcbiAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5fc3luY1NuYXBzaG90ID0gc3luY1NuYXBzaG90O1xuICAgIHRoaXMub3B0aW9ucyA9IHJlc29sdmVkT3B0aW9ucztcbiAgICB0aGlzLnNyYyA9IHJlc29sdmVkT3B0aW9ucy5zcmMgPz8gbG9naWM7XG4gICAgdGhpcy5yZWYgPSB0aGlzO1xuICAgIHRoaXMuX2FjdG9yU2NvcGUgPSB7XG4gICAgICBzZWxmOiB0aGlzLFxuICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICBzZXNzaW9uSWQ6IHRoaXMuc2Vzc2lvbklkLFxuICAgICAgbG9nZ2VyOiB0aGlzLmxvZ2dlcixcbiAgICAgIGRlZmVyOiBmbiA9PiB7XG4gICAgICAgIHRoaXMuX2RlZmVycmVkLnB1c2goZm4pO1xuICAgICAgfSxcbiAgICAgIHN5c3RlbTogdGhpcy5zeXN0ZW0sXG4gICAgICBzdG9wQ2hpbGQ6IGNoaWxkID0+IHtcbiAgICAgICAgaWYgKGNoaWxkLl9wYXJlbnQgIT09IHRoaXMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBzdG9wIGNoaWxkIGFjdG9yICR7Y2hpbGQuaWR9IG9mICR7dGhpcy5pZH0gYmVjYXVzZSBpdCBpcyBub3QgYSBjaGlsZGApO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkLl9zdG9wKCk7XG4gICAgICB9LFxuICAgICAgZW1pdDogZW1pdHRlZEV2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5ldmVudExpc3RlbmVycy5nZXQoZW1pdHRlZEV2ZW50LnR5cGUpO1xuICAgICAgICBjb25zdCB3aWxkY2FyZExpc3RlbmVyID0gdGhpcy5ldmVudExpc3RlbmVycy5nZXQoJyonKTtcbiAgICAgICAgaWYgKCFsaXN0ZW5lcnMgJiYgIXdpbGRjYXJkTGlzdGVuZXIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxsTGlzdGVuZXJzID0gWy4uLihsaXN0ZW5lcnMgPyBsaXN0ZW5lcnMudmFsdWVzKCkgOiBbXSksIC4uLih3aWxkY2FyZExpc3RlbmVyID8gd2lsZGNhcmRMaXN0ZW5lci52YWx1ZXMoKSA6IFtdKV07XG4gICAgICAgIGZvciAoY29uc3QgaGFuZGxlciBvZiBhbGxMaXN0ZW5lcnMpIHtcbiAgICAgICAgICBoYW5kbGVyKGVtaXR0ZWRFdmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhY3Rpb25FeGVjdXRvcjogYWN0aW9uID0+IHtcbiAgICAgICAgY29uc3QgZXhlYyA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLl9hY3RvclNjb3BlLnN5c3RlbS5fc2VuZEluc3BlY3Rpb25FdmVudCh7XG4gICAgICAgICAgICB0eXBlOiAnQHhzdGF0ZS5hY3Rpb24nLFxuICAgICAgICAgICAgYWN0b3JSZWY6IHRoaXMsXG4gICAgICAgICAgICBhY3Rpb246IHtcbiAgICAgICAgICAgICAgdHlwZTogYWN0aW9uLnR5cGUsXG4gICAgICAgICAgICAgIHBhcmFtczogYWN0aW9uLnBhcmFtc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICghYWN0aW9uLmV4ZWMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc2F2ZUV4ZWN1dGluZ0N1c3RvbUFjdGlvbiA9IGV4ZWN1dGluZ0N1c3RvbUFjdGlvbjtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZXhlY3V0aW5nQ3VzdG9tQWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIGFjdGlvbi5leGVjKGFjdGlvbi5pbmZvLCBhY3Rpb24ucGFyYW1zKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgZXhlY3V0aW5nQ3VzdG9tQWN0aW9uID0gc2F2ZUV4ZWN1dGluZ0N1c3RvbUFjdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLl9wcm9jZXNzaW5nU3RhdHVzID09PSBQcm9jZXNzaW5nU3RhdHVzLlJ1bm5pbmcpIHtcbiAgICAgICAgICBleGVjKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fZGVmZXJyZWQucHVzaChleGVjKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBFbnN1cmUgdGhhdCB0aGUgc2VuZCBtZXRob2QgaXMgYm91bmQgdG8gdGhpcyBBY3RvciBpbnN0YW5jZVxuICAgIC8vIGlmIGRlc3RydWN0dXJlZFxuICAgIHRoaXMuc2VuZCA9IHRoaXMuc2VuZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc3lzdGVtLl9zZW5kSW5zcGVjdGlvbkV2ZW50KHtcbiAgICAgIHR5cGU6ICdAeHN0YXRlLmFjdG9yJyxcbiAgICAgIGFjdG9yUmVmOiB0aGlzXG4gICAgfSk7XG4gICAgaWYgKHN5c3RlbUlkKSB7XG4gICAgICB0aGlzLl9zeXN0ZW1JZCA9IHN5c3RlbUlkO1xuICAgICAgdGhpcy5zeXN0ZW0uX3NldChzeXN0ZW1JZCwgdGhpcyk7XG4gICAgfVxuICAgIHRoaXMuX2luaXRTdGF0ZShvcHRpb25zPy5zbmFwc2hvdCA/PyBvcHRpb25zPy5zdGF0ZSk7XG4gICAgaWYgKHN5c3RlbUlkICYmIHRoaXMuX3NuYXBzaG90LnN0YXR1cyAhPT0gJ2FjdGl2ZScpIHtcbiAgICAgIHRoaXMuc3lzdGVtLl91bnJlZ2lzdGVyKHRoaXMpO1xuICAgIH1cbiAgfVxuICBfaW5pdFN0YXRlKHBlcnNpc3RlZFN0YXRlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX3NuYXBzaG90ID0gcGVyc2lzdGVkU3RhdGUgPyB0aGlzLmxvZ2ljLnJlc3RvcmVTbmFwc2hvdCA/IHRoaXMubG9naWMucmVzdG9yZVNuYXBzaG90KHBlcnNpc3RlZFN0YXRlLCB0aGlzLl9hY3RvclNjb3BlKSA6IHBlcnNpc3RlZFN0YXRlIDogdGhpcy5sb2dpYy5nZXRJbml0aWFsU25hcHNob3QodGhpcy5fYWN0b3JTY29wZSwgdGhpcy5vcHRpb25zPy5pbnB1dCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBpZiB3ZSBnZXQgaGVyZSB0aGVuIGl0IG1lYW5zIHRoYXQgd2UgYXNzaWduIGEgdmFsdWUgdG8gdGhpcy5fc25hcHNob3QgdGhhdCBpcyBub3Qgb2YgdGhlIGNvcnJlY3QgdHlwZVxuICAgICAgLy8gd2UgY2FuJ3QgZ2V0IHRoZSB0cnVlIGBUU25hcHNob3QgJiB7IHN0YXR1czogJ2Vycm9yJzsgfWAsIGl0J3MgaW1wb3NzaWJsZVxuICAgICAgLy8gc28gcmlnaHQgbm93IHRoaXMgaXMgYSBsaWUgb2Ygc29ydHNcbiAgICAgIHRoaXMuX3NuYXBzaG90ID0ge1xuICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgIG91dHB1dDogdW5kZWZpbmVkLFxuICAgICAgICBlcnJvcjogZXJyXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICB1cGRhdGUoc25hcHNob3QsIGV2ZW50KSB7XG4gICAgLy8gVXBkYXRlIHN0YXRlXG4gICAgdGhpcy5fc25hcHNob3QgPSBzbmFwc2hvdDtcblxuICAgIC8vIEV4ZWN1dGUgZGVmZXJyZWQgZWZmZWN0c1xuICAgIGxldCBkZWZlcnJlZEZuO1xuICAgIHdoaWxlIChkZWZlcnJlZEZuID0gdGhpcy5fZGVmZXJyZWQuc2hpZnQoKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGVmZXJyZWRGbigpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIHRoaXMgZXJyb3IgY2FuIG9ubHkgYmUgY2F1Z2h0IHdoZW4gZXhlY3V0aW5nICppbml0aWFsKiBhY3Rpb25zXG4gICAgICAgIC8vIGl0J3MgdGhlIG9ubHkgdGltZSB3aGVuIHdlIGNhbGwgYWN0aW9ucyBwcm92aWRlZCBieSB0aGUgdXNlciB0aHJvdWdoIHRob3NlIGRlZmVycmVkc1xuICAgICAgICAvLyB3aGVuIHRoZSBhY3RvciBpcyBhbHJlYWR5IHJ1bm5pbmcgd2UgYWx3YXlzIGV4ZWN1dGUgdGhlbSBzeW5jaHJvbm91c2x5IHdoaWxlIHRyYW5zaXRpb25pbmdcbiAgICAgICAgLy8gbm8gXCJidWlsdGluIGRlZmVycmVkXCIgc2hvdWxkIGFjdHVhbGx5IHRocm93IGFuIGVycm9yIHNpbmNlIHRoZXkgYXJlIGVpdGhlciBzYWZlXG4gICAgICAgIC8vIG9yIHRoZSBjb250cm9sIGZsb3cgaXMgcGFzc2VkIHRocm91Z2ggdGhlIG1haWxib3ggYW5kIGVycm9ycyBzaG91bGQgYmUgY2F1Z2h0IGJ5IHRoZSBgX3Byb2Nlc3NgIHVzZWQgYnkgdGhlIG1haWxib3hcbiAgICAgICAgdGhpcy5fZGVmZXJyZWQubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5fc25hcHNob3QgPSB7XG4gICAgICAgICAgLi4uc25hcHNob3QsXG4gICAgICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoICh0aGlzLl9zbmFwc2hvdC5zdGF0dXMpIHtcbiAgICAgIGNhc2UgJ2FjdGl2ZSc6XG4gICAgICAgIGZvciAoY29uc3Qgb2JzZXJ2ZXIgb2YgdGhpcy5vYnNlcnZlcnMpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dD8uKHNuYXBzaG90KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJlcG9ydFVuaGFuZGxlZEVycm9yKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZG9uZSc6XG4gICAgICAgIC8vIG5leHQgb2JzZXJ2ZXJzIGFyZSBtZWFudCB0byBiZSBub3RpZmllZCBhYm91dCBkb25lIHNuYXBzaG90c1xuICAgICAgICAvLyB0aGlzIGNhbiBiZSBzZWVuIGFzIHNvbWV0aGluZyB0aGF0IGlzIGRpZmZlcmVudCBmcm9tIGhvdyBvYnNlcnZhYmxlIHdvcmtcbiAgICAgICAgLy8gYnV0IHdpdGggb2JzZXJ2YWJsZXMgYGNvbXBsZXRlYCBjYWxsYmFjayBpcyBjYWxsZWQgd2l0aG91dCBhbnkgYXJndW1lbnRzXG4gICAgICAgIC8vIGl0J3MgbW9yZSBlcmdvbm9taWMgZm9yIFhTdGF0ZSB0byB0cmVhdCBhIGRvbmUgc25hcHNob3QgYXMgYSBcIm5leHRcIiB2YWx1ZVxuICAgICAgICAvLyBhbmQgdGhlIGNvbXBsZXRpb24gZXZlbnQgYXMgc29tZXRoaW5nIHRoYXQgaXMgc2VwYXJhdGUsXG4gICAgICAgIC8vIHNvbWV0aGluZyB0aGF0IG1lcmVseSBmb2xsb3dzIGVtaXR0aW5nIHRoYXQgZG9uZSBzbmFwc2hvdFxuICAgICAgICBmb3IgKGNvbnN0IG9ic2VydmVyIG9mIHRoaXMub2JzZXJ2ZXJzKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQ/LihzbmFwc2hvdCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXBvcnRVbmhhbmRsZWRFcnJvcihlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdG9wUHJvY2VkdXJlKCk7XG4gICAgICAgIHRoaXMuX2NvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMuX2RvbmVFdmVudCA9IGNyZWF0ZURvbmVBY3RvckV2ZW50KHRoaXMuaWQsIHRoaXMuX3NuYXBzaG90Lm91dHB1dCk7XG4gICAgICAgIGlmICh0aGlzLl9wYXJlbnQpIHtcbiAgICAgICAgICB0aGlzLnN5c3RlbS5fcmVsYXkodGhpcywgdGhpcy5fcGFyZW50LCB0aGlzLl9kb25lRXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICB0aGlzLl9lcnJvcih0aGlzLl9zbmFwc2hvdC5lcnJvcik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLnN5c3RlbS5fc2VuZEluc3BlY3Rpb25FdmVudCh7XG4gICAgICB0eXBlOiAnQHhzdGF0ZS5zbmFwc2hvdCcsXG4gICAgICBhY3RvclJlZjogdGhpcyxcbiAgICAgIGV2ZW50LFxuICAgICAgc25hcHNob3RcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgYW4gb2JzZXJ2ZXIgdG8gYW4gYWN0b3LigJlzIHNuYXBzaG90IHZhbHVlcy5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogVGhlIG9ic2VydmVyIHdpbGwgcmVjZWl2ZSB0aGUgYWN0b3LigJlzIHNuYXBzaG90IHZhbHVlIHdoZW4gaXQgaXMgZW1pdHRlZC5cbiAgICogVGhlIG9ic2VydmVyIGNhbiBiZTpcbiAgICpcbiAgICogLSBBIHBsYWluIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgdGhlIGxhdGVzdCBzbmFwc2hvdCwgb3JcbiAgICogLSBBbiBvYnNlcnZlciBvYmplY3Qgd2hvc2UgYC5uZXh0KHNuYXBzaG90KWAgbWV0aG9kIHJlY2VpdmVzIHRoZSBsYXRlc3RcbiAgICogICBzbmFwc2hvdFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGB0c1xuICAgKiAvLyBPYnNlcnZlciBhcyBhIHBsYWluIGZ1bmN0aW9uXG4gICAqIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGFjdG9yLnN1YnNjcmliZSgoc25hcHNob3QpID0+IHtcbiAgICogICBjb25zb2xlLmxvZyhzbmFwc2hvdCk7XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogYGBgdHNcbiAgICogLy8gT2JzZXJ2ZXIgYXMgYW4gb2JqZWN0XG4gICAqIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGFjdG9yLnN1YnNjcmliZSh7XG4gICAqICAgbmV4dChzbmFwc2hvdCkge1xuICAgKiAgICAgY29uc29sZS5sb2coc25hcHNob3QpO1xuICAgKiAgIH0sXG4gICAqICAgZXJyb3IoZXJyKSB7XG4gICAqICAgICAvLyAuLi5cbiAgICogICB9LFxuICAgKiAgIGNvbXBsZXRlKCkge1xuICAgKiAgICAgLy8gLi4uXG4gICAqICAgfVxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIFRoZSByZXR1cm4gdmFsdWUgb2YgYGFjdG9yLnN1YnNjcmliZShvYnNlcnZlcilgIGlzIGEgc3Vic2NyaXB0aW9uIG9iamVjdFxuICAgKiB0aGF0IGhhcyBhbiBgLnVuc3Vic2NyaWJlKClgIG1ldGhvZC4gWW91IGNhbiBjYWxsXG4gICAqIGBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKWAgdG8gdW5zdWJzY3JpYmUgdGhlIG9ic2VydmVyOlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGB0c1xuICAgKiBjb25zdCBzdWJzY3JpcHRpb24gPSBhY3Rvci5zdWJzY3JpYmUoKHNuYXBzaG90KSA9PiB7XG4gICAqICAgLy8gLi4uXG4gICAqIH0pO1xuICAgKlxuICAgKiAvLyBVbnN1YnNjcmliZSB0aGUgb2JzZXJ2ZXJcbiAgICogc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBXaGVuIHRoZSBhY3RvciBpcyBzdG9wcGVkLCBhbGwgb2YgaXRzIG9ic2VydmVycyB3aWxsIGF1dG9tYXRpY2FsbHkgYmVcbiAgICogdW5zdWJzY3JpYmVkLlxuICAgKlxuICAgKiBAcGFyYW0gb2JzZXJ2ZXIgLSBFaXRoZXIgYSBwbGFpbiBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIHRoZSBsYXRlc3RcbiAgICogICBzbmFwc2hvdCwgb3IgYW4gb2JzZXJ2ZXIgb2JqZWN0IHdob3NlIGAubmV4dChzbmFwc2hvdClgIG1ldGhvZCByZWNlaXZlc1xuICAgKiAgIHRoZSBsYXRlc3Qgc25hcHNob3RcbiAgICovXG5cbiAgc3Vic2NyaWJlKG5leHRMaXN0ZW5lck9yT2JzZXJ2ZXIsIGVycm9yTGlzdGVuZXIsIGNvbXBsZXRlTGlzdGVuZXIpIHtcbiAgICBjb25zdCBvYnNlcnZlciA9IHRvT2JzZXJ2ZXIobmV4dExpc3RlbmVyT3JPYnNlcnZlciwgZXJyb3JMaXN0ZW5lciwgY29tcGxldGVMaXN0ZW5lcik7XG4gICAgaWYgKHRoaXMuX3Byb2Nlc3NpbmdTdGF0dXMgIT09IFByb2Nlc3NpbmdTdGF0dXMuU3RvcHBlZCkge1xuICAgICAgdGhpcy5vYnNlcnZlcnMuYWRkKG9ic2VydmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoICh0aGlzLl9zbmFwc2hvdC5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSAnZG9uZSc6XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlPy4oKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJlcG9ydFVuaGFuZGxlZEVycm9yKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgZXJyID0gdGhpcy5fc25hcHNob3QuZXJyb3I7XG4gICAgICAgICAgICBpZiAoIW9ic2VydmVyLmVycm9yKSB7XG4gICAgICAgICAgICAgIHJlcG9ydFVuaGFuZGxlZEVycm9yKGVycik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGVycik7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHJlcG9ydFVuaGFuZGxlZEVycm9yKGVycik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHVuc3Vic2NyaWJlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzLmRlbGV0ZShvYnNlcnZlcik7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBvbih0eXBlLCBoYW5kbGVyKSB7XG4gICAgbGV0IGxpc3RlbmVycyA9IHRoaXMuZXZlbnRMaXN0ZW5lcnMuZ2V0KHR5cGUpO1xuICAgIGlmICghbGlzdGVuZXJzKSB7XG4gICAgICBsaXN0ZW5lcnMgPSBuZXcgU2V0KCk7XG4gICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzLnNldCh0eXBlLCBsaXN0ZW5lcnMpO1xuICAgIH1cbiAgICBjb25zdCB3cmFwcGVkSGFuZGxlciA9IGhhbmRsZXIuYmluZCh1bmRlZmluZWQpO1xuICAgIGxpc3RlbmVycy5hZGQod3JhcHBlZEhhbmRsZXIpO1xuICAgIHJldHVybiB7XG4gICAgICB1bnN1YnNjcmliZTogKCkgPT4ge1xuICAgICAgICBsaXN0ZW5lcnMuZGVsZXRlKHdyYXBwZWRIYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqIFN0YXJ0cyB0aGUgQWN0b3IgZnJvbSB0aGUgaW5pdGlhbCBzdGF0ZSAqL1xuICBzdGFydCgpIHtcbiAgICBpZiAodGhpcy5fcHJvY2Vzc2luZ1N0YXR1cyA9PT0gUHJvY2Vzc2luZ1N0YXR1cy5SdW5uaW5nKSB7XG4gICAgICAvLyBEbyBub3QgcmVzdGFydCB0aGUgc2VydmljZSBpZiBpdCBpcyBhbHJlYWR5IHN0YXJ0ZWRcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc3luY1NuYXBzaG90KSB7XG4gICAgICB0aGlzLnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6IHNuYXBzaG90ID0+IHtcbiAgICAgICAgICBpZiAoc25hcHNob3Quc3RhdHVzID09PSAnYWN0aXZlJykge1xuICAgICAgICAgICAgdGhpcy5zeXN0ZW0uX3JlbGF5KHRoaXMsIHRoaXMuX3BhcmVudCwge1xuICAgICAgICAgICAgICB0eXBlOiBgeHN0YXRlLnNuYXBzaG90LiR7dGhpcy5pZH1gLFxuICAgICAgICAgICAgICBzbmFwc2hvdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogKCkgPT4ge31cbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnN5c3RlbS5fcmVnaXN0ZXIodGhpcy5zZXNzaW9uSWQsIHRoaXMpO1xuICAgIGlmICh0aGlzLl9zeXN0ZW1JZCkge1xuICAgICAgdGhpcy5zeXN0ZW0uX3NldCh0aGlzLl9zeXN0ZW1JZCwgdGhpcyk7XG4gICAgfVxuICAgIHRoaXMuX3Byb2Nlc3NpbmdTdGF0dXMgPSBQcm9jZXNzaW5nU3RhdHVzLlJ1bm5pbmc7XG5cbiAgICAvLyBUT0RPOiB0aGlzIGlzbid0IGNvcnJlY3Qgd2hlbiByZWh5ZHJhdGluZ1xuICAgIGNvbnN0IGluaXRFdmVudCA9IGNyZWF0ZUluaXRFdmVudCh0aGlzLm9wdGlvbnMuaW5wdXQpO1xuICAgIHRoaXMuc3lzdGVtLl9zZW5kSW5zcGVjdGlvbkV2ZW50KHtcbiAgICAgIHR5cGU6ICdAeHN0YXRlLmV2ZW50JyxcbiAgICAgIHNvdXJjZVJlZjogdGhpcy5fcGFyZW50LFxuICAgICAgYWN0b3JSZWY6IHRoaXMsXG4gICAgICBldmVudDogaW5pdEV2ZW50XG4gICAgfSk7XG4gICAgY29uc3Qgc3RhdHVzID0gdGhpcy5fc25hcHNob3Quc3RhdHVzO1xuICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICBjYXNlICdkb25lJzpcbiAgICAgICAgLy8gYSBzdGF0ZSBtYWNoaW5lIGNhbiBiZSBcImRvbmVcIiB1cG9uIGluaXRpYWxpemF0aW9uIChpdCBjb3VsZCByZWFjaCBhIGZpbmFsIHN0YXRlIHVzaW5nIGluaXRpYWwgbWljcm9zdGVwcylcbiAgICAgICAgLy8gd2Ugc3RpbGwgbmVlZCB0byBjb21wbGV0ZSBvYnNlcnZlcnMsIGZsdXNoIGRlZmVycmVkcyBldGNcbiAgICAgICAgdGhpcy51cGRhdGUodGhpcy5fc25hcHNob3QsIGluaXRFdmVudCk7XG4gICAgICAgIC8vIFRPRE86IHJldGhpbmsgY2xlYW51cCBvZiBvYnNlcnZlcnMsIG1haWxib3gsIGV0Y1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgdGhpcy5fZXJyb3IodGhpcy5fc25hcHNob3QuZXJyb3IpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9wYXJlbnQpIHtcbiAgICAgIHRoaXMuc3lzdGVtLnN0YXJ0KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmxvZ2ljLnN0YXJ0KSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmxvZ2ljLnN0YXJ0KHRoaXMuX3NuYXBzaG90LCB0aGlzLl9hY3RvclNjb3BlKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLl9zbmFwc2hvdCA9IHtcbiAgICAgICAgICAuLi50aGlzLl9zbmFwc2hvdCxcbiAgICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9lcnJvcihlcnIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiB0aGlzIG5vdGlmaWVzIGFsbCBzdWJzY3JpYmVycyBidXQgdXN1YWxseSB0aGlzIGlzIHJlZHVuZGFudFxuICAgIC8vIHRoZXJlIGlzIG5vIHJlYWwgY2hhbmdlIGhhcHBlbmluZyBoZXJlXG4gICAgLy8gd2UgbmVlZCB0byByZXRoaW5rIGlmIHRoaXMgbmVlZHMgdG8gYmUgcmVmYWN0b3JlZFxuICAgIHRoaXMudXBkYXRlKHRoaXMuX3NuYXBzaG90LCBpbml0RXZlbnQpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZGV2VG9vbHMpIHtcbiAgICAgIHRoaXMuYXR0YWNoRGV2VG9vbHMoKTtcbiAgICB9XG4gICAgdGhpcy5tYWlsYm94LnN0YXJ0KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgX3Byb2Nlc3MoZXZlbnQpIHtcbiAgICBsZXQgbmV4dFN0YXRlO1xuICAgIGxldCBjYXVnaHRFcnJvcjtcbiAgICB0cnkge1xuICAgICAgbmV4dFN0YXRlID0gdGhpcy5sb2dpYy50cmFuc2l0aW9uKHRoaXMuX3NuYXBzaG90LCBldmVudCwgdGhpcy5fYWN0b3JTY29wZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyB3ZSB3cmFwIGl0IGluIGEgYm94IHNvIHdlIGNhbiByZXRocm93IGl0IGxhdGVyIGV2ZW4gaWYgZmFsc3kgdmFsdWUgZ2V0cyBjYXVnaHQgaGVyZVxuICAgICAgY2F1Z2h0RXJyb3IgPSB7XG4gICAgICAgIGVyclxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGNhdWdodEVycm9yKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGVyclxuICAgICAgfSA9IGNhdWdodEVycm9yO1xuICAgICAgdGhpcy5fc25hcHNob3QgPSB7XG4gICAgICAgIC4uLnRoaXMuX3NuYXBzaG90LFxuICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgIGVycm9yOiBlcnJcbiAgICAgIH07XG4gICAgICB0aGlzLl9lcnJvcihlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZShuZXh0U3RhdGUsIGV2ZW50KTtcbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gWFNUQVRFX1NUT1ApIHtcbiAgICAgIHRoaXMuX3N0b3BQcm9jZWR1cmUoKTtcbiAgICAgIHRoaXMuX2NvbXBsZXRlKCk7XG4gICAgfVxuICB9XG4gIF9zdG9wKCkge1xuICAgIGlmICh0aGlzLl9wcm9jZXNzaW5nU3RhdHVzID09PSBQcm9jZXNzaW5nU3RhdHVzLlN0b3BwZWQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0aGlzLm1haWxib3guY2xlYXIoKTtcbiAgICBpZiAodGhpcy5fcHJvY2Vzc2luZ1N0YXR1cyA9PT0gUHJvY2Vzc2luZ1N0YXR1cy5Ob3RTdGFydGVkKSB7XG4gICAgICB0aGlzLl9wcm9jZXNzaW5nU3RhdHVzID0gUHJvY2Vzc2luZ1N0YXR1cy5TdG9wcGVkO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRoaXMubWFpbGJveC5lbnF1ZXVlKHtcbiAgICAgIHR5cGU6IFhTVEFURV9TVE9QXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogU3RvcHMgdGhlIEFjdG9yIGFuZCB1bnN1YnNjcmliZSBhbGwgbGlzdGVuZXJzLiAqL1xuICBzdG9wKCkge1xuICAgIGlmICh0aGlzLl9wYXJlbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQSBub24tcm9vdCBhY3RvciBjYW5ub3QgYmUgc3RvcHBlZCBkaXJlY3RseS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3N0b3AoKTtcbiAgfVxuICBfY29tcGxldGUoKSB7XG4gICAgZm9yIChjb25zdCBvYnNlcnZlciBvZiB0aGlzLm9ic2VydmVycykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGU/LigpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlcG9ydFVuaGFuZGxlZEVycm9yKGVycik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMub2JzZXJ2ZXJzLmNsZWFyKCk7XG4gIH1cbiAgX3JlcG9ydEVycm9yKGVycikge1xuICAgIGlmICghdGhpcy5vYnNlcnZlcnMuc2l6ZSkge1xuICAgICAgaWYgKCF0aGlzLl9wYXJlbnQpIHtcbiAgICAgICAgcmVwb3J0VW5oYW5kbGVkRXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHJlcG9ydEVycm9yID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBvYnNlcnZlciBvZiB0aGlzLm9ic2VydmVycykge1xuICAgICAgY29uc3QgZXJyb3JMaXN0ZW5lciA9IG9ic2VydmVyLmVycm9yO1xuICAgICAgcmVwb3J0RXJyb3IgfHw9ICFlcnJvckxpc3RlbmVyO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZXJyb3JMaXN0ZW5lcj8uKGVycik7XG4gICAgICB9IGNhdGNoIChlcnIyKSB7XG4gICAgICAgIHJlcG9ydFVuaGFuZGxlZEVycm9yKGVycjIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm9ic2VydmVycy5jbGVhcigpO1xuICAgIGlmIChyZXBvcnRFcnJvcikge1xuICAgICAgcmVwb3J0VW5oYW5kbGVkRXJyb3IoZXJyKTtcbiAgICB9XG4gIH1cbiAgX2Vycm9yKGVycikge1xuICAgIHRoaXMuX3N0b3BQcm9jZWR1cmUoKTtcbiAgICB0aGlzLl9yZXBvcnRFcnJvcihlcnIpO1xuICAgIGlmICh0aGlzLl9wYXJlbnQpIHtcbiAgICAgIHRoaXMuc3lzdGVtLl9yZWxheSh0aGlzLCB0aGlzLl9wYXJlbnQsIGNyZWF0ZUVycm9yQWN0b3JFdmVudCh0aGlzLmlkLCBlcnIpKTtcbiAgICB9XG4gIH1cbiAgLy8gVE9ETzogYXRtIGNoaWxkcmVuIGRvbid0IGJlbG9uZyBlbnRpcmVseSB0byB0aGUgYWN0b3Igc29cbiAgLy8gaW4gYSB3YXkgLSBpdCdzIG5vdCBldmVuIHN1cGVyIGF3YXJlIG9mIHRoZW1cbiAgLy8gc28gd2UgY2FuJ3Qgc3RvcCB0aGVtIGZyb20gaGVyZSBidXQgd2UgcmVhbGx5IHNob3VsZCFcbiAgLy8gcmlnaHQgbm93LCB0aGV5IGFyZSBiZWluZyBzdG9wcGVkIHdpdGhpbiB0aGUgbWFjaGluZSdzIHRyYW5zaXRpb25cbiAgLy8gYnV0IHRoYXQgY291bGQgdGhyb3cgYW5kIGxlYXZlIHVzIHdpdGggXCJvcnBoYW5lZFwiIGFjdGl2ZSBhY3RvcnNcbiAgX3N0b3BQcm9jZWR1cmUoKSB7XG4gICAgaWYgKHRoaXMuX3Byb2Nlc3NpbmdTdGF0dXMgIT09IFByb2Nlc3NpbmdTdGF0dXMuUnVubmluZykge1xuICAgICAgLy8gQWN0b3IgYWxyZWFkeSBzdG9wcGVkOyBkbyBub3RoaW5nXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBDYW5jZWwgYWxsIGRlbGF5ZWQgZXZlbnRzXG4gICAgdGhpcy5zeXN0ZW0uc2NoZWR1bGVyLmNhbmNlbEFsbCh0aGlzKTtcblxuICAgIC8vIFRPRE86IG1haWxib3gucmVzZXRcbiAgICB0aGlzLm1haWxib3guY2xlYXIoKTtcbiAgICAvLyBUT0RPOiBhZnRlciBgc3RvcGAgd2UgbXVzdCBwcmVwYXJlIG91cnNlbHZlcyBmb3IgcmVjZWl2aW5nIGV2ZW50cyBhZ2FpblxuICAgIC8vIGV2ZW50cyBzZW50ICphZnRlciogc3RvcCBzaWduYWwgbXVzdCBiZSBxdWV1ZWRcbiAgICAvLyBpdCBzZWVtcyBsaWtlIHRoaXMgc2hvdWxkIGJlIHRoZSBjb21tb24gYmVoYXZpb3IgZm9yIGFsbCBvZiBvdXIgY29uc3VtZXJzXG4gICAgLy8gc28gcGVyaGFwcyB0aGlzIHNob3VsZCBiZSB1bmlmaWVkIHNvbWVob3cgZm9yIGFsbCBvZiB0aGVtXG4gICAgdGhpcy5tYWlsYm94ID0gbmV3IE1haWxib3godGhpcy5fcHJvY2Vzcy5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9wcm9jZXNzaW5nU3RhdHVzID0gUHJvY2Vzc2luZ1N0YXR1cy5TdG9wcGVkO1xuICAgIHRoaXMuc3lzdGVtLl91bnJlZ2lzdGVyKHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc2VuZChldmVudCkge1xuICAgIGlmICh0aGlzLl9wcm9jZXNzaW5nU3RhdHVzID09PSBQcm9jZXNzaW5nU3RhdHVzLlN0b3BwZWQpIHtcbiAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgIHtcbiAgICAgICAgY29uc3QgZXZlbnRTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShldmVudCk7XG4gICAgICAgIGNvbnNvbGUud2FybihgRXZlbnQgXCIke2V2ZW50LnR5cGV9XCIgd2FzIHNlbnQgdG8gc3RvcHBlZCBhY3RvciBcIiR7dGhpcy5pZH0gKCR7dGhpcy5zZXNzaW9uSWR9KVwiLiBUaGlzIGFjdG9yIGhhcyBhbHJlYWR5IHJlYWNoZWQgaXRzIGZpbmFsIHN0YXRlLCBhbmQgd2lsbCBub3QgdHJhbnNpdGlvbi5cXG5FdmVudDogJHtldmVudFN0cmluZ31gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5tYWlsYm94LmVucXVldWUoZXZlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGFuIGV2ZW50IHRvIHRoZSBydW5uaW5nIEFjdG9yIHRvIHRyaWdnZXIgYSB0cmFuc2l0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IHRvIHNlbmRcbiAgICovXG4gIHNlbmQoZXZlbnQpIHtcbiAgICBpZiAodHlwZW9mIGV2ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBPbmx5IGV2ZW50IG9iamVjdHMgbWF5IGJlIHNlbnQgdG8gYWN0b3JzOyB1c2UgLnNlbmQoeyB0eXBlOiBcIiR7ZXZlbnR9XCIgfSkgaW5zdGVhZGApO1xuICAgIH1cbiAgICB0aGlzLnN5c3RlbS5fcmVsYXkodW5kZWZpbmVkLCB0aGlzLCBldmVudCk7XG4gIH1cbiAgYXR0YWNoRGV2VG9vbHMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGV2VG9vbHNcbiAgICB9ID0gdGhpcy5vcHRpb25zO1xuICAgIGlmIChkZXZUb29scykge1xuICAgICAgY29uc3QgcmVzb2x2ZWREZXZUb29sc0FkYXB0ZXIgPSB0eXBlb2YgZGV2VG9vbHMgPT09ICdmdW5jdGlvbicgPyBkZXZUb29scyA6IGRldlRvb2xzQWRhcHRlcjtcbiAgICAgIHJlc29sdmVkRGV2VG9vbHNBZGFwdGVyKHRoaXMpO1xuICAgIH1cbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHhzdGF0ZSQkdHlwZTogJCRBQ1RPUl9UWVBFLFxuICAgICAgaWQ6IHRoaXMuaWRcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIE9idGFpbiB0aGUgaW50ZXJuYWwgc3RhdGUgb2YgdGhlIGFjdG9yLCB3aGljaCBjYW4gYmUgcGVyc2lzdGVkLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBUaGUgaW50ZXJuYWwgc3RhdGUgY2FuIGJlIHBlcnNpc3RlZCBmcm9tIGFueSBhY3Rvciwgbm90IG9ubHkgbWFjaGluZXMuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgcGVyc2lzdGVkIHN0YXRlIGlzIG5vdCB0aGUgc2FtZSBhcyB0aGUgc25hcHNob3QgZnJvbVxuICAgKiB7QGxpbmsgQWN0b3IuZ2V0U25hcHNob3R9LiBQZXJzaXN0ZWQgc3RhdGUgcmVwcmVzZW50cyB0aGUgaW50ZXJuYWwgc3RhdGUgb2ZcbiAgICogdGhlIGFjdG9yLCB3aGlsZSBzbmFwc2hvdHMgcmVwcmVzZW50IHRoZSBhY3RvcidzIGxhc3QgZW1pdHRlZCB2YWx1ZS5cbiAgICpcbiAgICogQ2FuIGJlIHJlc3RvcmVkIHdpdGgge0BsaW5rIEFjdG9yT3B0aW9ucy5zdGF0ZX1cbiAgICogQHNlZSBodHRwczovL3N0YXRlbHkuYWkvZG9jcy9wZXJzaXN0ZW5jZVxuICAgKi9cblxuICBnZXRQZXJzaXN0ZWRTbmFwc2hvdChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMubG9naWMuZ2V0UGVyc2lzdGVkU25hcHNob3QodGhpcy5fc25hcHNob3QsIG9wdGlvbnMpO1xuICB9XG4gIFtzeW1ib2xPYnNlcnZhYmxlXSgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIGFuIGFjdG9y4oCZcyBzbmFwc2hvdCBzeW5jaHJvbm91c2x5LlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBUaGUgc25hcHNob3QgcmVwcmVzZW50IGFuIGFjdG9yJ3MgbGFzdCBlbWl0dGVkIHZhbHVlLlxuICAgKlxuICAgKiBXaGVuIGFuIGFjdG9yIHJlY2VpdmVzIGFuIGV2ZW50LCBpdHMgaW50ZXJuYWwgc3RhdGUgbWF5IGNoYW5nZS4gQW4gYWN0b3JcbiAgICogbWF5IGVtaXQgYSBzbmFwc2hvdCB3aGVuIGEgc3RhdGUgdHJhbnNpdGlvbiBvY2N1cnMuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBzb21lIGFjdG9ycywgc3VjaCBhcyBjYWxsYmFjayBhY3RvcnMgZ2VuZXJhdGVkIHdpdGhcbiAgICogYGZyb21DYWxsYmFja2AsIHdpbGwgbm90IGVtaXQgc25hcHNob3RzLlxuICAgKiBAc2VlIHtAbGluayBBY3Rvci5zdWJzY3JpYmV9IHRvIHN1YnNjcmliZSB0byBhbiBhY3RvcuKAmXMgc25hcHNob3QgdmFsdWVzLlxuICAgKiBAc2VlIHtAbGluayBBY3Rvci5nZXRQZXJzaXN0ZWRTbmFwc2hvdH0gdG8gcGVyc2lzdCB0aGUgaW50ZXJuYWwgc3RhdGUgb2YgYW4gYWN0b3IgKHdoaWNoIGlzIG1vcmUgdGhhbiBqdXN0IGEgc25hcHNob3QpLlxuICAgKi9cbiAgZ2V0U25hcHNob3QoKSB7XG4gICAgaWYgKCF0aGlzLl9zbmFwc2hvdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTbmFwc2hvdCBjYW4ndCBiZSByZWFkIHdoaWxlIHRoZSBhY3RvciBpbml0aWFsaXplcyBpdHNlbGZgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NuYXBzaG90O1xuICB9XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYWN0b3IgaW5zdGFuY2UgZm9yIHRoZSBnaXZlbiBhY3RvciBsb2dpYyB3aXRoIHRoZSBwcm92aWRlZFxuICogb3B0aW9ucywgaWYgYW55LlxuICpcbiAqIEByZW1hcmtzXG4gKiBXaGVuIHlvdSBjcmVhdGUgYW4gYWN0b3IgZnJvbSBhY3RvciBsb2dpYyB2aWEgYGNyZWF0ZUFjdG9yKGxvZ2ljKWAsIHlvdVxuICogaW1wbGljaXRseSBjcmVhdGUgYW4gYWN0b3Igc3lzdGVtIHdoZXJlIHRoZSBjcmVhdGVkIGFjdG9yIGlzIHRoZSByb290IGFjdG9yLlxuICogQW55IGFjdG9ycyBzcGF3bmVkIGZyb20gdGhpcyByb290IGFjdG9yIGFuZCBpdHMgZGVzY2VuZGFudHMgYXJlIHBhcnQgb2YgdGhhdFxuICogYWN0b3Igc3lzdGVtLlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgY3JlYXRlQWN0b3IgfSBmcm9tICd4c3RhdGUnO1xuICogaW1wb3J0IHsgc29tZUFjdG9yTG9naWMgfSBmcm9tICcuL3NvbWVBY3RvckxvZ2ljLnRzJztcbiAqXG4gKiAvLyBDcmVhdGluZyB0aGUgYWN0b3IsIHdoaWNoIGltcGxpY2l0bHkgY3JlYXRlcyBhbiBhY3RvciBzeXN0ZW0gd2l0aCBpdHNlbGYgYXMgdGhlIHJvb3QgYWN0b3JcbiAqIGNvbnN0IGFjdG9yID0gY3JlYXRlQWN0b3Ioc29tZUFjdG9yTG9naWMpO1xuICpcbiAqIGFjdG9yLnN1YnNjcmliZSgoc25hcHNob3QpID0+IHtcbiAqICAgY29uc29sZS5sb2coc25hcHNob3QpO1xuICogfSk7XG4gKlxuICogLy8gQWN0b3JzIG11c3QgYmUgc3RhcnRlZCBieSBjYWxsaW5nIGBhY3Rvci5zdGFydCgpYCwgd2hpY2ggd2lsbCBhbHNvIHN0YXJ0IHRoZSBhY3RvciBzeXN0ZW0uXG4gKiBhY3Rvci5zdGFydCgpO1xuICpcbiAqIC8vIEFjdG9ycyBjYW4gcmVjZWl2ZSBldmVudHNcbiAqIGFjdG9yLnNlbmQoeyB0eXBlOiAnc29tZUV2ZW50JyB9KTtcbiAqXG4gKiAvLyBZb3UgY2FuIHN0b3Agcm9vdCBhY3RvcnMgYnkgY2FsbGluZyBgYWN0b3Iuc3RvcCgpYCwgd2hpY2ggd2lsbCBhbHNvIHN0b3AgdGhlIGFjdG9yIHN5c3RlbSBhbmQgYWxsIGFjdG9ycyBpbiB0aGF0IHN5c3RlbS5cbiAqIGFjdG9yLnN0b3AoKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBsb2dpYyAtIFRoZSBhY3RvciBsb2dpYyB0byBjcmVhdGUgYW4gYWN0b3IgZnJvbS4gRm9yIGEgc3RhdGUgbWFjaGluZVxuICogICBhY3RvciBsb2dpYyBjcmVhdG9yLCBzZWUge0BsaW5rIGNyZWF0ZU1hY2hpbmV9LiBPdGhlciBhY3RvciBsb2dpYyBjcmVhdG9yc1xuICogICBpbmNsdWRlIHtAbGluayBmcm9tQ2FsbGJhY2t9LCB7QGxpbmsgZnJvbUV2ZW50T2JzZXJ2YWJsZX0sXG4gKiAgIHtAbGluayBmcm9tT2JzZXJ2YWJsZX0sIHtAbGluayBmcm9tUHJvbWlzZX0sIGFuZCB7QGxpbmsgZnJvbVRyYW5zaXRpb259LlxuICogQHBhcmFtIG9wdGlvbnMgLSBBY3RvciBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFjdG9yKGxvZ2ljLCAuLi5bb3B0aW9uc10pIHtcbiAgcmV0dXJuIG5ldyBBY3Rvcihsb2dpYywgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBJbnRlcnByZXRlciBpbnN0YW5jZSBmb3IgdGhlIGdpdmVuIG1hY2hpbmUgd2l0aCB0aGUgcHJvdmlkZWRcbiAqIG9wdGlvbnMsIGlmIGFueS5cbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgYGNyZWF0ZUFjdG9yYCBpbnN0ZWFkXG4gKiBAYWxpYXNcbiAqL1xuY29uc3QgaW50ZXJwcmV0ID0gY3JlYXRlQWN0b3I7XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIGBBY3RvcmAgaW5zdGVhZC5cbiAqIEBhbGlhc1xuICovXG5cbmZ1bmN0aW9uIHJlc29sdmVDYW5jZWwoXywgc25hcHNob3QsIGFjdGlvbkFyZ3MsIGFjdGlvblBhcmFtcywge1xuICBzZW5kSWRcbn0pIHtcbiAgY29uc3QgcmVzb2x2ZWRTZW5kSWQgPSB0eXBlb2Ygc2VuZElkID09PSAnZnVuY3Rpb24nID8gc2VuZElkKGFjdGlvbkFyZ3MsIGFjdGlvblBhcmFtcykgOiBzZW5kSWQ7XG4gIHJldHVybiBbc25hcHNob3QsIHtcbiAgICBzZW5kSWQ6IHJlc29sdmVkU2VuZElkXG4gIH0sIHVuZGVmaW5lZF07XG59XG5mdW5jdGlvbiBleGVjdXRlQ2FuY2VsKGFjdG9yU2NvcGUsIHBhcmFtcykge1xuICBhY3RvclNjb3BlLmRlZmVyKCgpID0+IHtcbiAgICBhY3RvclNjb3BlLnN5c3RlbS5zY2hlZHVsZXIuY2FuY2VsKGFjdG9yU2NvcGUuc2VsZiwgcGFyYW1zLnNlbmRJZCk7XG4gIH0pO1xufVxuLyoqXG4gKiBDYW5jZWxzIGEgZGVsYXllZCBgc2VuZFRvKC4uLilgIGFjdGlvbiB0aGF0IGlzIHdhaXRpbmcgdG8gYmUgZXhlY3V0ZWQuIFRoZVxuICogY2FuY2VsZWQgYHNlbmRUbyguLi4pYCBhY3Rpb24gd2lsbCBub3Qgc2VuZCBpdHMgZXZlbnQgb3IgZXhlY3V0ZSwgdW5sZXNzIHRoZVxuICogYGRlbGF5YCBoYXMgYWxyZWFkeSBlbGFwc2VkIGJlZm9yZSBgY2FuY2VsKC4uLilgIGlzIGNhbGxlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBjcmVhdGVNYWNoaW5lLCBzZW5kVG8sIGNhbmNlbCB9IGZyb20gJ3hzdGF0ZSc7XG4gKlxuICogY29uc3QgbWFjaGluZSA9IGNyZWF0ZU1hY2hpbmUoe1xuICogICAvLyAuLi5cbiAqICAgb246IHtcbiAqICAgICBzZW5kRXZlbnQ6IHtcbiAqICAgICAgIGFjdGlvbnM6IHNlbmRUbyhcbiAqICAgICAgICAgJ3NvbWUtYWN0b3InLFxuICogICAgICAgICB7IHR5cGU6ICdzb21lRXZlbnQnIH0sXG4gKiAgICAgICAgIHtcbiAqICAgICAgICAgICBpZDogJ3NvbWUtaWQnLFxuICogICAgICAgICAgIGRlbGF5OiAxMDAwXG4gKiAgICAgICAgIH1cbiAqICAgICAgIClcbiAqICAgICB9LFxuICogICAgIGNhbmNlbEV2ZW50OiB7XG4gKiAgICAgICBhY3Rpb25zOiBjYW5jZWwoJ3NvbWUtaWQnKVxuICogICAgIH1cbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2VuZElkIFRoZSBgaWRgIG9mIHRoZSBgc2VuZFRvKC4uLilgIGFjdGlvbiB0byBjYW5jZWwuXG4gKi9cbmZ1bmN0aW9uIGNhbmNlbChzZW5kSWQpIHtcbiAgZnVuY3Rpb24gY2FuY2VsKF9hcmdzLCBfcGFyYW1zKSB7XG4gICAge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIGlzbid0IHN1cHBvc2VkIHRvIGJlIGNhbGxlZGApO1xuICAgIH1cbiAgfVxuICBjYW5jZWwudHlwZSA9ICd4c3RhdGUuY2FuY2VsJztcbiAgY2FuY2VsLnNlbmRJZCA9IHNlbmRJZDtcbiAgY2FuY2VsLnJlc29sdmUgPSByZXNvbHZlQ2FuY2VsO1xuICBjYW5jZWwuZXhlY3V0ZSA9IGV4ZWN1dGVDYW5jZWw7XG4gIHJldHVybiBjYW5jZWw7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVTcGF3bihhY3RvclNjb3BlLCBzbmFwc2hvdCwgYWN0aW9uQXJncywgX2FjdGlvblBhcmFtcywge1xuICBpZCxcbiAgc3lzdGVtSWQsXG4gIHNyYyxcbiAgaW5wdXQsXG4gIHN5bmNTbmFwc2hvdFxufSkge1xuICBjb25zdCBsb2dpYyA9IHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnID8gcmVzb2x2ZVJlZmVyZW5jZWRBY3RvcihzbmFwc2hvdC5tYWNoaW5lLCBzcmMpIDogc3JjO1xuICBjb25zdCByZXNvbHZlZElkID0gdHlwZW9mIGlkID09PSAnZnVuY3Rpb24nID8gaWQoYWN0aW9uQXJncykgOiBpZDtcbiAgbGV0IGFjdG9yUmVmO1xuICBsZXQgcmVzb2x2ZWRJbnB1dCA9IHVuZGVmaW5lZDtcbiAgaWYgKGxvZ2ljKSB7XG4gICAgcmVzb2x2ZWRJbnB1dCA9IHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJyA/IGlucHV0KHtcbiAgICAgIGNvbnRleHQ6IHNuYXBzaG90LmNvbnRleHQsXG4gICAgICBldmVudDogYWN0aW9uQXJncy5ldmVudCxcbiAgICAgIHNlbGY6IGFjdG9yU2NvcGUuc2VsZlxuICAgIH0pIDogaW5wdXQ7XG4gICAgYWN0b3JSZWYgPSBjcmVhdGVBY3Rvcihsb2dpYywge1xuICAgICAgaWQ6IHJlc29sdmVkSWQsXG4gICAgICBzcmMsXG4gICAgICBwYXJlbnQ6IGFjdG9yU2NvcGUuc2VsZixcbiAgICAgIHN5bmNTbmFwc2hvdCxcbiAgICAgIHN5c3RlbUlkLFxuICAgICAgaW5wdXQ6IHJlc29sdmVkSW5wdXRcbiAgICB9KTtcbiAgfVxuICBpZiAoIWFjdG9yUmVmKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtdGVtcGxhdGUtZXhwcmVzc2lvbnMsQHR5cGVzY3JpcHQtZXNsaW50L25vLWJhc2UtdG8tc3RyaW5nXG4gICAgYEFjdG9yIHR5cGUgJyR7c3JjfScgbm90IGZvdW5kIGluIG1hY2hpbmUgJyR7YWN0b3JTY29wZS5pZH0nLmApO1xuICB9XG4gIHJldHVybiBbY2xvbmVNYWNoaW5lU25hcHNob3Qoc25hcHNob3QsIHtcbiAgICBjaGlsZHJlbjoge1xuICAgICAgLi4uc25hcHNob3QuY2hpbGRyZW4sXG4gICAgICBbcmVzb2x2ZWRJZF06IGFjdG9yUmVmXG4gICAgfVxuICB9KSwge1xuICAgIGlkLFxuICAgIHN5c3RlbUlkLFxuICAgIGFjdG9yUmVmLFxuICAgIHNyYyxcbiAgICBpbnB1dDogcmVzb2x2ZWRJbnB1dFxuICB9LCB1bmRlZmluZWRdO1xufVxuZnVuY3Rpb24gZXhlY3V0ZVNwYXduKGFjdG9yU2NvcGUsIHtcbiAgYWN0b3JSZWZcbn0pIHtcbiAgaWYgKCFhY3RvclJlZikge1xuICAgIHJldHVybjtcbiAgfVxuICBhY3RvclNjb3BlLmRlZmVyKCgpID0+IHtcbiAgICBpZiAoYWN0b3JSZWYuX3Byb2Nlc3NpbmdTdGF0dXMgPT09IFByb2Nlc3NpbmdTdGF0dXMuU3RvcHBlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhY3RvclJlZi5zdGFydCgpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHNwYXduQ2hpbGQoLi4uW3NyYywge1xuICBpZCxcbiAgc3lzdGVtSWQsXG4gIGlucHV0LFxuICBzeW5jU25hcHNob3QgPSBmYWxzZVxufSA9IHt9XSkge1xuICBmdW5jdGlvbiBzcGF3bkNoaWxkKF9hcmdzLCBfcGFyYW1zKSB7XG4gICAge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIGlzbid0IHN1cHBvc2VkIHRvIGJlIGNhbGxlZGApO1xuICAgIH1cbiAgfVxuICBzcGF3bkNoaWxkLnR5cGUgPSAneHN0YXRlLnNwYXduQ2hpbGQnO1xuICBzcGF3bkNoaWxkLmlkID0gaWQ7XG4gIHNwYXduQ2hpbGQuc3lzdGVtSWQgPSBzeXN0ZW1JZDtcbiAgc3Bhd25DaGlsZC5zcmMgPSBzcmM7XG4gIHNwYXduQ2hpbGQuaW5wdXQgPSBpbnB1dDtcbiAgc3Bhd25DaGlsZC5zeW5jU25hcHNob3QgPSBzeW5jU25hcHNob3Q7XG4gIHNwYXduQ2hpbGQucmVzb2x2ZSA9IHJlc29sdmVTcGF3bjtcbiAgc3Bhd25DaGlsZC5leGVjdXRlID0gZXhlY3V0ZVNwYXduO1xuICByZXR1cm4gc3Bhd25DaGlsZDtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVN0b3AoXywgc25hcHNob3QsIGFyZ3MsIGFjdGlvblBhcmFtcywge1xuICBhY3RvclJlZlxufSkge1xuICBjb25zdCBhY3RvclJlZk9yU3RyaW5nID0gdHlwZW9mIGFjdG9yUmVmID09PSAnZnVuY3Rpb24nID8gYWN0b3JSZWYoYXJncywgYWN0aW9uUGFyYW1zKSA6IGFjdG9yUmVmO1xuICBjb25zdCByZXNvbHZlZEFjdG9yUmVmID0gdHlwZW9mIGFjdG9yUmVmT3JTdHJpbmcgPT09ICdzdHJpbmcnID8gc25hcHNob3QuY2hpbGRyZW5bYWN0b3JSZWZPclN0cmluZ10gOiBhY3RvclJlZk9yU3RyaW5nO1xuICBsZXQgY2hpbGRyZW4gPSBzbmFwc2hvdC5jaGlsZHJlbjtcbiAgaWYgKHJlc29sdmVkQWN0b3JSZWYpIHtcbiAgICBjaGlsZHJlbiA9IHtcbiAgICAgIC4uLmNoaWxkcmVuXG4gICAgfTtcbiAgICBkZWxldGUgY2hpbGRyZW5bcmVzb2x2ZWRBY3RvclJlZi5pZF07XG4gIH1cbiAgcmV0dXJuIFtjbG9uZU1hY2hpbmVTbmFwc2hvdChzbmFwc2hvdCwge1xuICAgIGNoaWxkcmVuXG4gIH0pLCByZXNvbHZlZEFjdG9yUmVmLCB1bmRlZmluZWRdO1xufVxuZnVuY3Rpb24gZXhlY3V0ZVN0b3AoYWN0b3JTY29wZSwgYWN0b3JSZWYpIHtcbiAgaWYgKCFhY3RvclJlZikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHdlIG5lZWQgdG8gZWFnZXJseSB1bnJlZ2lzdGVyIGl0IGhlcmUgc28gYSBuZXcgYWN0b3Igd2l0aCB0aGUgc2FtZSBzeXN0ZW1JZCBjYW4gYmUgcmVnaXN0ZXJlZCBpbW1lZGlhdGVseVxuICAvLyBzaW5jZSB3ZSBkZWZlciBhY3R1YWwgc3RvcHBpbmcgb2YgdGhlIGFjdG9yIGJ1dCB3ZSBkb24ndCBkZWZlciBhY3RvciBjcmVhdGlvbnMgKGFuZCB3ZSBjYW4ndCBkbyB0aGF0KVxuICAvLyB0aGlzIGNvdWxkIHRocm93IG9uIGBzeXN0ZW1JZGAgY29sbGlzaW9uLCBmb3IgZXhhbXBsZSwgd2hlbiBkZWFsaW5nIHdpdGggcmVlbnRlcmluZyB0cmFuc2l0aW9uc1xuICBhY3RvclNjb3BlLnN5c3RlbS5fdW5yZWdpc3RlcihhY3RvclJlZik7XG5cbiAgLy8gdGhpcyBhbGxvd3MgdXMgdG8gcHJldmVudCBhbiBhY3RvciBmcm9tIGJlaW5nIHN0YXJ0ZWQgaWYgaXQgZ2V0cyBzdG9wcGVkIHdpdGhpbiB0aGUgc2FtZSBtYWNyb3N0ZXBcbiAgLy8gdGhpcyBjYW4gaGFwcGVuLCBmb3IgZXhhbXBsZSwgd2hlbiB0aGUgaW52b2tpbmcgc3RhdGUgaXMgYmVpbmcgZXhpdGVkIGltbWVkaWF0ZWx5IGJ5IGFuIGFsd2F5cyB0cmFuc2l0aW9uXG4gIGlmIChhY3RvclJlZi5fcHJvY2Vzc2luZ1N0YXR1cyAhPT0gUHJvY2Vzc2luZ1N0YXR1cy5SdW5uaW5nKSB7XG4gICAgYWN0b3JTY29wZS5zdG9wQ2hpbGQoYWN0b3JSZWYpO1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBzdG9wcGluZyBhIGNoaWxkIGVucXVldWVzIGEgc3RvcCBldmVudCBpbiB0aGUgY2hpbGQgYWN0b3IncyBtYWlsYm94XG4gIC8vIHdlIG5lZWQgZm9yIGFsbCBvZiB0aGUgYWxyZWFkeSBlbnF1ZXVlZCBldmVudHMgdG8gYmUgcHJvY2Vzc2VkIGJlZm9yZSB3ZSBzdG9wIHRoZSBjaGlsZFxuICAvLyB0aGUgcGFyZW50IGl0c2VsZiBtaWdodCB3YW50IHRvIHNlbmQgc29tZSBldmVudHMgdG8gYSBjaGlsZCAoZm9yIGV4YW1wbGUgZnJvbSBleGl0IGFjdGlvbnMgb24gdGhlIGludm9raW5nIHN0YXRlKVxuICAvLyBhbmQgd2UgZG9uJ3Qgd2FudCB0byBpZ25vcmUgdGhvc2UgZXZlbnRzXG4gIGFjdG9yU2NvcGUuZGVmZXIoKCkgPT4ge1xuICAgIGFjdG9yU2NvcGUuc3RvcENoaWxkKGFjdG9yUmVmKTtcbiAgfSk7XG59XG4vKipcbiAqIFN0b3BzIGEgY2hpbGQgYWN0b3IuXG4gKlxuICogQHBhcmFtIGFjdG9yUmVmIFRoZSBhY3RvciB0byBzdG9wLlxuICovXG5mdW5jdGlvbiBzdG9wQ2hpbGQoYWN0b3JSZWYpIHtcbiAgZnVuY3Rpb24gc3RvcChfYXJncywgX3BhcmFtcykge1xuICAgIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhpcyBpc24ndCBzdXBwb3NlZCB0byBiZSBjYWxsZWRgKTtcbiAgICB9XG4gIH1cbiAgc3RvcC50eXBlID0gJ3hzdGF0ZS5zdG9wQ2hpbGQnO1xuICBzdG9wLmFjdG9yUmVmID0gYWN0b3JSZWY7XG4gIHN0b3AucmVzb2x2ZSA9IHJlc29sdmVTdG9wO1xuICBzdG9wLmV4ZWN1dGUgPSBleGVjdXRlU3RvcDtcbiAgcmV0dXJuIHN0b3A7XG59XG5cbi8qKlxuICogU3RvcHMgYSBjaGlsZCBhY3Rvci5cbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgYHN0b3BDaGlsZCguLi4pYCBpbnN0ZWFkXG4gKiBAYWxpYXNcbiAqL1xuY29uc3Qgc3RvcCA9IHN0b3BDaGlsZDtcblxuZnVuY3Rpb24gY2hlY2tTdGF0ZUluKHNuYXBzaG90LCBfLCB7XG4gIHN0YXRlVmFsdWVcbn0pIHtcbiAgaWYgKHR5cGVvZiBzdGF0ZVZhbHVlID09PSAnc3RyaW5nJyAmJiBpc1N0YXRlSWQoc3RhdGVWYWx1ZSkpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBzbmFwc2hvdC5tYWNoaW5lLmdldFN0YXRlTm9kZUJ5SWQoc3RhdGVWYWx1ZSk7XG4gICAgcmV0dXJuIHNuYXBzaG90Ll9ub2Rlcy5zb21lKHNuID0+IHNuID09PSB0YXJnZXQpO1xuICB9XG4gIHJldHVybiBzbmFwc2hvdC5tYXRjaGVzKHN0YXRlVmFsdWUpO1xufVxuZnVuY3Rpb24gc3RhdGVJbihzdGF0ZVZhbHVlKSB7XG4gIGZ1bmN0aW9uIHN0YXRlSW4oKSB7XG4gICAge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIGlzbid0IHN1cHBvc2VkIHRvIGJlIGNhbGxlZGApO1xuICAgIH1cbiAgfVxuICBzdGF0ZUluLmNoZWNrID0gY2hlY2tTdGF0ZUluO1xuICBzdGF0ZUluLnN0YXRlVmFsdWUgPSBzdGF0ZVZhbHVlO1xuICByZXR1cm4gc3RhdGVJbjtcbn1cbmZ1bmN0aW9uIGNoZWNrTm90KHNuYXBzaG90LCB7XG4gIGNvbnRleHQsXG4gIGV2ZW50XG59LCB7XG4gIGd1YXJkc1xufSkge1xuICByZXR1cm4gIWV2YWx1YXRlR3VhcmQoZ3VhcmRzWzBdLCBjb250ZXh0LCBldmVudCwgc25hcHNob3QpO1xufVxuXG4vKipcbiAqIEhpZ2hlci1vcmRlciBndWFyZCB0aGF0IGV2YWx1YXRlcyB0byBgdHJ1ZWAgaWYgdGhlIGBndWFyZGAgcGFzc2VkIHRvIGl0XG4gKiBldmFsdWF0ZXMgdG8gYGZhbHNlYC5cbiAqXG4gKiBAY2F0ZWdvcnkgR3VhcmRzXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBzZXR1cCwgbm90IH0gZnJvbSAneHN0YXRlJztcbiAqXG4gKiBjb25zdCBtYWNoaW5lID0gc2V0dXAoe1xuICogICBndWFyZHM6IHtcbiAqICAgICBzb21lTmFtZWRHdWFyZDogKCkgPT4gZmFsc2VcbiAqICAgfVxuICogfSkuY3JlYXRlTWFjaGluZSh7XG4gKiAgIG9uOiB7XG4gKiAgICAgc29tZUV2ZW50OiB7XG4gKiAgICAgICBndWFyZDogbm90KCdzb21lTmFtZWRHdWFyZCcpLFxuICogICAgICAgYWN0aW9uczogKCkgPT4ge1xuICogICAgICAgICAvLyB3aWxsIGJlIGV4ZWN1dGVkIGlmIGd1YXJkIGluIGBub3QoLi4uKWBcbiAqICAgICAgICAgLy8gZXZhbHVhdGVzIHRvIGBmYWxzZWBcbiAqICAgICAgIH1cbiAqICAgICB9XG4gKiAgIH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHJldHVybnMgQSBndWFyZFxuICovXG5mdW5jdGlvbiBub3QoZ3VhcmQpIHtcbiAgZnVuY3Rpb24gbm90KF9hcmdzLCBfcGFyYW1zKSB7XG4gICAge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIGlzbid0IHN1cHBvc2VkIHRvIGJlIGNhbGxlZGApO1xuICAgIH1cbiAgfVxuICBub3QuY2hlY2sgPSBjaGVja05vdDtcbiAgbm90Lmd1YXJkcyA9IFtndWFyZF07XG4gIHJldHVybiBub3Q7XG59XG5mdW5jdGlvbiBjaGVja0FuZChzbmFwc2hvdCwge1xuICBjb250ZXh0LFxuICBldmVudFxufSwge1xuICBndWFyZHNcbn0pIHtcbiAgcmV0dXJuIGd1YXJkcy5ldmVyeShndWFyZCA9PiBldmFsdWF0ZUd1YXJkKGd1YXJkLCBjb250ZXh0LCBldmVudCwgc25hcHNob3QpKTtcbn1cblxuLyoqXG4gKiBIaWdoZXItb3JkZXIgZ3VhcmQgdGhhdCBldmFsdWF0ZXMgdG8gYHRydWVgIGlmIGFsbCBgZ3VhcmRzYCBwYXNzZWQgdG8gaXRcbiAqIGV2YWx1YXRlIHRvIGB0cnVlYC5cbiAqXG4gKiBAY2F0ZWdvcnkgR3VhcmRzXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBzZXR1cCwgYW5kIH0gZnJvbSAneHN0YXRlJztcbiAqXG4gKiBjb25zdCBtYWNoaW5lID0gc2V0dXAoe1xuICogICBndWFyZHM6IHtcbiAqICAgICBzb21lTmFtZWRHdWFyZDogKCkgPT4gdHJ1ZVxuICogICB9XG4gKiB9KS5jcmVhdGVNYWNoaW5lKHtcbiAqICAgb246IHtcbiAqICAgICBzb21lRXZlbnQ6IHtcbiAqICAgICAgIGd1YXJkOiBhbmQoWyh7IGNvbnRleHQgfSkgPT4gY29udGV4dC52YWx1ZSA+IDAsICdzb21lTmFtZWRHdWFyZCddKSxcbiAqICAgICAgIGFjdGlvbnM6ICgpID0+IHtcbiAqICAgICAgICAgLy8gd2lsbCBiZSBleGVjdXRlZCBpZiBhbGwgZ3VhcmRzIGluIGBhbmQoLi4uKWBcbiAqICAgICAgICAgLy8gZXZhbHVhdGUgdG8gdHJ1ZVxuICogICAgICAgfVxuICogICAgIH1cbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAcmV0dXJucyBBIGd1YXJkIGFjdGlvbiBvYmplY3RcbiAqL1xuZnVuY3Rpb24gYW5kKGd1YXJkcykge1xuICBmdW5jdGlvbiBhbmQoX2FyZ3MsIF9wYXJhbXMpIHtcbiAgICB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgaXNuJ3Qgc3VwcG9zZWQgdG8gYmUgY2FsbGVkYCk7XG4gICAgfVxuICB9XG4gIGFuZC5jaGVjayA9IGNoZWNrQW5kO1xuICBhbmQuZ3VhcmRzID0gZ3VhcmRzO1xuICByZXR1cm4gYW5kO1xufVxuZnVuY3Rpb24gY2hlY2tPcihzbmFwc2hvdCwge1xuICBjb250ZXh0LFxuICBldmVudFxufSwge1xuICBndWFyZHNcbn0pIHtcbiAgcmV0dXJuIGd1YXJkcy5zb21lKGd1YXJkID0+IGV2YWx1YXRlR3VhcmQoZ3VhcmQsIGNvbnRleHQsIGV2ZW50LCBzbmFwc2hvdCkpO1xufVxuXG4vKipcbiAqIEhpZ2hlci1vcmRlciBndWFyZCB0aGF0IGV2YWx1YXRlcyB0byBgdHJ1ZWAgaWYgYW55IG9mIHRoZSBgZ3VhcmRzYCBwYXNzZWQgdG9cbiAqIGl0IGV2YWx1YXRlIHRvIGB0cnVlYC5cbiAqXG4gKiBAY2F0ZWdvcnkgR3VhcmRzXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBzZXR1cCwgb3IgfSBmcm9tICd4c3RhdGUnO1xuICpcbiAqIGNvbnN0IG1hY2hpbmUgPSBzZXR1cCh7XG4gKiAgIGd1YXJkczoge1xuICogICAgIHNvbWVOYW1lZEd1YXJkOiAoKSA9PiB0cnVlXG4gKiAgIH1cbiAqIH0pLmNyZWF0ZU1hY2hpbmUoe1xuICogICBvbjoge1xuICogICAgIHNvbWVFdmVudDoge1xuICogICAgICAgZ3VhcmQ6IG9yKFsoeyBjb250ZXh0IH0pID0+IGNvbnRleHQudmFsdWUgPiAwLCAnc29tZU5hbWVkR3VhcmQnXSksXG4gKiAgICAgICBhY3Rpb25zOiAoKSA9PiB7XG4gKiAgICAgICAgIC8vIHdpbGwgYmUgZXhlY3V0ZWQgaWYgYW55IG9mIHRoZSBndWFyZHMgaW4gYG9yKC4uLilgXG4gKiAgICAgICAgIC8vIGV2YWx1YXRlIHRvIHRydWVcbiAqICAgICAgIH1cbiAqICAgICB9XG4gKiAgIH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHJldHVybnMgQSBndWFyZCBhY3Rpb24gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIG9yKGd1YXJkcykge1xuICBmdW5jdGlvbiBvcihfYXJncywgX3BhcmFtcykge1xuICAgIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhpcyBpc24ndCBzdXBwb3NlZCB0byBiZSBjYWxsZWRgKTtcbiAgICB9XG4gIH1cbiAgb3IuY2hlY2sgPSBjaGVja09yO1xuICBvci5ndWFyZHMgPSBndWFyZHM7XG4gIHJldHVybiBvcjtcbn1cblxuLy8gVE9ETzogdGhyb3cgb24gY3ljbGVzIChkZXB0aCBjaGVjayBzaG91bGQgYmUgZW5vdWdoKVxuZnVuY3Rpb24gZXZhbHVhdGVHdWFyZChndWFyZCwgY29udGV4dCwgZXZlbnQsIHNuYXBzaG90KSB7XG4gIGNvbnN0IHtcbiAgICBtYWNoaW5lXG4gIH0gPSBzbmFwc2hvdDtcbiAgY29uc3QgaXNJbmxpbmUgPSB0eXBlb2YgZ3VhcmQgPT09ICdmdW5jdGlvbic7XG4gIGNvbnN0IHJlc29sdmVkID0gaXNJbmxpbmUgPyBndWFyZCA6IG1hY2hpbmUuaW1wbGVtZW50YXRpb25zLmd1YXJkc1t0eXBlb2YgZ3VhcmQgPT09ICdzdHJpbmcnID8gZ3VhcmQgOiBndWFyZC50eXBlXTtcbiAgaWYgKCFpc0lubGluZSAmJiAhcmVzb2x2ZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEd1YXJkICcke3R5cGVvZiBndWFyZCA9PT0gJ3N0cmluZycgPyBndWFyZCA6IGd1YXJkLnR5cGV9JyBpcyBub3QgaW1wbGVtZW50ZWQuJy5gKTtcbiAgfVxuICBpZiAodHlwZW9mIHJlc29sdmVkICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGV2YWx1YXRlR3VhcmQocmVzb2x2ZWQsIGNvbnRleHQsIGV2ZW50LCBzbmFwc2hvdCk7XG4gIH1cbiAgY29uc3QgZ3VhcmRBcmdzID0ge1xuICAgIGNvbnRleHQsXG4gICAgZXZlbnRcbiAgfTtcbiAgY29uc3QgZ3VhcmRQYXJhbXMgPSBpc0lubGluZSB8fCB0eXBlb2YgZ3VhcmQgPT09ICdzdHJpbmcnID8gdW5kZWZpbmVkIDogJ3BhcmFtcycgaW4gZ3VhcmQgPyB0eXBlb2YgZ3VhcmQucGFyYW1zID09PSAnZnVuY3Rpb24nID8gZ3VhcmQucGFyYW1zKHtcbiAgICBjb250ZXh0LFxuICAgIGV2ZW50XG4gIH0pIDogZ3VhcmQucGFyYW1zIDogdW5kZWZpbmVkO1xuICBpZiAoISgnY2hlY2snIGluIHJlc29sdmVkKSkge1xuICAgIC8vIHRoZSBleGlzdGluZyB0eXBlIG9mIGAuZ3VhcmRzYCBhc3N1bWVzIG5vbi1udWxsYWJsZSBgVEV4cHJlc3Npb25HdWFyZGBcbiAgICAvLyBpbmxpbmUgZ3VhcmRzIGV4cGVjdCBgVEV4cHJlc3Npb25HdWFyZGAgdG8gYmUgc2V0IHRvIGB1bmRlZmluZWRgXG4gICAgLy8gaXQncyBmaW5lIHRvIGNhc3QgdGhpcyBoZXJlLCBvdXIgbG9naWMgbWFrZXMgc3VyZSB0aGF0IHdlIGNhbGwgdGhvc2UgMiBcInZhcmlhbnRzXCIgY29ycmVjdGx5XG4gICAgcmV0dXJuIHJlc29sdmVkKGd1YXJkQXJncywgZ3VhcmRQYXJhbXMpO1xuICB9XG4gIGNvbnN0IGJ1aWx0aW5HdWFyZCA9IHJlc29sdmVkO1xuICByZXR1cm4gYnVpbHRpbkd1YXJkLmNoZWNrKHNuYXBzaG90LCBndWFyZEFyZ3MsIHJlc29sdmVkIC8vIHRoaXMgaG9sZHMgYWxsIHBhcmFtc1xuICApO1xufVxuXG5jb25zdCBpc0F0b21pY1N0YXRlTm9kZSA9IHN0YXRlTm9kZSA9PiBzdGF0ZU5vZGUudHlwZSA9PT0gJ2F0b21pYycgfHwgc3RhdGVOb2RlLnR5cGUgPT09ICdmaW5hbCc7XG5mdW5jdGlvbiBnZXRDaGlsZHJlbihzdGF0ZU5vZGUpIHtcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMoc3RhdGVOb2RlLnN0YXRlcykuZmlsdGVyKHNuID0+IHNuLnR5cGUgIT09ICdoaXN0b3J5Jyk7XG59XG5mdW5jdGlvbiBnZXRQcm9wZXJBbmNlc3RvcnMoc3RhdGVOb2RlLCB0b1N0YXRlTm9kZSkge1xuICBjb25zdCBhbmNlc3RvcnMgPSBbXTtcbiAgaWYgKHRvU3RhdGVOb2RlID09PSBzdGF0ZU5vZGUpIHtcbiAgICByZXR1cm4gYW5jZXN0b3JzO1xuICB9XG5cbiAgLy8gYWRkIGFsbCBhbmNlc3RvcnNcbiAgbGV0IG0gPSBzdGF0ZU5vZGUucGFyZW50O1xuICB3aGlsZSAobSAmJiBtICE9PSB0b1N0YXRlTm9kZSkge1xuICAgIGFuY2VzdG9ycy5wdXNoKG0pO1xuICAgIG0gPSBtLnBhcmVudDtcbiAgfVxuICByZXR1cm4gYW5jZXN0b3JzO1xufVxuZnVuY3Rpb24gZ2V0QWxsU3RhdGVOb2RlcyhzdGF0ZU5vZGVzKSB7XG4gIGNvbnN0IG5vZGVTZXQgPSBuZXcgU2V0KHN0YXRlTm9kZXMpO1xuICBjb25zdCBhZGpMaXN0ID0gZ2V0QWRqTGlzdChub2RlU2V0KTtcblxuICAvLyBhZGQgZGVzY2VuZGFudHNcbiAgZm9yIChjb25zdCBzIG9mIG5vZGVTZXQpIHtcbiAgICAvLyBpZiBwcmV2aW91c2x5IGFjdGl2ZSwgYWRkIGV4aXN0aW5nIGNoaWxkIG5vZGVzXG4gICAgaWYgKHMudHlwZSA9PT0gJ2NvbXBvdW5kJyAmJiAoIWFkakxpc3QuZ2V0KHMpIHx8ICFhZGpMaXN0LmdldChzKS5sZW5ndGgpKSB7XG4gICAgICBnZXRJbml0aWFsU3RhdGVOb2Rlc1dpdGhUaGVpckFuY2VzdG9ycyhzKS5mb3JFYWNoKHNuID0+IG5vZGVTZXQuYWRkKHNuKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzLnR5cGUgPT09ICdwYXJhbGxlbCcpIHtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBnZXRDaGlsZHJlbihzKSkge1xuICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSAnaGlzdG9yeScpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIW5vZGVTZXQuaGFzKGNoaWxkKSkge1xuICAgICAgICAgICAgY29uc3QgaW5pdGlhbFN0YXRlcyA9IGdldEluaXRpYWxTdGF0ZU5vZGVzV2l0aFRoZWlyQW5jZXN0b3JzKGNoaWxkKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaW5pdGlhbFN0YXRlTm9kZSBvZiBpbml0aWFsU3RhdGVzKSB7XG4gICAgICAgICAgICAgIG5vZGVTZXQuYWRkKGluaXRpYWxTdGF0ZU5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGFkZCBhbGwgYW5jZXN0b3JzXG4gIGZvciAoY29uc3QgcyBvZiBub2RlU2V0KSB7XG4gICAgbGV0IG0gPSBzLnBhcmVudDtcbiAgICB3aGlsZSAobSkge1xuICAgICAgbm9kZVNldC5hZGQobSk7XG4gICAgICBtID0gbS5wYXJlbnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBub2RlU2V0O1xufVxuZnVuY3Rpb24gZ2V0VmFsdWVGcm9tQWRqKGJhc2VOb2RlLCBhZGpMaXN0KSB7XG4gIGNvbnN0IGNoaWxkU3RhdGVOb2RlcyA9IGFkakxpc3QuZ2V0KGJhc2VOb2RlKTtcbiAgaWYgKCFjaGlsZFN0YXRlTm9kZXMpIHtcbiAgICByZXR1cm4ge307IC8vIHRvZG86IGZpeD9cbiAgfVxuICBpZiAoYmFzZU5vZGUudHlwZSA9PT0gJ2NvbXBvdW5kJykge1xuICAgIGNvbnN0IGNoaWxkU3RhdGVOb2RlID0gY2hpbGRTdGF0ZU5vZGVzWzBdO1xuICAgIGlmIChjaGlsZFN0YXRlTm9kZSkge1xuICAgICAgaWYgKGlzQXRvbWljU3RhdGVOb2RlKGNoaWxkU3RhdGVOb2RlKSkge1xuICAgICAgICByZXR1cm4gY2hpbGRTdGF0ZU5vZGUua2V5O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9XG4gIGNvbnN0IHN0YXRlVmFsdWUgPSB7fTtcbiAgZm9yIChjb25zdCBjaGlsZFN0YXRlTm9kZSBvZiBjaGlsZFN0YXRlTm9kZXMpIHtcbiAgICBzdGF0ZVZhbHVlW2NoaWxkU3RhdGVOb2RlLmtleV0gPSBnZXRWYWx1ZUZyb21BZGooY2hpbGRTdGF0ZU5vZGUsIGFkakxpc3QpO1xuICB9XG4gIHJldHVybiBzdGF0ZVZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0QWRqTGlzdChzdGF0ZU5vZGVzKSB7XG4gIGNvbnN0IGFkakxpc3QgPSBuZXcgTWFwKCk7XG4gIGZvciAoY29uc3QgcyBvZiBzdGF0ZU5vZGVzKSB7XG4gICAgaWYgKCFhZGpMaXN0LmhhcyhzKSkge1xuICAgICAgYWRqTGlzdC5zZXQocywgW10pO1xuICAgIH1cbiAgICBpZiAocy5wYXJlbnQpIHtcbiAgICAgIGlmICghYWRqTGlzdC5oYXMocy5wYXJlbnQpKSB7XG4gICAgICAgIGFkakxpc3Quc2V0KHMucGFyZW50LCBbXSk7XG4gICAgICB9XG4gICAgICBhZGpMaXN0LmdldChzLnBhcmVudCkucHVzaChzKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFkakxpc3Q7XG59XG5mdW5jdGlvbiBnZXRTdGF0ZVZhbHVlKHJvb3ROb2RlLCBzdGF0ZU5vZGVzKSB7XG4gIGNvbnN0IGNvbmZpZyA9IGdldEFsbFN0YXRlTm9kZXMoc3RhdGVOb2Rlcyk7XG4gIHJldHVybiBnZXRWYWx1ZUZyb21BZGoocm9vdE5vZGUsIGdldEFkakxpc3QoY29uZmlnKSk7XG59XG5mdW5jdGlvbiBpc0luRmluYWxTdGF0ZShzdGF0ZU5vZGVTZXQsIHN0YXRlTm9kZSkge1xuICBpZiAoc3RhdGVOb2RlLnR5cGUgPT09ICdjb21wb3VuZCcpIHtcbiAgICByZXR1cm4gZ2V0Q2hpbGRyZW4oc3RhdGVOb2RlKS5zb21lKHMgPT4gcy50eXBlID09PSAnZmluYWwnICYmIHN0YXRlTm9kZVNldC5oYXMocykpO1xuICB9XG4gIGlmIChzdGF0ZU5vZGUudHlwZSA9PT0gJ3BhcmFsbGVsJykge1xuICAgIHJldHVybiBnZXRDaGlsZHJlbihzdGF0ZU5vZGUpLmV2ZXJ5KHNuID0+IGlzSW5GaW5hbFN0YXRlKHN0YXRlTm9kZVNldCwgc24pKTtcbiAgfVxuICByZXR1cm4gc3RhdGVOb2RlLnR5cGUgPT09ICdmaW5hbCc7XG59XG5jb25zdCBpc1N0YXRlSWQgPSBzdHIgPT4gc3RyWzBdID09PSBTVEFURV9JREVOVElGSUVSO1xuZnVuY3Rpb24gZ2V0Q2FuZGlkYXRlcyhzdGF0ZU5vZGUsIHJlY2VpdmVkRXZlbnRUeXBlKSB7XG4gIGNvbnN0IGNhbmRpZGF0ZXMgPSBzdGF0ZU5vZGUudHJhbnNpdGlvbnMuZ2V0KHJlY2VpdmVkRXZlbnRUeXBlKSB8fCBbLi4uc3RhdGVOb2RlLnRyYW5zaXRpb25zLmtleXMoKV0uZmlsdGVyKGV2ZW50RGVzY3JpcHRvciA9PiB7XG4gICAgLy8gY2hlY2sgaWYgdHJhbnNpdGlvbiBpcyBhIHdpbGRjYXJkIHRyYW5zaXRpb24sXG4gICAgLy8gd2hpY2ggbWF0Y2hlcyBhbnkgbm9uLXRyYW5zaWVudCBldmVudHNcbiAgICBpZiAoZXZlbnREZXNjcmlwdG9yID09PSBXSUxEQ0FSRCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghZXZlbnREZXNjcmlwdG9yLmVuZHNXaXRoKCcuKicpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICgvLipcXCouKy8udGVzdChldmVudERlc2NyaXB0b3IpKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFdpbGRjYXJkcyBjYW4gb25seSBiZSB0aGUgbGFzdCB0b2tlbiBvZiBhbiBldmVudCBkZXNjcmlwdG9yIChlLmcuLCBcImV2ZW50LipcIikgb3IgdGhlIGVudGlyZSBldmVudCBkZXNjcmlwdG9yIChcIipcIikuIENoZWNrIHRoZSBcIiR7ZXZlbnREZXNjcmlwdG9yfVwiIGV2ZW50LmApO1xuICAgIH1cbiAgICBjb25zdCBwYXJ0aWFsRXZlbnRUb2tlbnMgPSBldmVudERlc2NyaXB0b3Iuc3BsaXQoJy4nKTtcbiAgICBjb25zdCBldmVudFRva2VucyA9IHJlY2VpdmVkRXZlbnRUeXBlLnNwbGl0KCcuJyk7XG4gICAgZm9yIChsZXQgdG9rZW5JbmRleCA9IDA7IHRva2VuSW5kZXggPCBwYXJ0aWFsRXZlbnRUb2tlbnMubGVuZ3RoOyB0b2tlbkluZGV4KyspIHtcbiAgICAgIGNvbnN0IHBhcnRpYWxFdmVudFRva2VuID0gcGFydGlhbEV2ZW50VG9rZW5zW3Rva2VuSW5kZXhdO1xuICAgICAgY29uc3QgZXZlbnRUb2tlbiA9IGV2ZW50VG9rZW5zW3Rva2VuSW5kZXhdO1xuICAgICAgaWYgKHBhcnRpYWxFdmVudFRva2VuID09PSAnKicpIHtcbiAgICAgICAgY29uc3QgaXNMYXN0VG9rZW4gPSB0b2tlbkluZGV4ID09PSBwYXJ0aWFsRXZlbnRUb2tlbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKCFpc0xhc3RUb2tlbikge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgSW5maXggd2lsZGNhcmRzIGluIHRyYW5zaXRpb24gZXZlbnRzIGFyZSBub3QgYWxsb3dlZC4gQ2hlY2sgdGhlIFwiJHtldmVudERlc2NyaXB0b3J9XCIgdHJhbnNpdGlvbi5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNMYXN0VG9rZW47XG4gICAgICB9XG4gICAgICBpZiAocGFydGlhbEV2ZW50VG9rZW4gIT09IGV2ZW50VG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSkuc29ydCgoYSwgYikgPT4gYi5sZW5ndGggLSBhLmxlbmd0aCkuZmxhdE1hcChrZXkgPT4gc3RhdGVOb2RlLnRyYW5zaXRpb25zLmdldChrZXkpKTtcbiAgcmV0dXJuIGNhbmRpZGF0ZXM7XG59XG5cbi8qKiBBbGwgZGVsYXllZCB0cmFuc2l0aW9ucyBmcm9tIHRoZSBjb25maWcuICovXG5mdW5jdGlvbiBnZXREZWxheWVkVHJhbnNpdGlvbnMoc3RhdGVOb2RlKSB7XG4gIGNvbnN0IGFmdGVyQ29uZmlnID0gc3RhdGVOb2RlLmNvbmZpZy5hZnRlcjtcbiAgaWYgKCFhZnRlckNvbmZpZykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBjb25zdCBtdXRhdGVFbnRyeUV4aXQgPSBkZWxheSA9PiB7XG4gICAgY29uc3QgYWZ0ZXJFdmVudCA9IGNyZWF0ZUFmdGVyRXZlbnQoZGVsYXksIHN0YXRlTm9kZS5pZCk7XG4gICAgY29uc3QgZXZlbnRUeXBlID0gYWZ0ZXJFdmVudC50eXBlO1xuICAgIHN0YXRlTm9kZS5lbnRyeS5wdXNoKHJhaXNlKGFmdGVyRXZlbnQsIHtcbiAgICAgIGlkOiBldmVudFR5cGUsXG4gICAgICBkZWxheVxuICAgIH0pKTtcbiAgICBzdGF0ZU5vZGUuZXhpdC5wdXNoKGNhbmNlbChldmVudFR5cGUpKTtcbiAgICByZXR1cm4gZXZlbnRUeXBlO1xuICB9O1xuICBjb25zdCBkZWxheWVkVHJhbnNpdGlvbnMgPSBPYmplY3Qua2V5cyhhZnRlckNvbmZpZykuZmxhdE1hcChkZWxheSA9PiB7XG4gICAgY29uc3QgY29uZmlnVHJhbnNpdGlvbiA9IGFmdGVyQ29uZmlnW2RlbGF5XTtcbiAgICBjb25zdCByZXNvbHZlZFRyYW5zaXRpb24gPSB0eXBlb2YgY29uZmlnVHJhbnNpdGlvbiA9PT0gJ3N0cmluZycgPyB7XG4gICAgICB0YXJnZXQ6IGNvbmZpZ1RyYW5zaXRpb25cbiAgICB9IDogY29uZmlnVHJhbnNpdGlvbjtcbiAgICBjb25zdCByZXNvbHZlZERlbGF5ID0gTnVtYmVyLmlzTmFOKCtkZWxheSkgPyBkZWxheSA6ICtkZWxheTtcbiAgICBjb25zdCBldmVudFR5cGUgPSBtdXRhdGVFbnRyeUV4aXQocmVzb2x2ZWREZWxheSk7XG4gICAgcmV0dXJuIHRvQXJyYXkocmVzb2x2ZWRUcmFuc2l0aW9uKS5tYXAodHJhbnNpdGlvbiA9PiAoe1xuICAgICAgLi4udHJhbnNpdGlvbixcbiAgICAgIGV2ZW50OiBldmVudFR5cGUsXG4gICAgICBkZWxheTogcmVzb2x2ZWREZWxheVxuICAgIH0pKTtcbiAgfSk7XG4gIHJldHVybiBkZWxheWVkVHJhbnNpdGlvbnMubWFwKGRlbGF5ZWRUcmFuc2l0aW9uID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBkZWxheVxuICAgIH0gPSBkZWxheWVkVHJhbnNpdGlvbjtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZm9ybWF0VHJhbnNpdGlvbihzdGF0ZU5vZGUsIGRlbGF5ZWRUcmFuc2l0aW9uLmV2ZW50LCBkZWxheWVkVHJhbnNpdGlvbiksXG4gICAgICBkZWxheVxuICAgIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gZm9ybWF0VHJhbnNpdGlvbihzdGF0ZU5vZGUsIGRlc2NyaXB0b3IsIHRyYW5zaXRpb25Db25maWcpIHtcbiAgY29uc3Qgbm9ybWFsaXplZFRhcmdldCA9IG5vcm1hbGl6ZVRhcmdldCh0cmFuc2l0aW9uQ29uZmlnLnRhcmdldCk7XG4gIGNvbnN0IHJlZW50ZXIgPSB0cmFuc2l0aW9uQ29uZmlnLnJlZW50ZXIgPz8gZmFsc2U7XG4gIGNvbnN0IHRhcmdldCA9IHJlc29sdmVUYXJnZXQoc3RhdGVOb2RlLCBub3JtYWxpemVkVGFyZ2V0KTtcblxuICAvLyBUT0RPOiBzaG91bGQgdGhpcyBiZSBwYXJ0IG9mIGEgbGludCBydWxlIGluc3RlYWQ/XG4gIGlmICh0cmFuc2l0aW9uQ29uZmlnLmNvbmQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFN0YXRlIFwiJHtzdGF0ZU5vZGUuaWR9XCIgaGFzIGRlY2xhcmVkIFxcYGNvbmRcXGAgZm9yIG9uZSBvZiBpdHMgdHJhbnNpdGlvbnMuIFRoaXMgcHJvcGVydHkgaGFzIGJlZW4gcmVuYW1lZCB0byBcXGBndWFyZFxcYC4gUGxlYXNlIHVwZGF0ZSB5b3VyIGNvZGUuYCk7XG4gIH1cbiAgY29uc3QgdHJhbnNpdGlvbiA9IHtcbiAgICAuLi50cmFuc2l0aW9uQ29uZmlnLFxuICAgIGFjdGlvbnM6IHRvQXJyYXkodHJhbnNpdGlvbkNvbmZpZy5hY3Rpb25zKSxcbiAgICBndWFyZDogdHJhbnNpdGlvbkNvbmZpZy5ndWFyZCxcbiAgICB0YXJnZXQsXG4gICAgc291cmNlOiBzdGF0ZU5vZGUsXG4gICAgcmVlbnRlcixcbiAgICBldmVudFR5cGU6IGRlc2NyaXB0b3IsXG4gICAgdG9KU09OOiAoKSA9PiAoe1xuICAgICAgLi4udHJhbnNpdGlvbixcbiAgICAgIHNvdXJjZTogYCMke3N0YXRlTm9kZS5pZH1gLFxuICAgICAgdGFyZ2V0OiB0YXJnZXQgPyB0YXJnZXQubWFwKHQgPT4gYCMke3QuaWR9YCkgOiB1bmRlZmluZWRcbiAgICB9KVxuICB9O1xuICByZXR1cm4gdHJhbnNpdGlvbjtcbn1cbmZ1bmN0aW9uIGZvcm1hdFRyYW5zaXRpb25zKHN0YXRlTm9kZSkge1xuICBjb25zdCB0cmFuc2l0aW9ucyA9IG5ldyBNYXAoKTtcbiAgaWYgKHN0YXRlTm9kZS5jb25maWcub24pIHtcbiAgICBmb3IgKGNvbnN0IGRlc2NyaXB0b3Igb2YgT2JqZWN0LmtleXMoc3RhdGVOb2RlLmNvbmZpZy5vbikpIHtcbiAgICAgIGlmIChkZXNjcmlwdG9yID09PSBOVUxMX0VWRU5UKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTnVsbCBldmVudHMgKFwiXCIpIGNhbm5vdCBiZSBzcGVjaWZpZWQgYXMgYSB0cmFuc2l0aW9uIGtleS4gVXNlIGBhbHdheXM6IHsgLi4uIH1gIGluc3RlYWQuJyk7XG4gICAgICB9XG4gICAgICBjb25zdCB0cmFuc2l0aW9uc0NvbmZpZyA9IHN0YXRlTm9kZS5jb25maWcub25bZGVzY3JpcHRvcl07XG4gICAgICB0cmFuc2l0aW9ucy5zZXQoZGVzY3JpcHRvciwgdG9UcmFuc2l0aW9uQ29uZmlnQXJyYXkodHJhbnNpdGlvbnNDb25maWcpLm1hcCh0ID0+IGZvcm1hdFRyYW5zaXRpb24oc3RhdGVOb2RlLCBkZXNjcmlwdG9yLCB0KSkpO1xuICAgIH1cbiAgfVxuICBpZiAoc3RhdGVOb2RlLmNvbmZpZy5vbkRvbmUpIHtcbiAgICBjb25zdCBkZXNjcmlwdG9yID0gYHhzdGF0ZS5kb25lLnN0YXRlLiR7c3RhdGVOb2RlLmlkfWA7XG4gICAgdHJhbnNpdGlvbnMuc2V0KGRlc2NyaXB0b3IsIHRvVHJhbnNpdGlvbkNvbmZpZ0FycmF5KHN0YXRlTm9kZS5jb25maWcub25Eb25lKS5tYXAodCA9PiBmb3JtYXRUcmFuc2l0aW9uKHN0YXRlTm9kZSwgZGVzY3JpcHRvciwgdCkpKTtcbiAgfVxuICBmb3IgKGNvbnN0IGludm9rZURlZiBvZiBzdGF0ZU5vZGUuaW52b2tlKSB7XG4gICAgaWYgKGludm9rZURlZi5vbkRvbmUpIHtcbiAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBgeHN0YXRlLmRvbmUuYWN0b3IuJHtpbnZva2VEZWYuaWR9YDtcbiAgICAgIHRyYW5zaXRpb25zLnNldChkZXNjcmlwdG9yLCB0b1RyYW5zaXRpb25Db25maWdBcnJheShpbnZva2VEZWYub25Eb25lKS5tYXAodCA9PiBmb3JtYXRUcmFuc2l0aW9uKHN0YXRlTm9kZSwgZGVzY3JpcHRvciwgdCkpKTtcbiAgICB9XG4gICAgaWYgKGludm9rZURlZi5vbkVycm9yKSB7XG4gICAgICBjb25zdCBkZXNjcmlwdG9yID0gYHhzdGF0ZS5lcnJvci5hY3Rvci4ke2ludm9rZURlZi5pZH1gO1xuICAgICAgdHJhbnNpdGlvbnMuc2V0KGRlc2NyaXB0b3IsIHRvVHJhbnNpdGlvbkNvbmZpZ0FycmF5KGludm9rZURlZi5vbkVycm9yKS5tYXAodCA9PiBmb3JtYXRUcmFuc2l0aW9uKHN0YXRlTm9kZSwgZGVzY3JpcHRvciwgdCkpKTtcbiAgICB9XG4gICAgaWYgKGludm9rZURlZi5vblNuYXBzaG90KSB7XG4gICAgICBjb25zdCBkZXNjcmlwdG9yID0gYHhzdGF0ZS5zbmFwc2hvdC4ke2ludm9rZURlZi5pZH1gO1xuICAgICAgdHJhbnNpdGlvbnMuc2V0KGRlc2NyaXB0b3IsIHRvVHJhbnNpdGlvbkNvbmZpZ0FycmF5KGludm9rZURlZi5vblNuYXBzaG90KS5tYXAodCA9PiBmb3JtYXRUcmFuc2l0aW9uKHN0YXRlTm9kZSwgZGVzY3JpcHRvciwgdCkpKTtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBkZWxheWVkVHJhbnNpdGlvbiBvZiBzdGF0ZU5vZGUuYWZ0ZXIpIHtcbiAgICBsZXQgZXhpc3RpbmcgPSB0cmFuc2l0aW9ucy5nZXQoZGVsYXllZFRyYW5zaXRpb24uZXZlbnRUeXBlKTtcbiAgICBpZiAoIWV4aXN0aW5nKSB7XG4gICAgICBleGlzdGluZyA9IFtdO1xuICAgICAgdHJhbnNpdGlvbnMuc2V0KGRlbGF5ZWRUcmFuc2l0aW9uLmV2ZW50VHlwZSwgZXhpc3RpbmcpO1xuICAgIH1cbiAgICBleGlzdGluZy5wdXNoKGRlbGF5ZWRUcmFuc2l0aW9uKTtcbiAgfVxuICByZXR1cm4gdHJhbnNpdGlvbnM7XG59XG5mdW5jdGlvbiBmb3JtYXRJbml0aWFsVHJhbnNpdGlvbihzdGF0ZU5vZGUsIF90YXJnZXQpIHtcbiAgY29uc3QgcmVzb2x2ZWRUYXJnZXQgPSB0eXBlb2YgX3RhcmdldCA9PT0gJ3N0cmluZycgPyBzdGF0ZU5vZGUuc3RhdGVzW190YXJnZXRdIDogX3RhcmdldCA/IHN0YXRlTm9kZS5zdGF0ZXNbX3RhcmdldC50YXJnZXRdIDogdW5kZWZpbmVkO1xuICBpZiAoIXJlc29sdmVkVGFyZ2V0ICYmIF90YXJnZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC10ZW1wbGF0ZS1leHByZXNzaW9ucywgQHR5cGVzY3JpcHQtZXNsaW50L25vLWJhc2UtdG8tc3RyaW5nXG4gICAgYEluaXRpYWwgc3RhdGUgbm9kZSBcIiR7X3RhcmdldH1cIiBub3QgZm91bmQgb24gcGFyZW50IHN0YXRlIG5vZGUgIyR7c3RhdGVOb2RlLmlkfWApO1xuICB9XG4gIGNvbnN0IHRyYW5zaXRpb24gPSB7XG4gICAgc291cmNlOiBzdGF0ZU5vZGUsXG4gICAgYWN0aW9uczogIV90YXJnZXQgfHwgdHlwZW9mIF90YXJnZXQgPT09ICdzdHJpbmcnID8gW10gOiB0b0FycmF5KF90YXJnZXQuYWN0aW9ucyksXG4gICAgZXZlbnRUeXBlOiBudWxsLFxuICAgIHJlZW50ZXI6IGZhbHNlLFxuICAgIHRhcmdldDogcmVzb2x2ZWRUYXJnZXQgPyBbcmVzb2x2ZWRUYXJnZXRdIDogW10sXG4gICAgdG9KU09OOiAoKSA9PiAoe1xuICAgICAgLi4udHJhbnNpdGlvbixcbiAgICAgIHNvdXJjZTogYCMke3N0YXRlTm9kZS5pZH1gLFxuICAgICAgdGFyZ2V0OiByZXNvbHZlZFRhcmdldCA/IFtgIyR7cmVzb2x2ZWRUYXJnZXQuaWR9YF0gOiBbXVxuICAgIH0pXG4gIH07XG4gIHJldHVybiB0cmFuc2l0aW9uO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVRhcmdldChzdGF0ZU5vZGUsIHRhcmdldHMpIHtcbiAgaWYgKHRhcmdldHMgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGFuIHVuZGVmaW5lZCB0YXJnZXQgc2lnbmFscyB0aGF0IHRoZSBzdGF0ZSBub2RlIHNob3VsZCBub3QgdHJhbnNpdGlvbiBmcm9tIHRoYXQgc3RhdGUgd2hlbiByZWNlaXZpbmcgdGhhdCBldmVudFxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIHRhcmdldHMubWFwKHRhcmdldCA9PiB7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICBpZiAoaXNTdGF0ZUlkKHRhcmdldCkpIHtcbiAgICAgIHJldHVybiBzdGF0ZU5vZGUubWFjaGluZS5nZXRTdGF0ZU5vZGVCeUlkKHRhcmdldCk7XG4gICAgfVxuICAgIGNvbnN0IGlzSW50ZXJuYWxUYXJnZXQgPSB0YXJnZXRbMF0gPT09IFNUQVRFX0RFTElNSVRFUjtcbiAgICAvLyBJZiBpbnRlcm5hbCB0YXJnZXQgaXMgZGVmaW5lZCBvbiBtYWNoaW5lLFxuICAgIC8vIGRvIG5vdCBpbmNsdWRlIG1hY2hpbmUga2V5IG9uIHRhcmdldFxuICAgIGlmIChpc0ludGVybmFsVGFyZ2V0ICYmICFzdGF0ZU5vZGUucGFyZW50KSB7XG4gICAgICByZXR1cm4gZ2V0U3RhdGVOb2RlQnlQYXRoKHN0YXRlTm9kZSwgdGFyZ2V0LnNsaWNlKDEpKTtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x2ZWRUYXJnZXQgPSBpc0ludGVybmFsVGFyZ2V0ID8gc3RhdGVOb2RlLmtleSArIHRhcmdldCA6IHRhcmdldDtcbiAgICBpZiAoc3RhdGVOb2RlLnBhcmVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0U3RhdGVOb2RlID0gZ2V0U3RhdGVOb2RlQnlQYXRoKHN0YXRlTm9kZS5wYXJlbnQsIHJlc29sdmVkVGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIHRhcmdldFN0YXRlTm9kZTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdHJhbnNpdGlvbiBkZWZpbml0aW9uIGZvciBzdGF0ZSBub2RlICcke3N0YXRlTm9kZS5pZH0nOlxcbiR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0YXJnZXQ6IFwiJHt0YXJnZXR9XCIgaXMgbm90IGEgdmFsaWQgdGFyZ2V0IGZyb20gdGhlIHJvb3Qgbm9kZS4gRGlkIHlvdSBtZWFuIFwiLiR7dGFyZ2V0fVwiP2ApO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiByZXNvbHZlSGlzdG9yeURlZmF1bHRUcmFuc2l0aW9uKHN0YXRlTm9kZSkge1xuICBjb25zdCBub3JtYWxpemVkVGFyZ2V0ID0gbm9ybWFsaXplVGFyZ2V0KHN0YXRlTm9kZS5jb25maWcudGFyZ2V0KTtcbiAgaWYgKCFub3JtYWxpemVkVGFyZ2V0KSB7XG4gICAgcmV0dXJuIHN0YXRlTm9kZS5wYXJlbnQuaW5pdGlhbDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHRhcmdldDogbm9ybWFsaXplZFRhcmdldC5tYXAodCA9PiB0eXBlb2YgdCA9PT0gJ3N0cmluZycgPyBnZXRTdGF0ZU5vZGVCeVBhdGgoc3RhdGVOb2RlLnBhcmVudCwgdCkgOiB0KVxuICB9O1xufVxuZnVuY3Rpb24gaXNIaXN0b3J5Tm9kZShzdGF0ZU5vZGUpIHtcbiAgcmV0dXJuIHN0YXRlTm9kZS50eXBlID09PSAnaGlzdG9yeSc7XG59XG5mdW5jdGlvbiBnZXRJbml0aWFsU3RhdGVOb2Rlc1dpdGhUaGVpckFuY2VzdG9ycyhzdGF0ZU5vZGUpIHtcbiAgY29uc3Qgc3RhdGVzID0gZ2V0SW5pdGlhbFN0YXRlTm9kZXMoc3RhdGVOb2RlKTtcbiAgZm9yIChjb25zdCBpbml0aWFsU3RhdGUgb2Ygc3RhdGVzKSB7XG4gICAgZm9yIChjb25zdCBhbmNlc3RvciBvZiBnZXRQcm9wZXJBbmNlc3RvcnMoaW5pdGlhbFN0YXRlLCBzdGF0ZU5vZGUpKSB7XG4gICAgICBzdGF0ZXMuYWRkKGFuY2VzdG9yKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0YXRlcztcbn1cbmZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZU5vZGVzKHN0YXRlTm9kZSkge1xuICBjb25zdCBzZXQgPSBuZXcgU2V0KCk7XG4gIGZ1bmN0aW9uIGl0ZXIoZGVzY1N0YXRlTm9kZSkge1xuICAgIGlmIChzZXQuaGFzKGRlc2NTdGF0ZU5vZGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNldC5hZGQoZGVzY1N0YXRlTm9kZSk7XG4gICAgaWYgKGRlc2NTdGF0ZU5vZGUudHlwZSA9PT0gJ2NvbXBvdW5kJykge1xuICAgICAgaXRlcihkZXNjU3RhdGVOb2RlLmluaXRpYWwudGFyZ2V0WzBdKTtcbiAgICB9IGVsc2UgaWYgKGRlc2NTdGF0ZU5vZGUudHlwZSA9PT0gJ3BhcmFsbGVsJykge1xuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBnZXRDaGlsZHJlbihkZXNjU3RhdGVOb2RlKSkge1xuICAgICAgICBpdGVyKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaXRlcihzdGF0ZU5vZGUpO1xuICByZXR1cm4gc2V0O1xufVxuLyoqIFJldHVybnMgdGhlIGNoaWxkIHN0YXRlIG5vZGUgZnJvbSBpdHMgcmVsYXRpdmUgYHN0YXRlS2V5YCwgb3IgdGhyb3dzLiAqL1xuZnVuY3Rpb24gZ2V0U3RhdGVOb2RlKHN0YXRlTm9kZSwgc3RhdGVLZXkpIHtcbiAgaWYgKGlzU3RhdGVJZChzdGF0ZUtleSkpIHtcbiAgICByZXR1cm4gc3RhdGVOb2RlLm1hY2hpbmUuZ2V0U3RhdGVOb2RlQnlJZChzdGF0ZUtleSk7XG4gIH1cbiAgaWYgKCFzdGF0ZU5vZGUuc3RhdGVzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gcmV0cmlldmUgY2hpbGQgc3RhdGUgJyR7c3RhdGVLZXl9JyBmcm9tICcke3N0YXRlTm9kZS5pZH0nOyBubyBjaGlsZCBzdGF0ZXMgZXhpc3QuYCk7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gc3RhdGVOb2RlLnN0YXRlc1tzdGF0ZUtleV07XG4gIGlmICghcmVzdWx0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDaGlsZCBzdGF0ZSAnJHtzdGF0ZUtleX0nIGRvZXMgbm90IGV4aXN0IG9uICcke3N0YXRlTm9kZS5pZH0nYCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSByZWxhdGl2ZSBzdGF0ZSBub2RlIGZyb20gdGhlIGdpdmVuIGBzdGF0ZVBhdGhgLCBvciB0aHJvd3MuXG4gKlxuICogQHBhcmFtIHN0YXRlUGF0aCBUaGUgc3RyaW5nIG9yIHN0cmluZyBhcnJheSByZWxhdGl2ZSBwYXRoIHRvIHRoZSBzdGF0ZSBub2RlLlxuICovXG5mdW5jdGlvbiBnZXRTdGF0ZU5vZGVCeVBhdGgoc3RhdGVOb2RlLCBzdGF0ZVBhdGgpIHtcbiAgaWYgKHR5cGVvZiBzdGF0ZVBhdGggPT09ICdzdHJpbmcnICYmIGlzU3RhdGVJZChzdGF0ZVBhdGgpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBzdGF0ZU5vZGUubWFjaGluZS5nZXRTdGF0ZU5vZGVCeUlkKHN0YXRlUGF0aCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICAvLyB0cnkgaW5kaXZpZHVhbCBwYXRoc1xuICAgICAgLy8gdGhyb3cgZTtcbiAgICB9XG4gIH1cbiAgY29uc3QgYXJyYXlTdGF0ZVBhdGggPSB0b1N0YXRlUGF0aChzdGF0ZVBhdGgpLnNsaWNlKCk7XG4gIGxldCBjdXJyZW50U3RhdGVOb2RlID0gc3RhdGVOb2RlO1xuICB3aGlsZSAoYXJyYXlTdGF0ZVBhdGgubGVuZ3RoKSB7XG4gICAgY29uc3Qga2V5ID0gYXJyYXlTdGF0ZVBhdGguc2hpZnQoKTtcbiAgICBpZiAoIWtleS5sZW5ndGgpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjdXJyZW50U3RhdGVOb2RlID0gZ2V0U3RhdGVOb2RlKGN1cnJlbnRTdGF0ZU5vZGUsIGtleSk7XG4gIH1cbiAgcmV0dXJuIGN1cnJlbnRTdGF0ZU5vZGU7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc3RhdGUgbm9kZXMgcmVwcmVzZW50ZWQgYnkgdGhlIGN1cnJlbnQgc3RhdGUgdmFsdWUuXG4gKlxuICogQHBhcmFtIHN0YXRlVmFsdWUgVGhlIHN0YXRlIHZhbHVlIG9yIFN0YXRlIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGdldFN0YXRlTm9kZXMoc3RhdGVOb2RlLCBzdGF0ZVZhbHVlKSB7XG4gIGlmICh0eXBlb2Ygc3RhdGVWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBjaGlsZFN0YXRlTm9kZSA9IHN0YXRlTm9kZS5zdGF0ZXNbc3RhdGVWYWx1ZV07XG4gICAgaWYgKCFjaGlsZFN0YXRlTm9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdGF0ZSAnJHtzdGF0ZVZhbHVlfScgZG9lcyBub3QgZXhpc3Qgb24gJyR7c3RhdGVOb2RlLmlkfSdgKTtcbiAgICB9XG4gICAgcmV0dXJuIFtzdGF0ZU5vZGUsIGNoaWxkU3RhdGVOb2RlXTtcbiAgfVxuICBjb25zdCBjaGlsZFN0YXRlS2V5cyA9IE9iamVjdC5rZXlzKHN0YXRlVmFsdWUpO1xuICBjb25zdCBjaGlsZFN0YXRlTm9kZXMgPSBjaGlsZFN0YXRlS2V5cy5tYXAoc3ViU3RhdGVLZXkgPT4gZ2V0U3RhdGVOb2RlKHN0YXRlTm9kZSwgc3ViU3RhdGVLZXkpKS5maWx0ZXIoQm9vbGVhbik7XG4gIHJldHVybiBbc3RhdGVOb2RlLm1hY2hpbmUucm9vdCwgc3RhdGVOb2RlXS5jb25jYXQoY2hpbGRTdGF0ZU5vZGVzLCBjaGlsZFN0YXRlS2V5cy5yZWR1Y2UoKGFsbFN1YlN0YXRlTm9kZXMsIHN1YlN0YXRlS2V5KSA9PiB7XG4gICAgY29uc3Qgc3ViU3RhdGVOb2RlID0gZ2V0U3RhdGVOb2RlKHN0YXRlTm9kZSwgc3ViU3RhdGVLZXkpO1xuICAgIGlmICghc3ViU3RhdGVOb2RlKSB7XG4gICAgICByZXR1cm4gYWxsU3ViU3RhdGVOb2RlcztcbiAgICB9XG4gICAgY29uc3Qgc3ViU3RhdGVOb2RlcyA9IGdldFN0YXRlTm9kZXMoc3ViU3RhdGVOb2RlLCBzdGF0ZVZhbHVlW3N1YlN0YXRlS2V5XSk7XG4gICAgcmV0dXJuIGFsbFN1YlN0YXRlTm9kZXMuY29uY2F0KHN1YlN0YXRlTm9kZXMpO1xuICB9LCBbXSkpO1xufVxuZnVuY3Rpb24gdHJhbnNpdGlvbkF0b21pY05vZGUoc3RhdGVOb2RlLCBzdGF0ZVZhbHVlLCBzbmFwc2hvdCwgZXZlbnQpIHtcbiAgY29uc3QgY2hpbGRTdGF0ZU5vZGUgPSBnZXRTdGF0ZU5vZGUoc3RhdGVOb2RlLCBzdGF0ZVZhbHVlKTtcbiAgY29uc3QgbmV4dCA9IGNoaWxkU3RhdGVOb2RlLm5leHQoc25hcHNob3QsIGV2ZW50KTtcbiAgaWYgKCFuZXh0IHx8ICFuZXh0Lmxlbmd0aCkge1xuICAgIHJldHVybiBzdGF0ZU5vZGUubmV4dChzbmFwc2hvdCwgZXZlbnQpO1xuICB9XG4gIHJldHVybiBuZXh0O1xufVxuZnVuY3Rpb24gdHJhbnNpdGlvbkNvbXBvdW5kTm9kZShzdGF0ZU5vZGUsIHN0YXRlVmFsdWUsIHNuYXBzaG90LCBldmVudCkge1xuICBjb25zdCBzdWJTdGF0ZUtleXMgPSBPYmplY3Qua2V5cyhzdGF0ZVZhbHVlKTtcbiAgY29uc3QgY2hpbGRTdGF0ZU5vZGUgPSBnZXRTdGF0ZU5vZGUoc3RhdGVOb2RlLCBzdWJTdGF0ZUtleXNbMF0pO1xuICBjb25zdCBuZXh0ID0gdHJhbnNpdGlvbk5vZGUoY2hpbGRTdGF0ZU5vZGUsIHN0YXRlVmFsdWVbc3ViU3RhdGVLZXlzWzBdXSwgc25hcHNob3QsIGV2ZW50KTtcbiAgaWYgKCFuZXh0IHx8ICFuZXh0Lmxlbmd0aCkge1xuICAgIHJldHVybiBzdGF0ZU5vZGUubmV4dChzbmFwc2hvdCwgZXZlbnQpO1xuICB9XG4gIHJldHVybiBuZXh0O1xufVxuZnVuY3Rpb24gdHJhbnNpdGlvblBhcmFsbGVsTm9kZShzdGF0ZU5vZGUsIHN0YXRlVmFsdWUsIHNuYXBzaG90LCBldmVudCkge1xuICBjb25zdCBhbGxJbm5lclRyYW5zaXRpb25zID0gW107XG4gIGZvciAoY29uc3Qgc3ViU3RhdGVLZXkgb2YgT2JqZWN0LmtleXMoc3RhdGVWYWx1ZSkpIHtcbiAgICBjb25zdCBzdWJTdGF0ZVZhbHVlID0gc3RhdGVWYWx1ZVtzdWJTdGF0ZUtleV07XG4gICAgaWYgKCFzdWJTdGF0ZVZhbHVlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3Qgc3ViU3RhdGVOb2RlID0gZ2V0U3RhdGVOb2RlKHN0YXRlTm9kZSwgc3ViU3RhdGVLZXkpO1xuICAgIGNvbnN0IGlubmVyVHJhbnNpdGlvbnMgPSB0cmFuc2l0aW9uTm9kZShzdWJTdGF0ZU5vZGUsIHN1YlN0YXRlVmFsdWUsIHNuYXBzaG90LCBldmVudCk7XG4gICAgaWYgKGlubmVyVHJhbnNpdGlvbnMpIHtcbiAgICAgIGFsbElubmVyVHJhbnNpdGlvbnMucHVzaCguLi5pbm5lclRyYW5zaXRpb25zKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFhbGxJbm5lclRyYW5zaXRpb25zLmxlbmd0aCkge1xuICAgIHJldHVybiBzdGF0ZU5vZGUubmV4dChzbmFwc2hvdCwgZXZlbnQpO1xuICB9XG4gIHJldHVybiBhbGxJbm5lclRyYW5zaXRpb25zO1xufVxuZnVuY3Rpb24gdHJhbnNpdGlvbk5vZGUoc3RhdGVOb2RlLCBzdGF0ZVZhbHVlLCBzbmFwc2hvdCwgZXZlbnQpIHtcbiAgLy8gbGVhZiBub2RlXG4gIGlmICh0eXBlb2Ygc3RhdGVWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvbkF0b21pY05vZGUoc3RhdGVOb2RlLCBzdGF0ZVZhbHVlLCBzbmFwc2hvdCwgZXZlbnQpO1xuICB9XG5cbiAgLy8gY29tcG91bmQgbm9kZVxuICBpZiAoT2JqZWN0LmtleXMoc3RhdGVWYWx1ZSkubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25Db21wb3VuZE5vZGUoc3RhdGVOb2RlLCBzdGF0ZVZhbHVlLCBzbmFwc2hvdCwgZXZlbnQpO1xuICB9XG5cbiAgLy8gcGFyYWxsZWwgbm9kZVxuICByZXR1cm4gdHJhbnNpdGlvblBhcmFsbGVsTm9kZShzdGF0ZU5vZGUsIHN0YXRlVmFsdWUsIHNuYXBzaG90LCBldmVudCk7XG59XG5mdW5jdGlvbiBnZXRIaXN0b3J5Tm9kZXMoc3RhdGVOb2RlKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhzdGF0ZU5vZGUuc3RhdGVzKS5tYXAoa2V5ID0+IHN0YXRlTm9kZS5zdGF0ZXNba2V5XSkuZmlsdGVyKHNuID0+IHNuLnR5cGUgPT09ICdoaXN0b3J5Jyk7XG59XG5mdW5jdGlvbiBpc0Rlc2NlbmRhbnQoY2hpbGRTdGF0ZU5vZGUsIHBhcmVudFN0YXRlTm9kZSkge1xuICBsZXQgbWFya2VyID0gY2hpbGRTdGF0ZU5vZGU7XG4gIHdoaWxlIChtYXJrZXIucGFyZW50ICYmIG1hcmtlci5wYXJlbnQgIT09IHBhcmVudFN0YXRlTm9kZSkge1xuICAgIG1hcmtlciA9IG1hcmtlci5wYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIG1hcmtlci5wYXJlbnQgPT09IHBhcmVudFN0YXRlTm9kZTtcbn1cbmZ1bmN0aW9uIGhhc0ludGVyc2VjdGlvbihzMSwgczIpIHtcbiAgY29uc3Qgc2V0MSA9IG5ldyBTZXQoczEpO1xuICBjb25zdCBzZXQyID0gbmV3IFNldChzMik7XG4gIGZvciAoY29uc3QgaXRlbSBvZiBzZXQxKSB7XG4gICAgaWYgKHNldDIuaGFzKGl0ZW0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBpdGVtIG9mIHNldDIpIHtcbiAgICBpZiAoc2V0MS5oYXMoaXRlbSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiByZW1vdmVDb25mbGljdGluZ1RyYW5zaXRpb25zKGVuYWJsZWRUcmFuc2l0aW9ucywgc3RhdGVOb2RlU2V0LCBoaXN0b3J5VmFsdWUpIHtcbiAgY29uc3QgZmlsdGVyZWRUcmFuc2l0aW9ucyA9IG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCB0MSBvZiBlbmFibGVkVHJhbnNpdGlvbnMpIHtcbiAgICBsZXQgdDFQcmVlbXB0ZWQgPSBmYWxzZTtcbiAgICBjb25zdCB0cmFuc2l0aW9uc1RvUmVtb3ZlID0gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgdDIgb2YgZmlsdGVyZWRUcmFuc2l0aW9ucykge1xuICAgICAgaWYgKGhhc0ludGVyc2VjdGlvbihjb21wdXRlRXhpdFNldChbdDFdLCBzdGF0ZU5vZGVTZXQsIGhpc3RvcnlWYWx1ZSksIGNvbXB1dGVFeGl0U2V0KFt0Ml0sIHN0YXRlTm9kZVNldCwgaGlzdG9yeVZhbHVlKSkpIHtcbiAgICAgICAgaWYgKGlzRGVzY2VuZGFudCh0MS5zb3VyY2UsIHQyLnNvdXJjZSkpIHtcbiAgICAgICAgICB0cmFuc2l0aW9uc1RvUmVtb3ZlLmFkZCh0Mik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdDFQcmVlbXB0ZWQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdDFQcmVlbXB0ZWQpIHtcbiAgICAgIGZvciAoY29uc3QgdDMgb2YgdHJhbnNpdGlvbnNUb1JlbW92ZSkge1xuICAgICAgICBmaWx0ZXJlZFRyYW5zaXRpb25zLmRlbGV0ZSh0Myk7XG4gICAgICB9XG4gICAgICBmaWx0ZXJlZFRyYW5zaXRpb25zLmFkZCh0MSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKGZpbHRlcmVkVHJhbnNpdGlvbnMpO1xufVxuZnVuY3Rpb24gZmluZExlYXN0Q29tbW9uQW5jZXN0b3Ioc3RhdGVOb2Rlcykge1xuICBjb25zdCBbaGVhZCwgLi4udGFpbF0gPSBzdGF0ZU5vZGVzO1xuICBmb3IgKGNvbnN0IGFuY2VzdG9yIG9mIGdldFByb3BlckFuY2VzdG9ycyhoZWFkLCB1bmRlZmluZWQpKSB7XG4gICAgaWYgKHRhaWwuZXZlcnkoc24gPT4gaXNEZXNjZW5kYW50KHNuLCBhbmNlc3RvcikpKSB7XG4gICAgICByZXR1cm4gYW5jZXN0b3I7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRFZmZlY3RpdmVUYXJnZXRTdGF0ZXModHJhbnNpdGlvbiwgaGlzdG9yeVZhbHVlKSB7XG4gIGlmICghdHJhbnNpdGlvbi50YXJnZXQpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3QgdGFyZ2V0cyA9IG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCB0YXJnZXROb2RlIG9mIHRyYW5zaXRpb24udGFyZ2V0KSB7XG4gICAgaWYgKGlzSGlzdG9yeU5vZGUodGFyZ2V0Tm9kZSkpIHtcbiAgICAgIGlmIChoaXN0b3J5VmFsdWVbdGFyZ2V0Tm9kZS5pZF0pIHtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIGhpc3RvcnlWYWx1ZVt0YXJnZXROb2RlLmlkXSkge1xuICAgICAgICAgIHRhcmdldHMuYWRkKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgZ2V0RWZmZWN0aXZlVGFyZ2V0U3RhdGVzKHJlc29sdmVIaXN0b3J5RGVmYXVsdFRyYW5zaXRpb24odGFyZ2V0Tm9kZSksIGhpc3RvcnlWYWx1ZSkpIHtcbiAgICAgICAgICB0YXJnZXRzLmFkZChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXRzLmFkZCh0YXJnZXROb2RlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFsuLi50YXJnZXRzXTtcbn1cbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25Eb21haW4odHJhbnNpdGlvbiwgaGlzdG9yeVZhbHVlKSB7XG4gIGNvbnN0IHRhcmdldFN0YXRlcyA9IGdldEVmZmVjdGl2ZVRhcmdldFN0YXRlcyh0cmFuc2l0aW9uLCBoaXN0b3J5VmFsdWUpO1xuICBpZiAoIXRhcmdldFN0YXRlcykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIXRyYW5zaXRpb24ucmVlbnRlciAmJiB0YXJnZXRTdGF0ZXMuZXZlcnkodGFyZ2V0ID0+IHRhcmdldCA9PT0gdHJhbnNpdGlvbi5zb3VyY2UgfHwgaXNEZXNjZW5kYW50KHRhcmdldCwgdHJhbnNpdGlvbi5zb3VyY2UpKSkge1xuICAgIHJldHVybiB0cmFuc2l0aW9uLnNvdXJjZTtcbiAgfVxuICBjb25zdCBsY2EgPSBmaW5kTGVhc3RDb21tb25BbmNlc3Rvcih0YXJnZXRTdGF0ZXMuY29uY2F0KHRyYW5zaXRpb24uc291cmNlKSk7XG4gIGlmIChsY2EpIHtcbiAgICByZXR1cm4gbGNhO1xuICB9XG5cbiAgLy8gYXQgdGhpcyBwb2ludCB3ZSBrbm93IHRoYXQgaXQncyBhIHJvb3QgdHJhbnNpdGlvbiBzaW5jZSBMQ0EgY291bGRuJ3QgYmUgZm91bmRcbiAgaWYgKHRyYW5zaXRpb24ucmVlbnRlcikge1xuICAgIHJldHVybjtcbiAgfVxuICByZXR1cm4gdHJhbnNpdGlvbi5zb3VyY2UubWFjaGluZS5yb290O1xufVxuZnVuY3Rpb24gY29tcHV0ZUV4aXRTZXQodHJhbnNpdGlvbnMsIHN0YXRlTm9kZVNldCwgaGlzdG9yeVZhbHVlKSB7XG4gIGNvbnN0IHN0YXRlc1RvRXhpdCA9IG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCB0IG9mIHRyYW5zaXRpb25zKSB7XG4gICAgaWYgKHQudGFyZ2V0Py5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGRvbWFpbiA9IGdldFRyYW5zaXRpb25Eb21haW4odCwgaGlzdG9yeVZhbHVlKTtcbiAgICAgIGlmICh0LnJlZW50ZXIgJiYgdC5zb3VyY2UgPT09IGRvbWFpbikge1xuICAgICAgICBzdGF0ZXNUb0V4aXQuYWRkKGRvbWFpbik7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHN0YXRlTm9kZSBvZiBzdGF0ZU5vZGVTZXQpIHtcbiAgICAgICAgaWYgKGlzRGVzY2VuZGFudChzdGF0ZU5vZGUsIGRvbWFpbikpIHtcbiAgICAgICAgICBzdGF0ZXNUb0V4aXQuYWRkKHN0YXRlTm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFsuLi5zdGF0ZXNUb0V4aXRdO1xufVxuZnVuY3Rpb24gYXJlU3RhdGVOb2RlQ29sbGVjdGlvbnNFcXVhbChwcmV2U3RhdGVOb2RlcywgbmV4dFN0YXRlTm9kZVNldCkge1xuICBpZiAocHJldlN0YXRlTm9kZXMubGVuZ3RoICE9PSBuZXh0U3RhdGVOb2RlU2V0LnNpemUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBub2RlIG9mIHByZXZTdGF0ZU5vZGVzKSB7XG4gICAgaWYgKCFuZXh0U3RhdGVOb2RlU2V0Lmhhcyhub2RlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9zY3htbC8jbWljcm9zdGVwUHJvY2VkdXJlICovXG5mdW5jdGlvbiBtaWNyb3N0ZXAodHJhbnNpdGlvbnMsIGN1cnJlbnRTbmFwc2hvdCwgYWN0b3JTY29wZSwgZXZlbnQsIGlzSW5pdGlhbCwgaW50ZXJuYWxRdWV1ZSkge1xuICBpZiAoIXRyYW5zaXRpb25zLmxlbmd0aCkge1xuICAgIHJldHVybiBjdXJyZW50U25hcHNob3Q7XG4gIH1cbiAgY29uc3QgbXV0U3RhdGVOb2RlU2V0ID0gbmV3IFNldChjdXJyZW50U25hcHNob3QuX25vZGVzKTtcbiAgbGV0IGhpc3RvcnlWYWx1ZSA9IGN1cnJlbnRTbmFwc2hvdC5oaXN0b3J5VmFsdWU7XG4gIGNvbnN0IGZpbHRlcmVkVHJhbnNpdGlvbnMgPSByZW1vdmVDb25mbGljdGluZ1RyYW5zaXRpb25zKHRyYW5zaXRpb25zLCBtdXRTdGF0ZU5vZGVTZXQsIGhpc3RvcnlWYWx1ZSk7XG4gIGxldCBuZXh0U3RhdGUgPSBjdXJyZW50U25hcHNob3Q7XG5cbiAgLy8gRXhpdCBzdGF0ZXNcbiAgaWYgKCFpc0luaXRpYWwpIHtcbiAgICBbbmV4dFN0YXRlLCBoaXN0b3J5VmFsdWVdID0gZXhpdFN0YXRlcyhuZXh0U3RhdGUsIGV2ZW50LCBhY3RvclNjb3BlLCBmaWx0ZXJlZFRyYW5zaXRpb25zLCBtdXRTdGF0ZU5vZGVTZXQsIGhpc3RvcnlWYWx1ZSwgaW50ZXJuYWxRdWV1ZSwgYWN0b3JTY29wZS5hY3Rpb25FeGVjdXRvcik7XG4gIH1cblxuICAvLyBFeGVjdXRlIHRyYW5zaXRpb24gY29udGVudFxuICBuZXh0U3RhdGUgPSByZXNvbHZlQWN0aW9uc0FuZENvbnRleHQobmV4dFN0YXRlLCBldmVudCwgYWN0b3JTY29wZSwgZmlsdGVyZWRUcmFuc2l0aW9ucy5mbGF0TWFwKHQgPT4gdC5hY3Rpb25zKSwgaW50ZXJuYWxRdWV1ZSwgdW5kZWZpbmVkKTtcblxuICAvLyBFbnRlciBzdGF0ZXNcbiAgbmV4dFN0YXRlID0gZW50ZXJTdGF0ZXMobmV4dFN0YXRlLCBldmVudCwgYWN0b3JTY29wZSwgZmlsdGVyZWRUcmFuc2l0aW9ucywgbXV0U3RhdGVOb2RlU2V0LCBpbnRlcm5hbFF1ZXVlLCBoaXN0b3J5VmFsdWUsIGlzSW5pdGlhbCk7XG4gIGNvbnN0IG5leHRTdGF0ZU5vZGVzID0gWy4uLm11dFN0YXRlTm9kZVNldF07XG4gIGlmIChuZXh0U3RhdGUuc3RhdHVzID09PSAnZG9uZScpIHtcbiAgICBuZXh0U3RhdGUgPSByZXNvbHZlQWN0aW9uc0FuZENvbnRleHQobmV4dFN0YXRlLCBldmVudCwgYWN0b3JTY29wZSwgbmV4dFN0YXRlTm9kZXMuc29ydCgoYSwgYikgPT4gYi5vcmRlciAtIGEub3JkZXIpLmZsYXRNYXAoc3RhdGUgPT4gc3RhdGUuZXhpdCksIGludGVybmFsUXVldWUsIHVuZGVmaW5lZCk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1jYXRjaFxuICB0cnkge1xuICAgIGlmIChoaXN0b3J5VmFsdWUgPT09IGN1cnJlbnRTbmFwc2hvdC5oaXN0b3J5VmFsdWUgJiYgYXJlU3RhdGVOb2RlQ29sbGVjdGlvbnNFcXVhbChjdXJyZW50U25hcHNob3QuX25vZGVzLCBtdXRTdGF0ZU5vZGVTZXQpKSB7XG4gICAgICByZXR1cm4gbmV4dFN0YXRlO1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmVNYWNoaW5lU25hcHNob3QobmV4dFN0YXRlLCB7XG4gICAgICBfbm9kZXM6IG5leHRTdGF0ZU5vZGVzLFxuICAgICAgaGlzdG9yeVZhbHVlXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBUT0RPOiBSZWZhY3RvciB0aGlzIG9uY2UgcHJvcGVyIGVycm9yIGhhbmRsaW5nIGlzIGltcGxlbWVudGVkLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc3RhdGVseWFpL3JmY3MvcHVsbC80XG4gICAgdGhyb3cgZTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0TWFjaGluZU91dHB1dChzbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUsIHJvb3ROb2RlLCByb290Q29tcGxldGlvbk5vZGUpIHtcbiAgaWYgKHJvb3ROb2RlLm91dHB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGRvbmVTdGF0ZUV2ZW50ID0gY3JlYXRlRG9uZVN0YXRlRXZlbnQocm9vdENvbXBsZXRpb25Ob2RlLmlkLCByb290Q29tcGxldGlvbk5vZGUub3V0cHV0ICE9PSB1bmRlZmluZWQgJiYgcm9vdENvbXBsZXRpb25Ob2RlLnBhcmVudCA/IHJlc29sdmVPdXRwdXQocm9vdENvbXBsZXRpb25Ob2RlLm91dHB1dCwgc25hcHNob3QuY29udGV4dCwgZXZlbnQsIGFjdG9yU2NvcGUuc2VsZikgOiB1bmRlZmluZWQpO1xuICByZXR1cm4gcmVzb2x2ZU91dHB1dChyb290Tm9kZS5vdXRwdXQsIHNuYXBzaG90LmNvbnRleHQsIGRvbmVTdGF0ZUV2ZW50LCBhY3RvclNjb3BlLnNlbGYpO1xufVxuZnVuY3Rpb24gZW50ZXJTdGF0ZXMoY3VycmVudFNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSwgZmlsdGVyZWRUcmFuc2l0aW9ucywgbXV0U3RhdGVOb2RlU2V0LCBpbnRlcm5hbFF1ZXVlLCBoaXN0b3J5VmFsdWUsIGlzSW5pdGlhbCkge1xuICBsZXQgbmV4dFNuYXBzaG90ID0gY3VycmVudFNuYXBzaG90O1xuICBjb25zdCBzdGF0ZXNUb0VudGVyID0gbmV3IFNldCgpO1xuICAvLyB0aG9zZSBhcmUgc3RhdGVzIHRoYXQgd2VyZSBkaXJlY3RseSB0YXJnZXRlZCBvciBpbmRpcmVjdGx5IHRhcmdldGVkIGJ5IHRoZSBleHBsaWNpdCB0YXJnZXRcbiAgLy8gaW4gb3RoZXIgd29yZHMsIHRob3NlIGFyZSBzdGF0ZXMgZm9yIHdoaWNoIGluaXRpYWwgYWN0aW9ucyBzaG91bGQgYmUgZXhlY3V0ZWRcbiAgLy8gd2hlbiB3ZSB0YXJnZXQgYCNkZWVwX2NoaWxkYCBpbml0aWFsIGFjdGlvbnMgb2YgaXRzIGFuY2VzdG9ycyBzaG91bGRuJ3QgYmUgZXhlY3V0ZWRcbiAgY29uc3Qgc3RhdGVzRm9yRGVmYXVsdEVudHJ5ID0gbmV3IFNldCgpO1xuICBjb21wdXRlRW50cnlTZXQoZmlsdGVyZWRUcmFuc2l0aW9ucywgaGlzdG9yeVZhbHVlLCBzdGF0ZXNGb3JEZWZhdWx0RW50cnksIHN0YXRlc1RvRW50ZXIpO1xuXG4gIC8vIEluIHRoZSBpbml0aWFsIHN0YXRlLCB0aGUgcm9vdCBzdGF0ZSBub2RlIGlzIFwiZW50ZXJlZFwiLlxuICBpZiAoaXNJbml0aWFsKSB7XG4gICAgc3RhdGVzRm9yRGVmYXVsdEVudHJ5LmFkZChjdXJyZW50U25hcHNob3QubWFjaGluZS5yb290KTtcbiAgfVxuICBjb25zdCBjb21wbGV0ZWROb2RlcyA9IG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCBzdGF0ZU5vZGVUb0VudGVyIG9mIFsuLi5zdGF0ZXNUb0VudGVyXS5zb3J0KChhLCBiKSA9PiBhLm9yZGVyIC0gYi5vcmRlcikpIHtcbiAgICBtdXRTdGF0ZU5vZGVTZXQuYWRkKHN0YXRlTm9kZVRvRW50ZXIpO1xuICAgIGNvbnN0IGFjdGlvbnMgPSBbXTtcblxuICAgIC8vIEFkZCBlbnRyeSBhY3Rpb25zXG4gICAgYWN0aW9ucy5wdXNoKC4uLnN0YXRlTm9kZVRvRW50ZXIuZW50cnkpO1xuICAgIGZvciAoY29uc3QgaW52b2tlRGVmIG9mIHN0YXRlTm9kZVRvRW50ZXIuaW52b2tlKSB7XG4gICAgICBhY3Rpb25zLnB1c2goc3Bhd25DaGlsZChpbnZva2VEZWYuc3JjLCB7XG4gICAgICAgIC4uLmludm9rZURlZixcbiAgICAgICAgc3luY1NuYXBzaG90OiAhIWludm9rZURlZi5vblNuYXBzaG90XG4gICAgICB9KSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZXNGb3JEZWZhdWx0RW50cnkuaGFzKHN0YXRlTm9kZVRvRW50ZXIpKSB7XG4gICAgICBjb25zdCBpbml0aWFsQWN0aW9ucyA9IHN0YXRlTm9kZVRvRW50ZXIuaW5pdGlhbC5hY3Rpb25zO1xuICAgICAgYWN0aW9ucy5wdXNoKC4uLmluaXRpYWxBY3Rpb25zKTtcbiAgICB9XG4gICAgbmV4dFNuYXBzaG90ID0gcmVzb2x2ZUFjdGlvbnNBbmRDb250ZXh0KG5leHRTbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUsIGFjdGlvbnMsIGludGVybmFsUXVldWUsIHN0YXRlTm9kZVRvRW50ZXIuaW52b2tlLm1hcChpbnZva2VEZWYgPT4gaW52b2tlRGVmLmlkKSk7XG4gICAgaWYgKHN0YXRlTm9kZVRvRW50ZXIudHlwZSA9PT0gJ2ZpbmFsJykge1xuICAgICAgY29uc3QgcGFyZW50ID0gc3RhdGVOb2RlVG9FbnRlci5wYXJlbnQ7XG4gICAgICBsZXQgYW5jZXN0b3JNYXJrZXIgPSBwYXJlbnQ/LnR5cGUgPT09ICdwYXJhbGxlbCcgPyBwYXJlbnQgOiBwYXJlbnQ/LnBhcmVudDtcbiAgICAgIGxldCByb290Q29tcGxldGlvbk5vZGUgPSBhbmNlc3Rvck1hcmtlciB8fCBzdGF0ZU5vZGVUb0VudGVyO1xuICAgICAgaWYgKHBhcmVudD8udHlwZSA9PT0gJ2NvbXBvdW5kJykge1xuICAgICAgICBpbnRlcm5hbFF1ZXVlLnB1c2goY3JlYXRlRG9uZVN0YXRlRXZlbnQocGFyZW50LmlkLCBzdGF0ZU5vZGVUb0VudGVyLm91dHB1dCAhPT0gdW5kZWZpbmVkID8gcmVzb2x2ZU91dHB1dChzdGF0ZU5vZGVUb0VudGVyLm91dHB1dCwgbmV4dFNuYXBzaG90LmNvbnRleHQsIGV2ZW50LCBhY3RvclNjb3BlLnNlbGYpIDogdW5kZWZpbmVkKSk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoYW5jZXN0b3JNYXJrZXI/LnR5cGUgPT09ICdwYXJhbGxlbCcgJiYgIWNvbXBsZXRlZE5vZGVzLmhhcyhhbmNlc3Rvck1hcmtlcikgJiYgaXNJbkZpbmFsU3RhdGUobXV0U3RhdGVOb2RlU2V0LCBhbmNlc3Rvck1hcmtlcikpIHtcbiAgICAgICAgY29tcGxldGVkTm9kZXMuYWRkKGFuY2VzdG9yTWFya2VyKTtcbiAgICAgICAgaW50ZXJuYWxRdWV1ZS5wdXNoKGNyZWF0ZURvbmVTdGF0ZUV2ZW50KGFuY2VzdG9yTWFya2VyLmlkKSk7XG4gICAgICAgIHJvb3RDb21wbGV0aW9uTm9kZSA9IGFuY2VzdG9yTWFya2VyO1xuICAgICAgICBhbmNlc3Rvck1hcmtlciA9IGFuY2VzdG9yTWFya2VyLnBhcmVudDtcbiAgICAgIH1cbiAgICAgIGlmIChhbmNlc3Rvck1hcmtlcikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIG5leHRTbmFwc2hvdCA9IGNsb25lTWFjaGluZVNuYXBzaG90KG5leHRTbmFwc2hvdCwge1xuICAgICAgICBzdGF0dXM6ICdkb25lJyxcbiAgICAgICAgb3V0cHV0OiBnZXRNYWNoaW5lT3V0cHV0KG5leHRTbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUsIG5leHRTbmFwc2hvdC5tYWNoaW5lLnJvb3QsIHJvb3RDb21wbGV0aW9uTm9kZSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV4dFNuYXBzaG90O1xufVxuZnVuY3Rpb24gY29tcHV0ZUVudHJ5U2V0KHRyYW5zaXRpb25zLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSwgc3RhdGVzVG9FbnRlcikge1xuICBmb3IgKGNvbnN0IHQgb2YgdHJhbnNpdGlvbnMpIHtcbiAgICBjb25zdCBkb21haW4gPSBnZXRUcmFuc2l0aW9uRG9tYWluKHQsIGhpc3RvcnlWYWx1ZSk7XG4gICAgZm9yIChjb25zdCBzIG9mIHQudGFyZ2V0IHx8IFtdKSB7XG4gICAgICBpZiAoIWlzSGlzdG9yeU5vZGUocykgJiYgKFxuICAgICAgLy8gaWYgdGhlIHRhcmdldCBpcyBkaWZmZXJlbnQgdGhhbiB0aGUgc291cmNlIHRoZW4gaXQgd2lsbCAqZGVmaW5pdGVseSogYmUgZW50ZXJlZFxuICAgICAgdC5zb3VyY2UgIT09IHMgfHxcbiAgICAgIC8vIHdlIGtub3cgdGhhdCB0aGUgZG9tYWluIGNhbid0IGxpZSB3aXRoaW4gdGhlIHNvdXJjZVxuICAgICAgLy8gaWYgaXQncyBkaWZmZXJlbnQgdGhhbiB0aGUgc291cmNlIHRoZW4gaXQncyBvdXRzaWRlIG9mIGl0IGFuZCBpdCBtZWFucyB0aGF0IHRoZSB0YXJnZXQgaGFzIHRvIGJlIGVudGVyZWQgYXMgd2VsbFxuICAgICAgdC5zb3VyY2UgIT09IGRvbWFpbiB8fFxuICAgICAgLy8gcmVlbnRlcmluZyB0cmFuc2l0aW9ucyBhbHdheXMgZW50ZXIgdGhlIHRhcmdldCwgZXZlbiBpZiBpdCdzIHRoZSBzb3VyY2UgaXRzZWxmXG4gICAgICB0LnJlZW50ZXIpKSB7XG4gICAgICAgIHN0YXRlc1RvRW50ZXIuYWRkKHMpO1xuICAgICAgICBzdGF0ZXNGb3JEZWZhdWx0RW50cnkuYWRkKHMpO1xuICAgICAgfVxuICAgICAgYWRkRGVzY2VuZGFudFN0YXRlc1RvRW50ZXIocywgaGlzdG9yeVZhbHVlLCBzdGF0ZXNGb3JEZWZhdWx0RW50cnksIHN0YXRlc1RvRW50ZXIpO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRTdGF0ZXMgPSBnZXRFZmZlY3RpdmVUYXJnZXRTdGF0ZXModCwgaGlzdG9yeVZhbHVlKTtcbiAgICBmb3IgKGNvbnN0IHMgb2YgdGFyZ2V0U3RhdGVzKSB7XG4gICAgICBjb25zdCBhbmNlc3RvcnMgPSBnZXRQcm9wZXJBbmNlc3RvcnMocywgZG9tYWluKTtcbiAgICAgIGlmIChkb21haW4/LnR5cGUgPT09ICdwYXJhbGxlbCcpIHtcbiAgICAgICAgYW5jZXN0b3JzLnB1c2goZG9tYWluKTtcbiAgICAgIH1cbiAgICAgIGFkZEFuY2VzdG9yU3RhdGVzVG9FbnRlcihzdGF0ZXNUb0VudGVyLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSwgYW5jZXN0b3JzLCAhdC5zb3VyY2UucGFyZW50ICYmIHQucmVlbnRlciA/IHVuZGVmaW5lZCA6IGRvbWFpbik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhZGREZXNjZW5kYW50U3RhdGVzVG9FbnRlcihzdGF0ZU5vZGUsIGhpc3RvcnlWYWx1ZSwgc3RhdGVzRm9yRGVmYXVsdEVudHJ5LCBzdGF0ZXNUb0VudGVyKSB7XG4gIGlmIChpc0hpc3RvcnlOb2RlKHN0YXRlTm9kZSkpIHtcbiAgICBpZiAoaGlzdG9yeVZhbHVlW3N0YXRlTm9kZS5pZF0pIHtcbiAgICAgIGNvbnN0IGhpc3RvcnlTdGF0ZU5vZGVzID0gaGlzdG9yeVZhbHVlW3N0YXRlTm9kZS5pZF07XG4gICAgICBmb3IgKGNvbnN0IHMgb2YgaGlzdG9yeVN0YXRlTm9kZXMpIHtcbiAgICAgICAgc3RhdGVzVG9FbnRlci5hZGQocyk7XG4gICAgICAgIGFkZERlc2NlbmRhbnRTdGF0ZXNUb0VudGVyKHMsIGhpc3RvcnlWYWx1ZSwgc3RhdGVzRm9yRGVmYXVsdEVudHJ5LCBzdGF0ZXNUb0VudGVyKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgcyBvZiBoaXN0b3J5U3RhdGVOb2Rlcykge1xuICAgICAgICBhZGRQcm9wZXJBbmNlc3RvclN0YXRlc1RvRW50ZXIocywgc3RhdGVOb2RlLnBhcmVudCwgc3RhdGVzVG9FbnRlciwgaGlzdG9yeVZhbHVlLCBzdGF0ZXNGb3JEZWZhdWx0RW50cnkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoaXN0b3J5RGVmYXVsdFRyYW5zaXRpb24gPSByZXNvbHZlSGlzdG9yeURlZmF1bHRUcmFuc2l0aW9uKHN0YXRlTm9kZSk7XG4gICAgICBmb3IgKGNvbnN0IHMgb2YgaGlzdG9yeURlZmF1bHRUcmFuc2l0aW9uLnRhcmdldCkge1xuICAgICAgICBzdGF0ZXNUb0VudGVyLmFkZChzKTtcbiAgICAgICAgaWYgKGhpc3RvcnlEZWZhdWx0VHJhbnNpdGlvbiA9PT0gc3RhdGVOb2RlLnBhcmVudD8uaW5pdGlhbCkge1xuICAgICAgICAgIHN0YXRlc0ZvckRlZmF1bHRFbnRyeS5hZGQoc3RhdGVOb2RlLnBhcmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkRGVzY2VuZGFudFN0YXRlc1RvRW50ZXIocywgaGlzdG9yeVZhbHVlLCBzdGF0ZXNGb3JEZWZhdWx0RW50cnksIHN0YXRlc1RvRW50ZXIpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBzIG9mIGhpc3RvcnlEZWZhdWx0VHJhbnNpdGlvbi50YXJnZXQpIHtcbiAgICAgICAgYWRkUHJvcGVyQW5jZXN0b3JTdGF0ZXNUb0VudGVyKHMsIHN0YXRlTm9kZS5wYXJlbnQsIHN0YXRlc1RvRW50ZXIsIGhpc3RvcnlWYWx1ZSwgc3RhdGVzRm9yRGVmYXVsdEVudHJ5KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHN0YXRlTm9kZS50eXBlID09PSAnY29tcG91bmQnKSB7XG4gICAgICBjb25zdCBbaW5pdGlhbFN0YXRlXSA9IHN0YXRlTm9kZS5pbml0aWFsLnRhcmdldDtcbiAgICAgIGlmICghaXNIaXN0b3J5Tm9kZShpbml0aWFsU3RhdGUpKSB7XG4gICAgICAgIHN0YXRlc1RvRW50ZXIuYWRkKGluaXRpYWxTdGF0ZSk7XG4gICAgICAgIHN0YXRlc0ZvckRlZmF1bHRFbnRyeS5hZGQoaW5pdGlhbFN0YXRlKTtcbiAgICAgIH1cbiAgICAgIGFkZERlc2NlbmRhbnRTdGF0ZXNUb0VudGVyKGluaXRpYWxTdGF0ZSwgaGlzdG9yeVZhbHVlLCBzdGF0ZXNGb3JEZWZhdWx0RW50cnksIHN0YXRlc1RvRW50ZXIpO1xuICAgICAgYWRkUHJvcGVyQW5jZXN0b3JTdGF0ZXNUb0VudGVyKGluaXRpYWxTdGF0ZSwgc3RhdGVOb2RlLCBzdGF0ZXNUb0VudGVyLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdGF0ZU5vZGUudHlwZSA9PT0gJ3BhcmFsbGVsJykge1xuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGdldENoaWxkcmVuKHN0YXRlTm9kZSkuZmlsdGVyKHNuID0+ICFpc0hpc3RvcnlOb2RlKHNuKSkpIHtcbiAgICAgICAgICBpZiAoIVsuLi5zdGF0ZXNUb0VudGVyXS5zb21lKHMgPT4gaXNEZXNjZW5kYW50KHMsIGNoaWxkKSkpIHtcbiAgICAgICAgICAgIGlmICghaXNIaXN0b3J5Tm9kZShjaGlsZCkpIHtcbiAgICAgICAgICAgICAgc3RhdGVzVG9FbnRlci5hZGQoY2hpbGQpO1xuICAgICAgICAgICAgICBzdGF0ZXNGb3JEZWZhdWx0RW50cnkuYWRkKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZERlc2NlbmRhbnRTdGF0ZXNUb0VudGVyKGNoaWxkLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSwgc3RhdGVzVG9FbnRlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhZGRBbmNlc3RvclN0YXRlc1RvRW50ZXIoc3RhdGVzVG9FbnRlciwgaGlzdG9yeVZhbHVlLCBzdGF0ZXNGb3JEZWZhdWx0RW50cnksIGFuY2VzdG9ycywgcmVlbnRyYW5jeURvbWFpbikge1xuICBmb3IgKGNvbnN0IGFuYyBvZiBhbmNlc3RvcnMpIHtcbiAgICBpZiAoIXJlZW50cmFuY3lEb21haW4gfHwgaXNEZXNjZW5kYW50KGFuYywgcmVlbnRyYW5jeURvbWFpbikpIHtcbiAgICAgIHN0YXRlc1RvRW50ZXIuYWRkKGFuYyk7XG4gICAgfVxuICAgIGlmIChhbmMudHlwZSA9PT0gJ3BhcmFsbGVsJykge1xuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBnZXRDaGlsZHJlbihhbmMpLmZpbHRlcihzbiA9PiAhaXNIaXN0b3J5Tm9kZShzbikpKSB7XG4gICAgICAgIGlmICghWy4uLnN0YXRlc1RvRW50ZXJdLnNvbWUocyA9PiBpc0Rlc2NlbmRhbnQocywgY2hpbGQpKSkge1xuICAgICAgICAgIHN0YXRlc1RvRW50ZXIuYWRkKGNoaWxkKTtcbiAgICAgICAgICBhZGREZXNjZW5kYW50U3RhdGVzVG9FbnRlcihjaGlsZCwgaGlzdG9yeVZhbHVlLCBzdGF0ZXNGb3JEZWZhdWx0RW50cnksIHN0YXRlc1RvRW50ZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhZGRQcm9wZXJBbmNlc3RvclN0YXRlc1RvRW50ZXIoc3RhdGVOb2RlLCB0b1N0YXRlTm9kZSwgc3RhdGVzVG9FbnRlciwgaGlzdG9yeVZhbHVlLCBzdGF0ZXNGb3JEZWZhdWx0RW50cnkpIHtcbiAgYWRkQW5jZXN0b3JTdGF0ZXNUb0VudGVyKHN0YXRlc1RvRW50ZXIsIGhpc3RvcnlWYWx1ZSwgc3RhdGVzRm9yRGVmYXVsdEVudHJ5LCBnZXRQcm9wZXJBbmNlc3RvcnMoc3RhdGVOb2RlLCB0b1N0YXRlTm9kZSkpO1xufVxuZnVuY3Rpb24gZXhpdFN0YXRlcyhjdXJyZW50U25hcHNob3QsIGV2ZW50LCBhY3RvclNjb3BlLCB0cmFuc2l0aW9ucywgbXV0U3RhdGVOb2RlU2V0LCBoaXN0b3J5VmFsdWUsIGludGVybmFsUXVldWUsIF9hY3Rpb25FeGVjdXRvcikge1xuICBsZXQgbmV4dFNuYXBzaG90ID0gY3VycmVudFNuYXBzaG90O1xuICBjb25zdCBzdGF0ZXNUb0V4aXQgPSBjb21wdXRlRXhpdFNldCh0cmFuc2l0aW9ucywgbXV0U3RhdGVOb2RlU2V0LCBoaXN0b3J5VmFsdWUpO1xuICBzdGF0ZXNUb0V4aXQuc29ydCgoYSwgYikgPT4gYi5vcmRlciAtIGEub3JkZXIpO1xuICBsZXQgY2hhbmdlZEhpc3Rvcnk7XG5cbiAgLy8gRnJvbSBTQ1hNTCBhbGdvcml0aG06IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9zY3htbC8jZXhpdFN0YXRlc1xuICBmb3IgKGNvbnN0IGV4aXRTdGF0ZU5vZGUgb2Ygc3RhdGVzVG9FeGl0KSB7XG4gICAgZm9yIChjb25zdCBoaXN0b3J5Tm9kZSBvZiBnZXRIaXN0b3J5Tm9kZXMoZXhpdFN0YXRlTm9kZSkpIHtcbiAgICAgIGxldCBwcmVkaWNhdGU7XG4gICAgICBpZiAoaGlzdG9yeU5vZGUuaGlzdG9yeSA9PT0gJ2RlZXAnKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IHNuID0+IGlzQXRvbWljU3RhdGVOb2RlKHNuKSAmJiBpc0Rlc2NlbmRhbnQoc24sIGV4aXRTdGF0ZU5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJlZGljYXRlID0gc24gPT4ge1xuICAgICAgICAgIHJldHVybiBzbi5wYXJlbnQgPT09IGV4aXRTdGF0ZU5vZGU7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjaGFuZ2VkSGlzdG9yeSA/Pz0ge1xuICAgICAgICAuLi5oaXN0b3J5VmFsdWVcbiAgICAgIH07XG4gICAgICBjaGFuZ2VkSGlzdG9yeVtoaXN0b3J5Tm9kZS5pZF0gPSBBcnJheS5mcm9tKG11dFN0YXRlTm9kZVNldCkuZmlsdGVyKHByZWRpY2F0ZSk7XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgcyBvZiBzdGF0ZXNUb0V4aXQpIHtcbiAgICBuZXh0U25hcHNob3QgPSByZXNvbHZlQWN0aW9uc0FuZENvbnRleHQobmV4dFNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSwgWy4uLnMuZXhpdCwgLi4ucy5pbnZva2UubWFwKGRlZiA9PiBzdG9wQ2hpbGQoZGVmLmlkKSldLCBpbnRlcm5hbFF1ZXVlLCB1bmRlZmluZWQpO1xuICAgIG11dFN0YXRlTm9kZVNldC5kZWxldGUocyk7XG4gIH1cbiAgcmV0dXJuIFtuZXh0U25hcHNob3QsIGNoYW5nZWRIaXN0b3J5IHx8IGhpc3RvcnlWYWx1ZV07XG59XG5mdW5jdGlvbiBnZXRBY3Rpb24obWFjaGluZSwgYWN0aW9uVHlwZSkge1xuICByZXR1cm4gbWFjaGluZS5pbXBsZW1lbnRhdGlvbnMuYWN0aW9uc1thY3Rpb25UeXBlXTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVBbmRFeGVjdXRlQWN0aW9uc1dpdGhDb250ZXh0KGN1cnJlbnRTbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUsIGFjdGlvbnMsIGV4dHJhLCByZXRyaWVzKSB7XG4gIGNvbnN0IHtcbiAgICBtYWNoaW5lXG4gIH0gPSBjdXJyZW50U25hcHNob3Q7XG4gIGxldCBpbnRlcm1lZGlhdGVTbmFwc2hvdCA9IGN1cnJlbnRTbmFwc2hvdDtcbiAgZm9yIChjb25zdCBhY3Rpb24gb2YgYWN0aW9ucykge1xuICAgIGNvbnN0IGlzSW5saW5lID0gdHlwZW9mIGFjdGlvbiA9PT0gJ2Z1bmN0aW9uJztcbiAgICBjb25zdCByZXNvbHZlZEFjdGlvbiA9IGlzSW5saW5lID8gYWN0aW9uIDpcbiAgICAvLyB0aGUgZXhpc3RpbmcgdHlwZSBvZiBgLmFjdGlvbnNgIGFzc3VtZXMgbm9uLW51bGxhYmxlIGBURXhwcmVzc2lvbkFjdGlvbmBcbiAgICAvLyBpdCdzIGZpbmUgdG8gY2FzdCB0aGlzIGhlcmUgdG8gZ2V0IGEgY29tbW9uIHR5cGUgYW5kIGxhY2sgb2YgZXJyb3JzIGluIHRoZSByZXN0IG9mIHRoZSBjb2RlXG4gICAgLy8gb3VyIGxvZ2ljIGJlbG93IG1ha2VzIHN1cmUgdGhhdCB3ZSBjYWxsIHRob3NlIDIgXCJ2YXJpYW50c1wiIGNvcnJlY3RseVxuXG4gICAgZ2V0QWN0aW9uKG1hY2hpbmUsIHR5cGVvZiBhY3Rpb24gPT09ICdzdHJpbmcnID8gYWN0aW9uIDogYWN0aW9uLnR5cGUpO1xuICAgIGNvbnN0IGFjdGlvbkFyZ3MgPSB7XG4gICAgICBjb250ZXh0OiBpbnRlcm1lZGlhdGVTbmFwc2hvdC5jb250ZXh0LFxuICAgICAgZXZlbnQsXG4gICAgICBzZWxmOiBhY3RvclNjb3BlLnNlbGYsXG4gICAgICBzeXN0ZW06IGFjdG9yU2NvcGUuc3lzdGVtXG4gICAgfTtcbiAgICBjb25zdCBhY3Rpb25QYXJhbXMgPSBpc0lubGluZSB8fCB0eXBlb2YgYWN0aW9uID09PSAnc3RyaW5nJyA/IHVuZGVmaW5lZCA6ICdwYXJhbXMnIGluIGFjdGlvbiA/IHR5cGVvZiBhY3Rpb24ucGFyYW1zID09PSAnZnVuY3Rpb24nID8gYWN0aW9uLnBhcmFtcyh7XG4gICAgICBjb250ZXh0OiBpbnRlcm1lZGlhdGVTbmFwc2hvdC5jb250ZXh0LFxuICAgICAgZXZlbnRcbiAgICB9KSA6IGFjdGlvbi5wYXJhbXMgOiB1bmRlZmluZWQ7XG4gICAgaWYgKCFyZXNvbHZlZEFjdGlvbiB8fCAhKCdyZXNvbHZlJyBpbiByZXNvbHZlZEFjdGlvbikpIHtcbiAgICAgIGFjdG9yU2NvcGUuYWN0aW9uRXhlY3V0b3Ioe1xuICAgICAgICB0eXBlOiB0eXBlb2YgYWN0aW9uID09PSAnc3RyaW5nJyA/IGFjdGlvbiA6IHR5cGVvZiBhY3Rpb24gPT09ICdvYmplY3QnID8gYWN0aW9uLnR5cGUgOiBhY3Rpb24ubmFtZSB8fCAnKGFub255bW91cyknLFxuICAgICAgICBpbmZvOiBhY3Rpb25BcmdzLFxuICAgICAgICBwYXJhbXM6IGFjdGlvblBhcmFtcyxcbiAgICAgICAgZXhlYzogcmVzb2x2ZWRBY3Rpb25cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGJ1aWx0aW5BY3Rpb24gPSByZXNvbHZlZEFjdGlvbjtcbiAgICBjb25zdCBbbmV4dFN0YXRlLCBwYXJhbXMsIGFjdGlvbnNdID0gYnVpbHRpbkFjdGlvbi5yZXNvbHZlKGFjdG9yU2NvcGUsIGludGVybWVkaWF0ZVNuYXBzaG90LCBhY3Rpb25BcmdzLCBhY3Rpb25QYXJhbXMsIHJlc29sdmVkQWN0aW9uLFxuICAgIC8vIHRoaXMgaG9sZHMgYWxsIHBhcmFtc1xuICAgIGV4dHJhKTtcbiAgICBpbnRlcm1lZGlhdGVTbmFwc2hvdCA9IG5leHRTdGF0ZTtcbiAgICBpZiAoJ3JldHJ5UmVzb2x2ZScgaW4gYnVpbHRpbkFjdGlvbikge1xuICAgICAgcmV0cmllcz8ucHVzaChbYnVpbHRpbkFjdGlvbiwgcGFyYW1zXSk7XG4gICAgfVxuICAgIGlmICgnZXhlY3V0ZScgaW4gYnVpbHRpbkFjdGlvbikge1xuICAgICAgYWN0b3JTY29wZS5hY3Rpb25FeGVjdXRvcih7XG4gICAgICAgIHR5cGU6IGJ1aWx0aW5BY3Rpb24udHlwZSxcbiAgICAgICAgaW5mbzogYWN0aW9uQXJncyxcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBleGVjOiBidWlsdGluQWN0aW9uLmV4ZWN1dGUuYmluZChudWxsLCBhY3RvclNjb3BlLCBwYXJhbXMpXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGFjdGlvbnMpIHtcbiAgICAgIGludGVybWVkaWF0ZVNuYXBzaG90ID0gcmVzb2x2ZUFuZEV4ZWN1dGVBY3Rpb25zV2l0aENvbnRleHQoaW50ZXJtZWRpYXRlU25hcHNob3QsIGV2ZW50LCBhY3RvclNjb3BlLCBhY3Rpb25zLCBleHRyYSwgcmV0cmllcyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbnRlcm1lZGlhdGVTbmFwc2hvdDtcbn1cbmZ1bmN0aW9uIHJlc29sdmVBY3Rpb25zQW5kQ29udGV4dChjdXJyZW50U25hcHNob3QsIGV2ZW50LCBhY3RvclNjb3BlLCBhY3Rpb25zLCBpbnRlcm5hbFF1ZXVlLCBkZWZlcnJlZEFjdG9ySWRzKSB7XG4gIGNvbnN0IHJldHJpZXMgPSBkZWZlcnJlZEFjdG9ySWRzID8gW10gOiB1bmRlZmluZWQ7XG4gIGNvbnN0IG5leHRTdGF0ZSA9IHJlc29sdmVBbmRFeGVjdXRlQWN0aW9uc1dpdGhDb250ZXh0KGN1cnJlbnRTbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUsIGFjdGlvbnMsIHtcbiAgICBpbnRlcm5hbFF1ZXVlLFxuICAgIGRlZmVycmVkQWN0b3JJZHNcbiAgfSwgcmV0cmllcyk7XG4gIHJldHJpZXM/LmZvckVhY2goKFtidWlsdGluQWN0aW9uLCBwYXJhbXNdKSA9PiB7XG4gICAgYnVpbHRpbkFjdGlvbi5yZXRyeVJlc29sdmUoYWN0b3JTY29wZSwgbmV4dFN0YXRlLCBwYXJhbXMpO1xuICB9KTtcbiAgcmV0dXJuIG5leHRTdGF0ZTtcbn1cbmZ1bmN0aW9uIG1hY3Jvc3RlcChzbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUsIGludGVybmFsUXVldWUpIHtcbiAgaWYgKGV2ZW50LnR5cGUgPT09IFdJTERDQVJEKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBBbiBldmVudCBjYW5ub3QgaGF2ZSB0aGUgd2lsZGNhcmQgdHlwZSAoJyR7V0lMRENBUkR9JylgKTtcbiAgfVxuICBsZXQgbmV4dFNuYXBzaG90ID0gc25hcHNob3Q7XG4gIGNvbnN0IG1pY3Jvc3RhdGVzID0gW107XG4gIGZ1bmN0aW9uIGFkZE1pY3Jvc3RhdGUobWljcm9zdGF0ZSwgZXZlbnQsIHRyYW5zaXRpb25zKSB7XG4gICAgYWN0b3JTY29wZS5zeXN0ZW0uX3NlbmRJbnNwZWN0aW9uRXZlbnQoe1xuICAgICAgdHlwZTogJ0B4c3RhdGUubWljcm9zdGVwJyxcbiAgICAgIGFjdG9yUmVmOiBhY3RvclNjb3BlLnNlbGYsXG4gICAgICBldmVudCxcbiAgICAgIHNuYXBzaG90OiBtaWNyb3N0YXRlLFxuICAgICAgX3RyYW5zaXRpb25zOiB0cmFuc2l0aW9uc1xuICAgIH0pO1xuICAgIG1pY3Jvc3RhdGVzLnB1c2gobWljcm9zdGF0ZSk7XG4gIH1cblxuICAvLyBIYW5kbGUgc3RvcCBldmVudFxuICBpZiAoZXZlbnQudHlwZSA9PT0gWFNUQVRFX1NUT1ApIHtcbiAgICBuZXh0U25hcHNob3QgPSBjbG9uZU1hY2hpbmVTbmFwc2hvdChzdG9wQ2hpbGRyZW4obmV4dFNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSksIHtcbiAgICAgIHN0YXR1czogJ3N0b3BwZWQnXG4gICAgfSk7XG4gICAgYWRkTWljcm9zdGF0ZShuZXh0U25hcHNob3QsIGV2ZW50LCBbXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNuYXBzaG90OiBuZXh0U25hcHNob3QsXG4gICAgICBtaWNyb3N0YXRlc1xuICAgIH07XG4gIH1cbiAgbGV0IG5leHRFdmVudCA9IGV2ZW50O1xuXG4gIC8vIEFzc3VtZSB0aGUgc3RhdGUgaXMgYXQgcmVzdCAobm8gcmFpc2VkIGV2ZW50cylcbiAgLy8gRGV0ZXJtaW5lIHRoZSBuZXh0IHN0YXRlIGJhc2VkIG9uIHRoZSBuZXh0IG1pY3Jvc3RlcFxuICBpZiAobmV4dEV2ZW50LnR5cGUgIT09IFhTVEFURV9JTklUKSB7XG4gICAgY29uc3QgY3VycmVudEV2ZW50ID0gbmV4dEV2ZW50O1xuICAgIGNvbnN0IGlzRXJyID0gaXNFcnJvckFjdG9yRXZlbnQoY3VycmVudEV2ZW50KTtcbiAgICBjb25zdCB0cmFuc2l0aW9ucyA9IHNlbGVjdFRyYW5zaXRpb25zKGN1cnJlbnRFdmVudCwgbmV4dFNuYXBzaG90KTtcbiAgICBpZiAoaXNFcnIgJiYgIXRyYW5zaXRpb25zLmxlbmd0aCkge1xuICAgICAgLy8gVE9ETzogd2Ugc2hvdWxkIGxpa2VseSBvbmx5IGFsbG93IHRyYW5zaXRpb25zIHNlbGVjdGVkIGJ5IHZlcnkgZXhwbGljaXQgZGVzY3JpcHRvcnNcbiAgICAgIC8vIGAqYCBzaG91bGRuJ3QgYmUgbWF0Y2hlZCwgbGlrZWx5IGB4c3RhdGUuZXJyb3IuKmAgc2hvdWxkbid0IGJlIGVpdGhlclxuICAgICAgLy8gc2ltaWxhcmx5IGB4c3RhdGUuZXJyb3IuYWN0b3IuKmAgYW5kIGB4c3RhdGUuZXJyb3IuYWN0b3IudG9kby4qYCBoYXZlIHRvIGJlIGNvbnNpZGVyZWQgdG9vXG4gICAgICBuZXh0U25hcHNob3QgPSBjbG9uZU1hY2hpbmVTbmFwc2hvdChzbmFwc2hvdCwge1xuICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgIGVycm9yOiBjdXJyZW50RXZlbnQuZXJyb3JcbiAgICAgIH0pO1xuICAgICAgYWRkTWljcm9zdGF0ZShuZXh0U25hcHNob3QsIGN1cnJlbnRFdmVudCwgW10pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc25hcHNob3Q6IG5leHRTbmFwc2hvdCxcbiAgICAgICAgbWljcm9zdGF0ZXNcbiAgICAgIH07XG4gICAgfVxuICAgIG5leHRTbmFwc2hvdCA9IG1pY3Jvc3RlcCh0cmFuc2l0aW9ucywgc25hcHNob3QsIGFjdG9yU2NvcGUsIG5leHRFdmVudCwgZmFsc2UsXG4gICAgLy8gaXNJbml0aWFsXG4gICAgaW50ZXJuYWxRdWV1ZSk7XG4gICAgYWRkTWljcm9zdGF0ZShuZXh0U25hcHNob3QsIGN1cnJlbnRFdmVudCwgdHJhbnNpdGlvbnMpO1xuICB9XG4gIGxldCBzaG91bGRTZWxlY3RFdmVudGxlc3NUcmFuc2l0aW9ucyA9IHRydWU7XG4gIHdoaWxlIChuZXh0U25hcHNob3Quc3RhdHVzID09PSAnYWN0aXZlJykge1xuICAgIGxldCBlbmFibGVkVHJhbnNpdGlvbnMgPSBzaG91bGRTZWxlY3RFdmVudGxlc3NUcmFuc2l0aW9ucyA/IHNlbGVjdEV2ZW50bGVzc1RyYW5zaXRpb25zKG5leHRTbmFwc2hvdCwgbmV4dEV2ZW50KSA6IFtdO1xuXG4gICAgLy8gZXZlbnRsZXNzIHRyYW5zaXRpb25zIHNob3VsZCBhbHdheXMgYmUgc2VsZWN0ZWQgYWZ0ZXIgc2VsZWN0aW5nICpyZWd1bGFyKiB0cmFuc2l0aW9uc1xuICAgIC8vIGJ5IGFzc2lnbmluZyBgdW5kZWZpbmVkYCB0byBgcHJldmlvdXNTdGF0ZWAgd2UgZW5zdXJlIHRoYXQgYHNob3VsZFNlbGVjdEV2ZW50bGVzc1RyYW5zaXRpb25zYCBnZXRzIGFsd2F5cyBjb21wdXRlZCB0byB0cnVlIGluIHN1Y2ggYSBjYXNlXG4gICAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IGVuYWJsZWRUcmFuc2l0aW9ucy5sZW5ndGggPyBuZXh0U25hcHNob3QgOiB1bmRlZmluZWQ7XG4gICAgaWYgKCFlbmFibGVkVHJhbnNpdGlvbnMubGVuZ3RoKSB7XG4gICAgICBpZiAoIWludGVybmFsUXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbmV4dEV2ZW50ID0gaW50ZXJuYWxRdWV1ZS5zaGlmdCgpO1xuICAgICAgZW5hYmxlZFRyYW5zaXRpb25zID0gc2VsZWN0VHJhbnNpdGlvbnMobmV4dEV2ZW50LCBuZXh0U25hcHNob3QpO1xuICAgIH1cbiAgICBuZXh0U25hcHNob3QgPSBtaWNyb3N0ZXAoZW5hYmxlZFRyYW5zaXRpb25zLCBuZXh0U25hcHNob3QsIGFjdG9yU2NvcGUsIG5leHRFdmVudCwgZmFsc2UsIGludGVybmFsUXVldWUpO1xuICAgIHNob3VsZFNlbGVjdEV2ZW50bGVzc1RyYW5zaXRpb25zID0gbmV4dFNuYXBzaG90ICE9PSBwcmV2aW91c1N0YXRlO1xuICAgIGFkZE1pY3Jvc3RhdGUobmV4dFNuYXBzaG90LCBuZXh0RXZlbnQsIGVuYWJsZWRUcmFuc2l0aW9ucyk7XG4gIH1cbiAgaWYgKG5leHRTbmFwc2hvdC5zdGF0dXMgIT09ICdhY3RpdmUnKSB7XG4gICAgc3RvcENoaWxkcmVuKG5leHRTbmFwc2hvdCwgbmV4dEV2ZW50LCBhY3RvclNjb3BlKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNuYXBzaG90OiBuZXh0U25hcHNob3QsXG4gICAgbWljcm9zdGF0ZXNcbiAgfTtcbn1cbmZ1bmN0aW9uIHN0b3BDaGlsZHJlbihuZXh0U3RhdGUsIGV2ZW50LCBhY3RvclNjb3BlKSB7XG4gIHJldHVybiByZXNvbHZlQWN0aW9uc0FuZENvbnRleHQobmV4dFN0YXRlLCBldmVudCwgYWN0b3JTY29wZSwgT2JqZWN0LnZhbHVlcyhuZXh0U3RhdGUuY2hpbGRyZW4pLm1hcChjaGlsZCA9PiBzdG9wQ2hpbGQoY2hpbGQpKSwgW10sIHVuZGVmaW5lZCk7XG59XG5mdW5jdGlvbiBzZWxlY3RUcmFuc2l0aW9ucyhldmVudCwgbmV4dFN0YXRlKSB7XG4gIHJldHVybiBuZXh0U3RhdGUubWFjaGluZS5nZXRUcmFuc2l0aW9uRGF0YShuZXh0U3RhdGUsIGV2ZW50KTtcbn1cbmZ1bmN0aW9uIHNlbGVjdEV2ZW50bGVzc1RyYW5zaXRpb25zKG5leHRTdGF0ZSwgZXZlbnQpIHtcbiAgY29uc3QgZW5hYmxlZFRyYW5zaXRpb25TZXQgPSBuZXcgU2V0KCk7XG4gIGNvbnN0IGF0b21pY1N0YXRlcyA9IG5leHRTdGF0ZS5fbm9kZXMuZmlsdGVyKGlzQXRvbWljU3RhdGVOb2RlKTtcbiAgZm9yIChjb25zdCBzdGF0ZU5vZGUgb2YgYXRvbWljU3RhdGVzKSB7XG4gICAgbG9vcDogZm9yIChjb25zdCBzIG9mIFtzdGF0ZU5vZGVdLmNvbmNhdChnZXRQcm9wZXJBbmNlc3RvcnMoc3RhdGVOb2RlLCB1bmRlZmluZWQpKSkge1xuICAgICAgaWYgKCFzLmFsd2F5cykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgdHJhbnNpdGlvbiBvZiBzLmFsd2F5cykge1xuICAgICAgICBpZiAodHJhbnNpdGlvbi5ndWFyZCA9PT0gdW5kZWZpbmVkIHx8IGV2YWx1YXRlR3VhcmQodHJhbnNpdGlvbi5ndWFyZCwgbmV4dFN0YXRlLmNvbnRleHQsIGV2ZW50LCBuZXh0U3RhdGUpKSB7XG4gICAgICAgICAgZW5hYmxlZFRyYW5zaXRpb25TZXQuYWRkKHRyYW5zaXRpb24pO1xuICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlbW92ZUNvbmZsaWN0aW5nVHJhbnNpdGlvbnMoQXJyYXkuZnJvbShlbmFibGVkVHJhbnNpdGlvblNldCksIG5ldyBTZXQobmV4dFN0YXRlLl9ub2RlcyksIG5leHRTdGF0ZS5oaXN0b3J5VmFsdWUpO1xufVxuXG4vKipcbiAqIFJlc29sdmVzIGEgcGFydGlhbCBzdGF0ZSB2YWx1ZSB3aXRoIGl0cyBmdWxsIHJlcHJlc2VudGF0aW9uIGluIHRoZSBzdGF0ZVxuICogbm9kZSdzIG1hY2hpbmUuXG4gKlxuICogQHBhcmFtIHN0YXRlVmFsdWUgVGhlIHBhcnRpYWwgc3RhdGUgdmFsdWUgdG8gcmVzb2x2ZS5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVN0YXRlVmFsdWUocm9vdE5vZGUsIHN0YXRlVmFsdWUpIHtcbiAgY29uc3QgYWxsU3RhdGVOb2RlcyA9IGdldEFsbFN0YXRlTm9kZXMoZ2V0U3RhdGVOb2Rlcyhyb290Tm9kZSwgc3RhdGVWYWx1ZSkpO1xuICByZXR1cm4gZ2V0U3RhdGVWYWx1ZShyb290Tm9kZSwgWy4uLmFsbFN0YXRlTm9kZXNdKTtcbn1cblxuZnVuY3Rpb24gaXNNYWNoaW5lU25hcHNob3QodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAnbWFjaGluZScgaW4gdmFsdWUgJiYgJ3ZhbHVlJyBpbiB2YWx1ZTtcbn1cbmNvbnN0IG1hY2hpbmVTbmFwc2hvdE1hdGNoZXMgPSBmdW5jdGlvbiBtYXRjaGVzKHRlc3RWYWx1ZSkge1xuICByZXR1cm4gbWF0Y2hlc1N0YXRlKHRlc3RWYWx1ZSwgdGhpcy52YWx1ZSk7XG59O1xuY29uc3QgbWFjaGluZVNuYXBzaG90SGFzVGFnID0gZnVuY3Rpb24gaGFzVGFnKHRhZykge1xuICByZXR1cm4gdGhpcy50YWdzLmhhcyh0YWcpO1xufTtcbmNvbnN0IG1hY2hpbmVTbmFwc2hvdENhbiA9IGZ1bmN0aW9uIGNhbihldmVudCkge1xuICBpZiAoIXRoaXMubWFjaGluZSkge1xuICAgIGNvbnNvbGUud2Fybihgc3RhdGUuY2FuKC4uLikgdXNlZCBvdXRzaWRlIG9mIGEgbWFjaGluZS1jcmVhdGVkIFN0YXRlIG9iamVjdDsgdGhpcyB3aWxsIGFsd2F5cyByZXR1cm4gZmFsc2UuYCk7XG4gIH1cbiAgY29uc3QgdHJhbnNpdGlvbkRhdGEgPSB0aGlzLm1hY2hpbmUuZ2V0VHJhbnNpdGlvbkRhdGEodGhpcywgZXZlbnQpO1xuICByZXR1cm4gISF0cmFuc2l0aW9uRGF0YT8ubGVuZ3RoICYmXG4gIC8vIENoZWNrIHRoYXQgYXQgbGVhc3Qgb25lIHRyYW5zaXRpb24gaXMgbm90IGZvcmJpZGRlblxuICB0cmFuc2l0aW9uRGF0YS5zb21lKHQgPT4gdC50YXJnZXQgIT09IHVuZGVmaW5lZCB8fCB0LmFjdGlvbnMubGVuZ3RoKTtcbn07XG5jb25zdCBtYWNoaW5lU25hcHNob3RUb0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gIGNvbnN0IHtcbiAgICBfbm9kZXM6IG5vZGVzLFxuICAgIHRhZ3MsXG4gICAgbWFjaGluZSxcbiAgICBnZXRNZXRhLFxuICAgIHRvSlNPTixcbiAgICBjYW4sXG4gICAgaGFzVGFnLFxuICAgIG1hdGNoZXMsXG4gICAgLi4uanNvblZhbHVlc1xuICB9ID0gdGhpcztcbiAgcmV0dXJuIHtcbiAgICAuLi5qc29uVmFsdWVzLFxuICAgIHRhZ3M6IEFycmF5LmZyb20odGFncylcbiAgfTtcbn07XG5jb25zdCBtYWNoaW5lU25hcHNob3RHZXRNZXRhID0gZnVuY3Rpb24gZ2V0TWV0YSgpIHtcbiAgcmV0dXJuIHRoaXMuX25vZGVzLnJlZHVjZSgoYWNjLCBzdGF0ZU5vZGUpID0+IHtcbiAgICBpZiAoc3RhdGVOb2RlLm1ldGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYWNjW3N0YXRlTm9kZS5pZF0gPSBzdGF0ZU5vZGUubWV0YTtcbiAgICB9XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xufTtcbmZ1bmN0aW9uIGNyZWF0ZU1hY2hpbmVTbmFwc2hvdChjb25maWcsIG1hY2hpbmUpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGF0dXM6IGNvbmZpZy5zdGF0dXMsXG4gICAgb3V0cHV0OiBjb25maWcub3V0cHV0LFxuICAgIGVycm9yOiBjb25maWcuZXJyb3IsXG4gICAgbWFjaGluZSxcbiAgICBjb250ZXh0OiBjb25maWcuY29udGV4dCxcbiAgICBfbm9kZXM6IGNvbmZpZy5fbm9kZXMsXG4gICAgdmFsdWU6IGdldFN0YXRlVmFsdWUobWFjaGluZS5yb290LCBjb25maWcuX25vZGVzKSxcbiAgICB0YWdzOiBuZXcgU2V0KGNvbmZpZy5fbm9kZXMuZmxhdE1hcChzbiA9PiBzbi50YWdzKSksXG4gICAgY2hpbGRyZW46IGNvbmZpZy5jaGlsZHJlbixcbiAgICBoaXN0b3J5VmFsdWU6IGNvbmZpZy5oaXN0b3J5VmFsdWUgfHwge30sXG4gICAgbWF0Y2hlczogbWFjaGluZVNuYXBzaG90TWF0Y2hlcyxcbiAgICBoYXNUYWc6IG1hY2hpbmVTbmFwc2hvdEhhc1RhZyxcbiAgICBjYW46IG1hY2hpbmVTbmFwc2hvdENhbixcbiAgICBnZXRNZXRhOiBtYWNoaW5lU25hcHNob3RHZXRNZXRhLFxuICAgIHRvSlNPTjogbWFjaGluZVNuYXBzaG90VG9KU09OXG4gIH07XG59XG5mdW5jdGlvbiBjbG9uZU1hY2hpbmVTbmFwc2hvdChzbmFwc2hvdCwgY29uZmlnID0ge30pIHtcbiAgcmV0dXJuIGNyZWF0ZU1hY2hpbmVTbmFwc2hvdCh7XG4gICAgLi4uc25hcHNob3QsXG4gICAgLi4uY29uZmlnXG4gIH0sIHNuYXBzaG90Lm1hY2hpbmUpO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplSGlzdG9yeVZhbHVlKGhpc3RvcnlWYWx1ZSkge1xuICBpZiAodHlwZW9mIGhpc3RvcnlWYWx1ZSAhPT0gJ29iamVjdCcgfHwgaGlzdG9yeVZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBoaXN0b3J5VmFsdWUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGhpc3RvcnlWYWx1ZVtrZXldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZS5tYXAoaXRlbSA9PiAoe1xuICAgICAgICBpZDogaXRlbS5pZFxuICAgICAgfSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0UGVyc2lzdGVkU25hcHNob3Qoc25hcHNob3QsIG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIF9ub2Rlczogbm9kZXMsXG4gICAgdGFncyxcbiAgICBtYWNoaW5lLFxuICAgIGNoaWxkcmVuLFxuICAgIGNvbnRleHQsXG4gICAgY2FuLFxuICAgIGhhc1RhZyxcbiAgICBtYXRjaGVzLFxuICAgIGdldE1ldGEsXG4gICAgdG9KU09OLFxuICAgIC4uLmpzb25WYWx1ZXNcbiAgfSA9IHNuYXBzaG90O1xuICBjb25zdCBjaGlsZHJlbkpzb24gPSB7fTtcbiAgZm9yIChjb25zdCBpZCBpbiBjaGlsZHJlbikge1xuICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baWRdO1xuICAgIGlmICh0eXBlb2YgY2hpbGQuc3JjICE9PSAnc3RyaW5nJyAmJiAoIW9wdGlvbnMgfHwgISgnX191bnNhZmVBbGxvd0lubGluZUFjdG9ycycgaW4gb3B0aW9ucykpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuIGlubGluZSBjaGlsZCBhY3RvciBjYW5ub3QgYmUgcGVyc2lzdGVkLicpO1xuICAgIH1cbiAgICBjaGlsZHJlbkpzb25baWRdID0ge1xuICAgICAgc25hcHNob3Q6IGNoaWxkLmdldFBlcnNpc3RlZFNuYXBzaG90KG9wdGlvbnMpLFxuICAgICAgc3JjOiBjaGlsZC5zcmMsXG4gICAgICBzeXN0ZW1JZDogY2hpbGQuX3N5c3RlbUlkLFxuICAgICAgc3luY1NuYXBzaG90OiBjaGlsZC5fc3luY1NuYXBzaG90XG4gICAgfTtcbiAgfVxuICBjb25zdCBwZXJzaXN0ZWQgPSB7XG4gICAgLi4uanNvblZhbHVlcyxcbiAgICBjb250ZXh0OiBwZXJzaXN0Q29udGV4dChjb250ZXh0KSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW5Kc29uLFxuICAgIGhpc3RvcnlWYWx1ZTogc2VyaWFsaXplSGlzdG9yeVZhbHVlKGpzb25WYWx1ZXMuaGlzdG9yeVZhbHVlKVxuICB9O1xuICByZXR1cm4gcGVyc2lzdGVkO1xufVxuZnVuY3Rpb24gcGVyc2lzdENvbnRleHQoY29udGV4dFBhcnQpIHtcbiAgbGV0IGNvcHk7XG4gIGZvciAoY29uc3Qga2V5IGluIGNvbnRleHRQYXJ0KSB7XG4gICAgY29uc3QgdmFsdWUgPSBjb250ZXh0UGFydFtrZXldO1xuICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoJ3Nlc3Npb25JZCcgaW4gdmFsdWUgJiYgJ3NlbmQnIGluIHZhbHVlICYmICdyZWYnIGluIHZhbHVlKSB7XG4gICAgICAgIGNvcHkgPz89IEFycmF5LmlzQXJyYXkoY29udGV4dFBhcnQpID8gY29udGV4dFBhcnQuc2xpY2UoKSA6IHtcbiAgICAgICAgICAuLi5jb250ZXh0UGFydFxuICAgICAgICB9O1xuICAgICAgICBjb3B5W2tleV0gPSB7XG4gICAgICAgICAgeHN0YXRlJCR0eXBlOiAkJEFDVE9SX1RZUEUsXG4gICAgICAgICAgaWQ6IHZhbHVlLmlkXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBwZXJzaXN0Q29udGV4dCh2YWx1ZSk7XG4gICAgICAgIGlmIChyZXN1bHQgIT09IHZhbHVlKSB7XG4gICAgICAgICAgY29weSA/Pz0gQXJyYXkuaXNBcnJheShjb250ZXh0UGFydCkgPyBjb250ZXh0UGFydC5zbGljZSgpIDoge1xuICAgICAgICAgICAgLi4uY29udGV4dFBhcnRcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvcHlba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29weSA/PyBjb250ZXh0UGFydDtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVJhaXNlKF8sIHNuYXBzaG90LCBhcmdzLCBhY3Rpb25QYXJhbXMsIHtcbiAgZXZlbnQ6IGV2ZW50T3JFeHByLFxuICBpZCxcbiAgZGVsYXlcbn0sIHtcbiAgaW50ZXJuYWxRdWV1ZVxufSkge1xuICBjb25zdCBkZWxheXNNYXAgPSBzbmFwc2hvdC5tYWNoaW5lLmltcGxlbWVudGF0aW9ucy5kZWxheXM7XG4gIGlmICh0eXBlb2YgZXZlbnRPckV4cHIgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtdGVtcGxhdGUtZXhwcmVzc2lvbnNcbiAgICBgT25seSBldmVudCBvYmplY3RzIG1heSBiZSB1c2VkIHdpdGggcmFpc2U7IHVzZSByYWlzZSh7IHR5cGU6IFwiJHtldmVudE9yRXhwcn1cIiB9KSBpbnN0ZWFkYCk7XG4gIH1cbiAgY29uc3QgcmVzb2x2ZWRFdmVudCA9IHR5cGVvZiBldmVudE9yRXhwciA9PT0gJ2Z1bmN0aW9uJyA/IGV2ZW50T3JFeHByKGFyZ3MsIGFjdGlvblBhcmFtcykgOiBldmVudE9yRXhwcjtcbiAgbGV0IHJlc29sdmVkRGVsYXk7XG4gIGlmICh0eXBlb2YgZGVsYXkgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgY29uZmlnRGVsYXkgPSBkZWxheXNNYXAgJiYgZGVsYXlzTWFwW2RlbGF5XTtcbiAgICByZXNvbHZlZERlbGF5ID0gdHlwZW9mIGNvbmZpZ0RlbGF5ID09PSAnZnVuY3Rpb24nID8gY29uZmlnRGVsYXkoYXJncywgYWN0aW9uUGFyYW1zKSA6IGNvbmZpZ0RlbGF5O1xuICB9IGVsc2Uge1xuICAgIHJlc29sdmVkRGVsYXkgPSB0eXBlb2YgZGVsYXkgPT09ICdmdW5jdGlvbicgPyBkZWxheShhcmdzLCBhY3Rpb25QYXJhbXMpIDogZGVsYXk7XG4gIH1cbiAgaWYgKHR5cGVvZiByZXNvbHZlZERlbGF5ICE9PSAnbnVtYmVyJykge1xuICAgIGludGVybmFsUXVldWUucHVzaChyZXNvbHZlZEV2ZW50KTtcbiAgfVxuICByZXR1cm4gW3NuYXBzaG90LCB7XG4gICAgZXZlbnQ6IHJlc29sdmVkRXZlbnQsXG4gICAgaWQsXG4gICAgZGVsYXk6IHJlc29sdmVkRGVsYXlcbiAgfSwgdW5kZWZpbmVkXTtcbn1cbmZ1bmN0aW9uIGV4ZWN1dGVSYWlzZShhY3RvclNjb3BlLCBwYXJhbXMpIHtcbiAgY29uc3Qge1xuICAgIGV2ZW50LFxuICAgIGRlbGF5LFxuICAgIGlkXG4gIH0gPSBwYXJhbXM7XG4gIGlmICh0eXBlb2YgZGVsYXkgPT09ICdudW1iZXInKSB7XG4gICAgYWN0b3JTY29wZS5kZWZlcigoKSA9PiB7XG4gICAgICBjb25zdCBzZWxmID0gYWN0b3JTY29wZS5zZWxmO1xuICAgICAgYWN0b3JTY29wZS5zeXN0ZW0uc2NoZWR1bGVyLnNjaGVkdWxlKHNlbGYsIHNlbGYsIGV2ZW50LCBkZWxheSwgaWQpO1xuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxufVxuLyoqXG4gKiBSYWlzZXMgYW4gZXZlbnQuIFRoaXMgcGxhY2VzIHRoZSBldmVudCBpbiB0aGUgaW50ZXJuYWwgZXZlbnQgcXVldWUsIHNvIHRoYXRcbiAqIHRoZSBldmVudCBpcyBpbW1lZGlhdGVseSBjb25zdW1lZCBieSB0aGUgbWFjaGluZSBpbiB0aGUgY3VycmVudCBzdGVwLlxuICpcbiAqIEBwYXJhbSBldmVudFR5cGUgVGhlIGV2ZW50IHRvIHJhaXNlLlxuICovXG5mdW5jdGlvbiByYWlzZShldmVudE9yRXhwciwgb3B0aW9ucykge1xuICBpZiAoZXhlY3V0aW5nQ3VzdG9tQWN0aW9uKSB7XG4gICAgY29uc29sZS53YXJuKCdDdXN0b20gYWN0aW9ucyBzaG91bGQgbm90IGNhbGwgYHJhaXNlKClgIGRpcmVjdGx5LCBhcyBpdCBpcyBub3QgaW1wZXJhdGl2ZS4gU2VlIGh0dHBzOi8vc3RhdGVseS5haS9kb2NzL2FjdGlvbnMjYnVpbHQtaW4tYWN0aW9ucyBmb3IgbW9yZSBkZXRhaWxzLicpO1xuICB9XG4gIGZ1bmN0aW9uIHJhaXNlKF9hcmdzLCBfcGFyYW1zKSB7XG4gICAge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIGlzbid0IHN1cHBvc2VkIHRvIGJlIGNhbGxlZGApO1xuICAgIH1cbiAgfVxuICByYWlzZS50eXBlID0gJ3hzdGF0ZS5yYWlzZSc7XG4gIHJhaXNlLmV2ZW50ID0gZXZlbnRPckV4cHI7XG4gIHJhaXNlLmlkID0gb3B0aW9ucz8uaWQ7XG4gIHJhaXNlLmRlbGF5ID0gb3B0aW9ucz8uZGVsYXk7XG4gIHJhaXNlLnJlc29sdmUgPSByZXNvbHZlUmFpc2U7XG4gIHJhaXNlLmV4ZWN1dGUgPSBleGVjdXRlUmFpc2U7XG4gIHJldHVybiByYWlzZTtcbn1cblxuZXhwb3J0IHsgJCRBQ1RPUl9UWVBFIGFzICQsIEFjdG9yIGFzIEEsIGdldENhbmRpZGF0ZXMgYXMgQiwgcmVzb2x2ZVN0YXRlVmFsdWUgYXMgQywgZ2V0QWxsU3RhdGVOb2RlcyBhcyBELCBjcmVhdGVNYWNoaW5lU25hcHNob3QgYXMgRSwgaXNJbkZpbmFsU3RhdGUgYXMgRiwgbWFjcm9zdGVwIGFzIEcsIHRyYW5zaXRpb25Ob2RlIGFzIEgsIHJlc29sdmVBY3Rpb25zQW5kQ29udGV4dCBhcyBJLCBjcmVhdGVJbml0RXZlbnQgYXMgSiwgbWljcm9zdGVwIGFzIEssIGdldEluaXRpYWxTdGF0ZU5vZGVzIGFzIEwsIHRvU3RhdGVQYXRoIGFzIE0sIE5VTExfRVZFTlQgYXMgTiwgaXNTdGF0ZUlkIGFzIE8sIGdldFN0YXRlTm9kZUJ5UGF0aCBhcyBQLCBnZXRQZXJzaXN0ZWRTbmFwc2hvdCBhcyBRLCByZXNvbHZlUmVmZXJlbmNlZEFjdG9yIGFzIFIsIFNUQVRFX0RFTElNSVRFUiBhcyBTLCBleGVjdXRpbmdDdXN0b21BY3Rpb24gYXMgVCwgWFNUQVRFX0VSUk9SIGFzIFUsIGNyZWF0ZUVycm9yQWN0b3JFdmVudCBhcyBWLCBQcm9jZXNzaW5nU3RhdHVzIGFzIFcsIFhTVEFURV9TVE9QIGFzIFgsIGNsb25lTWFjaGluZVNuYXBzaG90IGFzIFksIGFuZCBhcyBhLCBpc01hY2hpbmVTbmFwc2hvdCBhcyBiLCBjcmVhdGVBY3RvciBhcyBjLCBnZXRBbGxPd25FdmVudERlc2NyaXB0b3JzIGFzIGQsIHRvT2JzZXJ2ZXIgYXMgZSwgY2FuY2VsIGFzIGYsIGdldFN0YXRlTm9kZXMgYXMgZywgc3Bhd25DaGlsZCBhcyBoLCBpbnRlcnByZXQgYXMgaSwgc3RvcCBhcyBqLCBzdG9wQ2hpbGQgYXMgaywgbWFwVmFsdWVzIGFzIGwsIG1hdGNoZXNTdGF0ZSBhcyBtLCBub3QgYXMgbiwgb3IgYXMgbywgcGF0aFRvU3RhdGVWYWx1ZSBhcyBwLCBmb3JtYXRUcmFuc2l0aW9ucyBhcyBxLCByYWlzZSBhcyByLCBzdGF0ZUluIGFzIHMsIHRvQXJyYXkgYXMgdCwgdG9UcmFuc2l0aW9uQ29uZmlnQXJyYXkgYXMgdSwgZm9ybWF0VHJhbnNpdGlvbiBhcyB2LCBldmFsdWF0ZUd1YXJkIGFzIHcsIGNyZWF0ZUludm9rZUlkIGFzIHgsIGdldERlbGF5ZWRUcmFuc2l0aW9ucyBhcyB5LCBmb3JtYXRJbml0aWFsVHJhbnNpdGlvbiBhcyB6IH07XG4iXSwibmFtZXMiOlsiZGV2VG9vbHNBZGFwdGVyIiwiTWFpbGJveCIsImNvbnN0cnVjdG9yIiwiX3Byb2Nlc3MiLCJfYWN0aXZlIiwiX2N1cnJlbnQiLCJfbGFzdCIsInN0YXJ0IiwiZmx1c2giLCJjbGVhciIsIm5leHQiLCJlbnF1ZXVlIiwiZXZlbnQiLCJlbnF1ZXVlZCIsInZhbHVlIiwiY29uc3VtZWQiLCJTVEFURV9ERUxJTUlURVIiLCJUQVJHRVRMRVNTX0tFWSIsIk5VTExfRVZFTlQiLCJTVEFURV9JREVOVElGSUVSIiwiV0lMRENBUkQiLCJYU1RBVEVfSU5JVCIsIlhTVEFURV9FUlJPUiIsIlhTVEFURV9TVE9QIiwiY3JlYXRlQWZ0ZXJFdmVudCIsImRlbGF5UmVmIiwiaWQiLCJ0eXBlIiwiY3JlYXRlRG9uZVN0YXRlRXZlbnQiLCJvdXRwdXQiLCJjcmVhdGVEb25lQWN0b3JFdmVudCIsImludm9rZUlkIiwiYWN0b3JJZCIsImNyZWF0ZUVycm9yQWN0b3JFdmVudCIsImVycm9yIiwiY3JlYXRlSW5pdEV2ZW50IiwiaW5wdXQiLCJyZXBvcnRVbmhhbmRsZWRFcnJvciIsImVyciIsInNldFRpbWVvdXQiLCJzeW1ib2xPYnNlcnZhYmxlIiwiU3ltYm9sIiwib2JzZXJ2YWJsZSIsIm1hdGNoZXNTdGF0ZSIsInBhcmVudFN0YXRlSWQiLCJjaGlsZFN0YXRlSWQiLCJwYXJlbnRTdGF0ZVZhbHVlIiwidG9TdGF0ZVZhbHVlIiwiY2hpbGRTdGF0ZVZhbHVlIiwiT2JqZWN0Iiwia2V5cyIsImV2ZXJ5Iiwia2V5IiwidG9TdGF0ZVBhdGgiLCJzdGF0ZUlkIiwiaXNBcnJheSIsInJlc3VsdCIsInNlZ21lbnQiLCJpIiwibGVuZ3RoIiwiY2hhciIsImNoYXJDb2RlQXQiLCJwdXNoIiwic3RhdGVWYWx1ZSIsImlzTWFjaGluZVNuYXBzaG90Iiwic3RhdGVQYXRoIiwicGF0aFRvU3RhdGVWYWx1ZSIsIm1hcmtlciIsInByZXZpb3VzIiwibWFwVmFsdWVzIiwiY29sbGVjdGlvbiIsIml0ZXJhdGVlIiwiY29sbGVjdGlvbktleXMiLCJ0b0FycmF5U3RyaWN0IiwidG9BcnJheSIsInVuZGVmaW5lZCIsInJlc29sdmVPdXRwdXQiLCJtYXBwZXIiLCJjb250ZXh0Iiwic2VsZiIsInZhbHVlcyIsInNvbWUiLCJ2YWwiLCJjb25zb2xlIiwid2FybiIsImVudHJpZXMiLCJmaWx0ZXIiLCJtYXAiLCJ0b1N0cmluZyIsInJlcGxhY2UiLCJqb2luIiwiQXJyYXkiLCJpc0Vycm9yQWN0b3JFdmVudCIsInN0YXJ0c1dpdGgiLCJ0b1RyYW5zaXRpb25Db25maWdBcnJheSIsImNvbmZpZ0xpa2UiLCJ0cmFuc2l0aW9uTGlrZSIsInRhcmdldCIsIm5vcm1hbGl6ZVRhcmdldCIsInRvT2JzZXJ2ZXIiLCJuZXh0SGFuZGxlciIsImVycm9ySGFuZGxlciIsImNvbXBsZXRpb25IYW5kbGVyIiwiaXNPYnNlcnZlciIsImJpbmQiLCJjb21wbGV0ZSIsImNyZWF0ZUludm9rZUlkIiwic3RhdGVOb2RlSWQiLCJpbmRleCIsInJlc29sdmVSZWZlcmVuY2VkQWN0b3IiLCJtYWNoaW5lIiwic3JjIiwibWF0Y2giLCJpbXBsZW1lbnRhdGlvbnMiLCJhY3RvcnMiLCJpbmRleFN0ciIsIm5vZGVJZCIsIm5vZGUiLCJnZXRTdGF0ZU5vZGVCeUlkIiwiaW52b2tlQ29uZmlnIiwiY29uZmlnIiwiaW52b2tlIiwiZ2V0QWxsT3duRXZlbnREZXNjcmlwdG9ycyIsInNuYXBzaG90IiwiU2V0IiwiX25vZGVzIiwiZmxhdE1hcCIsInNuIiwib3duRXZlbnRzIiwiY3JlYXRlU2NoZWR1bGVkRXZlbnRJZCIsImFjdG9yUmVmIiwic2Vzc2lvbklkIiwiaWRDb3VudGVyIiwiY3JlYXRlU3lzdGVtIiwicm9vdEFjdG9yIiwib3B0aW9ucyIsImNoaWxkcmVuIiwiTWFwIiwia2V5ZWRBY3RvcnMiLCJyZXZlcnNlS2V5ZWRBY3RvcnMiLCJXZWFrTWFwIiwiaW5zcGVjdGlvbk9ic2VydmVycyIsInRpbWVyTWFwIiwiY2xvY2siLCJsb2dnZXIiLCJzY2hlZHVsZXIiLCJzY2hlZHVsZSIsInNvdXJjZSIsImRlbGF5IiwiTWF0aCIsInJhbmRvbSIsInNsaWNlIiwic2NoZWR1bGVkRXZlbnQiLCJzdGFydGVkQXQiLCJEYXRlIiwibm93Iiwic2NoZWR1bGVkRXZlbnRJZCIsInN5c3RlbSIsIl9zbmFwc2hvdCIsIl9zY2hlZHVsZWRFdmVudHMiLCJ0aW1lb3V0IiwiX3JlbGF5IiwiY2FuY2VsIiwiY2xlYXJUaW1lb3V0IiwiY2FuY2VsQWxsIiwic2VuZEluc3BlY3Rpb25FdmVudCIsInNpemUiLCJyZXNvbHZlZEluc3BlY3Rpb25FdmVudCIsInJvb3RJZCIsImZvckVhY2giLCJvYnNlcnZlciIsIl9ib29rSWQiLCJfcmVnaXN0ZXIiLCJzZXQiLCJfdW5yZWdpc3RlciIsImRlbGV0ZSIsInN5c3RlbUlkIiwiZ2V0IiwiX3NldCIsImV4aXN0aW5nIiwiRXJyb3IiLCJpbnNwZWN0Iiwib2JzZXJ2ZXJPckZuIiwiYWRkIiwidW5zdWJzY3JpYmUiLCJfc2VuZEluc3BlY3Rpb25FdmVudCIsInNvdXJjZVJlZiIsIl9zZW5kIiwiZ2V0U25hcHNob3QiLCJzY2hlZHVsZWRFdmVudHMiLCJzY2hlZHVsZWRJZCIsIl9jbG9jayIsIl9sb2dnZXIiLCJleGVjdXRpbmdDdXN0b21BY3Rpb24iLCIkJEFDVE9SX1RZUEUiLCJQcm9jZXNzaW5nU3RhdHVzIiwiZGVmYXVsdE9wdGlvbnMiLCJmbiIsIm1zIiwibG9nIiwiZGV2VG9vbHMiLCJBY3RvciIsImxvZ2ljIiwibWFpbGJveCIsIm9ic2VydmVycyIsImV2ZW50TGlzdGVuZXJzIiwiX3Byb2Nlc3NpbmdTdGF0dXMiLCJOb3RTdGFydGVkIiwiX3BhcmVudCIsIl9zeW5jU25hcHNob3QiLCJyZWYiLCJfYWN0b3JTY29wZSIsIl9zeXN0ZW1JZCIsIl9kb25lRXZlbnQiLCJfZGVmZXJyZWQiLCJyZXNvbHZlZE9wdGlvbnMiLCJwYXJlbnQiLCJzeW5jU25hcHNob3QiLCJkZWZlciIsInN0b3BDaGlsZCIsImNoaWxkIiwiX3N0b3AiLCJlbWl0IiwiZW1pdHRlZEV2ZW50IiwibGlzdGVuZXJzIiwid2lsZGNhcmRMaXN0ZW5lciIsImFsbExpc3RlbmVycyIsImhhbmRsZXIiLCJhY3Rpb25FeGVjdXRvciIsImFjdGlvbiIsImV4ZWMiLCJwYXJhbXMiLCJzYXZlRXhlY3V0aW5nQ3VzdG9tQWN0aW9uIiwiaW5mbyIsIlJ1bm5pbmciLCJzZW5kIiwiX2luaXRTdGF0ZSIsInN0YXRlIiwic3RhdHVzIiwicGVyc2lzdGVkU3RhdGUiLCJyZXN0b3JlU25hcHNob3QiLCJnZXRJbml0aWFsU25hcHNob3QiLCJ1cGRhdGUiLCJkZWZlcnJlZEZuIiwic2hpZnQiLCJfc3RvcFByb2NlZHVyZSIsIl9jb21wbGV0ZSIsIl9lcnJvciIsInN1YnNjcmliZSIsIm5leHRMaXN0ZW5lck9yT2JzZXJ2ZXIiLCJlcnJvckxpc3RlbmVyIiwiY29tcGxldGVMaXN0ZW5lciIsIlN0b3BwZWQiLCJvbiIsIndyYXBwZWRIYW5kbGVyIiwiaW5pdEV2ZW50IiwiYXR0YWNoRGV2VG9vbHMiLCJuZXh0U3RhdGUiLCJjYXVnaHRFcnJvciIsInRyYW5zaXRpb24iLCJzdG9wIiwiX3JlcG9ydEVycm9yIiwicmVwb3J0RXJyb3IiLCJlcnIyIiwiZXZlbnRTdHJpbmciLCJKU09OIiwic3RyaW5naWZ5IiwicmVzb2x2ZWREZXZUb29sc0FkYXB0ZXIiLCJ0b0pTT04iLCJ4c3RhdGUkJHR5cGUiLCJnZXRQZXJzaXN0ZWRTbmFwc2hvdCIsImNyZWF0ZUFjdG9yIiwiaW50ZXJwcmV0IiwicmVzb2x2ZUNhbmNlbCIsIl8iLCJhY3Rpb25BcmdzIiwiYWN0aW9uUGFyYW1zIiwic2VuZElkIiwicmVzb2x2ZWRTZW5kSWQiLCJleGVjdXRlQ2FuY2VsIiwiYWN0b3JTY29wZSIsIl9hcmdzIiwiX3BhcmFtcyIsInJlc29sdmUiLCJleGVjdXRlIiwicmVzb2x2ZVNwYXduIiwiX2FjdGlvblBhcmFtcyIsInJlc29sdmVkSWQiLCJyZXNvbHZlZElucHV0IiwiY2xvbmVNYWNoaW5lU25hcHNob3QiLCJleGVjdXRlU3Bhd24iLCJzcGF3bkNoaWxkIiwicmVzb2x2ZVN0b3AiLCJhcmdzIiwiYWN0b3JSZWZPclN0cmluZyIsInJlc29sdmVkQWN0b3JSZWYiLCJleGVjdXRlU3RvcCIsImNoZWNrU3RhdGVJbiIsImlzU3RhdGVJZCIsIm1hdGNoZXMiLCJzdGF0ZUluIiwiY2hlY2siLCJjaGVja05vdCIsImd1YXJkcyIsImV2YWx1YXRlR3VhcmQiLCJub3QiLCJndWFyZCIsImNoZWNrQW5kIiwiYW5kIiwiY2hlY2tPciIsIm9yIiwiaXNJbmxpbmUiLCJyZXNvbHZlZCIsImd1YXJkQXJncyIsImd1YXJkUGFyYW1zIiwiYnVpbHRpbkd1YXJkIiwiaXNBdG9taWNTdGF0ZU5vZGUiLCJzdGF0ZU5vZGUiLCJnZXRDaGlsZHJlbiIsInN0YXRlcyIsImdldFByb3BlckFuY2VzdG9ycyIsInRvU3RhdGVOb2RlIiwiYW5jZXN0b3JzIiwibSIsImdldEFsbFN0YXRlTm9kZXMiLCJzdGF0ZU5vZGVzIiwibm9kZVNldCIsImFkakxpc3QiLCJnZXRBZGpMaXN0IiwicyIsImdldEluaXRpYWxTdGF0ZU5vZGVzV2l0aFRoZWlyQW5jZXN0b3JzIiwiaGFzIiwiaW5pdGlhbFN0YXRlcyIsImluaXRpYWxTdGF0ZU5vZGUiLCJnZXRWYWx1ZUZyb21BZGoiLCJiYXNlTm9kZSIsImNoaWxkU3RhdGVOb2RlcyIsImNoaWxkU3RhdGVOb2RlIiwiZ2V0U3RhdGVWYWx1ZSIsInJvb3ROb2RlIiwiaXNJbkZpbmFsU3RhdGUiLCJzdGF0ZU5vZGVTZXQiLCJzdHIiLCJnZXRDYW5kaWRhdGVzIiwicmVjZWl2ZWRFdmVudFR5cGUiLCJjYW5kaWRhdGVzIiwidHJhbnNpdGlvbnMiLCJldmVudERlc2NyaXB0b3IiLCJlbmRzV2l0aCIsInRlc3QiLCJwYXJ0aWFsRXZlbnRUb2tlbnMiLCJzcGxpdCIsImV2ZW50VG9rZW5zIiwidG9rZW5JbmRleCIsInBhcnRpYWxFdmVudFRva2VuIiwiZXZlbnRUb2tlbiIsImlzTGFzdFRva2VuIiwic29ydCIsImEiLCJiIiwiZ2V0RGVsYXllZFRyYW5zaXRpb25zIiwiYWZ0ZXJDb25maWciLCJhZnRlciIsIm11dGF0ZUVudHJ5RXhpdCIsImFmdGVyRXZlbnQiLCJldmVudFR5cGUiLCJlbnRyeSIsInJhaXNlIiwiZXhpdCIsImRlbGF5ZWRUcmFuc2l0aW9ucyIsImNvbmZpZ1RyYW5zaXRpb24iLCJyZXNvbHZlZFRyYW5zaXRpb24iLCJyZXNvbHZlZERlbGF5IiwiTnVtYmVyIiwiaXNOYU4iLCJkZWxheWVkVHJhbnNpdGlvbiIsImZvcm1hdFRyYW5zaXRpb24iLCJkZXNjcmlwdG9yIiwidHJhbnNpdGlvbkNvbmZpZyIsIm5vcm1hbGl6ZWRUYXJnZXQiLCJyZWVudGVyIiwicmVzb2x2ZVRhcmdldCIsImNvbmQiLCJhY3Rpb25zIiwidCIsImZvcm1hdFRyYW5zaXRpb25zIiwidHJhbnNpdGlvbnNDb25maWciLCJvbkRvbmUiLCJpbnZva2VEZWYiLCJvbkVycm9yIiwib25TbmFwc2hvdCIsImZvcm1hdEluaXRpYWxUcmFuc2l0aW9uIiwiX3RhcmdldCIsInJlc29sdmVkVGFyZ2V0IiwidGFyZ2V0cyIsImlzSW50ZXJuYWxUYXJnZXQiLCJnZXRTdGF0ZU5vZGVCeVBhdGgiLCJ0YXJnZXRTdGF0ZU5vZGUiLCJtZXNzYWdlIiwicmVzb2x2ZUhpc3RvcnlEZWZhdWx0VHJhbnNpdGlvbiIsImluaXRpYWwiLCJpc0hpc3RvcnlOb2RlIiwiZ2V0SW5pdGlhbFN0YXRlTm9kZXMiLCJpbml0aWFsU3RhdGUiLCJhbmNlc3RvciIsIml0ZXIiLCJkZXNjU3RhdGVOb2RlIiwiZ2V0U3RhdGVOb2RlIiwic3RhdGVLZXkiLCJhcnJheVN0YXRlUGF0aCIsImN1cnJlbnRTdGF0ZU5vZGUiLCJnZXRTdGF0ZU5vZGVzIiwiY2hpbGRTdGF0ZUtleXMiLCJzdWJTdGF0ZUtleSIsIkJvb2xlYW4iLCJyb290IiwiY29uY2F0IiwicmVkdWNlIiwiYWxsU3ViU3RhdGVOb2RlcyIsInN1YlN0YXRlTm9kZSIsInN1YlN0YXRlTm9kZXMiLCJ0cmFuc2l0aW9uQXRvbWljTm9kZSIsInRyYW5zaXRpb25Db21wb3VuZE5vZGUiLCJzdWJTdGF0ZUtleXMiLCJ0cmFuc2l0aW9uTm9kZSIsInRyYW5zaXRpb25QYXJhbGxlbE5vZGUiLCJhbGxJbm5lclRyYW5zaXRpb25zIiwic3ViU3RhdGVWYWx1ZSIsImlubmVyVHJhbnNpdGlvbnMiLCJnZXRIaXN0b3J5Tm9kZXMiLCJpc0Rlc2NlbmRhbnQiLCJwYXJlbnRTdGF0ZU5vZGUiLCJoYXNJbnRlcnNlY3Rpb24iLCJzMSIsInMyIiwic2V0MSIsInNldDIiLCJpdGVtIiwicmVtb3ZlQ29uZmxpY3RpbmdUcmFuc2l0aW9ucyIsImVuYWJsZWRUcmFuc2l0aW9ucyIsImhpc3RvcnlWYWx1ZSIsImZpbHRlcmVkVHJhbnNpdGlvbnMiLCJ0MSIsInQxUHJlZW1wdGVkIiwidHJhbnNpdGlvbnNUb1JlbW92ZSIsInQyIiwiY29tcHV0ZUV4aXRTZXQiLCJ0MyIsImZyb20iLCJmaW5kTGVhc3RDb21tb25BbmNlc3RvciIsImhlYWQiLCJ0YWlsIiwiZ2V0RWZmZWN0aXZlVGFyZ2V0U3RhdGVzIiwidGFyZ2V0Tm9kZSIsImdldFRyYW5zaXRpb25Eb21haW4iLCJ0YXJnZXRTdGF0ZXMiLCJsY2EiLCJzdGF0ZXNUb0V4aXQiLCJkb21haW4iLCJhcmVTdGF0ZU5vZGVDb2xsZWN0aW9uc0VxdWFsIiwicHJldlN0YXRlTm9kZXMiLCJuZXh0U3RhdGVOb2RlU2V0IiwibWljcm9zdGVwIiwiY3VycmVudFNuYXBzaG90IiwiaXNJbml0aWFsIiwiaW50ZXJuYWxRdWV1ZSIsIm11dFN0YXRlTm9kZVNldCIsImV4aXRTdGF0ZXMiLCJyZXNvbHZlQWN0aW9uc0FuZENvbnRleHQiLCJlbnRlclN0YXRlcyIsIm5leHRTdGF0ZU5vZGVzIiwib3JkZXIiLCJlIiwiZ2V0TWFjaGluZU91dHB1dCIsInJvb3RDb21wbGV0aW9uTm9kZSIsImRvbmVTdGF0ZUV2ZW50IiwibmV4dFNuYXBzaG90Iiwic3RhdGVzVG9FbnRlciIsInN0YXRlc0ZvckRlZmF1bHRFbnRyeSIsImNvbXB1dGVFbnRyeVNldCIsImNvbXBsZXRlZE5vZGVzIiwic3RhdGVOb2RlVG9FbnRlciIsImluaXRpYWxBY3Rpb25zIiwiYW5jZXN0b3JNYXJrZXIiLCJhZGREZXNjZW5kYW50U3RhdGVzVG9FbnRlciIsImFkZEFuY2VzdG9yU3RhdGVzVG9FbnRlciIsImhpc3RvcnlTdGF0ZU5vZGVzIiwiYWRkUHJvcGVyQW5jZXN0b3JTdGF0ZXNUb0VudGVyIiwiaGlzdG9yeURlZmF1bHRUcmFuc2l0aW9uIiwicmVlbnRyYW5jeURvbWFpbiIsImFuYyIsIl9hY3Rpb25FeGVjdXRvciIsImNoYW5nZWRIaXN0b3J5IiwiZXhpdFN0YXRlTm9kZSIsImhpc3RvcnlOb2RlIiwicHJlZGljYXRlIiwiaGlzdG9yeSIsImRlZiIsImdldEFjdGlvbiIsImFjdGlvblR5cGUiLCJyZXNvbHZlQW5kRXhlY3V0ZUFjdGlvbnNXaXRoQ29udGV4dCIsImV4dHJhIiwicmV0cmllcyIsImludGVybWVkaWF0ZVNuYXBzaG90IiwicmVzb2x2ZWRBY3Rpb24iLCJuYW1lIiwiYnVpbHRpbkFjdGlvbiIsImRlZmVycmVkQWN0b3JJZHMiLCJyZXRyeVJlc29sdmUiLCJtYWNyb3N0ZXAiLCJtaWNyb3N0YXRlcyIsImFkZE1pY3Jvc3RhdGUiLCJtaWNyb3N0YXRlIiwiX3RyYW5zaXRpb25zIiwic3RvcENoaWxkcmVuIiwibmV4dEV2ZW50IiwiY3VycmVudEV2ZW50IiwiaXNFcnIiLCJzZWxlY3RUcmFuc2l0aW9ucyIsInNob3VsZFNlbGVjdEV2ZW50bGVzc1RyYW5zaXRpb25zIiwic2VsZWN0RXZlbnRsZXNzVHJhbnNpdGlvbnMiLCJwcmV2aW91c1N0YXRlIiwiZ2V0VHJhbnNpdGlvbkRhdGEiLCJlbmFibGVkVHJhbnNpdGlvblNldCIsImF0b21pY1N0YXRlcyIsImxvb3AiLCJhbHdheXMiLCJyZXNvbHZlU3RhdGVWYWx1ZSIsImFsbFN0YXRlTm9kZXMiLCJtYWNoaW5lU25hcHNob3RNYXRjaGVzIiwidGVzdFZhbHVlIiwibWFjaGluZVNuYXBzaG90SGFzVGFnIiwiaGFzVGFnIiwidGFnIiwidGFncyIsIm1hY2hpbmVTbmFwc2hvdENhbiIsImNhbiIsInRyYW5zaXRpb25EYXRhIiwibWFjaGluZVNuYXBzaG90VG9KU09OIiwibm9kZXMiLCJnZXRNZXRhIiwianNvblZhbHVlcyIsIm1hY2hpbmVTbmFwc2hvdEdldE1ldGEiLCJhY2MiLCJtZXRhIiwiY3JlYXRlTWFjaGluZVNuYXBzaG90Iiwic2VyaWFsaXplSGlzdG9yeVZhbHVlIiwiY2hpbGRyZW5Kc29uIiwicGVyc2lzdGVkIiwicGVyc2lzdENvbnRleHQiLCJjb250ZXh0UGFydCIsImNvcHkiLCJyZXNvbHZlUmFpc2UiLCJldmVudE9yRXhwciIsImRlbGF5c01hcCIsImRlbGF5cyIsInJlc29sdmVkRXZlbnQiLCJjb25maWdEZWxheSIsImV4ZWN1dGVSYWlzZSIsIiQiLCJBIiwiQiIsIkMiLCJEIiwiRSIsIkYiLCJHIiwiSCIsIkkiLCJKIiwiSyIsIkwiLCJNIiwiTiIsIk8iLCJQIiwiUSIsIlIiLCJTIiwiVCIsIlUiLCJWIiwiVyIsIlgiLCJZIiwiYyIsImQiLCJmIiwiZyIsImgiLCJqIiwiayIsImwiLCJuIiwibyIsInAiLCJxIiwiciIsInUiLCJ2IiwidyIsIngiLCJ5IiwieiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xstate/dist/raise-78b8dcb8.development.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/xstate/dist/xstate.development.esm.js":
/*!************************************************************!*\
  !*** ./node_modules/xstate/dist/xstate.development.esm.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Actor: () => (/* reexport safe */ _raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.A),\n/* harmony export */   SimulatedClock: () => (/* binding */ SimulatedClock),\n/* harmony export */   SpecialTargets: () => (/* reexport safe */ _log_ef959da6_development_esm_js__WEBPACK_IMPORTED_MODULE_3__.S),\n/* harmony export */   StateMachine: () => (/* reexport safe */ _StateMachine_b4e94439_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.S),\n/* harmony export */   StateNode: () => (/* reexport safe */ _StateMachine_b4e94439_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.a),\n/* harmony export */   __unsafe_getAllOwnEventDescriptors: () => (/* reexport safe */ _raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.d),\n/* harmony export */   and: () => (/* reexport safe */ _raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.a),\n/* harmony export */   assertEvent: () => (/* binding */ assertEvent),\n/* harmony export */   assign: () => (/* reexport safe */ _assign_6313ccb3_development_esm_js__WEBPACK_IMPORTED_MODULE_4__.a),\n/* harmony export */   cancel: () => (/* reexport safe */ _raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.f),\n/* harmony export */   createActor: () => (/* reexport safe */ _raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.c),\n/* harmony export */   createEmptyActor: () => (/* reexport safe */ _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.createEmptyActor),\n/* harmony export */   createMachine: () => (/* binding */ createMachine),\n/* harmony export */   emit: () => (/* reexport safe */ _log_ef959da6_development_esm_js__WEBPACK_IMPORTED_MODULE_3__.e),\n/* harmony export */   enqueueActions: () => (/* reexport safe */ _log_ef959da6_development_esm_js__WEBPACK_IMPORTED_MODULE_3__.a),\n/* harmony export */   forwardTo: () => (/* reexport safe */ _log_ef959da6_development_esm_js__WEBPACK_IMPORTED_MODULE_3__.f),\n/* harmony export */   fromCallback: () => (/* reexport safe */ _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.fromCallback),\n/* harmony export */   fromEventObservable: () => (/* reexport safe */ _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.fromEventObservable),\n/* harmony export */   fromObservable: () => (/* reexport safe */ _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.fromObservable),\n/* harmony export */   fromPromise: () => (/* reexport safe */ _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.fromPromise),\n/* harmony export */   fromTransition: () => (/* reexport safe */ _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.fromTransition),\n/* harmony export */   getInitialSnapshot: () => (/* binding */ getInitialSnapshot),\n/* harmony export */   getNextSnapshot: () => (/* binding */ getNextSnapshot),\n/* harmony export */   getStateNodes: () => (/* reexport safe */ _raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.g),\n/* harmony export */   initialTransition: () => (/* binding */ initialTransition),\n/* harmony export */   interpret: () => (/* reexport safe */ _raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.i),\n/* harmony export */   isMachineSnapshot: () => (/* reexport safe */ _raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.b),\n/* harmony export */   log: () => (/* reexport safe */ _log_ef959da6_development_esm_js__WEBPACK_IMPORTED_MODULE_3__.l),\n/* harmony export */   matchesState: () => (/* reexport safe */ _raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.m),\n/* harmony export */   not: () => (/* reexport safe */ _raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.n),\n/* harmony export */   or: () => (/* reexport safe */ _raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.o),\n/* harmony export */   pathToStateValue: () => (/* reexport safe */ _raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.p),\n/* harmony export */   raise: () => (/* reexport safe */ _raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.r),\n/* harmony export */   sendParent: () => (/* reexport safe */ _log_ef959da6_development_esm_js__WEBPACK_IMPORTED_MODULE_3__.s),\n/* harmony export */   sendTo: () => (/* reexport safe */ _log_ef959da6_development_esm_js__WEBPACK_IMPORTED_MODULE_3__.b),\n/* harmony export */   setup: () => (/* binding */ setup),\n/* harmony export */   spawnChild: () => (/* reexport safe */ _raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.h),\n/* harmony export */   stateIn: () => (/* reexport safe */ _raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.s),\n/* harmony export */   stop: () => (/* reexport safe */ _raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.j),\n/* harmony export */   stopChild: () => (/* reexport safe */ _raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.k),\n/* harmony export */   toObserver: () => (/* reexport safe */ _raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.e),\n/* harmony export */   toPromise: () => (/* binding */ toPromise),\n/* harmony export */   transition: () => (/* binding */ transition),\n/* harmony export */   waitFor: () => (/* binding */ waitFor)\n/* harmony export */ });\n/* harmony import */ var _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../actors/dist/xstate-actors.development.esm.js */ \"(ssr)/./node_modules/xstate/actors/dist/xstate-actors.development.esm.js\");\n/* harmony import */ var _raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./raise-78b8dcb8.development.esm.js */ \"(ssr)/./node_modules/xstate/dist/raise-78b8dcb8.development.esm.js\");\n/* harmony import */ var _StateMachine_b4e94439_development_esm_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./StateMachine-b4e94439.development.esm.js */ \"(ssr)/./node_modules/xstate/dist/StateMachine-b4e94439.development.esm.js\");\n/* harmony import */ var _log_ef959da6_development_esm_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./log-ef959da6.development.esm.js */ \"(ssr)/./node_modules/xstate/dist/log-ef959da6.development.esm.js\");\n/* harmony import */ var _assign_6313ccb3_development_esm_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./assign-6313ccb3.development.esm.js */ \"(ssr)/./node_modules/xstate/dist/assign-6313ccb3.development.esm.js\");\n/* harmony import */ var _dev_dist_xstate_dev_development_esm_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dev/dist/xstate-dev.development.esm.js */ \"(ssr)/./node_modules/xstate/dev/dist/xstate-dev.development.esm.js\");\n\n\n\n\n\n\n\n\n/**\n * Asserts that the given event object is of the specified type or types. Throws\n * an error if the event object is not of the specified types.\n *\n * @example\n *\n * ```ts\n * // ...\n * entry: ({ event }) => {\n *   assertEvent(event, 'doNothing');\n *   // event is { type: 'doNothing' }\n * },\n * // ...\n * exit: ({ event }) => {\n *   assertEvent(event, 'greet');\n *   // event is { type: 'greet'; message: string }\n *\n *   assertEvent(event, ['greet', 'notify']);\n *   // event is { type: 'greet'; message: string }\n *   // or { type: 'notify'; message: string; level: 'info' | 'error' }\n * },\n * ```\n */ function assertEvent(event, type) {\n    const types = (0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.t)(type);\n    if (!types.includes(event.type)) {\n        const typesText = types.length === 1 ? `type \"${types[0]}\"` : `one of types \"${types.join('\", \"')}\"`;\n        throw new Error(`Expected event ${JSON.stringify(event)} to have ${typesText}`);\n    }\n}\n/**\n * Creates a state machine (statechart) with the given configuration.\n *\n * The state machine represents the pure logic of a state machine actor.\n *\n * @example\n *\n * ```ts\n * import { createMachine } from 'xstate';\n *\n * const lightMachine = createMachine({\n *   id: 'light',\n *   initial: 'green',\n *   states: {\n *     green: {\n *       on: {\n *         TIMER: { target: 'yellow' }\n *       }\n *     },\n *     yellow: {\n *       on: {\n *         TIMER: { target: 'red' }\n *       }\n *     },\n *     red: {\n *       on: {\n *         TIMER: { target: 'green' }\n *       }\n *     }\n *   }\n * });\n *\n * const lightActor = createActor(lightMachine);\n * lightActor.start();\n *\n * lightActor.send({ type: 'TIMER' });\n * ```\n *\n * @param config The state machine configuration.\n * @param options DEPRECATED: use `setup({ ... })` or `machine.provide({ ... })`\n *   to provide machine implementations instead.\n */ function createMachine(config, implementations) {\n    return new _StateMachine_b4e94439_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.S(config, implementations);\n}\n/** @internal */ function createInertActorScope(actorLogic) {\n    const self = (0,_raise_78b8dcb8_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.c)(actorLogic);\n    const inertActorScope = {\n        self,\n        defer: ()=>{},\n        id: \"\",\n        logger: ()=>{},\n        sessionId: \"\",\n        stopChild: ()=>{},\n        system: self.system,\n        emit: ()=>{},\n        actionExecutor: ()=>{}\n    };\n    return inertActorScope;\n}\n/** @deprecated Use `initialTransition(…)` instead. */ function getInitialSnapshot(actorLogic, ...[input]) {\n    const actorScope = createInertActorScope(actorLogic);\n    return actorLogic.getInitialSnapshot(actorScope, input);\n}\n/**\n * Determines the next snapshot for the given `actorLogic` based on the given\n * `snapshot` and `event`.\n *\n * If the `snapshot` is `undefined`, the initial snapshot of the `actorLogic` is\n * used.\n *\n * @deprecated Use `transition(…)` instead.\n * @example\n *\n * ```ts\n * import { getNextSnapshot } from 'xstate';\n * import { trafficLightMachine } from './trafficLightMachine.ts';\n *\n * const nextSnapshot = getNextSnapshot(\n *   trafficLightMachine, // actor logic\n *   undefined, // snapshot (or initial state if undefined)\n *   { type: 'TIMER' }\n * ); // event object\n *\n * console.log(nextSnapshot.value);\n * // => 'yellow'\n *\n * const nextSnapshot2 = getNextSnapshot(\n *   trafficLightMachine, // actor logic\n *   nextSnapshot, // snapshot\n *   { type: 'TIMER' }\n * ); // event object\n *\n * console.log(nextSnapshot2.value);\n * // =>'red'\n * ```\n */ function getNextSnapshot(actorLogic, snapshot, event) {\n    const inertActorScope = createInertActorScope(actorLogic);\n    inertActorScope.self._snapshot = snapshot;\n    return actorLogic.transition(snapshot, event, inertActorScope);\n}\n// at the moment we allow extra actors - ones that are not specified by `children`\n// this could be reconsidered in the future\nfunction setup({ schemas, actors, actions, guards, delays }) {\n    return {\n        createMachine: (config)=>createMachine({\n                ...config,\n                schemas\n            }, {\n                actors,\n                actions,\n                guards,\n                delays\n            })\n    };\n}\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nclass SimulatedClock {\n    constructor(){\n        this.timeouts = new Map();\n        this._now = 0;\n        this._id = 0;\n        this._flushing = false;\n        this._flushingInvalidated = false;\n    }\n    now() {\n        return this._now;\n    }\n    getId() {\n        return this._id++;\n    }\n    setTimeout(fn, timeout) {\n        this._flushingInvalidated = this._flushing;\n        const id = this.getId();\n        this.timeouts.set(id, {\n            start: this.now(),\n            timeout,\n            fn\n        });\n        return id;\n    }\n    clearTimeout(id) {\n        this._flushingInvalidated = this._flushing;\n        this.timeouts.delete(id);\n    }\n    set(time) {\n        if (this._now > time) {\n            throw new Error(\"Unable to travel back in time\");\n        }\n        this._now = time;\n        this.flushTimeouts();\n    }\n    flushTimeouts() {\n        if (this._flushing) {\n            this._flushingInvalidated = true;\n            return;\n        }\n        this._flushing = true;\n        const sorted = [\n            ...this.timeouts\n        ].sort(([_idA, timeoutA], [_idB, timeoutB])=>{\n            const endA = timeoutA.start + timeoutA.timeout;\n            const endB = timeoutB.start + timeoutB.timeout;\n            return endB > endA ? -1 : 1;\n        });\n        for (const [id, timeout] of sorted){\n            if (this._flushingInvalidated) {\n                this._flushingInvalidated = false;\n                this._flushing = false;\n                this.flushTimeouts();\n                return;\n            }\n            if (this.now() - timeout.start >= timeout.timeout) {\n                this.timeouts.delete(id);\n                timeout.fn.call(null);\n            }\n        }\n        this._flushing = false;\n    }\n    increment(ms) {\n        this._now += ms;\n        this.flushTimeouts();\n    }\n}\n/**\n * Returns a promise that resolves to the `output` of the actor when it is done.\n *\n * @example\n *\n * ```ts\n * const machine = createMachine({\n *   // ...\n *   output: {\n *     count: 42\n *   }\n * });\n *\n * const actor = createActor(machine);\n *\n * actor.start();\n *\n * const output = await toPromise(actor);\n *\n * console.log(output);\n * // logs { count: 42 }\n * ```\n */ function toPromise(actor) {\n    return new Promise((resolve, reject)=>{\n        actor.subscribe({\n            complete: ()=>{\n                resolve(actor.getSnapshot().output);\n            },\n            error: reject\n        });\n    });\n}\n/**\n * Given actor `logic`, a `snapshot`, and an `event`, returns a tuple of the\n * `nextSnapshot` and `actions` to execute.\n *\n * This is a pure function that does not execute `actions`.\n */ function transition(logic, snapshot, event) {\n    const executableActions = [];\n    const actorScope = createInertActorScope(logic);\n    actorScope.actionExecutor = (action)=>{\n        executableActions.push(action);\n    };\n    const nextSnapshot = logic.transition(snapshot, event, actorScope);\n    return [\n        nextSnapshot,\n        executableActions\n    ];\n}\n/**\n * Given actor `logic` and optional `input`, returns a tuple of the\n * `nextSnapshot` and `actions` to execute from the initial transition (no\n * previous state).\n *\n * This is a pure function that does not execute `actions`.\n */ function initialTransition(logic, ...[input]) {\n    const executableActions = [];\n    const actorScope = createInertActorScope(logic);\n    actorScope.actionExecutor = (action)=>{\n        executableActions.push(action);\n    };\n    const nextSnapshot = logic.getInitialSnapshot(actorScope, input);\n    return [\n        nextSnapshot,\n        executableActions\n    ];\n}\nconst defaultWaitForOptions = {\n    timeout: Infinity // much more than 10 seconds\n};\n/**\n * Subscribes to an actor ref and waits for its emitted value to satisfy a\n * predicate, and then resolves with that value. Will throw if the desired state\n * is not reached after an optional timeout. (defaults to Infinity).\n *\n * @example\n *\n * ```js\n * const state = await waitFor(someService, (state) => {\n *   return state.hasTag('loaded');\n * });\n *\n * state.hasTag('loaded'); // true\n * ```\n *\n * @param actorRef The actor ref to subscribe to\n * @param predicate Determines if a value matches the condition to wait for\n * @param options\n * @returns A promise that eventually resolves to the emitted value that matches\n *   the condition\n */ function waitFor(actorRef, predicate, options) {\n    const resolvedOptions = {\n        ...defaultWaitForOptions,\n        ...options\n    };\n    return new Promise((res, rej)=>{\n        const { signal } = resolvedOptions;\n        if (signal?.aborted) {\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            rej(signal.reason);\n            return;\n        }\n        let done = false;\n        if (resolvedOptions.timeout < 0) {\n            console.error(\"`timeout` passed to `waitFor` is negative and it will reject its internal promise immediately.\");\n        }\n        const handle = resolvedOptions.timeout === Infinity ? undefined : setTimeout(()=>{\n            dispose();\n            rej(new Error(`Timeout of ${resolvedOptions.timeout} ms exceeded`));\n        }, resolvedOptions.timeout);\n        const dispose = ()=>{\n            clearTimeout(handle);\n            done = true;\n            sub?.unsubscribe();\n            if (abortListener) {\n                signal.removeEventListener(\"abort\", abortListener);\n            }\n        };\n        function checkEmitted(emitted) {\n            if (predicate(emitted)) {\n                dispose();\n                res(emitted);\n            }\n        }\n        /**\n     * If the `signal` option is provided, this will be the listener for its\n     * `abort` event\n     */ let abortListener;\n        // eslint-disable-next-line prefer-const\n        let sub; // avoid TDZ when disposing synchronously\n        // See if the current snapshot already matches the predicate\n        checkEmitted(actorRef.getSnapshot());\n        if (done) {\n            return;\n        }\n        // only define the `abortListener` if the `signal` option is provided\n        if (signal) {\n            abortListener = ()=>{\n                dispose();\n                // XState does not \"own\" the signal, so we should reject with its reason (if any)\n                // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                rej(signal.reason);\n            };\n            signal.addEventListener(\"abort\", abortListener);\n        }\n        sub = actorRef.subscribe({\n            next: checkEmitted,\n            error: (err)=>{\n                dispose();\n                // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                rej(err);\n            },\n            complete: ()=>{\n                dispose();\n                rej(new Error(`Actor terminated without satisfying predicate`));\n            }\n        });\n        if (done) {\n            sub.unsubscribe();\n        }\n    });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHN0YXRlL2Rpc3QveHN0YXRlLmRldmVsb3BtZW50LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFtSztBQUM5RTtBQUM4UTtBQUNwUjtBQUNnQjtBQUNpRTtBQUM3RjtBQUNoQjtBQUVuRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXNCQyxHQUNELFNBQVN3RCxZQUFZQyxLQUFLLEVBQUVDLElBQUk7SUFDOUIsTUFBTUMsUUFBUXBELHFFQUFPQSxDQUFDbUQ7SUFDdEIsSUFBSSxDQUFDQyxNQUFNQyxRQUFRLENBQUNILE1BQU1DLElBQUksR0FBRztRQUMvQixNQUFNRyxZQUFZRixNQUFNRyxNQUFNLEtBQUssSUFBSSxDQUFDLE1BQU0sRUFBRUgsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLGNBQWMsRUFBRUEsTUFBTUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ3BHLE1BQU0sSUFBSUMsTUFBTSxDQUFDLGVBQWUsRUFBRUMsS0FBS0MsU0FBUyxDQUFDVCxPQUFPLFNBQVMsRUFBRUksVUFBVSxDQUFDO0lBQ2hGO0FBQ0Y7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F5Q0MsR0FDRCxTQUFTTSxjQUFjQyxNQUFNLEVBQUVDLGVBQWU7SUFDNUMsT0FBTyxJQUFJeEIsd0VBQVlBLENBQUN1QixRQUFRQztBQUNsQztBQUVBLGNBQWMsR0FDZCxTQUFTQyxzQkFBc0JDLFVBQVU7SUFDdkMsTUFBTUMsT0FBTy9ELHFFQUFXQSxDQUFDOEQ7SUFDekIsTUFBTUUsa0JBQWtCO1FBQ3RCRDtRQUNBRSxPQUFPLEtBQU87UUFDZEMsSUFBSTtRQUNKQyxRQUFRLEtBQU87UUFDZkMsV0FBVztRQUNYcEMsV0FBVyxLQUFPO1FBQ2xCcUMsUUFBUU4sS0FBS00sTUFBTTtRQUNuQjlCLE1B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QVQsSUFBSWU7WUFDTjtRQUNGO1FBRUE7OztLQUdDLEdBQ0QsSUFBSUg7UUFDSix3Q0FBd0M7UUFDeEMsSUFBSUYsS0FBSyx5Q0FBeUM7UUFFbEQsNERBQTREO1FBQzVESSxhQUFhbEIsU0FBU1osV0FBVztRQUNqQyxJQUFJcUIsTUFBTTtZQUNSO1FBQ0Y7UUFFQSxxRUFBcUU7UUFDckUsSUFBSUgsUUFBUTtZQUNWVSxnQkFBZ0I7Z0JBQ2RIO2dCQUNBLGlGQUFpRjtnQkFDakYsMkVBQTJFO2dCQUMzRVIsSUFBSUMsT0FBT0UsTUFBTTtZQUNuQjtZQUNBRixPQUFPYyxnQkFBZ0IsQ0FBQyxTQUFTSjtRQUNuQztRQUNBRixNQUFNZCxTQUFTZCxTQUFTLENBQUM7WUFDdkJtQyxNQUFNSDtZQUNONUIsT0FBT2dDLENBQUFBO2dCQUNMVDtnQkFDQSwyRUFBMkU7Z0JBQzNFUixJQUFJaUI7WUFDTjtZQUNBbkMsVUFBVTtnQkFDUjBCO2dCQUNBUixJQUFJLElBQUluRixNQUFNLENBQUMsNkNBQTZDLENBQUM7WUFDL0Q7UUFDRjtRQUNBLElBQUl1RixNQUFNO1lBQ1JLLElBQUlDLFdBQVc7UUFDakI7SUFDRjtBQUNGO0FBRXFKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXJhLXBvcnRmb2xpby8uL25vZGVfbW9kdWxlcy94c3RhdGUvZGlzdC94c3RhdGUuZGV2ZWxvcG1lbnQuZXNtLmpzPzRjZDQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgY3JlYXRlRW1wdHlBY3RvciwgZnJvbUNhbGxiYWNrLCBmcm9tRXZlbnRPYnNlcnZhYmxlLCBmcm9tT2JzZXJ2YWJsZSwgZnJvbVByb21pc2UsIGZyb21UcmFuc2l0aW9uIH0gZnJvbSAnLi4vYWN0b3JzL2Rpc3QveHN0YXRlLWFjdG9ycy5kZXZlbG9wbWVudC5lc20uanMnO1xuaW1wb3J0IHsgdCBhcyB0b0FycmF5LCBjIGFzIGNyZWF0ZUFjdG9yIH0gZnJvbSAnLi9yYWlzZS03OGI4ZGNiOC5kZXZlbG9wbWVudC5lc20uanMnO1xuZXhwb3J0IHsgQSBhcyBBY3RvciwgZCBhcyBfX3Vuc2FmZV9nZXRBbGxPd25FdmVudERlc2NyaXB0b3JzLCBhIGFzIGFuZCwgZiBhcyBjYW5jZWwsIGMgYXMgY3JlYXRlQWN0b3IsIGcgYXMgZ2V0U3RhdGVOb2RlcywgaSBhcyBpbnRlcnByZXQsIGIgYXMgaXNNYWNoaW5lU25hcHNob3QsIG0gYXMgbWF0Y2hlc1N0YXRlLCBuIGFzIG5vdCwgbyBhcyBvciwgcCBhcyBwYXRoVG9TdGF0ZVZhbHVlLCByIGFzIHJhaXNlLCBoIGFzIHNwYXduQ2hpbGQsIHMgYXMgc3RhdGVJbiwgaiBhcyBzdG9wLCBrIGFzIHN0b3BDaGlsZCwgZSBhcyB0b09ic2VydmVyIH0gZnJvbSAnLi9yYWlzZS03OGI4ZGNiOC5kZXZlbG9wbWVudC5lc20uanMnO1xuaW1wb3J0IHsgUyBhcyBTdGF0ZU1hY2hpbmUgfSBmcm9tICcuL1N0YXRlTWFjaGluZS1iNGU5NDQzOS5kZXZlbG9wbWVudC5lc20uanMnO1xuZXhwb3J0IHsgUyBhcyBTdGF0ZU1hY2hpbmUsIGEgYXMgU3RhdGVOb2RlIH0gZnJvbSAnLi9TdGF0ZU1hY2hpbmUtYjRlOTQ0MzkuZGV2ZWxvcG1lbnQuZXNtLmpzJztcbmV4cG9ydCB7IFMgYXMgU3BlY2lhbFRhcmdldHMsIGUgYXMgZW1pdCwgYSBhcyBlbnF1ZXVlQWN0aW9ucywgZiBhcyBmb3J3YXJkVG8sIGwgYXMgbG9nLCBzIGFzIHNlbmRQYXJlbnQsIGIgYXMgc2VuZFRvIH0gZnJvbSAnLi9sb2ctZWY5NTlkYTYuZGV2ZWxvcG1lbnQuZXNtLmpzJztcbmV4cG9ydCB7IGEgYXMgYXNzaWduIH0gZnJvbSAnLi9hc3NpZ24tNjMxM2NjYjMuZGV2ZWxvcG1lbnQuZXNtLmpzJztcbmltcG9ydCAnLi4vZGV2L2Rpc3QveHN0YXRlLWRldi5kZXZlbG9wbWVudC5lc20uanMnO1xuXG4vKipcbiAqIEFzc2VydHMgdGhhdCB0aGUgZ2l2ZW4gZXZlbnQgb2JqZWN0IGlzIG9mIHRoZSBzcGVjaWZpZWQgdHlwZSBvciB0eXBlcy4gVGhyb3dzXG4gKiBhbiBlcnJvciBpZiB0aGUgZXZlbnQgb2JqZWN0IGlzIG5vdCBvZiB0aGUgc3BlY2lmaWVkIHR5cGVzLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIC8vIC4uLlxuICogZW50cnk6ICh7IGV2ZW50IH0pID0+IHtcbiAqICAgYXNzZXJ0RXZlbnQoZXZlbnQsICdkb05vdGhpbmcnKTtcbiAqICAgLy8gZXZlbnQgaXMgeyB0eXBlOiAnZG9Ob3RoaW5nJyB9XG4gKiB9LFxuICogLy8gLi4uXG4gKiBleGl0OiAoeyBldmVudCB9KSA9PiB7XG4gKiAgIGFzc2VydEV2ZW50KGV2ZW50LCAnZ3JlZXQnKTtcbiAqICAgLy8gZXZlbnQgaXMgeyB0eXBlOiAnZ3JlZXQnOyBtZXNzYWdlOiBzdHJpbmcgfVxuICpcbiAqICAgYXNzZXJ0RXZlbnQoZXZlbnQsIFsnZ3JlZXQnLCAnbm90aWZ5J10pO1xuICogICAvLyBldmVudCBpcyB7IHR5cGU6ICdncmVldCc7IG1lc3NhZ2U6IHN0cmluZyB9XG4gKiAgIC8vIG9yIHsgdHlwZTogJ25vdGlmeSc7IG1lc3NhZ2U6IHN0cmluZzsgbGV2ZWw6ICdpbmZvJyB8ICdlcnJvcicgfVxuICogfSxcbiAqIGBgYFxuICovXG5mdW5jdGlvbiBhc3NlcnRFdmVudChldmVudCwgdHlwZSkge1xuICBjb25zdCB0eXBlcyA9IHRvQXJyYXkodHlwZSk7XG4gIGlmICghdHlwZXMuaW5jbHVkZXMoZXZlbnQudHlwZSkpIHtcbiAgICBjb25zdCB0eXBlc1RleHQgPSB0eXBlcy5sZW5ndGggPT09IDEgPyBgdHlwZSBcIiR7dHlwZXNbMF19XCJgIDogYG9uZSBvZiB0eXBlcyBcIiR7dHlwZXMuam9pbignXCIsIFwiJyl9XCJgO1xuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgZXZlbnQgJHtKU09OLnN0cmluZ2lmeShldmVudCl9IHRvIGhhdmUgJHt0eXBlc1RleHR9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhdGUgbWFjaGluZSAoc3RhdGVjaGFydCkgd2l0aCB0aGUgZ2l2ZW4gY29uZmlndXJhdGlvbi5cbiAqXG4gKiBUaGUgc3RhdGUgbWFjaGluZSByZXByZXNlbnRzIHRoZSBwdXJlIGxvZ2ljIG9mIGEgc3RhdGUgbWFjaGluZSBhY3Rvci5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBjcmVhdGVNYWNoaW5lIH0gZnJvbSAneHN0YXRlJztcbiAqXG4gKiBjb25zdCBsaWdodE1hY2hpbmUgPSBjcmVhdGVNYWNoaW5lKHtcbiAqICAgaWQ6ICdsaWdodCcsXG4gKiAgIGluaXRpYWw6ICdncmVlbicsXG4gKiAgIHN0YXRlczoge1xuICogICAgIGdyZWVuOiB7XG4gKiAgICAgICBvbjoge1xuICogICAgICAgICBUSU1FUjogeyB0YXJnZXQ6ICd5ZWxsb3cnIH1cbiAqICAgICAgIH1cbiAqICAgICB9LFxuICogICAgIHllbGxvdzoge1xuICogICAgICAgb246IHtcbiAqICAgICAgICAgVElNRVI6IHsgdGFyZ2V0OiAncmVkJyB9XG4gKiAgICAgICB9XG4gKiAgICAgfSxcbiAqICAgICByZWQ6IHtcbiAqICAgICAgIG9uOiB7XG4gKiAgICAgICAgIFRJTUVSOiB7IHRhcmdldDogJ2dyZWVuJyB9XG4gKiAgICAgICB9XG4gKiAgICAgfVxuICogICB9XG4gKiB9KTtcbiAqXG4gKiBjb25zdCBsaWdodEFjdG9yID0gY3JlYXRlQWN0b3IobGlnaHRNYWNoaW5lKTtcbiAqIGxpZ2h0QWN0b3Iuc3RhcnQoKTtcbiAqXG4gKiBsaWdodEFjdG9yLnNlbmQoeyB0eXBlOiAnVElNRVInIH0pO1xuICogYGBgXG4gKlxuICogQHBhcmFtIGNvbmZpZyBUaGUgc3RhdGUgbWFjaGluZSBjb25maWd1cmF0aW9uLlxuICogQHBhcmFtIG9wdGlvbnMgREVQUkVDQVRFRDogdXNlIGBzZXR1cCh7IC4uLiB9KWAgb3IgYG1hY2hpbmUucHJvdmlkZSh7IC4uLiB9KWBcbiAqICAgdG8gcHJvdmlkZSBtYWNoaW5lIGltcGxlbWVudGF0aW9ucyBpbnN0ZWFkLlxuICovXG5mdW5jdGlvbiBjcmVhdGVNYWNoaW5lKGNvbmZpZywgaW1wbGVtZW50YXRpb25zKSB7XG4gIHJldHVybiBuZXcgU3RhdGVNYWNoaW5lKGNvbmZpZywgaW1wbGVtZW50YXRpb25zKTtcbn1cblxuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gY3JlYXRlSW5lcnRBY3RvclNjb3BlKGFjdG9yTG9naWMpIHtcbiAgY29uc3Qgc2VsZiA9IGNyZWF0ZUFjdG9yKGFjdG9yTG9naWMpO1xuICBjb25zdCBpbmVydEFjdG9yU2NvcGUgPSB7XG4gICAgc2VsZixcbiAgICBkZWZlcjogKCkgPT4ge30sXG4gICAgaWQ6ICcnLFxuICAgIGxvZ2dlcjogKCkgPT4ge30sXG4gICAgc2Vzc2lvbklkOiAnJyxcbiAgICBzdG9wQ2hpbGQ6ICgpID0+IHt9LFxuICAgIHN5c3RlbTogc2VsZi5zeXN0ZW0sXG4gICAgZW1pdDogKCkgPT4ge30sXG4gICAgYWN0aW9uRXhlY3V0b3I6ICgpID0+IHt9XG4gIH07XG4gIHJldHVybiBpbmVydEFjdG9yU2NvcGU7XG59XG5cbi8qKiBAZGVwcmVjYXRlZCBVc2UgYGluaXRpYWxUcmFuc2l0aW9uKOKApilgIGluc3RlYWQuICovXG5mdW5jdGlvbiBnZXRJbml0aWFsU25hcHNob3QoYWN0b3JMb2dpYywgLi4uW2lucHV0XSkge1xuICBjb25zdCBhY3RvclNjb3BlID0gY3JlYXRlSW5lcnRBY3RvclNjb3BlKGFjdG9yTG9naWMpO1xuICByZXR1cm4gYWN0b3JMb2dpYy5nZXRJbml0aWFsU25hcHNob3QoYWN0b3JTY29wZSwgaW5wdXQpO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgdGhlIG5leHQgc25hcHNob3QgZm9yIHRoZSBnaXZlbiBgYWN0b3JMb2dpY2AgYmFzZWQgb24gdGhlIGdpdmVuXG4gKiBgc25hcHNob3RgIGFuZCBgZXZlbnRgLlxuICpcbiAqIElmIHRoZSBgc25hcHNob3RgIGlzIGB1bmRlZmluZWRgLCB0aGUgaW5pdGlhbCBzbmFwc2hvdCBvZiB0aGUgYGFjdG9yTG9naWNgIGlzXG4gKiB1c2VkLlxuICpcbiAqIEBkZXByZWNhdGVkIFVzZSBgdHJhbnNpdGlvbijigKYpYCBpbnN0ZWFkLlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgZ2V0TmV4dFNuYXBzaG90IH0gZnJvbSAneHN0YXRlJztcbiAqIGltcG9ydCB7IHRyYWZmaWNMaWdodE1hY2hpbmUgfSBmcm9tICcuL3RyYWZmaWNMaWdodE1hY2hpbmUudHMnO1xuICpcbiAqIGNvbnN0IG5leHRTbmFwc2hvdCA9IGdldE5leHRTbmFwc2hvdChcbiAqICAgdHJhZmZpY0xpZ2h0TWFjaGluZSwgLy8gYWN0b3IgbG9naWNcbiAqICAgdW5kZWZpbmVkLCAvLyBzbmFwc2hvdCAob3IgaW5pdGlhbCBzdGF0ZSBpZiB1bmRlZmluZWQpXG4gKiAgIHsgdHlwZTogJ1RJTUVSJyB9XG4gKiApOyAvLyBldmVudCBvYmplY3RcbiAqXG4gKiBjb25zb2xlLmxvZyhuZXh0U25hcHNob3QudmFsdWUpO1xuICogLy8gPT4gJ3llbGxvdydcbiAqXG4gKiBjb25zdCBuZXh0U25hcHNob3QyID0gZ2V0TmV4dFNuYXBzaG90KFxuICogICB0cmFmZmljTGlnaHRNYWNoaW5lLCAvLyBhY3RvciBsb2dpY1xuICogICBuZXh0U25hcHNob3QsIC8vIHNuYXBzaG90XG4gKiAgIHsgdHlwZTogJ1RJTUVSJyB9XG4gKiApOyAvLyBldmVudCBvYmplY3RcbiAqXG4gKiBjb25zb2xlLmxvZyhuZXh0U25hcHNob3QyLnZhbHVlKTtcbiAqIC8vID0+J3JlZCdcbiAqIGBgYFxuICovXG5mdW5jdGlvbiBnZXROZXh0U25hcHNob3QoYWN0b3JMb2dpYywgc25hcHNob3QsIGV2ZW50KSB7XG4gIGNvbnN0IGluZXJ0QWN0b3JTY29wZSA9IGNyZWF0ZUluZXJ0QWN0b3JTY29wZShhY3RvckxvZ2ljKTtcbiAgaW5lcnRBY3RvclNjb3BlLnNlbGYuX3NuYXBzaG90ID0gc25hcHNob3Q7XG4gIHJldHVybiBhY3RvckxvZ2ljLnRyYW5zaXRpb24oc25hcHNob3QsIGV2ZW50LCBpbmVydEFjdG9yU2NvcGUpO1xufVxuXG4vLyBhdCB0aGUgbW9tZW50IHdlIGFsbG93IGV4dHJhIGFjdG9ycyAtIG9uZXMgdGhhdCBhcmUgbm90IHNwZWNpZmllZCBieSBgY2hpbGRyZW5gXG4vLyB0aGlzIGNvdWxkIGJlIHJlY29uc2lkZXJlZCBpbiB0aGUgZnV0dXJlXG5cbmZ1bmN0aW9uIHNldHVwKHtcbiAgc2NoZW1hcyxcbiAgYWN0b3JzLFxuICBhY3Rpb25zLFxuICBndWFyZHMsXG4gIGRlbGF5c1xufSkge1xuICByZXR1cm4ge1xuICAgIGNyZWF0ZU1hY2hpbmU6IGNvbmZpZyA9PiBjcmVhdGVNYWNoaW5lKHtcbiAgICAgIC4uLmNvbmZpZyxcbiAgICAgIHNjaGVtYXNcbiAgICB9LCB7XG4gICAgICBhY3RvcnMsXG4gICAgICBhY3Rpb25zLFxuICAgICAgZ3VhcmRzLFxuICAgICAgZGVsYXlzXG4gICAgfSlcbiAgfTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZGVjbGFyYXRpb24tbWVyZ2luZ1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1kZWNsYXJhdGlvbi1tZXJnaW5nXG5jbGFzcyBTaW11bGF0ZWRDbG9jayB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudGltZW91dHMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fbm93ID0gMDtcbiAgICB0aGlzLl9pZCA9IDA7XG4gICAgdGhpcy5fZmx1c2hpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9mbHVzaGluZ0ludmFsaWRhdGVkID0gZmFsc2U7XG4gIH1cbiAgbm93KCkge1xuICAgIHJldHVybiB0aGlzLl9ub3c7XG4gIH1cbiAgZ2V0SWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lkKys7XG4gIH1cbiAgc2V0VGltZW91dChmbiwgdGltZW91dCkge1xuICAgIHRoaXMuX2ZsdXNoaW5nSW52YWxpZGF0ZWQgPSB0aGlzLl9mbHVzaGluZztcbiAgICBjb25zdCBpZCA9IHRoaXMuZ2V0SWQoKTtcbiAgICB0aGlzLnRpbWVvdXRzLnNldChpZCwge1xuICAgICAgc3RhcnQ6IHRoaXMubm93KCksXG4gICAgICB0aW1lb3V0LFxuICAgICAgZm5cbiAgICB9KTtcbiAgICByZXR1cm4gaWQ7XG4gIH1cbiAgY2xlYXJUaW1lb3V0KGlkKSB7XG4gICAgdGhpcy5fZmx1c2hpbmdJbnZhbGlkYXRlZCA9IHRoaXMuX2ZsdXNoaW5nO1xuICAgIHRoaXMudGltZW91dHMuZGVsZXRlKGlkKTtcbiAgfVxuICBzZXQodGltZSkge1xuICAgIGlmICh0aGlzLl9ub3cgPiB0aW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byB0cmF2ZWwgYmFjayBpbiB0aW1lJyk7XG4gICAgfVxuICAgIHRoaXMuX25vdyA9IHRpbWU7XG4gICAgdGhpcy5mbHVzaFRpbWVvdXRzKCk7XG4gIH1cbiAgZmx1c2hUaW1lb3V0cygpIHtcbiAgICBpZiAodGhpcy5fZmx1c2hpbmcpIHtcbiAgICAgIHRoaXMuX2ZsdXNoaW5nSW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9mbHVzaGluZyA9IHRydWU7XG4gICAgY29uc3Qgc29ydGVkID0gWy4uLnRoaXMudGltZW91dHNdLnNvcnQoKFtfaWRBLCB0aW1lb3V0QV0sIFtfaWRCLCB0aW1lb3V0Ql0pID0+IHtcbiAgICAgIGNvbnN0IGVuZEEgPSB0aW1lb3V0QS5zdGFydCArIHRpbWVvdXRBLnRpbWVvdXQ7XG4gICAgICBjb25zdCBlbmRCID0gdGltZW91dEIuc3RhcnQgKyB0aW1lb3V0Qi50aW1lb3V0O1xuICAgICAgcmV0dXJuIGVuZEIgPiBlbmRBID8gLTEgOiAxO1xuICAgIH0pO1xuICAgIGZvciAoY29uc3QgW2lkLCB0aW1lb3V0XSBvZiBzb3J0ZWQpIHtcbiAgICAgIGlmICh0aGlzLl9mbHVzaGluZ0ludmFsaWRhdGVkKSB7XG4gICAgICAgIHRoaXMuX2ZsdXNoaW5nSW52YWxpZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZmx1c2hpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5mbHVzaFRpbWVvdXRzKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm5vdygpIC0gdGltZW91dC5zdGFydCA+PSB0aW1lb3V0LnRpbWVvdXQpIHtcbiAgICAgICAgdGhpcy50aW1lb3V0cy5kZWxldGUoaWQpO1xuICAgICAgICB0aW1lb3V0LmZuLmNhbGwobnVsbCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2ZsdXNoaW5nID0gZmFsc2U7XG4gIH1cbiAgaW5jcmVtZW50KG1zKSB7XG4gICAgdGhpcy5fbm93ICs9IG1zO1xuICAgIHRoaXMuZmx1c2hUaW1lb3V0cygpO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgYG91dHB1dGAgb2YgdGhlIGFjdG9yIHdoZW4gaXQgaXMgZG9uZS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCBtYWNoaW5lID0gY3JlYXRlTWFjaGluZSh7XG4gKiAgIC8vIC4uLlxuICogICBvdXRwdXQ6IHtcbiAqICAgICBjb3VudDogNDJcbiAqICAgfVxuICogfSk7XG4gKlxuICogY29uc3QgYWN0b3IgPSBjcmVhdGVBY3RvcihtYWNoaW5lKTtcbiAqXG4gKiBhY3Rvci5zdGFydCgpO1xuICpcbiAqIGNvbnN0IG91dHB1dCA9IGF3YWl0IHRvUHJvbWlzZShhY3Rvcik7XG4gKlxuICogY29uc29sZS5sb2cob3V0cHV0KTtcbiAqIC8vIGxvZ3MgeyBjb3VudDogNDIgfVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIHRvUHJvbWlzZShhY3Rvcikge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGFjdG9yLnN1YnNjcmliZSh7XG4gICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICByZXNvbHZlKGFjdG9yLmdldFNuYXBzaG90KCkub3V0cHV0KTtcbiAgICAgIH0sXG4gICAgICBlcnJvcjogcmVqZWN0XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdpdmVuIGFjdG9yIGBsb2dpY2AsIGEgYHNuYXBzaG90YCwgYW5kIGFuIGBldmVudGAsIHJldHVybnMgYSB0dXBsZSBvZiB0aGVcbiAqIGBuZXh0U25hcHNob3RgIGFuZCBgYWN0aW9uc2AgdG8gZXhlY3V0ZS5cbiAqXG4gKiBUaGlzIGlzIGEgcHVyZSBmdW5jdGlvbiB0aGF0IGRvZXMgbm90IGV4ZWN1dGUgYGFjdGlvbnNgLlxuICovXG5mdW5jdGlvbiB0cmFuc2l0aW9uKGxvZ2ljLCBzbmFwc2hvdCwgZXZlbnQpIHtcbiAgY29uc3QgZXhlY3V0YWJsZUFjdGlvbnMgPSBbXTtcbiAgY29uc3QgYWN0b3JTY29wZSA9IGNyZWF0ZUluZXJ0QWN0b3JTY29wZShsb2dpYyk7XG4gIGFjdG9yU2NvcGUuYWN0aW9uRXhlY3V0b3IgPSBhY3Rpb24gPT4ge1xuICAgIGV4ZWN1dGFibGVBY3Rpb25zLnB1c2goYWN0aW9uKTtcbiAgfTtcbiAgY29uc3QgbmV4dFNuYXBzaG90ID0gbG9naWMudHJhbnNpdGlvbihzbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUpO1xuICByZXR1cm4gW25leHRTbmFwc2hvdCwgZXhlY3V0YWJsZUFjdGlvbnNdO1xufVxuXG4vKipcbiAqIEdpdmVuIGFjdG9yIGBsb2dpY2AgYW5kIG9wdGlvbmFsIGBpbnB1dGAsIHJldHVybnMgYSB0dXBsZSBvZiB0aGVcbiAqIGBuZXh0U25hcHNob3RgIGFuZCBgYWN0aW9uc2AgdG8gZXhlY3V0ZSBmcm9tIHRoZSBpbml0aWFsIHRyYW5zaXRpb24gKG5vXG4gKiBwcmV2aW91cyBzdGF0ZSkuXG4gKlxuICogVGhpcyBpcyBhIHB1cmUgZnVuY3Rpb24gdGhhdCBkb2VzIG5vdCBleGVjdXRlIGBhY3Rpb25zYC5cbiAqL1xuZnVuY3Rpb24gaW5pdGlhbFRyYW5zaXRpb24obG9naWMsIC4uLltpbnB1dF0pIHtcbiAgY29uc3QgZXhlY3V0YWJsZUFjdGlvbnMgPSBbXTtcbiAgY29uc3QgYWN0b3JTY29wZSA9IGNyZWF0ZUluZXJ0QWN0b3JTY29wZShsb2dpYyk7XG4gIGFjdG9yU2NvcGUuYWN0aW9uRXhlY3V0b3IgPSBhY3Rpb24gPT4ge1xuICAgIGV4ZWN1dGFibGVBY3Rpb25zLnB1c2goYWN0aW9uKTtcbiAgfTtcbiAgY29uc3QgbmV4dFNuYXBzaG90ID0gbG9naWMuZ2V0SW5pdGlhbFNuYXBzaG90KGFjdG9yU2NvcGUsIGlucHV0KTtcbiAgcmV0dXJuIFtuZXh0U25hcHNob3QsIGV4ZWN1dGFibGVBY3Rpb25zXTtcbn1cblxuY29uc3QgZGVmYXVsdFdhaXRGb3JPcHRpb25zID0ge1xuICB0aW1lb3V0OiBJbmZpbml0eSAvLyBtdWNoIG1vcmUgdGhhbiAxMCBzZWNvbmRzXG59O1xuXG4vKipcbiAqIFN1YnNjcmliZXMgdG8gYW4gYWN0b3IgcmVmIGFuZCB3YWl0cyBmb3IgaXRzIGVtaXR0ZWQgdmFsdWUgdG8gc2F0aXNmeSBhXG4gKiBwcmVkaWNhdGUsIGFuZCB0aGVuIHJlc29sdmVzIHdpdGggdGhhdCB2YWx1ZS4gV2lsbCB0aHJvdyBpZiB0aGUgZGVzaXJlZCBzdGF0ZVxuICogaXMgbm90IHJlYWNoZWQgYWZ0ZXIgYW4gb3B0aW9uYWwgdGltZW91dC4gKGRlZmF1bHRzIHRvIEluZmluaXR5KS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBzdGF0ZSA9IGF3YWl0IHdhaXRGb3Ioc29tZVNlcnZpY2UsIChzdGF0ZSkgPT4ge1xuICogICByZXR1cm4gc3RhdGUuaGFzVGFnKCdsb2FkZWQnKTtcbiAqIH0pO1xuICpcbiAqIHN0YXRlLmhhc1RhZygnbG9hZGVkJyk7IC8vIHRydWVcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhY3RvclJlZiBUaGUgYWN0b3IgcmVmIHRvIHN1YnNjcmliZSB0b1xuICogQHBhcmFtIHByZWRpY2F0ZSBEZXRlcm1pbmVzIGlmIGEgdmFsdWUgbWF0Y2hlcyB0aGUgY29uZGl0aW9uIHRvIHdhaXQgZm9yXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgZXZlbnR1YWxseSByZXNvbHZlcyB0byB0aGUgZW1pdHRlZCB2YWx1ZSB0aGF0IG1hdGNoZXNcbiAqICAgdGhlIGNvbmRpdGlvblxuICovXG5mdW5jdGlvbiB3YWl0Rm9yKGFjdG9yUmVmLCBwcmVkaWNhdGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzb2x2ZWRPcHRpb25zID0ge1xuICAgIC4uLmRlZmF1bHRXYWl0Rm9yT3B0aW9ucyxcbiAgICAuLi5vcHRpb25zXG4gIH07XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBzaWduYWxcbiAgICB9ID0gcmVzb2x2ZWRPcHRpb25zO1xuICAgIGlmIChzaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJlZmVyLXByb21pc2UtcmVqZWN0LWVycm9yc1xuICAgICAgcmVqKHNpZ25hbC5yZWFzb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgIGlmIChyZXNvbHZlZE9wdGlvbnMudGltZW91dCA8IDApIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ2B0aW1lb3V0YCBwYXNzZWQgdG8gYHdhaXRGb3JgIGlzIG5lZ2F0aXZlIGFuZCBpdCB3aWxsIHJlamVjdCBpdHMgaW50ZXJuYWwgcHJvbWlzZSBpbW1lZGlhdGVseS4nKTtcbiAgICB9XG4gICAgY29uc3QgaGFuZGxlID0gcmVzb2x2ZWRPcHRpb25zLnRpbWVvdXQgPT09IEluZmluaXR5ID8gdW5kZWZpbmVkIDogc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBkaXNwb3NlKCk7XG4gICAgICByZWoobmV3IEVycm9yKGBUaW1lb3V0IG9mICR7cmVzb2x2ZWRPcHRpb25zLnRpbWVvdXR9IG1zIGV4Y2VlZGVkYCkpO1xuICAgIH0sIHJlc29sdmVkT3B0aW9ucy50aW1lb3V0KTtcbiAgICBjb25zdCBkaXNwb3NlID0gKCkgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KGhhbmRsZSk7XG4gICAgICBkb25lID0gdHJ1ZTtcbiAgICAgIHN1Yj8udW5zdWJzY3JpYmUoKTtcbiAgICAgIGlmIChhYm9ydExpc3RlbmVyKSB7XG4gICAgICAgIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0TGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gY2hlY2tFbWl0dGVkKGVtaXR0ZWQpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUoZW1pdHRlZCkpIHtcbiAgICAgICAgZGlzcG9zZSgpO1xuICAgICAgICByZXMoZW1pdHRlZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIGBzaWduYWxgIG9wdGlvbiBpcyBwcm92aWRlZCwgdGhpcyB3aWxsIGJlIHRoZSBsaXN0ZW5lciBmb3IgaXRzXG4gICAgICogYGFib3J0YCBldmVudFxuICAgICAqL1xuICAgIGxldCBhYm9ydExpc3RlbmVyO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgICBsZXQgc3ViOyAvLyBhdm9pZCBURFogd2hlbiBkaXNwb3Npbmcgc3luY2hyb25vdXNseVxuXG4gICAgLy8gU2VlIGlmIHRoZSBjdXJyZW50IHNuYXBzaG90IGFscmVhZHkgbWF0Y2hlcyB0aGUgcHJlZGljYXRlXG4gICAgY2hlY2tFbWl0dGVkKGFjdG9yUmVmLmdldFNuYXBzaG90KCkpO1xuICAgIGlmIChkb25lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gb25seSBkZWZpbmUgdGhlIGBhYm9ydExpc3RlbmVyYCBpZiB0aGUgYHNpZ25hbGAgb3B0aW9uIGlzIHByb3ZpZGVkXG4gICAgaWYgKHNpZ25hbCkge1xuICAgICAgYWJvcnRMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgZGlzcG9zZSgpO1xuICAgICAgICAvLyBYU3RhdGUgZG9lcyBub3QgXCJvd25cIiB0aGUgc2lnbmFsLCBzbyB3ZSBzaG91bGQgcmVqZWN0IHdpdGggaXRzIHJlYXNvbiAoaWYgYW55KVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1wcm9taXNlLXJlamVjdC1lcnJvcnNcbiAgICAgICAgcmVqKHNpZ25hbC5yZWFzb24pO1xuICAgICAgfTtcbiAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0TGlzdGVuZXIpO1xuICAgIH1cbiAgICBzdWIgPSBhY3RvclJlZi5zdWJzY3JpYmUoe1xuICAgICAgbmV4dDogY2hlY2tFbWl0dGVkLFxuICAgICAgZXJyb3I6IGVyciA9PiB7XG4gICAgICAgIGRpc3Bvc2UoKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItcHJvbWlzZS1yZWplY3QtZXJyb3JzXG4gICAgICAgIHJlaihlcnIpO1xuICAgICAgfSxcbiAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgIGRpc3Bvc2UoKTtcbiAgICAgICAgcmVqKG5ldyBFcnJvcihgQWN0b3IgdGVybWluYXRlZCB3aXRob3V0IHNhdGlzZnlpbmcgcHJlZGljYXRlYCkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChkb25lKSB7XG4gICAgICBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgeyBTaW11bGF0ZWRDbG9jaywgYXNzZXJ0RXZlbnQsIGNyZWF0ZU1hY2hpbmUsIGdldEluaXRpYWxTbmFwc2hvdCwgZ2V0TmV4dFNuYXBzaG90LCBpbml0aWFsVHJhbnNpdGlvbiwgc2V0dXAsIHRvUHJvbWlzZSwgdHJhbnNpdGlvbiwgd2FpdEZvciB9O1xuIl0sIm5hbWVzIjpbImNyZWF0ZUVtcHR5QWN0b3IiLCJmcm9tQ2FsbGJhY2siLCJmcm9tRXZlbnRPYnNlcnZhYmxlIiwiZnJvbU9ic2VydmFibGUiLCJmcm9tUHJvbWlzZSIsImZyb21UcmFuc2l0aW9uIiwidCIsInRvQXJyYXkiLCJjIiwiY3JlYXRlQWN0b3IiLCJBIiwiQWN0b3IiLCJkIiwiX191bnNhZmVfZ2V0QWxsT3duRXZlbnREZXNjcmlwdG9ycyIsImEiLCJhbmQiLCJmIiwiY2FuY2VsIiwiZyIsImdldFN0YXRlTm9kZXMiLCJpIiwiaW50ZXJwcmV0IiwiYiIsImlzTWFjaGluZVNuYXBzaG90IiwibSIsIm1hdGNoZXNTdGF0ZSIsIm4iLCJub3QiLCJvIiwib3IiLCJwIiwicGF0aFRvU3RhdGVWYWx1ZSIsInIiLCJyYWlzZSIsImgiLCJzcGF3bkNoaWxkIiwicyIsInN0YXRlSW4iLCJqIiwic3RvcCIsImsiLCJzdG9wQ2hpbGQiLCJlIiwidG9PYnNlcnZlciIsIlMiLCJTdGF0ZU1hY2hpbmUiLCJTdGF0ZU5vZGUiLCJTcGVjaWFsVGFyZ2V0cyIsImVtaXQiLCJlbnF1ZXVlQWN0aW9ucyIsImZvcndhcmRUbyIsImwiLCJsb2ciLCJzZW5kUGFyZW50Iiwic2VuZFRvIiwiYXNzaWduIiwiYXNzZXJ0RXZlbnQiLCJldmVudCIsInR5cGUiLCJ0eXBlcyIsImluY2x1ZGVzIiwidHlwZXNUZXh0IiwibGVuZ3RoIiwiam9pbiIsIkVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsImNyZWF0ZU1hY2hpbmUiLCJjb25maWciLCJpbXBsZW1lbnRhdGlvbnMiLCJjcmVhdGVJbmVydEFjdG9yU2NvcGUiLCJhY3RvckxvZ2ljIiwic2VsZiIsImluZXJ0QWN0b3JTY29wZSIsImRlZmVyIiwiaWQiLCJsb2dnZXIiLCJzZXNzaW9uSWQiLCJzeXN0ZW0iLCJhY3Rpb25FeGVjdXRvciIsImdldEluaXRpYWxTbmFwc2hvdCIsImlucHV0IiwiYWN0b3JTY29wZSIsImdldE5leHRTbmFwc2hvdCIsInNuYXBzaG90IiwiX3NuYXBzaG90IiwidHJhbnNpdGlvbiIsInNldHVwIiwic2NoZW1hcyIsImFjdG9ycyIsImFjdGlvbnMiLCJndWFyZHMiLCJkZWxheXMiLCJTaW11bGF0ZWRDbG9jayIsImNvbnN0cnVjdG9yIiwidGltZW91dHMiLCJNYXAiLCJfbm93IiwiX2lkIiwiX2ZsdXNoaW5nIiwiX2ZsdXNoaW5nSW52YWxpZGF0ZWQiLCJub3ciLCJnZXRJZCIsInNldFRpbWVvdXQiLCJmbiIsInRpbWVvdXQiLCJzZXQiLCJzdGFydCIsImNsZWFyVGltZW91dCIsImRlbGV0ZSIsInRpbWUiLCJmbHVzaFRpbWVvdXRzIiwic29ydGVkIiwic29ydCIsIl9pZEEiLCJ0aW1lb3V0QSIsIl9pZEIiLCJ0aW1lb3V0QiIsImVuZEEiLCJlbmRCIiwiY2FsbCIsImluY3JlbWVudCIsIm1zIiwidG9Qcm9taXNlIiwiYWN0b3IiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInN1YnNjcmliZSIsImNvbXBsZXRlIiwiZ2V0U25hcHNob3QiLCJvdXRwdXQiLCJlcnJvciIsImxvZ2ljIiwiZXhlY3V0YWJsZUFjdGlvbnMiLCJhY3Rpb24iLCJwdXNoIiwibmV4dFNuYXBzaG90IiwiaW5pdGlhbFRyYW5zaXRpb24iLCJkZWZhdWx0V2FpdEZvck9wdGlvbnMiLCJJbmZpbml0eSIsIndhaXRGb3IiLCJhY3RvclJlZiIsInByZWRpY2F0ZSIsIm9wdGlvbnMiLCJyZXNvbHZlZE9wdGlvbnMiLCJyZXMiLCJyZWoiLCJzaWduYWwiLCJhYm9ydGVkIiwicmVhc29uIiwiZG9uZSIsImNvbnNvbGUiLCJoYW5kbGUiLCJ1bmRlZmluZWQiLCJkaXNwb3NlIiwic3ViIiwidW5zdWJzY3JpYmUiLCJhYm9ydExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNoZWNrRW1pdHRlZCIsImVtaXR0ZWQiLCJhZGRFdmVudExpc3RlbmVyIiwibmV4dCIsImVyciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xstate/dist/xstate.development.esm.js\n");

/***/ })

};
;