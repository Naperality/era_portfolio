/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-compiler-runtime";
exports.ids = ["vendor-chunks/react-compiler-runtime"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-compiler-runtime/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-compiler-runtime/dist/index.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @lightSyntaxTransform\n * @noflow\n * @nolint\n * @preventMunge\n * @preserve-invariant-messages\n */ \"use no memo\";\n\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all)=>{\n    for(var name in all)__defProp(target, name, {\n        get: all[name],\n        enumerable: true\n    });\n};\nvar __copyProps = (to, from, except, desc)=>{\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n            get: ()=>from[key],\n            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n        });\n    }\n    return to;\n};\nvar __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM\n    // file that has been converted to a CommonJS file using a Babel-\n    // compatible transform (i.e. \"__esModule\" has not been set), then set\n    // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n    isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n        value: mod,\n        enumerable: true\n    }) : target, mod));\nvar __toCommonJS = (mod)=>__copyProps(__defProp({}, \"__esModule\", {\n        value: true\n    }), mod);\n// src/index.ts\nvar index_exports = {};\n__export(index_exports, {\n    $dispatcherGuard: ()=>$dispatcherGuard,\n    $makeReadOnly: ()=>$makeReadOnly,\n    $reset: ()=>$reset,\n    $structuralCheck: ()=>$structuralCheck,\n    c: ()=>c,\n    clearRenderCounterRegistry: ()=>clearRenderCounterRegistry,\n    renderCounterRegistry: ()=>renderCounterRegistry,\n    useRenderCounter: ()=>useRenderCounter\n});\nmodule.exports = __toCommonJS(index_exports);\nvar React = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar { useRef, useEffect, isValidElement } = React;\nvar _a;\nvar ReactSecretInternals = //@ts-ignore\n(_a = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE) != null ? _a : React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\nvar $empty = Symbol.for(\"react.memo_cache_sentinel\");\nvar _a2;\nvar c = // @ts-expect-error\ntypeof ((_a2 = React.__COMPILER_RUNTIME) == null ? void 0 : _a2.c) === \"function\" ? // @ts-expect-error\nReact.__COMPILER_RUNTIME.c : function c2(size) {\n    return React.useMemo(()=>{\n        const $ = new Array(size);\n        for(let ii = 0; ii < size; ii++){\n            $[ii] = $empty;\n        }\n        $[$empty] = true;\n        return $;\n    }, []);\n};\nvar LazyGuardDispatcher = {};\n[\n    \"readContext\",\n    \"useCallback\",\n    \"useContext\",\n    \"useEffect\",\n    \"useImperativeHandle\",\n    \"useInsertionEffect\",\n    \"useLayoutEffect\",\n    \"useMemo\",\n    \"useReducer\",\n    \"useRef\",\n    \"useState\",\n    \"useDebugValue\",\n    \"useDeferredValue\",\n    \"useTransition\",\n    \"useMutableSource\",\n    \"useSyncExternalStore\",\n    \"useId\",\n    \"unstable_isNewReconciler\",\n    \"getCacheSignal\",\n    \"getCacheForType\",\n    \"useCacheRefresh\"\n].forEach((name)=>{\n    LazyGuardDispatcher[name] = ()=>{\n        throw new Error(`[React] Unexpected React hook call (${name}) from a React compiled function. Check that all hooks are called directly and named according to convention ('use[A-Z]') `);\n    };\n});\nvar originalDispatcher = null;\nLazyGuardDispatcher[\"useMemoCache\"] = (count)=>{\n    if (originalDispatcher == null) {\n        throw new Error(\"React Compiler internal invariant violation: unexpected null dispatcher\");\n    } else {\n        return originalDispatcher.useMemoCache(count);\n    }\n};\nfunction setCurrent(newDispatcher) {\n    ReactSecretInternals.ReactCurrentDispatcher.current = newDispatcher;\n    return ReactSecretInternals.ReactCurrentDispatcher.current;\n}\nvar guardFrames = [];\nfunction $dispatcherGuard(kind) {\n    const curr = ReactSecretInternals.ReactCurrentDispatcher.current;\n    if (kind === 0 /* PushGuardContext */ ) {\n        guardFrames.push(curr);\n        if (guardFrames.length === 1) {\n            originalDispatcher = curr;\n        }\n        if (curr === LazyGuardDispatcher) {\n            throw new Error(`[React] Unexpected call to custom hook or component from a React compiled function. Check that (1) all hooks are called directly and named according to convention ('use[A-Z]') and (2) components are returned as JSX instead of being directly invoked.`);\n        }\n        setCurrent(LazyGuardDispatcher);\n    } else if (kind === 1 /* PopGuardContext */ ) {\n        const lastFrame = guardFrames.pop();\n        if (lastFrame == null) {\n            throw new Error(\"React Compiler internal error: unexpected null in guard stack\");\n        }\n        if (guardFrames.length === 0) {\n            originalDispatcher = null;\n        }\n        setCurrent(lastFrame);\n    } else if (kind === 2 /* PushExpectHook */ ) {\n        guardFrames.push(curr);\n        setCurrent(originalDispatcher);\n    } else if (kind === 3 /* PopExpectHook */ ) {\n        const lastFrame = guardFrames.pop();\n        if (lastFrame == null) {\n            throw new Error(\"React Compiler internal error: unexpected null in guard stack\");\n        }\n        setCurrent(lastFrame);\n    } else {\n        throw new Error(\"React Compiler internal error: unreachable block\" + kind);\n    }\n}\nfunction $reset($) {\n    for(let ii = 0; ii < $.length; ii++){\n        $[ii] = $empty;\n    }\n}\nfunction $makeReadOnly() {\n    throw new Error(\"TODO: implement $makeReadOnly in react-compiler-runtime\");\n}\nvar renderCounterRegistry = /* @__PURE__ */ new Map();\nfunction clearRenderCounterRegistry() {\n    for (const counters of renderCounterRegistry.values()){\n        counters.forEach((counter)=>{\n            counter.count = 0;\n        });\n    }\n}\nfunction registerRenderCounter(name, val) {\n    let counters = renderCounterRegistry.get(name);\n    if (counters == null) {\n        counters = /* @__PURE__ */ new Set();\n        renderCounterRegistry.set(name, counters);\n    }\n    counters.add(val);\n}\nfunction removeRenderCounter(name, val) {\n    const counters = renderCounterRegistry.get(name);\n    if (counters == null) {\n        return;\n    }\n    counters.delete(val);\n}\nfunction useRenderCounter(name) {\n    const val = useRef(null);\n    if (val.current != null) {\n        val.current.count += 1;\n    }\n    useEffect(()=>{\n        if (val.current == null) {\n            const counter = {\n                count: 0\n            };\n            registerRenderCounter(name, counter);\n            val.current = counter;\n        }\n        return ()=>{\n            if (val.current !== null) {\n                removeRenderCounter(name, val.current);\n            }\n        };\n    });\n}\nvar seenErrors = /* @__PURE__ */ new Set();\nfunction $structuralCheck(oldValue, newValue, variableName, fnName, kind, loc) {\n    function error(l, r, path, depth) {\n        const str = `${fnName}:${loc} [${kind}] ${variableName}${path} changed from ${l} to ${r} at depth ${depth}`;\n        if (seenErrors.has(str)) {\n            return;\n        }\n        seenErrors.add(str);\n        console.error(str);\n    }\n    const depthLimit = 2;\n    function recur(oldValue2, newValue2, path, depth) {\n        if (depth > depthLimit) {\n            return;\n        } else if (oldValue2 === newValue2) {\n            return;\n        } else if (typeof oldValue2 !== typeof newValue2) {\n            error(`type ${typeof oldValue2}`, `type ${typeof newValue2}`, path, depth);\n        } else if (typeof oldValue2 === \"object\") {\n            const oldArray = Array.isArray(oldValue2);\n            const newArray = Array.isArray(newValue2);\n            if (oldValue2 === null && newValue2 !== null) {\n                error(\"null\", `type ${typeof newValue2}`, path, depth);\n            } else if (newValue2 === null) {\n                error(`type ${typeof oldValue2}`, \"null\", path, depth);\n            } else if (oldValue2 instanceof Map) {\n                if (!(newValue2 instanceof Map)) {\n                    error(`Map instance`, `other value`, path, depth);\n                } else if (oldValue2.size !== newValue2.size) {\n                    error(`Map instance with size ${oldValue2.size}`, `Map instance with size ${newValue2.size}`, path, depth);\n                } else {\n                    for (const [k, v] of oldValue2){\n                        if (!newValue2.has(k)) {\n                            error(`Map instance with key ${k}`, `Map instance without key ${k}`, path, depth);\n                        } else {\n                            recur(v, newValue2.get(k), `${path}.get(${k})`, depth + 1);\n                        }\n                    }\n                }\n            } else if (newValue2 instanceof Map) {\n                error(\"other value\", `Map instance`, path, depth);\n            } else if (oldValue2 instanceof Set) {\n                if (!(newValue2 instanceof Set)) {\n                    error(`Set instance`, `other value`, path, depth);\n                } else if (oldValue2.size !== newValue2.size) {\n                    error(`Set instance with size ${oldValue2.size}`, `Set instance with size ${newValue2.size}`, path, depth);\n                } else {\n                    for (const v of newValue2){\n                        if (!oldValue2.has(v)) {\n                            error(`Set instance without element ${v}`, `Set instance with element ${v}`, path, depth);\n                        }\n                    }\n                }\n            } else if (newValue2 instanceof Set) {\n                error(\"other value\", `Set instance`, path, depth);\n            } else if (oldArray || newArray) {\n                if (oldArray !== newArray) {\n                    error(`type ${oldArray ? \"array\" : \"object\"}`, `type ${newArray ? \"array\" : \"object\"}`, path, depth);\n                } else if (oldValue2.length !== newValue2.length) {\n                    error(`array with length ${oldValue2.length}`, `array with length ${newValue2.length}`, path, depth);\n                } else {\n                    for(let ii = 0; ii < oldValue2.length; ii++){\n                        recur(oldValue2[ii], newValue2[ii], `${path}[${ii}]`, depth + 1);\n                    }\n                }\n            } else if (isValidElement(oldValue2) || isValidElement(newValue2)) {\n                if (isValidElement(oldValue2) !== isValidElement(newValue2)) {\n                    error(`type ${isValidElement(oldValue2) ? \"React element\" : \"object\"}`, `type ${isValidElement(newValue2) ? \"React element\" : \"object\"}`, path, depth);\n                } else if (oldValue2.type !== newValue2.type) {\n                    error(`React element of type ${oldValue2.type}`, `React element of type ${newValue2.type}`, path, depth);\n                } else {\n                    recur(oldValue2.props, newValue2.props, `[props of ${path}]`, depth + 1);\n                }\n            } else {\n                for(const key in newValue2){\n                    if (!(key in oldValue2)) {\n                        error(`object without key ${key}`, `object with key ${key}`, path, depth);\n                    }\n                }\n                for(const key in oldValue2){\n                    if (!(key in newValue2)) {\n                        error(`object with key ${key}`, `object without key ${key}`, path, depth);\n                    } else {\n                        recur(oldValue2[key], newValue2[key], `${path}.${key}`, depth + 1);\n                    }\n                }\n            }\n        } else if (typeof oldValue2 === \"function\") {\n            return;\n        } else if (isNaN(oldValue2) || isNaN(newValue2)) {\n            if (isNaN(oldValue2) !== isNaN(newValue2)) {\n                error(`${isNaN(oldValue2) ? \"NaN\" : \"non-NaN value\"}`, `${isNaN(newValue2) ? \"NaN\" : \"non-NaN value\"}`, path, depth);\n            }\n        } else if (oldValue2 !== newValue2) {\n            error(oldValue2, newValue2, path, depth);\n        }\n    }\n    recur(oldValue, newValue, \"\", 0);\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtY29tcGlsZXItcnVudGltZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7OztDQVdDLEdBRUQ7QUFDQTtBQUNBLElBQUlBLFdBQVdDLE9BQU9DLE1BQU07QUFDNUIsSUFBSUMsWUFBWUYsT0FBT0csY0FBYztBQUNyQyxJQUFJQyxtQkFBbUJKLE9BQU9LLHdCQUF3QjtBQUN0RCxJQUFJQyxvQkFBb0JOLE9BQU9PLG1CQUFtQjtBQUNsRCxJQUFJQyxlQUFlUixPQUFPUyxjQUFjO0FBQ3hDLElBQUlDLGVBQWVWLE9BQU9XLFNBQVMsQ0FBQ0MsY0FBYztBQUNsRCxJQUFJQyxXQUFXLENBQUNDLFFBQVFDO0lBQ3RCLElBQUssSUFBSUMsUUFBUUQsSUFDZmIsVUFBVVksUUFBUUUsTUFBTTtRQUFFQyxLQUFLRixHQUFHLENBQUNDLEtBQUs7UUFBRUUsWUFBWTtJQUFLO0FBQy9EO0FBQ0EsSUFBSUMsY0FBYyxDQUFDQyxJQUFJQyxNQUFNQyxRQUFRQztJQUNuQyxJQUFJRixRQUFRLE9BQU9BLFNBQVMsWUFBWSxPQUFPQSxTQUFTLFlBQVk7UUFDbEUsS0FBSyxJQUFJRyxPQUFPbEIsa0JBQWtCZSxNQUNoQyxJQUFJLENBQUNYLGFBQWFlLElBQUksQ0FBQ0wsSUFBSUksUUFBUUEsUUFBUUYsUUFDekNwQixVQUFVa0IsSUFBSUksS0FBSztZQUFFUCxLQUFLLElBQU1JLElBQUksQ0FBQ0csSUFBSTtZQUFFTixZQUFZLENBQUVLLENBQUFBLE9BQU9uQixpQkFBaUJpQixNQUFNRyxJQUFHLEtBQU1ELEtBQUtMLFVBQVU7UUFBQztJQUN0SDtJQUNBLE9BQU9FO0FBQ1Q7QUFDQSxJQUFJTSxVQUFVLENBQUNDLEtBQUtDLFlBQVlkLFNBQVlBLENBQUFBLFNBQVNhLE9BQU8sT0FBTzVCLFNBQVNTLGFBQWFtQixRQUFRLENBQUMsR0FBR1IsWUFDbkcsc0VBQXNFO0lBQ3RFLGlFQUFpRTtJQUNqRSxzRUFBc0U7SUFD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UUFBUSxnQkFBZ0IsQ0FBQyxFQUMvQ1IsTUFDQUM7WUFFSjtRQUNGLE9BQU8sSUFBSU0sY0FBY0MsV0FBVztZQUNsQ1gsTUFBTVUsV0FBV0MsV0FBV1IsTUFBTUM7UUFDcEM7SUFDRjtJQUNBSyxNQUFNZCxVQUFVQyxVQUFVLElBQUk7QUFDaEM7QUFDQSw2REFBNkQ7QUFDN0QsS0FBTXBELENBQUFBLENBU04sR0FDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lcmEtcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWNvbXBpbGVyLXJ1bnRpbWUvZGlzdC9pbmRleC5qcz8zMzI5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGlnaHRTeW50YXhUcmFuc2Zvcm1cbiAqIEBub2Zsb3dcbiAqIEBub2xpbnRcbiAqIEBwcmV2ZW50TXVuZ2VcbiAqIEBwcmVzZXJ2ZS1pbnZhcmlhbnQtbWVzc2FnZXNcbiAqL1xuXG5cInVzZSBubyBtZW1vXCI7XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0VTTSA9IChtb2QsIGlzTm9kZU1vZGUsIHRhcmdldCkgPT4gKHRhcmdldCA9IG1vZCAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZCkpIDoge30sIF9fY29weVByb3BzKFxuICAvLyBJZiB0aGUgaW1wb3J0ZXIgaXMgaW4gbm9kZSBjb21wYXRpYmlsaXR5IG1vZGUgb3IgdGhpcyBpcyBub3QgYW4gRVNNXG4gIC8vIGZpbGUgdGhhdCBoYXMgYmVlbiBjb252ZXJ0ZWQgdG8gYSBDb21tb25KUyBmaWxlIHVzaW5nIGEgQmFiZWwtXG4gIC8vIGNvbXBhdGlibGUgdHJhbnNmb3JtIChpLmUuIFwiX19lc01vZHVsZVwiIGhhcyBub3QgYmVlbiBzZXQpLCB0aGVuIHNldFxuICAvLyBcImRlZmF1bHRcIiB0byB0aGUgQ29tbW9uSlMgXCJtb2R1bGUuZXhwb3J0c1wiIGZvciBub2RlIGNvbXBhdGliaWxpdHkuXG4gIGlzTm9kZU1vZGUgfHwgIW1vZCB8fCAhbW9kLl9fZXNNb2R1bGUgPyBfX2RlZlByb3AodGFyZ2V0LCBcImRlZmF1bHRcIiwgeyB2YWx1ZTogbW9kLCBlbnVtZXJhYmxlOiB0cnVlIH0pIDogdGFyZ2V0LFxuICBtb2RcbikpO1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIGluZGV4X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGluZGV4X2V4cG9ydHMsIHtcbiAgJGRpc3BhdGNoZXJHdWFyZDogKCkgPT4gJGRpc3BhdGNoZXJHdWFyZCxcbiAgJG1ha2VSZWFkT25seTogKCkgPT4gJG1ha2VSZWFkT25seSxcbiAgJHJlc2V0OiAoKSA9PiAkcmVzZXQsXG4gICRzdHJ1Y3R1cmFsQ2hlY2s6ICgpID0+ICRzdHJ1Y3R1cmFsQ2hlY2ssXG4gIGM6ICgpID0+IGMsXG4gIGNsZWFyUmVuZGVyQ291bnRlclJlZ2lzdHJ5OiAoKSA9PiBjbGVhclJlbmRlckNvdW50ZXJSZWdpc3RyeSxcbiAgcmVuZGVyQ291bnRlclJlZ2lzdHJ5OiAoKSA9PiByZW5kZXJDb3VudGVyUmVnaXN0cnksXG4gIHVzZVJlbmRlckNvdW50ZXI6ICgpID0+IHVzZVJlbmRlckNvdW50ZXJcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoaW5kZXhfZXhwb3J0cyk7XG52YXIgUmVhY3QgPSBfX3RvRVNNKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgeyB1c2VSZWYsIHVzZUVmZmVjdCwgaXNWYWxpZEVsZW1lbnQgfSA9IFJlYWN0O1xudmFyIF9hO1xudmFyIFJlYWN0U2VjcmV0SW50ZXJuYWxzID0gKFxuICAvL0B0cy1pZ25vcmVcbiAgKF9hID0gUmVhY3QuX19DTElFTlRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFKSAhPSBudWxsID8gX2EgOiBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRFxuKTtcbnZhciAkZW1wdHkgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb19jYWNoZV9zZW50aW5lbFwiKTtcbnZhciBfYTI7XG52YXIgYyA9IChcbiAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICB0eXBlb2YgKChfYTIgPSBSZWFjdC5fX0NPTVBJTEVSX1JVTlRJTUUpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuYykgPT09IFwiZnVuY3Rpb25cIiA/IChcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgUmVhY3QuX19DT01QSUxFUl9SVU5USU1FLmNcbiAgKSA6IGZ1bmN0aW9uIGMyKHNpemUpIHtcbiAgICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICBjb25zdCAkID0gbmV3IEFycmF5KHNpemUpO1xuICAgICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IHNpemU7IGlpKyspIHtcbiAgICAgICAgJFtpaV0gPSAkZW1wdHk7XG4gICAgICB9XG4gICAgICAkWyRlbXB0eV0gPSB0cnVlO1xuICAgICAgcmV0dXJuICQ7XG4gICAgfSwgW10pO1xuICB9XG4pO1xudmFyIExhenlHdWFyZERpc3BhdGNoZXIgPSB7fTtcbltcbiAgXCJyZWFkQ29udGV4dFwiLFxuICBcInVzZUNhbGxiYWNrXCIsXG4gIFwidXNlQ29udGV4dFwiLFxuICBcInVzZUVmZmVjdFwiLFxuICBcInVzZUltcGVyYXRpdmVIYW5kbGVcIixcbiAgXCJ1c2VJbnNlcnRpb25FZmZlY3RcIixcbiAgXCJ1c2VMYXlvdXRFZmZlY3RcIixcbiAgXCJ1c2VNZW1vXCIsXG4gIFwidXNlUmVkdWNlclwiLFxuICBcInVzZVJlZlwiLFxuICBcInVzZVN0YXRlXCIsXG4gIFwidXNlRGVidWdWYWx1ZVwiLFxuICBcInVzZURlZmVycmVkVmFsdWVcIixcbiAgXCJ1c2VUcmFuc2l0aW9uXCIsXG4gIFwidXNlTXV0YWJsZVNvdXJjZVwiLFxuICBcInVzZVN5bmNFeHRlcm5hbFN0b3JlXCIsXG4gIFwidXNlSWRcIixcbiAgXCJ1bnN0YWJsZV9pc05ld1JlY29uY2lsZXJcIixcbiAgXCJnZXRDYWNoZVNpZ25hbFwiLFxuICBcImdldENhY2hlRm9yVHlwZVwiLFxuICBcInVzZUNhY2hlUmVmcmVzaFwiXG5dLmZvckVhY2goKG5hbWUpID0+IHtcbiAgTGF6eUd1YXJkRGlzcGF0Y2hlcltuYW1lXSA9ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgW1JlYWN0XSBVbmV4cGVjdGVkIFJlYWN0IGhvb2sgY2FsbCAoJHtuYW1lfSkgZnJvbSBhIFJlYWN0IGNvbXBpbGVkIGZ1bmN0aW9uLiBDaGVjayB0aGF0IGFsbCBob29rcyBhcmUgY2FsbGVkIGRpcmVjdGx5IGFuZCBuYW1lZCBhY2NvcmRpbmcgdG8gY29udmVudGlvbiAoJ3VzZVtBLVpdJykgYFxuICAgICk7XG4gIH07XG59KTtcbnZhciBvcmlnaW5hbERpc3BhdGNoZXIgPSBudWxsO1xuTGF6eUd1YXJkRGlzcGF0Y2hlcltcInVzZU1lbW9DYWNoZVwiXSA9IChjb3VudCkgPT4ge1xuICBpZiAob3JpZ2luYWxEaXNwYXRjaGVyID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlJlYWN0IENvbXBpbGVyIGludGVybmFsIGludmFyaWFudCB2aW9sYXRpb246IHVuZXhwZWN0ZWQgbnVsbCBkaXNwYXRjaGVyXCJcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBvcmlnaW5hbERpc3BhdGNoZXIudXNlTWVtb0NhY2hlKGNvdW50KTtcbiAgfVxufTtcbmZ1bmN0aW9uIHNldEN1cnJlbnQobmV3RGlzcGF0Y2hlcikge1xuICBSZWFjdFNlY3JldEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBuZXdEaXNwYXRjaGVyO1xuICByZXR1cm4gUmVhY3RTZWNyZXRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50O1xufVxudmFyIGd1YXJkRnJhbWVzID0gW107XG5mdW5jdGlvbiAkZGlzcGF0Y2hlckd1YXJkKGtpbmQpIHtcbiAgY29uc3QgY3VyciA9IFJlYWN0U2VjcmV0SW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDtcbiAgaWYgKGtpbmQgPT09IDAgLyogUHVzaEd1YXJkQ29udGV4dCAqLykge1xuICAgIGd1YXJkRnJhbWVzLnB1c2goY3Vycik7XG4gICAgaWYgKGd1YXJkRnJhbWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgb3JpZ2luYWxEaXNwYXRjaGVyID0gY3VycjtcbiAgICB9XG4gICAgaWYgKGN1cnIgPT09IExhenlHdWFyZERpc3BhdGNoZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFtSZWFjdF0gVW5leHBlY3RlZCBjYWxsIHRvIGN1c3RvbSBob29rIG9yIGNvbXBvbmVudCBmcm9tIGEgUmVhY3QgY29tcGlsZWQgZnVuY3Rpb24uIENoZWNrIHRoYXQgKDEpIGFsbCBob29rcyBhcmUgY2FsbGVkIGRpcmVjdGx5IGFuZCBuYW1lZCBhY2NvcmRpbmcgdG8gY29udmVudGlvbiAoJ3VzZVtBLVpdJykgYW5kICgyKSBjb21wb25lbnRzIGFyZSByZXR1cm5lZCBhcyBKU1ggaW5zdGVhZCBvZiBiZWluZyBkaXJlY3RseSBpbnZva2VkLmBcbiAgICAgICk7XG4gICAgfVxuICAgIHNldEN1cnJlbnQoTGF6eUd1YXJkRGlzcGF0Y2hlcik7XG4gIH0gZWxzZSBpZiAoa2luZCA9PT0gMSAvKiBQb3BHdWFyZENvbnRleHQgKi8pIHtcbiAgICBjb25zdCBsYXN0RnJhbWUgPSBndWFyZEZyYW1lcy5wb3AoKTtcbiAgICBpZiAobGFzdEZyYW1lID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJSZWFjdCBDb21waWxlciBpbnRlcm5hbCBlcnJvcjogdW5leHBlY3RlZCBudWxsIGluIGd1YXJkIHN0YWNrXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChndWFyZEZyYW1lcy5sZW5ndGggPT09IDApIHtcbiAgICAgIG9yaWdpbmFsRGlzcGF0Y2hlciA9IG51bGw7XG4gICAgfVxuICAgIHNldEN1cnJlbnQobGFzdEZyYW1lKTtcbiAgfSBlbHNlIGlmIChraW5kID09PSAyIC8qIFB1c2hFeHBlY3RIb29rICovKSB7XG4gICAgZ3VhcmRGcmFtZXMucHVzaChjdXJyKTtcbiAgICBzZXRDdXJyZW50KG9yaWdpbmFsRGlzcGF0Y2hlcik7XG4gIH0gZWxzZSBpZiAoa2luZCA9PT0gMyAvKiBQb3BFeHBlY3RIb29rICovKSB7XG4gICAgY29uc3QgbGFzdEZyYW1lID0gZ3VhcmRGcmFtZXMucG9wKCk7XG4gICAgaWYgKGxhc3RGcmFtZSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiUmVhY3QgQ29tcGlsZXIgaW50ZXJuYWwgZXJyb3I6IHVuZXhwZWN0ZWQgbnVsbCBpbiBndWFyZCBzdGFja1wiXG4gICAgICApO1xuICAgIH1cbiAgICBzZXRDdXJyZW50KGxhc3RGcmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUmVhY3QgQ29tcGlsZXIgaW50ZXJuYWwgZXJyb3I6IHVucmVhY2hhYmxlIGJsb2NrXCIgKyBraW5kKTtcbiAgfVxufVxuZnVuY3Rpb24gJHJlc2V0KCQpIHtcbiAgZm9yIChsZXQgaWkgPSAwOyBpaSA8ICQubGVuZ3RoOyBpaSsrKSB7XG4gICAgJFtpaV0gPSAkZW1wdHk7XG4gIH1cbn1cbmZ1bmN0aW9uICRtYWtlUmVhZE9ubHkoKSB7XG4gIHRocm93IG5ldyBFcnJvcihcIlRPRE86IGltcGxlbWVudCAkbWFrZVJlYWRPbmx5IGluIHJlYWN0LWNvbXBpbGVyLXJ1bnRpbWVcIik7XG59XG52YXIgcmVuZGVyQ291bnRlclJlZ2lzdHJ5ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGNsZWFyUmVuZGVyQ291bnRlclJlZ2lzdHJ5KCkge1xuICBmb3IgKGNvbnN0IGNvdW50ZXJzIG9mIHJlbmRlckNvdW50ZXJSZWdpc3RyeS52YWx1ZXMoKSkge1xuICAgIGNvdW50ZXJzLmZvckVhY2goKGNvdW50ZXIpID0+IHtcbiAgICAgIGNvdW50ZXIuY291bnQgPSAwO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiByZWdpc3RlclJlbmRlckNvdW50ZXIobmFtZSwgdmFsKSB7XG4gIGxldCBjb3VudGVycyA9IHJlbmRlckNvdW50ZXJSZWdpc3RyeS5nZXQobmFtZSk7XG4gIGlmIChjb3VudGVycyA9PSBudWxsKSB7XG4gICAgY291bnRlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHJlbmRlckNvdW50ZXJSZWdpc3RyeS5zZXQobmFtZSwgY291bnRlcnMpO1xuICB9XG4gIGNvdW50ZXJzLmFkZCh2YWwpO1xufVxuZnVuY3Rpb24gcmVtb3ZlUmVuZGVyQ291bnRlcihuYW1lLCB2YWwpIHtcbiAgY29uc3QgY291bnRlcnMgPSByZW5kZXJDb3VudGVyUmVnaXN0cnkuZ2V0KG5hbWUpO1xuICBpZiAoY291bnRlcnMgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb3VudGVycy5kZWxldGUodmFsKTtcbn1cbmZ1bmN0aW9uIHVzZVJlbmRlckNvdW50ZXIobmFtZSkge1xuICBjb25zdCB2YWwgPSB1c2VSZWYobnVsbCk7XG4gIGlmICh2YWwuY3VycmVudCAhPSBudWxsKSB7XG4gICAgdmFsLmN1cnJlbnQuY291bnQgKz0gMTtcbiAgfVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh2YWwuY3VycmVudCA9PSBudWxsKSB7XG4gICAgICBjb25zdCBjb3VudGVyID0geyBjb3VudDogMCB9O1xuICAgICAgcmVnaXN0ZXJSZW5kZXJDb3VudGVyKG5hbWUsIGNvdW50ZXIpO1xuICAgICAgdmFsLmN1cnJlbnQgPSBjb3VudGVyO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKHZhbC5jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHJlbW92ZVJlbmRlckNvdW50ZXIobmFtZSwgdmFsLmN1cnJlbnQpO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxudmFyIHNlZW5FcnJvcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuZnVuY3Rpb24gJHN0cnVjdHVyYWxDaGVjayhvbGRWYWx1ZSwgbmV3VmFsdWUsIHZhcmlhYmxlTmFtZSwgZm5OYW1lLCBraW5kLCBsb2MpIHtcbiAgZnVuY3Rpb24gZXJyb3IobCwgciwgcGF0aCwgZGVwdGgpIHtcbiAgICBjb25zdCBzdHIgPSBgJHtmbk5hbWV9OiR7bG9jfSBbJHtraW5kfV0gJHt2YXJpYWJsZU5hbWV9JHtwYXRofSBjaGFuZ2VkIGZyb20gJHtsfSB0byAke3J9IGF0IGRlcHRoICR7ZGVwdGh9YDtcbiAgICBpZiAoc2VlbkVycm9ycy5oYXMoc3RyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZWVuRXJyb3JzLmFkZChzdHIpO1xuICAgIGNvbnNvbGUuZXJyb3Ioc3RyKTtcbiAgfVxuICBjb25zdCBkZXB0aExpbWl0ID0gMjtcbiAgZnVuY3Rpb24gcmVjdXIob2xkVmFsdWUyLCBuZXdWYWx1ZTIsIHBhdGgsIGRlcHRoKSB7XG4gICAgaWYgKGRlcHRoID4gZGVwdGhMaW1pdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAob2xkVmFsdWUyID09PSBuZXdWYWx1ZTIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvbGRWYWx1ZTIgIT09IHR5cGVvZiBuZXdWYWx1ZTIpIHtcbiAgICAgIGVycm9yKGB0eXBlICR7dHlwZW9mIG9sZFZhbHVlMn1gLCBgdHlwZSAke3R5cGVvZiBuZXdWYWx1ZTJ9YCwgcGF0aCwgZGVwdGgpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9sZFZhbHVlMiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgY29uc3Qgb2xkQXJyYXkgPSBBcnJheS5pc0FycmF5KG9sZFZhbHVlMik7XG4gICAgICBjb25zdCBuZXdBcnJheSA9IEFycmF5LmlzQXJyYXkobmV3VmFsdWUyKTtcbiAgICAgIGlmIChvbGRWYWx1ZTIgPT09IG51bGwgJiYgbmV3VmFsdWUyICE9PSBudWxsKSB7XG4gICAgICAgIGVycm9yKFwibnVsbFwiLCBgdHlwZSAke3R5cGVvZiBuZXdWYWx1ZTJ9YCwgcGF0aCwgZGVwdGgpO1xuICAgICAgfSBlbHNlIGlmIChuZXdWYWx1ZTIgPT09IG51bGwpIHtcbiAgICAgICAgZXJyb3IoYHR5cGUgJHt0eXBlb2Ygb2xkVmFsdWUyfWAsIFwibnVsbFwiLCBwYXRoLCBkZXB0aCk7XG4gICAgICB9IGVsc2UgaWYgKG9sZFZhbHVlMiBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBpZiAoIShuZXdWYWx1ZTIgaW5zdGFuY2VvZiBNYXApKSB7XG4gICAgICAgICAgZXJyb3IoYE1hcCBpbnN0YW5jZWAsIGBvdGhlciB2YWx1ZWAsIHBhdGgsIGRlcHRoKTtcbiAgICAgICAgfSBlbHNlIGlmIChvbGRWYWx1ZTIuc2l6ZSAhPT0gbmV3VmFsdWUyLnNpemUpIHtcbiAgICAgICAgICBlcnJvcihcbiAgICAgICAgICAgIGBNYXAgaW5zdGFuY2Ugd2l0aCBzaXplICR7b2xkVmFsdWUyLnNpemV9YCxcbiAgICAgICAgICAgIGBNYXAgaW5zdGFuY2Ugd2l0aCBzaXplICR7bmV3VmFsdWUyLnNpemV9YCxcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBkZXB0aFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2Ygb2xkVmFsdWUyKSB7XG4gICAgICAgICAgICBpZiAoIW5ld1ZhbHVlMi5oYXMoaykpIHtcbiAgICAgICAgICAgICAgZXJyb3IoXG4gICAgICAgICAgICAgICAgYE1hcCBpbnN0YW5jZSB3aXRoIGtleSAke2t9YCxcbiAgICAgICAgICAgICAgICBgTWFwIGluc3RhbmNlIHdpdGhvdXQga2V5ICR7a31gLFxuICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgZGVwdGhcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlY3VyKHYsIG5ld1ZhbHVlMi5nZXQoayksIGAke3BhdGh9LmdldCgke2t9KWAsIGRlcHRoICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5ld1ZhbHVlMiBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBlcnJvcihcIm90aGVyIHZhbHVlXCIsIGBNYXAgaW5zdGFuY2VgLCBwYXRoLCBkZXB0aCk7XG4gICAgICB9IGVsc2UgaWYgKG9sZFZhbHVlMiBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICBpZiAoIShuZXdWYWx1ZTIgaW5zdGFuY2VvZiBTZXQpKSB7XG4gICAgICAgICAgZXJyb3IoYFNldCBpbnN0YW5jZWAsIGBvdGhlciB2YWx1ZWAsIHBhdGgsIGRlcHRoKTtcbiAgICAgICAgfSBlbHNlIGlmIChvbGRWYWx1ZTIuc2l6ZSAhPT0gbmV3VmFsdWUyLnNpemUpIHtcbiAgICAgICAgICBlcnJvcihcbiAgICAgICAgICAgIGBTZXQgaW5zdGFuY2Ugd2l0aCBzaXplICR7b2xkVmFsdWUyLnNpemV9YCxcbiAgICAgICAgICAgIGBTZXQgaW5zdGFuY2Ugd2l0aCBzaXplICR7bmV3VmFsdWUyLnNpemV9YCxcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBkZXB0aFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChjb25zdCB2IG9mIG5ld1ZhbHVlMikge1xuICAgICAgICAgICAgaWYgKCFvbGRWYWx1ZTIuaGFzKHYpKSB7XG4gICAgICAgICAgICAgIGVycm9yKFxuICAgICAgICAgICAgICAgIGBTZXQgaW5zdGFuY2Ugd2l0aG91dCBlbGVtZW50ICR7dn1gLFxuICAgICAgICAgICAgICAgIGBTZXQgaW5zdGFuY2Ugd2l0aCBlbGVtZW50ICR7dn1gLFxuICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgZGVwdGhcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobmV3VmFsdWUyIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIGVycm9yKFwib3RoZXIgdmFsdWVcIiwgYFNldCBpbnN0YW5jZWAsIHBhdGgsIGRlcHRoKTtcbiAgICAgIH0gZWxzZSBpZiAob2xkQXJyYXkgfHwgbmV3QXJyYXkpIHtcbiAgICAgICAgaWYgKG9sZEFycmF5ICE9PSBuZXdBcnJheSkge1xuICAgICAgICAgIGVycm9yKFxuICAgICAgICAgICAgYHR5cGUgJHtvbGRBcnJheSA/IFwiYXJyYXlcIiA6IFwib2JqZWN0XCJ9YCxcbiAgICAgICAgICAgIGB0eXBlICR7bmV3QXJyYXkgPyBcImFycmF5XCIgOiBcIm9iamVjdFwifWAsXG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgZGVwdGhcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKG9sZFZhbHVlMi5sZW5ndGggIT09IG5ld1ZhbHVlMi5sZW5ndGgpIHtcbiAgICAgICAgICBlcnJvcihcbiAgICAgICAgICAgIGBhcnJheSB3aXRoIGxlbmd0aCAke29sZFZhbHVlMi5sZW5ndGh9YCxcbiAgICAgICAgICAgIGBhcnJheSB3aXRoIGxlbmd0aCAke25ld1ZhbHVlMi5sZW5ndGh9YCxcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBkZXB0aFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IG9sZFZhbHVlMi5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgICAgIHJlY3VyKG9sZFZhbHVlMltpaV0sIG5ld1ZhbHVlMltpaV0sIGAke3BhdGh9WyR7aWl9XWAsIGRlcHRoICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG9sZFZhbHVlMikgfHwgaXNWYWxpZEVsZW1lbnQobmV3VmFsdWUyKSkge1xuICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQob2xkVmFsdWUyKSAhPT0gaXNWYWxpZEVsZW1lbnQobmV3VmFsdWUyKSkge1xuICAgICAgICAgIGVycm9yKFxuICAgICAgICAgICAgYHR5cGUgJHtpc1ZhbGlkRWxlbWVudChvbGRWYWx1ZTIpID8gXCJSZWFjdCBlbGVtZW50XCIgOiBcIm9iamVjdFwifWAsXG4gICAgICAgICAgICBgdHlwZSAke2lzVmFsaWRFbGVtZW50KG5ld1ZhbHVlMikgPyBcIlJlYWN0IGVsZW1lbnRcIiA6IFwib2JqZWN0XCJ9YCxcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBkZXB0aFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAob2xkVmFsdWUyLnR5cGUgIT09IG5ld1ZhbHVlMi50eXBlKSB7XG4gICAgICAgICAgZXJyb3IoXG4gICAgICAgICAgICBgUmVhY3QgZWxlbWVudCBvZiB0eXBlICR7b2xkVmFsdWUyLnR5cGV9YCxcbiAgICAgICAgICAgIGBSZWFjdCBlbGVtZW50IG9mIHR5cGUgJHtuZXdWYWx1ZTIudHlwZX1gLFxuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIGRlcHRoXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWN1cihcbiAgICAgICAgICAgIG9sZFZhbHVlMi5wcm9wcyxcbiAgICAgICAgICAgIG5ld1ZhbHVlMi5wcm9wcyxcbiAgICAgICAgICAgIGBbcHJvcHMgb2YgJHtwYXRofV1gLFxuICAgICAgICAgICAgZGVwdGggKyAxXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbmV3VmFsdWUyKSB7XG4gICAgICAgICAgaWYgKCEoa2V5IGluIG9sZFZhbHVlMikpIHtcbiAgICAgICAgICAgIGVycm9yKFxuICAgICAgICAgICAgICBgb2JqZWN0IHdpdGhvdXQga2V5ICR7a2V5fWAsXG4gICAgICAgICAgICAgIGBvYmplY3Qgd2l0aCBrZXkgJHtrZXl9YCxcbiAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgZGVwdGhcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9sZFZhbHVlMikge1xuICAgICAgICAgIGlmICghKGtleSBpbiBuZXdWYWx1ZTIpKSB7XG4gICAgICAgICAgICBlcnJvcihcbiAgICAgICAgICAgICAgYG9iamVjdCB3aXRoIGtleSAke2tleX1gLFxuICAgICAgICAgICAgICBgb2JqZWN0IHdpdGhvdXQga2V5ICR7a2V5fWAsXG4gICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgIGRlcHRoXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWN1cihvbGRWYWx1ZTJba2V5XSwgbmV3VmFsdWUyW2tleV0sIGAke3BhdGh9LiR7a2V5fWAsIGRlcHRoICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb2xkVmFsdWUyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKGlzTmFOKG9sZFZhbHVlMikgfHwgaXNOYU4obmV3VmFsdWUyKSkge1xuICAgICAgaWYgKGlzTmFOKG9sZFZhbHVlMikgIT09IGlzTmFOKG5ld1ZhbHVlMikpIHtcbiAgICAgICAgZXJyb3IoXG4gICAgICAgICAgYCR7aXNOYU4ob2xkVmFsdWUyKSA/IFwiTmFOXCIgOiBcIm5vbi1OYU4gdmFsdWVcIn1gLFxuICAgICAgICAgIGAke2lzTmFOKG5ld1ZhbHVlMikgPyBcIk5hTlwiIDogXCJub24tTmFOIHZhbHVlXCJ9YCxcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIGRlcHRoXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvbGRWYWx1ZTIgIT09IG5ld1ZhbHVlMikge1xuICAgICAgZXJyb3Iob2xkVmFsdWUyLCBuZXdWYWx1ZTIsIHBhdGgsIGRlcHRoKTtcbiAgICB9XG4gIH1cbiAgcmVjdXIob2xkVmFsdWUsIG5ld1ZhbHVlLCBcIlwiLCAwKTtcbn1cbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAkZGlzcGF0Y2hlckd1YXJkLFxuICAkbWFrZVJlYWRPbmx5LFxuICAkcmVzZXQsXG4gICRzdHJ1Y3R1cmFsQ2hlY2ssXG4gIGMsXG4gIGNsZWFyUmVuZGVyQ291bnRlclJlZ2lzdHJ5LFxuICByZW5kZXJDb3VudGVyUmVnaXN0cnksXG4gIHVzZVJlbmRlckNvdW50ZXJcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIl9fY3JlYXRlIiwiT2JqZWN0IiwiY3JlYXRlIiwiX19kZWZQcm9wIiwiZGVmaW5lUHJvcGVydHkiLCJfX2dldE93blByb3BEZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiX19nZXRPd25Qcm9wTmFtZXMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiX19nZXRQcm90b09mIiwiZ2V0UHJvdG90eXBlT2YiLCJfX2hhc093blByb3AiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsIl9fZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImdldCIsImVudW1lcmFibGUiLCJfX2NvcHlQcm9wcyIsInRvIiwiZnJvbSIsImV4Y2VwdCIsImRlc2MiLCJrZXkiLCJjYWxsIiwiX190b0VTTSIsIm1vZCIsImlzTm9kZU1vZGUiLCJfX2VzTW9kdWxlIiwidmFsdWUiLCJfX3RvQ29tbW9uSlMiLCJpbmRleF9leHBvcnRzIiwiJGRpc3BhdGNoZXJHdWFyZCIsIiRtYWtlUmVhZE9ubHkiLCIkcmVzZXQiLCIkc3RydWN0dXJhbENoZWNrIiwiYyIsImNsZWFyUmVuZGVyQ291bnRlclJlZ2lzdHJ5IiwicmVuZGVyQ291bnRlclJlZ2lzdHJ5IiwidXNlUmVuZGVyQ291bnRlciIsIm1vZHVsZSIsImV4cG9ydHMiLCJSZWFjdCIsInJlcXVpcmUiLCJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJpc1ZhbGlkRWxlbWVudCIsIl9hIiwiUmVhY3RTZWNyZXRJbnRlcm5hbHMiLCJfX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUiLCJfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCIsIiRlbXB0eSIsIlN5bWJvbCIsImZvciIsIl9hMiIsIl9fQ09NUElMRVJfUlVOVElNRSIsImMyIiwic2l6ZSIsInVzZU1lbW8iLCIkIiwiQXJyYXkiLCJpaSIsIkxhenlHdWFyZERpc3BhdGNoZXIiLCJmb3JFYWNoIiwiRXJyb3IiLCJvcmlnaW5hbERpc3BhdGNoZXIiLCJjb3VudCIsInVzZU1lbW9DYWNoZSIsInNldEN1cnJlbnQiLCJuZXdEaXNwYXRjaGVyIiwiUmVhY3RDdXJyZW50RGlzcGF0Y2hlciIsImN1cnJlbnQiLCJndWFyZEZyYW1lcyIsImtpbmQiLCJjdXJyIiwicHVzaCIsImxlbmd0aCIsImxhc3RGcmFtZSIsInBvcCIsIk1hcCIsImNvdW50ZXJzIiwidmFsdWVzIiwiY291bnRlciIsInJlZ2lzdGVyUmVuZGVyQ291bnRlciIsInZhbCIsIlNldCIsInNldCIsImFkZCIsInJlbW92ZVJlbmRlckNvdW50ZXIiLCJkZWxldGUiLCJzZWVuRXJyb3JzIiwib2xkVmFsdWUiLCJuZXdWYWx1ZSIsInZhcmlhYmxlTmFtZSIsImZuTmFtZSIsImxvYyIsImVycm9yIiwibCIsInIiLCJwYXRoIiwiZGVwdGgiLCJzdHIiLCJoYXMiLCJjb25zb2xlIiwiZGVwdGhMaW1pdCIsInJlY3VyIiwib2xkVmFsdWUyIiwibmV3VmFsdWUyIiwib2xkQXJyYXkiLCJpc0FycmF5IiwibmV3QXJyYXkiLCJrIiwidiIsInR5cGUiLCJwcm9wcyIsImlzTmFOIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-compiler-runtime/dist/index.js\n");

/***/ })

};
;