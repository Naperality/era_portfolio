"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_sanity_client_dist__chunks-es_stegaEncodeSourceMap_js"],{

/***/ "(app-pages-browser)/./node_modules/@sanity/client/dist/_chunks-es/stegaEncodeSourceMap.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@sanity/client/dist/_chunks-es/stegaEncodeSourceMap.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeIntoResult: function() { return /* binding */ encodeIntoResult; },\n/* harmony export */   stegaEncodeSourceMap: function() { return /* binding */ stegaEncodeSourceMap; },\n/* harmony export */   stegaEncodeSourceMap$1: function() { return /* binding */ stegaEncodeSourceMap$1; }\n/* harmony export */ });\n/* harmony import */ var _stegaClean_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stegaClean.js */ \"(app-pages-browser)/./node_modules/@sanity/client/dist/_chunks-es/stegaClean.js\");\n\nconst reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/;\nfunction isKeySegment(segment) {\n    return typeof segment == \"string\" ? reKeySegment.test(segment.trim()) : typeof segment == \"object\" && \"_key\" in segment;\n}\nfunction toString(path) {\n    if (!Array.isArray(path)) throw new Error(\"Path is not an array\");\n    return path.reduce((target, segment, i)=>{\n        const segmentType = typeof segment;\n        if (segmentType === \"number\") return \"\".concat(target, \"[\").concat(segment, \"]\");\n        if (segmentType === \"string\") return \"\".concat(target).concat(i === 0 ? \"\" : \".\").concat(segment);\n        if (isKeySegment(segment) && segment._key) return \"\".concat(target, '[_key==\"').concat(segment._key, '\"]');\n        if (Array.isArray(segment)) {\n            const [from, to] = segment;\n            return \"\".concat(target, \"[\").concat(from, \":\").concat(to, \"]\");\n        }\n        throw new Error(\"Unsupported path segment `\".concat(JSON.stringify(segment), \"`\"));\n    }, \"\");\n}\nconst ESCAPE = {\n    \"\\f\": \"\\\\f\",\n    \"\\n\": \"\\\\n\",\n    \"\\r\": \"\\\\r\",\n    \"\t\": \"\\\\t\",\n    \"'\": \"\\\\'\",\n    \"\\\\\": \"\\\\\\\\\"\n}, UNESCAPE = {\n    \"\\\\f\": \"\\f\",\n    \"\\\\n\": \"\\n\",\n    \"\\\\r\": \"\\r\",\n    \"\\\\t\": \"\t\",\n    \"\\\\'\": \"'\",\n    \"\\\\\\\\\": \"\\\\\"\n};\nfunction jsonPath(path) {\n    return \"$\".concat(path.map((segment)=>typeof segment == \"string\" ? \"['\".concat(segment.replace(/[\\f\\n\\r\\t'\\\\]/g, (match)=>ESCAPE[match]), \"']\") : typeof segment == \"number\" ? \"[\".concat(segment, \"]\") : segment._key !== \"\" ? \"[?(@._key=='\".concat(segment._key.replace(/['\\\\]/g, (match)=>ESCAPE[match]), \"')]\") : \"[\".concat(segment._index, \"]\")).join(\"\"));\n}\nfunction parseJsonPath(path) {\n    const parsed = [], parseRe = /\\['(.*?)'\\]|\\[(\\d+)\\]|\\[\\?\\(@\\._key=='(.*?)'\\)\\]/g;\n    let match;\n    for(; (match = parseRe.exec(path)) !== null;){\n        if (match[1] !== void 0) {\n            const key = match[1].replace(/\\\\(\\\\|f|n|r|t|')/g, (m)=>UNESCAPE[m]);\n            parsed.push(key);\n            continue;\n        }\n        if (match[2] !== void 0) {\n            parsed.push(parseInt(match[2], 10));\n            continue;\n        }\n        if (match[3] !== void 0) {\n            const _key = match[3].replace(/\\\\(\\\\')/g, (m)=>UNESCAPE[m]);\n            parsed.push({\n                _key,\n                _index: -1\n            });\n            continue;\n        }\n    }\n    return parsed;\n}\nfunction jsonPathToStudioPath(path) {\n    return path.map((segment)=>{\n        if (typeof segment == \"string\" || typeof segment == \"number\") return segment;\n        if (segment._key !== \"\") return {\n            _key: segment._key\n        };\n        if (segment._index !== -1) return segment._index;\n        throw new Error(\"invalid segment:\".concat(JSON.stringify(segment)));\n    });\n}\nfunction jsonPathToMappingPath(path) {\n    return path.map((segment)=>{\n        if (typeof segment == \"string\" || typeof segment == \"number\") return segment;\n        if (segment._index !== -1) return segment._index;\n        throw new Error(\"invalid segment:\".concat(JSON.stringify(segment)));\n    });\n}\nfunction resolveMapping(resultPath, csm) {\n    if (!(csm === null || csm === void 0 ? void 0 : csm.mappings)) return;\n    const resultMappingPath = jsonPath(jsonPathToMappingPath(resultPath));\n    if (csm.mappings[resultMappingPath] !== void 0) return {\n        mapping: csm.mappings[resultMappingPath],\n        matchedPath: resultMappingPath,\n        pathSuffix: \"\"\n    };\n    const mappings = Object.entries(csm.mappings).filter((param)=>{\n        let [key] = param;\n        return resultMappingPath.startsWith(key);\n    }).sort((param, param1)=>{\n        let [key1] = param, [key2] = param1;\n        return key2.length - key1.length;\n    });\n    if (mappings.length == 0) return;\n    const [matchedPath, mapping] = mappings[0], pathSuffix = resultMappingPath.substring(matchedPath.length);\n    return {\n        mapping,\n        matchedPath,\n        pathSuffix\n    };\n}\nfunction isArray(value) {\n    return value !== null && Array.isArray(value);\n}\nfunction walkMap(value, mappingFn) {\n    let path = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];\n    if (isArray(value)) return value.map((v, idx)=>{\n        if ((0,_stegaClean_js__WEBPACK_IMPORTED_MODULE_0__.isRecord)(v)) {\n            const _key = v._key;\n            if (typeof _key == \"string\") return walkMap(v, mappingFn, path.concat({\n                _key,\n                _index: idx\n            }));\n        }\n        return walkMap(v, mappingFn, path.concat(idx));\n    });\n    if ((0,_stegaClean_js__WEBPACK_IMPORTED_MODULE_0__.isRecord)(value)) {\n        if (value._type === \"block\" || value._type === \"span\") {\n            const result = {\n                ...value\n            };\n            return value._type === \"block\" ? result.children = walkMap(value.children, mappingFn, path.concat(\"children\")) : value._type === \"span\" && (result.text = walkMap(value.text, mappingFn, path.concat(\"text\"))), result;\n        }\n        return Object.fromEntries(Object.entries(value).map((param)=>{\n            let [k, v] = param;\n            return [\n                k,\n                walkMap(v, mappingFn, path.concat(k))\n            ];\n        }));\n    }\n    return mappingFn(value, path);\n}\nfunction encodeIntoResult(result, csm, encoder) {\n    return walkMap(result, (value, path)=>{\n        if (typeof value != \"string\") return value;\n        const resolveMappingResult = resolveMapping(path, csm);\n        if (!resolveMappingResult) return value;\n        const { mapping, matchedPath } = resolveMappingResult;\n        if (mapping.type !== \"value\" || mapping.source.type !== \"documentValue\") return value;\n        const sourceDocument = csm.documents[mapping.source.document], sourcePath = csm.paths[mapping.source.path], matchPathSegments = parseJsonPath(matchedPath), fullSourceSegments = parseJsonPath(sourcePath).concat(path.slice(matchPathSegments.length));\n        return encoder({\n            sourcePath: fullSourceSegments,\n            sourceDocument,\n            resultPath: path,\n            value\n        });\n    });\n}\nconst DRAFTS_FOLDER = \"drafts\", VERSION_FOLDER = \"versions\", PATH_SEPARATOR = \".\", DRAFTS_PREFIX = \"\".concat(DRAFTS_FOLDER).concat(PATH_SEPARATOR), VERSION_PREFIX = \"\".concat(VERSION_FOLDER).concat(PATH_SEPARATOR);\nfunction isDraftId(id) {\n    return id.startsWith(DRAFTS_PREFIX);\n}\nfunction isVersionId(id) {\n    return id.startsWith(VERSION_PREFIX);\n}\nfunction isPublishedId(id) {\n    return !isDraftId(id) && !isVersionId(id);\n}\nfunction getVersionFromId(id) {\n    if (!isVersionId(id)) return;\n    const [_versionPrefix, versionId, ..._publishedId] = id.split(PATH_SEPARATOR);\n    return versionId;\n}\nfunction getPublishedId(id) {\n    return isVersionId(id) ? id.split(PATH_SEPARATOR).slice(2).join(PATH_SEPARATOR) : isDraftId(id) ? id.slice(DRAFTS_PREFIX.length) : id;\n}\nfunction createEditUrl(options) {\n    const { baseUrl, workspace: _workspace = \"default\", tool: _tool = \"default\", id: _id, type, path, projectId, dataset } = options;\n    if (!baseUrl) throw new Error(\"baseUrl is required\");\n    if (!path) throw new Error(\"path is required\");\n    if (!_id) throw new Error(\"id is required\");\n    if (baseUrl !== \"/\" && baseUrl.endsWith(\"/\")) throw new Error(\"baseUrl must not end with a slash\");\n    const workspace = _workspace === \"default\" ? void 0 : _workspace, tool = _tool === \"default\" ? void 0 : _tool, id = getPublishedId(_id), stringifiedPath = Array.isArray(path) ? toString(jsonPathToStudioPath(path)) : path, searchParams = new URLSearchParams({\n        baseUrl,\n        id,\n        type,\n        path: stringifiedPath\n    });\n    if (workspace && searchParams.set(\"workspace\", workspace), tool && searchParams.set(\"tool\", tool), projectId && searchParams.set(\"projectId\", projectId), dataset && searchParams.set(\"dataset\", dataset), isPublishedId(_id)) searchParams.set(\"perspective\", \"published\");\n    else if (isVersionId(_id)) {\n        const versionId = getVersionFromId(_id);\n        searchParams.set(\"perspective\", versionId);\n    }\n    const segments = [\n        baseUrl === \"/\" ? \"\" : baseUrl\n    ];\n    workspace && segments.push(workspace);\n    const routerParams = [\n        \"mode=presentation\",\n        \"id=\".concat(id),\n        \"type=\".concat(type),\n        \"path=\".concat(encodeURIComponent(stringifiedPath))\n    ];\n    return tool && routerParams.push(\"tool=\".concat(tool)), segments.push(\"intent\", \"edit\", \"\".concat(routerParams.join(\";\"), \"?\").concat(searchParams)), segments.join(\"/\");\n}\nfunction resolveStudioBaseRoute(studioUrl) {\n    let baseUrl = typeof studioUrl == \"string\" ? studioUrl : studioUrl.baseUrl;\n    return baseUrl !== \"/\" && (baseUrl = baseUrl.replace(/\\/$/, \"\")), typeof studioUrl == \"string\" ? {\n        baseUrl\n    } : {\n        ...studioUrl,\n        baseUrl\n    };\n}\nconst filterDefault = (param)=>{\n    let { sourcePath, resultPath, value } = param;\n    if (isValidDate(value) || isValidURL(value)) return !1;\n    const endPath = sourcePath.at(-1);\n    return !(sourcePath.at(-2) === \"slug\" && endPath === \"current\" || typeof endPath == \"string\" && (endPath.startsWith(\"_\") || endPath.endsWith(\"Id\")) || sourcePath.some((path)=>path === \"meta\" || path === \"metadata\" || path === \"openGraph\" || path === \"seo\") || hasTypeLike(sourcePath) || hasTypeLike(resultPath) || typeof endPath == \"string\" && denylist.has(endPath));\n}, denylist = /* @__PURE__ */ new Set([\n    \"color\",\n    \"colour\",\n    \"currency\",\n    \"email\",\n    \"format\",\n    \"gid\",\n    \"hex\",\n    \"href\",\n    \"hsl\",\n    \"hsla\",\n    \"icon\",\n    \"id\",\n    \"index\",\n    \"key\",\n    \"language\",\n    \"layout\",\n    \"link\",\n    \"linkAction\",\n    \"locale\",\n    \"lqip\",\n    \"page\",\n    \"path\",\n    \"ref\",\n    \"rgb\",\n    \"rgba\",\n    \"route\",\n    \"secret\",\n    \"slug\",\n    \"status\",\n    \"tag\",\n    \"template\",\n    \"theme\",\n    \"type\",\n    \"textTheme\",\n    \"unit\",\n    \"url\",\n    \"username\",\n    \"variant\",\n    \"website\"\n]);\nfunction isValidDate(dateString) {\n    return /^\\d{4}-\\d{2}-\\d{2}/.test(dateString) ? !!Date.parse(dateString) : !1;\n}\nfunction isValidURL(url) {\n    try {\n        new URL(url, url.startsWith(\"/\") ? \"https://acme.com\" : void 0);\n    } catch (e) {\n        return !1;\n    }\n    return !0;\n}\nfunction hasTypeLike(path) {\n    return path.some((segment)=>typeof segment == \"string\" && segment.match(/type/i) !== null);\n}\nconst TRUNCATE_LENGTH = 20;\nfunction stegaEncodeSourceMap(result, resultSourceMap, config) {\n    var _logger_error;\n    const { filter, logger, enabled } = config;\n    if (!enabled) {\n        var _logger_error1;\n        const msg = \"config.enabled must be true, don't call this function otherwise\";\n        throw logger === null || logger === void 0 ? void 0 : (_logger_error1 = logger.error) === null || _logger_error1 === void 0 ? void 0 : _logger_error1.call(logger, \"[@sanity/client]: \".concat(msg), {\n            result,\n            resultSourceMap,\n            config\n        }), new TypeError(msg);\n    }\n    if (!resultSourceMap) return logger === null || logger === void 0 ? void 0 : (_logger_error = logger.error) === null || _logger_error === void 0 ? void 0 : _logger_error.call(logger, \"[@sanity/client]: Missing Content Source Map from response body\", {\n        result,\n        resultSourceMap,\n        config\n    }), result;\n    if (!config.studioUrl) {\n        var _logger_error2;\n        const msg = \"config.studioUrl must be defined\";\n        throw logger === null || logger === void 0 ? void 0 : (_logger_error2 = logger.error) === null || _logger_error2 === void 0 ? void 0 : _logger_error2.call(logger, \"[@sanity/client]: \".concat(msg), {\n            result,\n            resultSourceMap,\n            config\n        }), new TypeError(msg);\n    }\n    const report = {\n        encoded: [],\n        skipped: []\n    }, resultWithStega = encodeIntoResult(result, resultSourceMap, (param)=>{\n        let { sourcePath, sourceDocument, resultPath, value } = param;\n        if ((typeof filter == \"function\" ? filter({\n            sourcePath,\n            resultPath,\n            filterDefault,\n            sourceDocument,\n            value\n        }) : filterDefault({\n            sourcePath,\n            resultPath,\n            value\n        })) === !1) return logger && report.skipped.push({\n            path: prettyPathForLogging(sourcePath),\n            value: \"\".concat(value.slice(0, TRUNCATE_LENGTH)).concat(value.length > TRUNCATE_LENGTH ? \"...\" : \"\"),\n            length: value.length\n        }), value;\n        logger && report.encoded.push({\n            path: prettyPathForLogging(sourcePath),\n            value: \"\".concat(value.slice(0, TRUNCATE_LENGTH)).concat(value.length > TRUNCATE_LENGTH ? \"...\" : \"\"),\n            length: value.length\n        });\n        const { baseUrl, workspace, tool } = resolveStudioBaseRoute(typeof config.studioUrl == \"function\" ? config.studioUrl(sourceDocument) : config.studioUrl);\n        if (!baseUrl) return value;\n        const { _id: id, _type: type, _projectId: projectId, _dataset: dataset } = sourceDocument;\n        return (0,_stegaClean_js__WEBPACK_IMPORTED_MODULE_0__.C)(value, {\n            origin: \"sanity.io\",\n            href: createEditUrl({\n                baseUrl,\n                workspace,\n                tool,\n                id,\n                type,\n                path: sourcePath,\n                ...!config.omitCrossDatasetReferenceData && {\n                    dataset,\n                    projectId\n                }\n            })\n        }, // We use custom logic to determine if we should skip encoding\n        !1);\n    });\n    if (logger) {\n        var _this, _logger_log, _logger_log1, _this1, _logger_groupEnd;\n        const isSkipping = report.skipped.length, isEncoding = report.encoded.length;\n        if ((isSkipping || isEncoding) && ((_this = (logger === null || logger === void 0 ? void 0 : logger.groupCollapsed) || logger.log) === null || _this === void 0 ? void 0 : _this(\"[@sanity/client]: Encoding source map into result\"), (_logger_log = logger.log) === null || _logger_log === void 0 ? void 0 : _logger_log.call(logger, \"[@sanity/client]: Paths encoded: \".concat(report.encoded.length, \", skipped: \").concat(report.skipped.length))), report.encoded.length > 0 && (logger === null || logger === void 0 ? void 0 : (_logger_log1 = logger.log) === null || _logger_log1 === void 0 ? void 0 : _logger_log1.call(logger, \"[@sanity/client]: Table of encoded paths\"), (_this1 = (logger === null || logger === void 0 ? void 0 : logger.table) || logger.log) === null || _this1 === void 0 ? void 0 : _this1(report.encoded)), report.skipped.length > 0) {\n            var _logger_log2;\n            const skipped = /* @__PURE__ */ new Set();\n            for (const { path } of report.skipped)skipped.add(path.replace(reKeySegment, \"0\").replace(/\\[\\d+\\]/g, \"[]\"));\n            logger === null || logger === void 0 ? void 0 : (_logger_log2 = logger.log) === null || _logger_log2 === void 0 ? void 0 : _logger_log2.call(logger, \"[@sanity/client]: List of skipped paths\", [\n                ...skipped.values()\n            ]);\n        }\n        (isSkipping || isEncoding) && (logger === null || logger === void 0 ? void 0 : (_logger_groupEnd = logger.groupEnd) === null || _logger_groupEnd === void 0 ? void 0 : _logger_groupEnd.call(logger));\n    }\n    return resultWithStega;\n}\nfunction prettyPathForLogging(path) {\n    return toString(jsonPathToStudioPath(path));\n}\nvar stegaEncodeSourceMap$1 = /* @__PURE__ */ Object.freeze({\n    __proto__: null,\n    stegaEncodeSourceMap\n});\n //# sourceMappingURL=stegaEncodeSourceMap.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2NsaWVudC9kaXN0L19jaHVua3MtZXMvc3RlZ2FFbmNvZGVTb3VyY2VNYXAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUE4QztBQUM5QyxNQUFNRSxlQUFlO0FBQ3JCLFNBQVNDLGFBQWFDLE9BQU87SUFDM0IsT0FBTyxPQUFPQSxXQUFXLFdBQVdGLGFBQWFHLElBQUksQ0FBQ0QsUUFBUUUsSUFBSSxNQUFNLE9BQU9GLFdBQVcsWUFBWSxVQUFVQTtBQUNsSDtBQUNBLFNBQVNHLFNBQVNDLElBQUk7SUFDcEIsSUFBSSxDQUFDQyxNQUFNQyxPQUFPLENBQUNGLE9BQ2pCLE1BQU0sSUFBSUcsTUFBTTtJQUNsQixPQUFPSCxLQUFLSSxNQUFNLENBQUMsQ0FBQ0MsUUFBUVQsU0FBU1U7UUFDbkMsTUFBTUMsY0FBYyxPQUFPWDtRQUMzQixJQUFJVyxnQkFBZ0IsVUFDbEIsT0FBTyxHQUFhWCxPQUFWUyxRQUFPLEtBQVcsT0FBUlQsU0FBUTtRQUM5QixJQUFJVyxnQkFBZ0IsVUFDbEIsT0FBTyxHQUFZRCxPQUFURCxRQUE4QlQsT0FBckJVLE1BQU0sSUFBSSxLQUFLLEtBQWMsT0FBUlY7UUFDMUMsSUFBSUQsYUFBYUMsWUFBWUEsUUFBUVksSUFBSSxFQUN2QyxPQUFPLEdBQW9CWixPQUFqQlMsUUFBTyxZQUF1QixPQUFiVCxRQUFRWSxJQUFJLEVBQUM7UUFDMUMsSUFBSVAsTUFBTUMsT0FBTyxDQUFDTixVQUFVO1lBQzFCLE1BQU0sQ0FBQ2EsTUFBTUMsR0FBRyxHQUFHZDtZQUNuQixPQUFPLEdBQWFhLE9BQVZKLFFBQU8sS0FBV0ssT0FBUkQsTUFBSyxLQUFNLE9BQUhDLElBQUc7UUFDakM7UUFDQSxNQUFNLElBQUlQLE1BQU0sNkJBQXNELE9BQXhCUSxLQUFLQyxTQUFTLENBQUNoQixVQUFTO0lBQ3hFLEdBQUc7QUFDTDtBQUNBLE1BQU1pQixTQUFTO0lBQ2IsTUFBTTtJQUNOLE1BQU07SUFD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Y0FBWGxCLG1DQUFBQSxrQkFBQUEsUUFBYyw4Q0FBOENBLFNBQUFBLENBQUFBLG1CQUFBQSw2QkFBQUEsT0FBUW1CLEtBQUssS0FBSW5CLE9BQU9rQixHQUFHLGNBQTNCbEIsNkJBQUQsT0FBZ0NLLE9BQU9DLE9BQU8sSUFBSUQsT0FBT0UsT0FBTyxDQUFDeEYsTUFBTSxHQUFHLEdBQUc7Z0JBSXhLaUY7WUFIQSxNQUFNTyxVQUFVLGFBQWEsR0FBRyxJQUFJakI7WUFDcEMsS0FBSyxNQUFNLEVBQUVySCxJQUFJLEVBQUUsSUFBSW9JLE9BQU9FLE9BQU8sQ0FDbkNBLFFBQVFhLEdBQUcsQ0FBQ25KLEtBQUtpQixPQUFPLENBQUN2QixjQUFjLEtBQUt1QixPQUFPLENBQUMsWUFBWTtZQUNsRThHLG1CQUFBQSw4QkFBQUEsZUFBQUEsT0FBUWtCLEdBQUcsY0FBWGxCLG1DQUFBQSxrQkFBQUEsUUFBYywyQ0FBMkM7bUJBQUlPLFFBQVFjLE1BQU07YUFBRztRQUNoRjtRQUNDTixDQUFBQSxjQUFjQyxVQUFTLE1BQU1oQixtQkFBQUEsOEJBQUFBLG1CQUFBQSxPQUFRc0IsUUFBUSxjQUFoQnRCLHVDQUFBQSxzQkFBQUE7SUFDaEM7SUFDQSxPQUFPUTtBQUNUO0FBQ0EsU0FBU0MscUJBQXFCeEksSUFBSTtJQUNoQyxPQUFPRCxTQUFTOEIscUJBQXFCN0I7QUFDdkM7QUFDQSxJQUFJc0oseUJBQXlCLGFBQWEsR0FBRy9HLE9BQU9nSCxNQUFNLENBQUM7SUFDekRDLFdBQVc7SUFDWDVCO0FBQ0Y7QUFLRSxDQUNGLGdEQUFnRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jbGllbnQvZGlzdC9fY2h1bmtzLWVzL3N0ZWdhRW5jb2RlU291cmNlTWFwLmpzPzc3MWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNSZWNvcmQsIEMgfSBmcm9tIFwiLi9zdGVnYUNsZWFuLmpzXCI7XG5jb25zdCByZUtleVNlZ21lbnQgPSAvX2tleVxccyo9PVxccypbJ1wiXSguKilbJ1wiXS87XG5mdW5jdGlvbiBpc0tleVNlZ21lbnQoc2VnbWVudCkge1xuICByZXR1cm4gdHlwZW9mIHNlZ21lbnQgPT0gXCJzdHJpbmdcIiA/IHJlS2V5U2VnbWVudC50ZXN0KHNlZ21lbnQudHJpbSgpKSA6IHR5cGVvZiBzZWdtZW50ID09IFwib2JqZWN0XCIgJiYgXCJfa2V5XCIgaW4gc2VnbWVudDtcbn1cbmZ1bmN0aW9uIHRvU3RyaW5nKHBhdGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHBhdGgpKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlBhdGggaXMgbm90IGFuIGFycmF5XCIpO1xuICByZXR1cm4gcGF0aC5yZWR1Y2UoKHRhcmdldCwgc2VnbWVudCwgaSkgPT4ge1xuICAgIGNvbnN0IHNlZ21lbnRUeXBlID0gdHlwZW9mIHNlZ21lbnQ7XG4gICAgaWYgKHNlZ21lbnRUeXBlID09PSBcIm51bWJlclwiKVxuICAgICAgcmV0dXJuIGAke3RhcmdldH1bJHtzZWdtZW50fV1gO1xuICAgIGlmIChzZWdtZW50VHlwZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiBgJHt0YXJnZXR9JHtpID09PSAwID8gXCJcIiA6IFwiLlwifSR7c2VnbWVudH1gO1xuICAgIGlmIChpc0tleVNlZ21lbnQoc2VnbWVudCkgJiYgc2VnbWVudC5fa2V5KVxuICAgICAgcmV0dXJuIGAke3RhcmdldH1bX2tleT09XCIke3NlZ21lbnQuX2tleX1cIl1gO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNlZ21lbnQpKSB7XG4gICAgICBjb25zdCBbZnJvbSwgdG9dID0gc2VnbWVudDtcbiAgICAgIHJldHVybiBgJHt0YXJnZXR9WyR7ZnJvbX06JHt0b31dYDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwYXRoIHNlZ21lbnQgXFxgJHtKU09OLnN0cmluZ2lmeShzZWdtZW50KX1cXGBgKTtcbiAgfSwgXCJcIik7XG59XG5jb25zdCBFU0NBUEUgPSB7XG4gIFwiXFxmXCI6IFwiXFxcXGZcIixcbiAgXCJcXG5cIjogXCJcXFxcblwiLFxuICBcIlxcclwiOiBcIlxcXFxyXCIsXG4gIFwiXHRcIjogXCJcXFxcdFwiLFxuICBcIidcIjogXCJcXFxcJ1wiLFxuICBcIlxcXFxcIjogXCJcXFxcXFxcXFwiXG59LCBVTkVTQ0FQRSA9IHtcbiAgXCJcXFxcZlwiOiBcIlxcZlwiLFxuICBcIlxcXFxuXCI6IGBcbmAsXG4gIFwiXFxcXHJcIjogXCJcXHJcIixcbiAgXCJcXFxcdFwiOiBcIlx0XCIsXG4gIFwiXFxcXCdcIjogXCInXCIsXG4gIFwiXFxcXFxcXFxcIjogXCJcXFxcXCJcbn07XG5mdW5jdGlvbiBqc29uUGF0aChwYXRoKSB7XG4gIHJldHVybiBgJCR7cGF0aC5tYXAoKHNlZ21lbnQpID0+IHR5cGVvZiBzZWdtZW50ID09IFwic3RyaW5nXCIgPyBgWycke3NlZ21lbnQucmVwbGFjZSgvW1xcZlxcblxcclxcdCdcXFxcXS9nLCAobWF0Y2gpID0+IEVTQ0FQRVttYXRjaF0pfSddYCA6IHR5cGVvZiBzZWdtZW50ID09IFwibnVtYmVyXCIgPyBgWyR7c2VnbWVudH1dYCA6IHNlZ21lbnQuX2tleSAhPT0gXCJcIiA/IGBbPyhALl9rZXk9PScke3NlZ21lbnQuX2tleS5yZXBsYWNlKC9bJ1xcXFxdL2csIChtYXRjaCkgPT4gRVNDQVBFW21hdGNoXSl9JyldYCA6IGBbJHtzZWdtZW50Ll9pbmRleH1dYCkuam9pbihcIlwiKX1gO1xufVxuZnVuY3Rpb24gcGFyc2VKc29uUGF0aChwYXRoKSB7XG4gIGNvbnN0IHBhcnNlZCA9IFtdLCBwYXJzZVJlID0gL1xcWycoLio/KSdcXF18XFxbKFxcZCspXFxdfFxcW1xcP1xcKEBcXC5fa2V5PT0nKC4qPyknXFwpXFxdL2c7XG4gIGxldCBtYXRjaDtcbiAgZm9yICg7IChtYXRjaCA9IHBhcnNlUmUuZXhlYyhwYXRoKSkgIT09IG51bGw7ICkge1xuICAgIGlmIChtYXRjaFsxXSAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBrZXkgPSBtYXRjaFsxXS5yZXBsYWNlKC9cXFxcKFxcXFx8ZnxufHJ8dHwnKS9nLCAobSkgPT4gVU5FU0NBUEVbbV0pO1xuICAgICAgcGFyc2VkLnB1c2goa2V5KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobWF0Y2hbMl0gIT09IHZvaWQgMCkge1xuICAgICAgcGFyc2VkLnB1c2gocGFyc2VJbnQobWF0Y2hbMl0sIDEwKSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG1hdGNoWzNdICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IF9rZXkgPSBtYXRjaFszXS5yZXBsYWNlKC9cXFxcKFxcXFwnKS9nLCAobSkgPT4gVU5FU0NBUEVbbV0pO1xuICAgICAgcGFyc2VkLnB1c2goe1xuICAgICAgICBfa2V5LFxuICAgICAgICBfaW5kZXg6IC0xXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGFyc2VkO1xufVxuZnVuY3Rpb24ganNvblBhdGhUb1N0dWRpb1BhdGgocGF0aCkge1xuICByZXR1cm4gcGF0aC5tYXAoKHNlZ21lbnQpID0+IHtcbiAgICBpZiAodHlwZW9mIHNlZ21lbnQgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2Ygc2VnbWVudCA9PSBcIm51bWJlclwiKVxuICAgICAgcmV0dXJuIHNlZ21lbnQ7XG4gICAgaWYgKHNlZ21lbnQuX2tleSAhPT0gXCJcIilcbiAgICAgIHJldHVybiB7IF9rZXk6IHNlZ21lbnQuX2tleSB9O1xuICAgIGlmIChzZWdtZW50Ll9pbmRleCAhPT0gLTEpXG4gICAgICByZXR1cm4gc2VnbWVudC5faW5kZXg7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHNlZ21lbnQ6JHtKU09OLnN0cmluZ2lmeShzZWdtZW50KX1gKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBqc29uUGF0aFRvTWFwcGluZ1BhdGgocGF0aCkge1xuICByZXR1cm4gcGF0aC5tYXAoKHNlZ21lbnQpID0+IHtcbiAgICBpZiAodHlwZW9mIHNlZ21lbnQgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2Ygc2VnbWVudCA9PSBcIm51bWJlclwiKVxuICAgICAgcmV0dXJuIHNlZ21lbnQ7XG4gICAgaWYgKHNlZ21lbnQuX2luZGV4ICE9PSAtMSlcbiAgICAgIHJldHVybiBzZWdtZW50Ll9pbmRleDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgc2VnbWVudDoke0pTT04uc3RyaW5naWZ5KHNlZ21lbnQpfWApO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVNYXBwaW5nKHJlc3VsdFBhdGgsIGNzbSkge1xuICBpZiAoIWNzbT8ubWFwcGluZ3MpXG4gICAgcmV0dXJuO1xuICBjb25zdCByZXN1bHRNYXBwaW5nUGF0aCA9IGpzb25QYXRoKGpzb25QYXRoVG9NYXBwaW5nUGF0aChyZXN1bHRQYXRoKSk7XG4gIGlmIChjc20ubWFwcGluZ3NbcmVzdWx0TWFwcGluZ1BhdGhdICE9PSB2b2lkIDApXG4gICAgcmV0dXJuIHtcbiAgICAgIG1hcHBpbmc6IGNzbS5tYXBwaW5nc1tyZXN1bHRNYXBwaW5nUGF0aF0sXG4gICAgICBtYXRjaGVkUGF0aDogcmVzdWx0TWFwcGluZ1BhdGgsXG4gICAgICBwYXRoU3VmZml4OiBcIlwiXG4gICAgfTtcbiAgY29uc3QgbWFwcGluZ3MgPSBPYmplY3QuZW50cmllcyhjc20ubWFwcGluZ3MpLmZpbHRlcigoW2tleV0pID0+IHJlc3VsdE1hcHBpbmdQYXRoLnN0YXJ0c1dpdGgoa2V5KSkuc29ydCgoW2tleTFdLCBba2V5Ml0pID0+IGtleTIubGVuZ3RoIC0ga2V5MS5sZW5ndGgpO1xuICBpZiAobWFwcGluZ3MubGVuZ3RoID09IDApXG4gICAgcmV0dXJuO1xuICBjb25zdCBbbWF0Y2hlZFBhdGgsIG1hcHBpbmddID0gbWFwcGluZ3NbMF0sIHBhdGhTdWZmaXggPSByZXN1bHRNYXBwaW5nUGF0aC5zdWJzdHJpbmcobWF0Y2hlZFBhdGgubGVuZ3RoKTtcbiAgcmV0dXJuIHsgbWFwcGluZywgbWF0Y2hlZFBhdGgsIHBhdGhTdWZmaXggfTtcbn1cbmZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIEFycmF5LmlzQXJyYXkodmFsdWUpO1xufVxuZnVuY3Rpb24gd2Fsa01hcCh2YWx1ZSwgbWFwcGluZ0ZuLCBwYXRoID0gW10pIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKVxuICAgIHJldHVybiB2YWx1ZS5tYXAoKHYsIGlkeCkgPT4ge1xuICAgICAgaWYgKGlzUmVjb3JkKHYpKSB7XG4gICAgICAgIGNvbnN0IF9rZXkgPSB2Ll9rZXk7XG4gICAgICAgIGlmICh0eXBlb2YgX2tleSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgIHJldHVybiB3YWxrTWFwKHYsIG1hcHBpbmdGbiwgcGF0aC5jb25jYXQoeyBfa2V5LCBfaW5kZXg6IGlkeCB9KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2Fsa01hcCh2LCBtYXBwaW5nRm4sIHBhdGguY29uY2F0KGlkeCkpO1xuICAgIH0pO1xuICBpZiAoaXNSZWNvcmQodmFsdWUpKSB7XG4gICAgaWYgKHZhbHVlLl90eXBlID09PSBcImJsb2NrXCIgfHwgdmFsdWUuX3R5cGUgPT09IFwic3BhblwiKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB7IC4uLnZhbHVlIH07XG4gICAgICByZXR1cm4gdmFsdWUuX3R5cGUgPT09IFwiYmxvY2tcIiA/IHJlc3VsdC5jaGlsZHJlbiA9IHdhbGtNYXAodmFsdWUuY2hpbGRyZW4sIG1hcHBpbmdGbiwgcGF0aC5jb25jYXQoXCJjaGlsZHJlblwiKSkgOiB2YWx1ZS5fdHlwZSA9PT0gXCJzcGFuXCIgJiYgKHJlc3VsdC50ZXh0ID0gd2Fsa01hcCh2YWx1ZS50ZXh0LCBtYXBwaW5nRm4sIHBhdGguY29uY2F0KFwidGV4dFwiKSkpLCByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBPYmplY3QuZW50cmllcyh2YWx1ZSkubWFwKChbaywgdl0pID0+IFtrLCB3YWxrTWFwKHYsIG1hcHBpbmdGbiwgcGF0aC5jb25jYXQoaykpXSlcbiAgICApO1xuICB9XG4gIHJldHVybiBtYXBwaW5nRm4odmFsdWUsIHBhdGgpO1xufVxuZnVuY3Rpb24gZW5jb2RlSW50b1Jlc3VsdChyZXN1bHQsIGNzbSwgZW5jb2Rlcikge1xuICByZXR1cm4gd2Fsa01hcChyZXN1bHQsICh2YWx1ZSwgcGF0aCkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBjb25zdCByZXNvbHZlTWFwcGluZ1Jlc3VsdCA9IHJlc29sdmVNYXBwaW5nKHBhdGgsIGNzbSk7XG4gICAgaWYgKCFyZXNvbHZlTWFwcGluZ1Jlc3VsdClcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBjb25zdCB7IG1hcHBpbmcsIG1hdGNoZWRQYXRoIH0gPSByZXNvbHZlTWFwcGluZ1Jlc3VsdDtcbiAgICBpZiAobWFwcGluZy50eXBlICE9PSBcInZhbHVlXCIgfHwgbWFwcGluZy5zb3VyY2UudHlwZSAhPT0gXCJkb2N1bWVudFZhbHVlXCIpXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgY29uc3Qgc291cmNlRG9jdW1lbnQgPSBjc20uZG9jdW1lbnRzW21hcHBpbmcuc291cmNlLmRvY3VtZW50XSwgc291cmNlUGF0aCA9IGNzbS5wYXRoc1ttYXBwaW5nLnNvdXJjZS5wYXRoXSwgbWF0Y2hQYXRoU2VnbWVudHMgPSBwYXJzZUpzb25QYXRoKG1hdGNoZWRQYXRoKSwgZnVsbFNvdXJjZVNlZ21lbnRzID0gcGFyc2VKc29uUGF0aChzb3VyY2VQYXRoKS5jb25jYXQocGF0aC5zbGljZShtYXRjaFBhdGhTZWdtZW50cy5sZW5ndGgpKTtcbiAgICByZXR1cm4gZW5jb2Rlcih7XG4gICAgICBzb3VyY2VQYXRoOiBmdWxsU291cmNlU2VnbWVudHMsXG4gICAgICBzb3VyY2VEb2N1bWVudCxcbiAgICAgIHJlc3VsdFBhdGg6IHBhdGgsXG4gICAgICB2YWx1ZVxuICAgIH0pO1xuICB9KTtcbn1cbmNvbnN0IERSQUZUU19GT0xERVIgPSBcImRyYWZ0c1wiLCBWRVJTSU9OX0ZPTERFUiA9IFwidmVyc2lvbnNcIiwgUEFUSF9TRVBBUkFUT1IgPSBcIi5cIiwgRFJBRlRTX1BSRUZJWCA9IGAke0RSQUZUU19GT0xERVJ9JHtQQVRIX1NFUEFSQVRPUn1gLCBWRVJTSU9OX1BSRUZJWCA9IGAke1ZFUlNJT05fRk9MREVSfSR7UEFUSF9TRVBBUkFUT1J9YDtcbmZ1bmN0aW9uIGlzRHJhZnRJZChpZCkge1xuICByZXR1cm4gaWQuc3RhcnRzV2l0aChEUkFGVFNfUFJFRklYKTtcbn1cbmZ1bmN0aW9uIGlzVmVyc2lvbklkKGlkKSB7XG4gIHJldHVybiBpZC5zdGFydHNXaXRoKFZFUlNJT05fUFJFRklYKTtcbn1cbmZ1bmN0aW9uIGlzUHVibGlzaGVkSWQoaWQpIHtcbiAgcmV0dXJuICFpc0RyYWZ0SWQoaWQpICYmICFpc1ZlcnNpb25JZChpZCk7XG59XG5mdW5jdGlvbiBnZXRWZXJzaW9uRnJvbUlkKGlkKSB7XG4gIGlmICghaXNWZXJzaW9uSWQoaWQpKSByZXR1cm47XG4gIGNvbnN0IFtfdmVyc2lvblByZWZpeCwgdmVyc2lvbklkLCAuLi5fcHVibGlzaGVkSWRdID0gaWQuc3BsaXQoUEFUSF9TRVBBUkFUT1IpO1xuICByZXR1cm4gdmVyc2lvbklkO1xufVxuZnVuY3Rpb24gZ2V0UHVibGlzaGVkSWQoaWQpIHtcbiAgcmV0dXJuIGlzVmVyc2lvbklkKGlkKSA/IGlkLnNwbGl0KFBBVEhfU0VQQVJBVE9SKS5zbGljZSgyKS5qb2luKFBBVEhfU0VQQVJBVE9SKSA6IGlzRHJhZnRJZChpZCkgPyBpZC5zbGljZShEUkFGVFNfUFJFRklYLmxlbmd0aCkgOiBpZDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVkaXRVcmwob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgYmFzZVVybCxcbiAgICB3b3Jrc3BhY2U6IF93b3Jrc3BhY2UgPSBcImRlZmF1bHRcIixcbiAgICB0b29sOiBfdG9vbCA9IFwiZGVmYXVsdFwiLFxuICAgIGlkOiBfaWQsXG4gICAgdHlwZSxcbiAgICBwYXRoLFxuICAgIHByb2plY3RJZCxcbiAgICBkYXRhc2V0XG4gIH0gPSBvcHRpb25zO1xuICBpZiAoIWJhc2VVcmwpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYmFzZVVybCBpcyByZXF1aXJlZFwiKTtcbiAgaWYgKCFwYXRoKVxuICAgIHRocm93IG5ldyBFcnJvcihcInBhdGggaXMgcmVxdWlyZWRcIik7XG4gIGlmICghX2lkKVxuICAgIHRocm93IG5ldyBFcnJvcihcImlkIGlzIHJlcXVpcmVkXCIpO1xuICBpZiAoYmFzZVVybCAhPT0gXCIvXCIgJiYgYmFzZVVybC5lbmRzV2l0aChcIi9cIikpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYmFzZVVybCBtdXN0IG5vdCBlbmQgd2l0aCBhIHNsYXNoXCIpO1xuICBjb25zdCB3b3Jrc3BhY2UgPSBfd29ya3NwYWNlID09PSBcImRlZmF1bHRcIiA/IHZvaWQgMCA6IF93b3Jrc3BhY2UsIHRvb2wgPSBfdG9vbCA9PT0gXCJkZWZhdWx0XCIgPyB2b2lkIDAgOiBfdG9vbCwgaWQgPSBnZXRQdWJsaXNoZWRJZChfaWQpLCBzdHJpbmdpZmllZFBhdGggPSBBcnJheS5pc0FycmF5KHBhdGgpID8gdG9TdHJpbmcoanNvblBhdGhUb1N0dWRpb1BhdGgocGF0aCkpIDogcGF0aCwgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgYmFzZVVybCxcbiAgICBpZCxcbiAgICB0eXBlLFxuICAgIHBhdGg6IHN0cmluZ2lmaWVkUGF0aFxuICB9KTtcbiAgaWYgKHdvcmtzcGFjZSAmJiBzZWFyY2hQYXJhbXMuc2V0KFwid29ya3NwYWNlXCIsIHdvcmtzcGFjZSksIHRvb2wgJiYgc2VhcmNoUGFyYW1zLnNldChcInRvb2xcIiwgdG9vbCksIHByb2plY3RJZCAmJiBzZWFyY2hQYXJhbXMuc2V0KFwicHJvamVjdElkXCIsIHByb2plY3RJZCksIGRhdGFzZXQgJiYgc2VhcmNoUGFyYW1zLnNldChcImRhdGFzZXRcIiwgZGF0YXNldCksIGlzUHVibGlzaGVkSWQoX2lkKSlcbiAgICBzZWFyY2hQYXJhbXMuc2V0KFwicGVyc3BlY3RpdmVcIiwgXCJwdWJsaXNoZWRcIik7XG4gIGVsc2UgaWYgKGlzVmVyc2lvbklkKF9pZCkpIHtcbiAgICBjb25zdCB2ZXJzaW9uSWQgPSBnZXRWZXJzaW9uRnJvbUlkKF9pZCk7XG4gICAgc2VhcmNoUGFyYW1zLnNldChcInBlcnNwZWN0aXZlXCIsIHZlcnNpb25JZCk7XG4gIH1cbiAgY29uc3Qgc2VnbWVudHMgPSBbYmFzZVVybCA9PT0gXCIvXCIgPyBcIlwiIDogYmFzZVVybF07XG4gIHdvcmtzcGFjZSAmJiBzZWdtZW50cy5wdXNoKHdvcmtzcGFjZSk7XG4gIGNvbnN0IHJvdXRlclBhcmFtcyA9IFtcbiAgICBcIm1vZGU9cHJlc2VudGF0aW9uXCIsXG4gICAgYGlkPSR7aWR9YCxcbiAgICBgdHlwZT0ke3R5cGV9YCxcbiAgICBgcGF0aD0ke2VuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZmllZFBhdGgpfWBcbiAgXTtcbiAgcmV0dXJuIHRvb2wgJiYgcm91dGVyUGFyYW1zLnB1c2goYHRvb2w9JHt0b29sfWApLCBzZWdtZW50cy5wdXNoKFwiaW50ZW50XCIsIFwiZWRpdFwiLCBgJHtyb3V0ZXJQYXJhbXMuam9pbihcIjtcIil9PyR7c2VhcmNoUGFyYW1zfWApLCBzZWdtZW50cy5qb2luKFwiL1wiKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVTdHVkaW9CYXNlUm91dGUoc3R1ZGlvVXJsKSB7XG4gIGxldCBiYXNlVXJsID0gdHlwZW9mIHN0dWRpb1VybCA9PSBcInN0cmluZ1wiID8gc3R1ZGlvVXJsIDogc3R1ZGlvVXJsLmJhc2VVcmw7XG4gIHJldHVybiBiYXNlVXJsICE9PSBcIi9cIiAmJiAoYmFzZVVybCA9IGJhc2VVcmwucmVwbGFjZSgvXFwvJC8sIFwiXCIpKSwgdHlwZW9mIHN0dWRpb1VybCA9PSBcInN0cmluZ1wiID8geyBiYXNlVXJsIH0gOiB7IC4uLnN0dWRpb1VybCwgYmFzZVVybCB9O1xufVxuY29uc3QgZmlsdGVyRGVmYXVsdCA9ICh7IHNvdXJjZVBhdGgsIHJlc3VsdFBhdGgsIHZhbHVlIH0pID0+IHtcbiAgaWYgKGlzVmFsaWREYXRlKHZhbHVlKSB8fCBpc1ZhbGlkVVJMKHZhbHVlKSlcbiAgICByZXR1cm4gITE7XG4gIGNvbnN0IGVuZFBhdGggPSBzb3VyY2VQYXRoLmF0KC0xKTtcbiAgcmV0dXJuICEoc291cmNlUGF0aC5hdCgtMikgPT09IFwic2x1Z1wiICYmIGVuZFBhdGggPT09IFwiY3VycmVudFwiIHx8IHR5cGVvZiBlbmRQYXRoID09IFwic3RyaW5nXCIgJiYgKGVuZFBhdGguc3RhcnRzV2l0aChcIl9cIikgfHwgZW5kUGF0aC5lbmRzV2l0aChcIklkXCIpKSB8fCBzb3VyY2VQYXRoLnNvbWUoXG4gICAgKHBhdGgpID0+IHBhdGggPT09IFwibWV0YVwiIHx8IHBhdGggPT09IFwibWV0YWRhdGFcIiB8fCBwYXRoID09PSBcIm9wZW5HcmFwaFwiIHx8IHBhdGggPT09IFwic2VvXCJcbiAgKSB8fCBoYXNUeXBlTGlrZShzb3VyY2VQYXRoKSB8fCBoYXNUeXBlTGlrZShyZXN1bHRQYXRoKSB8fCB0eXBlb2YgZW5kUGF0aCA9PSBcInN0cmluZ1wiICYmIGRlbnlsaXN0LmhhcyhlbmRQYXRoKSk7XG59LCBkZW55bGlzdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgXCJjb2xvclwiLFxuICBcImNvbG91clwiLFxuICBcImN1cnJlbmN5XCIsXG4gIFwiZW1haWxcIixcbiAgXCJmb3JtYXRcIixcbiAgXCJnaWRcIixcbiAgXCJoZXhcIixcbiAgXCJocmVmXCIsXG4gIFwiaHNsXCIsXG4gIFwiaHNsYVwiLFxuICBcImljb25cIixcbiAgXCJpZFwiLFxuICBcImluZGV4XCIsXG4gIFwia2V5XCIsXG4gIFwibGFuZ3VhZ2VcIixcbiAgXCJsYXlvdXRcIixcbiAgXCJsaW5rXCIsXG4gIFwibGlua0FjdGlvblwiLFxuICBcImxvY2FsZVwiLFxuICBcImxxaXBcIixcbiAgXCJwYWdlXCIsXG4gIFwicGF0aFwiLFxuICBcInJlZlwiLFxuICBcInJnYlwiLFxuICBcInJnYmFcIixcbiAgXCJyb3V0ZVwiLFxuICBcInNlY3JldFwiLFxuICBcInNsdWdcIixcbiAgXCJzdGF0dXNcIixcbiAgXCJ0YWdcIixcbiAgXCJ0ZW1wbGF0ZVwiLFxuICBcInRoZW1lXCIsXG4gIFwidHlwZVwiLFxuICBcInRleHRUaGVtZVwiLFxuICBcInVuaXRcIixcbiAgXCJ1cmxcIixcbiAgXCJ1c2VybmFtZVwiLFxuICBcInZhcmlhbnRcIixcbiAgXCJ3ZWJzaXRlXCJcbl0pO1xuZnVuY3Rpb24gaXNWYWxpZERhdGUoZGF0ZVN0cmluZykge1xuICByZXR1cm4gL15cXGR7NH0tXFxkezJ9LVxcZHsyfS8udGVzdChkYXRlU3RyaW5nKSA/ICEhRGF0ZS5wYXJzZShkYXRlU3RyaW5nKSA6ICExO1xufVxuZnVuY3Rpb24gaXNWYWxpZFVSTCh1cmwpIHtcbiAgdHJ5IHtcbiAgICBuZXcgVVJMKHVybCwgdXJsLnN0YXJ0c1dpdGgoXCIvXCIpID8gXCJodHRwczovL2FjbWUuY29tXCIgOiB2b2lkIDApO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbiAgcmV0dXJuICEwO1xufVxuZnVuY3Rpb24gaGFzVHlwZUxpa2UocGF0aCkge1xuICByZXR1cm4gcGF0aC5zb21lKChzZWdtZW50KSA9PiB0eXBlb2Ygc2VnbWVudCA9PSBcInN0cmluZ1wiICYmIHNlZ21lbnQubWF0Y2goL3R5cGUvaSkgIT09IG51bGwpO1xufVxuY29uc3QgVFJVTkNBVEVfTEVOR1RIID0gMjA7XG5mdW5jdGlvbiBzdGVnYUVuY29kZVNvdXJjZU1hcChyZXN1bHQsIHJlc3VsdFNvdXJjZU1hcCwgY29uZmlnKSB7XG4gIGNvbnN0IHsgZmlsdGVyLCBsb2dnZXIsIGVuYWJsZWQgfSA9IGNvbmZpZztcbiAgaWYgKCFlbmFibGVkKSB7XG4gICAgY29uc3QgbXNnID0gXCJjb25maWcuZW5hYmxlZCBtdXN0IGJlIHRydWUsIGRvbid0IGNhbGwgdGhpcyBmdW5jdGlvbiBvdGhlcndpc2VcIjtcbiAgICB0aHJvdyBsb2dnZXI/LmVycm9yPy4oYFtAc2FuaXR5L2NsaWVudF06ICR7bXNnfWAsIHsgcmVzdWx0LCByZXN1bHRTb3VyY2VNYXAsIGNvbmZpZyB9KSwgbmV3IFR5cGVFcnJvcihtc2cpO1xuICB9XG4gIGlmICghcmVzdWx0U291cmNlTWFwKVxuICAgIHJldHVybiBsb2dnZXI/LmVycm9yPy4oXCJbQHNhbml0eS9jbGllbnRdOiBNaXNzaW5nIENvbnRlbnQgU291cmNlIE1hcCBmcm9tIHJlc3BvbnNlIGJvZHlcIiwge1xuICAgICAgcmVzdWx0LFxuICAgICAgcmVzdWx0U291cmNlTWFwLFxuICAgICAgY29uZmlnXG4gICAgfSksIHJlc3VsdDtcbiAgaWYgKCFjb25maWcuc3R1ZGlvVXJsKSB7XG4gICAgY29uc3QgbXNnID0gXCJjb25maWcuc3R1ZGlvVXJsIG11c3QgYmUgZGVmaW5lZFwiO1xuICAgIHRocm93IGxvZ2dlcj8uZXJyb3I/LihgW0BzYW5pdHkvY2xpZW50XTogJHttc2d9YCwgeyByZXN1bHQsIHJlc3VsdFNvdXJjZU1hcCwgY29uZmlnIH0pLCBuZXcgVHlwZUVycm9yKG1zZyk7XG4gIH1cbiAgY29uc3QgcmVwb3J0ID0ge1xuICAgIGVuY29kZWQ6IFtdLFxuICAgIHNraXBwZWQ6IFtdXG4gIH0sIHJlc3VsdFdpdGhTdGVnYSA9IGVuY29kZUludG9SZXN1bHQoXG4gICAgcmVzdWx0LFxuICAgIHJlc3VsdFNvdXJjZU1hcCxcbiAgICAoeyBzb3VyY2VQYXRoLCBzb3VyY2VEb2N1bWVudCwgcmVzdWx0UGF0aCwgdmFsdWUgfSkgPT4ge1xuICAgICAgaWYgKCh0eXBlb2YgZmlsdGVyID09IFwiZnVuY3Rpb25cIiA/IGZpbHRlcih7IHNvdXJjZVBhdGgsIHJlc3VsdFBhdGgsIGZpbHRlckRlZmF1bHQsIHNvdXJjZURvY3VtZW50LCB2YWx1ZSB9KSA6IGZpbHRlckRlZmF1bHQoeyBzb3VyY2VQYXRoLCByZXN1bHRQYXRoLCB2YWx1ZSB9KSkgPT09ICExKVxuICAgICAgICByZXR1cm4gbG9nZ2VyICYmIHJlcG9ydC5za2lwcGVkLnB1c2goe1xuICAgICAgICAgIHBhdGg6IHByZXR0eVBhdGhGb3JMb2dnaW5nKHNvdXJjZVBhdGgpLFxuICAgICAgICAgIHZhbHVlOiBgJHt2YWx1ZS5zbGljZSgwLCBUUlVOQ0FURV9MRU5HVEgpfSR7dmFsdWUubGVuZ3RoID4gVFJVTkNBVEVfTEVOR1RIID8gXCIuLi5cIiA6IFwiXCJ9YCxcbiAgICAgICAgICBsZW5ndGg6IHZhbHVlLmxlbmd0aFxuICAgICAgICB9KSwgdmFsdWU7XG4gICAgICBsb2dnZXIgJiYgcmVwb3J0LmVuY29kZWQucHVzaCh7XG4gICAgICAgIHBhdGg6IHByZXR0eVBhdGhGb3JMb2dnaW5nKHNvdXJjZVBhdGgpLFxuICAgICAgICB2YWx1ZTogYCR7dmFsdWUuc2xpY2UoMCwgVFJVTkNBVEVfTEVOR1RIKX0ke3ZhbHVlLmxlbmd0aCA+IFRSVU5DQVRFX0xFTkdUSCA/IFwiLi4uXCIgOiBcIlwifWAsXG4gICAgICAgIGxlbmd0aDogdmFsdWUubGVuZ3RoXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHsgYmFzZVVybCwgd29ya3NwYWNlLCB0b29sIH0gPSByZXNvbHZlU3R1ZGlvQmFzZVJvdXRlKFxuICAgICAgICB0eXBlb2YgY29uZmlnLnN0dWRpb1VybCA9PSBcImZ1bmN0aW9uXCIgPyBjb25maWcuc3R1ZGlvVXJsKHNvdXJjZURvY3VtZW50KSA6IGNvbmZpZy5zdHVkaW9VcmxcbiAgICAgICk7XG4gICAgICBpZiAoIWJhc2VVcmwpIHJldHVybiB2YWx1ZTtcbiAgICAgIGNvbnN0IHsgX2lkOiBpZCwgX3R5cGU6IHR5cGUsIF9wcm9qZWN0SWQ6IHByb2plY3RJZCwgX2RhdGFzZXQ6IGRhdGFzZXQgfSA9IHNvdXJjZURvY3VtZW50O1xuICAgICAgcmV0dXJuIEMoXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB7XG4gICAgICAgICAgb3JpZ2luOiBcInNhbml0eS5pb1wiLFxuICAgICAgICAgIGhyZWY6IGNyZWF0ZUVkaXRVcmwoe1xuICAgICAgICAgICAgYmFzZVVybCxcbiAgICAgICAgICAgIHdvcmtzcGFjZSxcbiAgICAgICAgICAgIHRvb2wsXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBwYXRoOiBzb3VyY2VQYXRoLFxuICAgICAgICAgICAgLi4uIWNvbmZpZy5vbWl0Q3Jvc3NEYXRhc2V0UmVmZXJlbmNlRGF0YSAmJiB7IGRhdGFzZXQsIHByb2plY3RJZCB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgLy8gV2UgdXNlIGN1c3RvbSBsb2dpYyB0byBkZXRlcm1pbmUgaWYgd2Ugc2hvdWxkIHNraXAgZW5jb2RpbmdcbiAgICAgICAgITFcbiAgICAgICk7XG4gICAgfVxuICApO1xuICBpZiAobG9nZ2VyKSB7XG4gICAgY29uc3QgaXNTa2lwcGluZyA9IHJlcG9ydC5za2lwcGVkLmxlbmd0aCwgaXNFbmNvZGluZyA9IHJlcG9ydC5lbmNvZGVkLmxlbmd0aDtcbiAgICBpZiAoKGlzU2tpcHBpbmcgfHwgaXNFbmNvZGluZykgJiYgKChsb2dnZXI/Lmdyb3VwQ29sbGFwc2VkIHx8IGxvZ2dlci5sb2cpPy4oXCJbQHNhbml0eS9jbGllbnRdOiBFbmNvZGluZyBzb3VyY2UgbWFwIGludG8gcmVzdWx0XCIpLCBsb2dnZXIubG9nPy4oXG4gICAgICBgW0BzYW5pdHkvY2xpZW50XTogUGF0aHMgZW5jb2RlZDogJHtyZXBvcnQuZW5jb2RlZC5sZW5ndGh9LCBza2lwcGVkOiAke3JlcG9ydC5za2lwcGVkLmxlbmd0aH1gXG4gICAgKSksIHJlcG9ydC5lbmNvZGVkLmxlbmd0aCA+IDAgJiYgKGxvZ2dlcj8ubG9nPy4oXCJbQHNhbml0eS9jbGllbnRdOiBUYWJsZSBvZiBlbmNvZGVkIHBhdGhzXCIpLCAobG9nZ2VyPy50YWJsZSB8fCBsb2dnZXIubG9nKT8uKHJlcG9ydC5lbmNvZGVkKSksIHJlcG9ydC5za2lwcGVkLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHNraXBwZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgZm9yIChjb25zdCB7IHBhdGggfSBvZiByZXBvcnQuc2tpcHBlZClcbiAgICAgICAgc2tpcHBlZC5hZGQocGF0aC5yZXBsYWNlKHJlS2V5U2VnbWVudCwgXCIwXCIpLnJlcGxhY2UoL1xcW1xcZCtcXF0vZywgXCJbXVwiKSk7XG4gICAgICBsb2dnZXI/LmxvZz8uKFwiW0BzYW5pdHkvY2xpZW50XTogTGlzdCBvZiBza2lwcGVkIHBhdGhzXCIsIFsuLi5za2lwcGVkLnZhbHVlcygpXSk7XG4gICAgfVxuICAgIChpc1NraXBwaW5nIHx8IGlzRW5jb2RpbmcpICYmIGxvZ2dlcj8uZ3JvdXBFbmQ/LigpO1xuICB9XG4gIHJldHVybiByZXN1bHRXaXRoU3RlZ2E7XG59XG5mdW5jdGlvbiBwcmV0dHlQYXRoRm9yTG9nZ2luZyhwYXRoKSB7XG4gIHJldHVybiB0b1N0cmluZyhqc29uUGF0aFRvU3R1ZGlvUGF0aChwYXRoKSk7XG59XG52YXIgc3RlZ2FFbmNvZGVTb3VyY2VNYXAkMSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBzdGVnYUVuY29kZVNvdXJjZU1hcFxufSk7XG5leHBvcnQge1xuICBlbmNvZGVJbnRvUmVzdWx0LFxuICBzdGVnYUVuY29kZVNvdXJjZU1hcCxcbiAgc3RlZ2FFbmNvZGVTb3VyY2VNYXAkMVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0ZWdhRW5jb2RlU291cmNlTWFwLmpzLm1hcFxuIl0sIm5hbWVzIjpbImlzUmVjb3JkIiwiQyIsInJlS2V5U2VnbWVudCIsImlzS2V5U2VnbWVudCIsInNlZ21lbnQiLCJ0ZXN0IiwidHJpbSIsInRvU3RyaW5nIiwicGF0aCIsIkFycmF5IiwiaXNBcnJheSIsIkVycm9yIiwicmVkdWNlIiwidGFyZ2V0IiwiaSIsInNlZ21lbnRUeXBlIiwiX2tleSIsImZyb20iLCJ0byIsIkpTT04iLCJzdHJpbmdpZnkiLCJFU0NBUEUiLCJVTkVTQ0FQRSIsImpzb25QYXRoIiwibWFwIiwicmVwbGFjZSIsIm1hdGNoIiwiX2luZGV4Iiwiam9pbiIsInBhcnNlSnNvblBhdGgiLCJwYXJzZWQiLCJwYXJzZVJlIiwiZXhlYyIsImtleSIsIm0iLCJwdXNoIiwicGFyc2VJbnQiLCJqc29uUGF0aFRvU3R1ZGlvUGF0aCIsImpzb25QYXRoVG9NYXBwaW5nUGF0aCIsInJlc29sdmVNYXBwaW5nIiwicmVzdWx0UGF0aCIsImNzbSIsIm1hcHBpbmdzIiwicmVzdWx0TWFwcGluZ1BhdGgiLCJtYXBwaW5nIiwibWF0Y2hlZFBhdGgiLCJwYXRoU3VmZml4IiwiT2JqZWN0IiwiZW50cmllcyIsImZpbHRlciIsInN0YXJ0c1dpdGgiLCJzb3J0Iiwia2V5MSIsImtleTIiLCJsZW5ndGgiLCJzdWJzdHJpbmciLCJ2YWx1ZSIsIndhbGtNYXAiLCJtYXBwaW5nRm4iLCJ2IiwiaWR4IiwiY29uY2F0IiwiX3R5cGUiLCJyZXN1bHQiLCJjaGlsZHJlbiIsInRleHQiLCJmcm9tRW50cmllcyIsImsiLCJlbmNvZGVJbnRvUmVzdWx0IiwiZW5jb2RlciIsInJlc29sdmVNYXBwaW5nUmVzdWx0IiwidHlwZSIsInNvdXJjZSIsInNvdXJjZURvY3VtZW50IiwiZG9jdW1lbnRzIiwiZG9jdW1lbnQiLCJzb3VyY2VQYXRoIiwicGF0aHMiLCJtYXRjaFBhdGhTZWdtZW50cyIsImZ1bGxTb3VyY2VTZWdtZW50cyIsInNsaWNlIiwiRFJBRlRTX0ZPTERFUiIsIlZFUlNJT05fRk9MREVSIiwiUEFUSF9TRVBBUkFUT1IiLCJEUkFGVFNfUFJFRklYIiwiVkVSU0lPTl9QUkVGSVgiLCJpc0RyYWZ0SWQiLCJpZCIsImlzVmVyc2lvbklkIiwiaXNQdWJsaXNoZWRJZCIsImdldFZlcnNpb25Gcm9tSWQiLCJfdmVyc2lvblByZWZpeCIsInZlcnNpb25JZCIsIl9wdWJsaXNoZWRJZCIsInNwbGl0IiwiZ2V0UHVibGlzaGVkSWQiLCJjcmVhdGVFZGl0VXJsIiwib3B0aW9ucyIsImJhc2VVcmwiLCJ3b3Jrc3BhY2UiLCJfd29ya3NwYWNlIiwidG9vbCIsIl90b29sIiwiX2lkIiwicHJvamVjdElkIiwiZGF0YXNldCIsImVuZHNXaXRoIiwic3RyaW5naWZpZWRQYXRoIiwic2VhcmNoUGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwic2V0Iiwic2VnbWVudHMiLCJyb3V0ZXJQYXJhbXMiLCJlbmNvZGVVUklDb21wb25lbnQiLCJyZXNvbHZlU3R1ZGlvQmFzZVJvdXRlIiwic3R1ZGlvVXJsIiwiZmlsdGVyRGVmYXVsdCIsImlzVmFsaWREYXRlIiwiaXNWYWxpZFVSTCIsImVuZFBhdGgiLCJhdCIsInNvbWUiLCJoYXNUeXBlTGlrZSIsImRlbnlsaXN0IiwiaGFzIiwiU2V0IiwiZGF0ZVN0cmluZyIsIkRhdGUiLCJwYXJzZSIsInVybCIsIlVSTCIsIlRSVU5DQVRFX0xFTkdUSCIsInN0ZWdhRW5jb2RlU291cmNlTWFwIiwicmVzdWx0U291cmNlTWFwIiwiY29uZmlnIiwibG9nZ2VyIiwiZW5hYmxlZCIsIm1zZyIsImVycm9yIiwiVHlwZUVycm9yIiwicmVwb3J0IiwiZW5jb2RlZCIsInNraXBwZWQiLCJyZXN1bHRXaXRoU3RlZ2EiLCJwcmV0dHlQYXRoRm9yTG9nZ2luZyIsIl9wcm9qZWN0SWQiLCJfZGF0YXNldCIsIm9yaWdpbiIsImhyZWYiLCJvbWl0Q3Jvc3NEYXRhc2V0UmVmZXJlbmNlRGF0YSIsImlzU2tpcHBpbmciLCJpc0VuY29kaW5nIiwiZ3JvdXBDb2xsYXBzZWQiLCJsb2ciLCJ0YWJsZSIsImFkZCIsInZhbHVlcyIsImdyb3VwRW5kIiwic3RlZ2FFbmNvZGVTb3VyY2VNYXAkMSIsImZyZWV6ZSIsIl9fcHJvdG9fXyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@sanity/client/dist/_chunks-es/stegaEncodeSourceMap.js\n"));

/***/ })

}]);